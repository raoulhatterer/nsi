{"config": {"indexing": "full", "lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "", "text": "Exercices pratiques pour vous entra\u00eener Le site e-nsi propose des exercices d'entrainement \u00e0 la pratique de la programmation en lien avec la sp\u00e9cialit\u00e9 NSI. Pour chaque exercice, on trouve un \u00e9nonc\u00e9, souvent pour cr\u00e9er une fonction, puis des exemples d'application de la fonction. Ensuite, une zone de saisie du code qui est accompagn\u00e9 des premiers tests. Il y a des tests secrets qui permettent ensuite d'accepter (ou valider) votre code. Python et terminal Linux Le site https://www.pythonanywhere.com permet de cr\u00e9er un compte gratuit pour programmer en python ou pour disposer d'un terminal sous Linux. \u00c9preuves pratiques Crit\u00e8res d\u2019\u00e9valuation D\u00e9finition du crit\u00e8re Tr\u00e8s insuffisant Insuffisant Satisfaisant Tr\u00e8s satisfaisant Connaissance des savoir-faire techniques Connaissance des concepts de base Besoin permanent d\u2019assistance A besoin de consignes compl\u00e9mentaires et d\u2019assistance ponctuelle A rarement besoin de consignes compl\u00e9mentaires Travaille de fa\u00e7on autonome Qualit\u00e9 de mise en \u0153uvre Niveau de conformit\u00e9 des op\u00e9rations r\u00e9alis\u00e9es Fait fr\u00e9quemment des erreurs, exige une surveillance permanente Produit un travail qu\u2019il faut contr\u00f4ler r\u00e9guli\u00e8rement Fait des erreurs minimes qu\u2019il ou elle parvient \u00e0 verbaliser et propose des solutions Travaille sans erreur Qualit\u00e9 du dialogue Justification Pas de r\u00e9ponse Pas clair Relativement clair mais manque parfois de pr\u00e9cision D\u00e9montre une capacit\u00e9 \u00e0 reformuler pour bien se faire comprendre. Informations sur les \u00e9preuves: Les \u00e9preuves pratiques de l'an dernier ont \u00e9t\u00e9 organis\u00e9es entre le 27 et 28 mai 2024. La totalit\u00e9 du programme pourra \u00eatre \u00e9valu\u00e9e. Coefficients : 15 points pour l'\u00e9preuve \u00e9crite, 5 points pour l'\u00e9preuve pratique. Pr\u00e9parez-vous \u00e0 l'\u00c9preuve \u00c9crite : les annales des ann\u00e9es pr\u00e9c\u00e9dentes sont disponibles ici Les supports d\u2019\u00e9valuation sont regroup\u00e9s dans une banque disponible sur ce site au plus tard au 24 mars de chaque session. Les exercices contenus dans cette banque ne sont pas dissociables. Le candidat traite les 2 exercices propos\u00e9s. Page sur l'orientation post-bac \u00e0 retrouver ici . Grand Oral Guide Eduscol pour le Grand Oral (avec exemples de sujets NSI) FAQ Grand Oral Th\u00e8me en cours d'\u00e9tude \u2693\ufe0e T3 > Dichotomie Th\u00e8mes d\u00e9j\u00e0 trait\u00e9s \u2693\ufe0e T2 Programmation > POO T1 Structures de donn\u00e9es > Dictionnaires T2 Programmation > R\u00e9cursivit\u00e9 T1 Structures de donn\u00e9es > Listes / piles / files T4 Base de donn\u00e9es T1 Structures de donn\u00e9es > Arbres T5 Architecture mat\u00e9rielle > Protocoles de routage T5 Architecture mat\u00e9rielle > Gestion des processus", "title": "Accueil"}, {"location": "#theme-en-cours-detude", "text": "T3 > Dichotomie", "title": "Th\u00e8me en cours d'\u00e9tude"}, {"location": "#themes-deja-traites", "text": "T2 Programmation > POO T1 Structures de donn\u00e9es > Dictionnaires T2 Programmation > R\u00e9cursivit\u00e9 T1 Structures de donn\u00e9es > Listes / piles / files T4 Base de donn\u00e9es T1 Structures de donn\u00e9es > Arbres T5 Architecture mat\u00e9rielle > Protocoles de routage T5 Architecture mat\u00e9rielle > Gestion des processus", "title": "Th\u00e8mes d\u00e9j\u00e0 trait\u00e9s"}, {"location": "progression_et_devoirs/", "text": "Progression et devoirs \u2693\ufe0e 2024-2025 s\u00e9ance 1 (4h jeudi 5/09/24): Cours sur la POO (T2>Chap1) TP d'introduction \u00e0 la POO Devoirs Avancer dans le TP jusqu'au 2 et le d\u00e9poser dans votre dossier personnel s\u00e9ance 2 (2h mardi 10/09/24): TP d'introduction \u00e0 la POO Devoirs Finir la partie POO du TP et le d\u00e9poser dans dans votre dossier personnel s\u00e9ance 3 (4h jeudi 12/09/24): POO : Exercices Devoirs Exercices sur la POO \u00e0 d\u00e9poser dans votre dossier personnel R\u00e9viser contr\u00f4le sur la POO s\u00e9ance 5 (2h mardi 16/09/24): POO : Correction des exercices sur la POO Les dictionnaires Devoirs R\u00e9viser la POO et les dictionnaires Contr\u00f4le \u00e9crit d'une heure sur la POO jeudi 19/09. s\u00e9ance 5 (4h jeudi 19/09/24): R\u00e9vision POO en salle 217 Contr\u00f4le sur la POO en salle 104 Les dictionnaires Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 6 (2h mardi 24/09/24): exercice 1: dictionnaires (cr\u00e9ation d'une rainbow table) Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 7 (4h jeudi 26/09/24): Correction du contr\u00f4le POO exercice 2: dictionnaires (Centres Etrangers J1 2021) Devoirs Revoir le dernier exercice sur les dictionnaires (surtout la fin de l'exercice qui est plus difficile) Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 8 (2h mardi 1/10/24): Cours sur la r\u00e9cursivit\u00e9 Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 9 (4h jeudi 3/10/24): Exercices du cours sur la r\u00e9cursivit\u00e9 Exercices suppl\u00e9mentaires sur la r\u00e9cursivit\u00e9 Devoirs Exercices 1 et 2 sur la r\u00e9cursivit\u00e9 (d\u00e9poser un Notebook dans votre r\u00e9pertoire personnel) s\u00e9ance 10 (2h mardi 8/10/2024): Exercices 2 et 3 sur la r\u00e9cursivit\u00e9 Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 11 (4h jeudi 9/10/2024): Exercices 4 \u00e0 8 sur la r\u00e9cursivit\u00e9 Devoirs s\u00e9ance 12 (2h mardi 15/10/2024): Exercices r\u00e9cursivit\u00e9 (hanoi + flocon) Devoirs Pr\u00e9parer contr\u00f4le (tout ce qui a \u00e9t\u00e9 fait jusqu'\u00e0 pr\u00e9sent) Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 13 (2h mardi 5/11/2024): Contr\u00f4le 2 portant sur la r\u00e9cursivit\u00e9 Devoirs Trouver un nom pour votre \u00e9quipe Passe Ton Hack D'abord Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 14 (4h jeudi 07/11/2024): T1 > 1 Liste, Pile, File Exercices du cours Devoirs Exercices 6 du cours sur les listes, piles et files Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance annul\u00e9e (2h mardi 12/11/2024): Pour cause de convocation ext\u00e9rieure s\u00e9ance 15 (4h jeudi 14/11/2024): Correction du contr\u00f4le n\u00b02 Exercices du cours sur les listes, piles et files Devoirs Pr\u00e9parer le contr\u00f4le de la semaine prochaine (qui pourra porter sur tout ce qui a \u00e9t\u00e9 vu jusqu'\u00e0 pr\u00e9sent) Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 16 (2h mardi 19/11/2024): T4 Base de donn\u00e9es > Mod\u00e8le relationnel Exercices sur le mod\u00e8le relationnel Utilisation de Mocodo Devoirs Pr\u00e9parer le contr\u00f4le de jeudi (qui pourra porter sur tout ce qui a \u00e9t\u00e9 vu jusqu'\u00e0 pr\u00e9sent) s\u00e9ance 17 (4h jeudi 21/11/2024): Contr\u00f4le n\u00b03 sur les piles et files T4 Base de donn\u00e9es > SQL Exercices SQL Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 18 (2h mardi 26/11/2024): Rattrapage du contr\u00f4le pour les absents Exercices SQL R\u00e9visions Wims sur les bases de python Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 19 (4h jeudi 28/11/2024): Correction du contr\u00f4le n\u00b03 Exercices SQL: n\u00b01 Devoirs Finir exercice 1 (Q3 sur JOIN) Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 20 (2h mardi 03/12/2024): Exercices SQL: n\u00b02 et n\u00b03 Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Finir l'exercice n\u00b03 sur SQL Commencer \u00e0 r\u00e9viser pour le contr\u00f4le de la semaine prochaine sur les bases de donn\u00e9es. s\u00e9ance 21 (4h jeudi 05/12/2024): S\u00e9ance annul\u00e9e pour cause de gr\u00e8ve Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. R\u00e9viser pour le contr\u00f4le de la semaine prochaine sur les bases de donn\u00e9es. s\u00e9ance 22 (2h mardi 10/12/2024): Exercices SQL (SQL Murder Mystery et suivants) Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. R\u00e9viser pour le contr\u00f4le de la s\u00e9ance prochaine sur les bases de donn\u00e9es. s\u00e9ance 23 (4h jeudi 12/12/2023): Contr\u00f4le SQL Python-SQL Mini-projets python-SQL Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Terminer les Mini-projets python-SQL s\u00e9ance 24 (2h mardi 17/12/2024): Les arbres Les commandes Linux Exercices sur les arbres Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Exercices 2 et 3 sur les arbres s\u00e9ance 25 (4h jeudi 19/12/2024): Exercices sur les arbres Devoirs Pr\u00e9parer le contr\u00f4le sur les arbres pr\u00e9vu \u00e0 la rentr\u00e9e. Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 26 (2h mardi 07/01/2025): Exercices sur les arbres Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 27 (4h mardi 09/01/2025): Contr\u00f4le sur les arbres report\u00e9 \u00e0 mardi Routage TP Routage d\u00e9branch\u00e9 Algorithme de Dijkstra Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 28 (2h mardi 14/01/2025): Contr\u00f4le sur les arbres Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Prochaine s\u00e9ance annul\u00e9e pour cause de pr\u00e9sentation de la sp\u00e9cialit\u00e9 NSI aux \u00e9l\u00e8ves de seconde. s\u00e9ance 29 (2h jeudi 16/01/2025): S\u00e9ance annul\u00e9e pour cause de pr\u00e9sentation de la sp\u00e9cialit\u00e9 NSI aux \u00e9l\u00e8ves de seconde. Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Pr\u00e9parer les exercices sur le routage. s\u00e9ance 30 (2h mardi 21/01/2025): Exercices sur le routage Correction du contr\u00f4le sur les arbres Distribution des codes passe ton hack d'abord Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 31 (4h jeudi 23/01/2025): Fin de la correction du contr\u00f4le sur les arbres Exercices sur le routage Devoirs R\u00e9viser le routage (et tout ce qui pr\u00e9c\u00e8de) pour le contr\u00f4le de la semaine prochaine. Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 32 (2h mardi 28/01/2025): Gestion des processus Exercices sur la gestion des processus Devoirs R\u00e9viser le routage (et tout ce qui pr\u00e9c\u00e8de) pour le contr\u00f4le de la semaine prochaine. Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 33 (4h jeudi 30/1/2025): Contr\u00f4le n\u00b06 portant sur le routage Exercices sur la gestion des processus Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 34 (2h mardi 04/02/2025): Exercices sur la gestion des processus Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 35 (4h jeudi 06/02/2025): Correction du contr\u00f4le n\u00b06 portant sur le routage Exercices sur la gestion des processus Devoirs R\u00e9viser le prochain contr\u00f4le portant sur la gestion des processus (et tout ce qui pr\u00e9c\u00e8de). Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 36 (2h mardi 25/02/2025): T3 > Dichotomie Activit\u00e9 d'introduction Dichotomie version r\u00e9cursive avec slicing Devoirs R\u00e9viser le prochain contr\u00f4le portant sur la gestion des processus (et tout ce qui pr\u00e9c\u00e8de). Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 37 (4h jeudi 27/02/2025): Contr\u00f4le n\u00b07 sur les processus Exercice 1 (Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes puissance) Devoirs Exercice 2 Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 38 (2h jeudi 4/3/2025): Tri fusion Exercice 2 Complexit\u00e9 O(1) O(log n) O(n) O(n log n) O(n2) Devoirs Exercice 4 du sujet Am\u00e9rique du Sud J2 2022 Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. \u00e0 suivre \u2693\ufe0e", "title": "Progression et devoirs"}, {"location": "progression_et_devoirs/#progression-et-devoirs", "text": "2024-2025 s\u00e9ance 1 (4h jeudi 5/09/24): Cours sur la POO (T2>Chap1) TP d'introduction \u00e0 la POO Devoirs Avancer dans le TP jusqu'au 2 et le d\u00e9poser dans votre dossier personnel s\u00e9ance 2 (2h mardi 10/09/24): TP d'introduction \u00e0 la POO Devoirs Finir la partie POO du TP et le d\u00e9poser dans dans votre dossier personnel s\u00e9ance 3 (4h jeudi 12/09/24): POO : Exercices Devoirs Exercices sur la POO \u00e0 d\u00e9poser dans votre dossier personnel R\u00e9viser contr\u00f4le sur la POO s\u00e9ance 5 (2h mardi 16/09/24): POO : Correction des exercices sur la POO Les dictionnaires Devoirs R\u00e9viser la POO et les dictionnaires Contr\u00f4le \u00e9crit d'une heure sur la POO jeudi 19/09. s\u00e9ance 5 (4h jeudi 19/09/24): R\u00e9vision POO en salle 217 Contr\u00f4le sur la POO en salle 104 Les dictionnaires Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 6 (2h mardi 24/09/24): exercice 1: dictionnaires (cr\u00e9ation d'une rainbow table) Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 7 (4h jeudi 26/09/24): Correction du contr\u00f4le POO exercice 2: dictionnaires (Centres Etrangers J1 2021) Devoirs Revoir le dernier exercice sur les dictionnaires (surtout la fin de l'exercice qui est plus difficile) Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 8 (2h mardi 1/10/24): Cours sur la r\u00e9cursivit\u00e9 Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 9 (4h jeudi 3/10/24): Exercices du cours sur la r\u00e9cursivit\u00e9 Exercices suppl\u00e9mentaires sur la r\u00e9cursivit\u00e9 Devoirs Exercices 1 et 2 sur la r\u00e9cursivit\u00e9 (d\u00e9poser un Notebook dans votre r\u00e9pertoire personnel) s\u00e9ance 10 (2h mardi 8/10/2024): Exercices 2 et 3 sur la r\u00e9cursivit\u00e9 Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 11 (4h jeudi 9/10/2024): Exercices 4 \u00e0 8 sur la r\u00e9cursivit\u00e9 Devoirs s\u00e9ance 12 (2h mardi 15/10/2024): Exercices r\u00e9cursivit\u00e9 (hanoi + flocon) Devoirs Pr\u00e9parer contr\u00f4le (tout ce qui a \u00e9t\u00e9 fait jusqu'\u00e0 pr\u00e9sent) Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 13 (2h mardi 5/11/2024): Contr\u00f4le 2 portant sur la r\u00e9cursivit\u00e9 Devoirs Trouver un nom pour votre \u00e9quipe Passe Ton Hack D'abord Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 14 (4h jeudi 07/11/2024): T1 > 1 Liste, Pile, File Exercices du cours Devoirs Exercices 6 du cours sur les listes, piles et files Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance annul\u00e9e (2h mardi 12/11/2024): Pour cause de convocation ext\u00e9rieure s\u00e9ance 15 (4h jeudi 14/11/2024): Correction du contr\u00f4le n\u00b02 Exercices du cours sur les listes, piles et files Devoirs Pr\u00e9parer le contr\u00f4le de la semaine prochaine (qui pourra porter sur tout ce qui a \u00e9t\u00e9 vu jusqu'\u00e0 pr\u00e9sent) Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 16 (2h mardi 19/11/2024): T4 Base de donn\u00e9es > Mod\u00e8le relationnel Exercices sur le mod\u00e8le relationnel Utilisation de Mocodo Devoirs Pr\u00e9parer le contr\u00f4le de jeudi (qui pourra porter sur tout ce qui a \u00e9t\u00e9 vu jusqu'\u00e0 pr\u00e9sent) s\u00e9ance 17 (4h jeudi 21/11/2024): Contr\u00f4le n\u00b03 sur les piles et files T4 Base de donn\u00e9es > SQL Exercices SQL Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 18 (2h mardi 26/11/2024): Rattrapage du contr\u00f4le pour les absents Exercices SQL R\u00e9visions Wims sur les bases de python Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 19 (4h jeudi 28/11/2024): Correction du contr\u00f4le n\u00b03 Exercices SQL: n\u00b01 Devoirs Finir exercice 1 (Q3 sur JOIN) Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 20 (2h mardi 03/12/2024): Exercices SQL: n\u00b02 et n\u00b03 Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Finir l'exercice n\u00b03 sur SQL Commencer \u00e0 r\u00e9viser pour le contr\u00f4le de la semaine prochaine sur les bases de donn\u00e9es. s\u00e9ance 21 (4h jeudi 05/12/2024): S\u00e9ance annul\u00e9e pour cause de gr\u00e8ve Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. R\u00e9viser pour le contr\u00f4le de la semaine prochaine sur les bases de donn\u00e9es. s\u00e9ance 22 (2h mardi 10/12/2024): Exercices SQL (SQL Murder Mystery et suivants) Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. R\u00e9viser pour le contr\u00f4le de la s\u00e9ance prochaine sur les bases de donn\u00e9es. s\u00e9ance 23 (4h jeudi 12/12/2023): Contr\u00f4le SQL Python-SQL Mini-projets python-SQL Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Terminer les Mini-projets python-SQL s\u00e9ance 24 (2h mardi 17/12/2024): Les arbres Les commandes Linux Exercices sur les arbres Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Exercices 2 et 3 sur les arbres s\u00e9ance 25 (4h jeudi 19/12/2024): Exercices sur les arbres Devoirs Pr\u00e9parer le contr\u00f4le sur les arbres pr\u00e9vu \u00e0 la rentr\u00e9e. Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 26 (2h mardi 07/01/2025): Exercices sur les arbres Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 27 (4h mardi 09/01/2025): Contr\u00f4le sur les arbres report\u00e9 \u00e0 mardi Routage TP Routage d\u00e9branch\u00e9 Algorithme de Dijkstra Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 28 (2h mardi 14/01/2025): Contr\u00f4le sur les arbres Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Prochaine s\u00e9ance annul\u00e9e pour cause de pr\u00e9sentation de la sp\u00e9cialit\u00e9 NSI aux \u00e9l\u00e8ves de seconde. s\u00e9ance 29 (2h jeudi 16/01/2025): S\u00e9ance annul\u00e9e pour cause de pr\u00e9sentation de la sp\u00e9cialit\u00e9 NSI aux \u00e9l\u00e8ves de seconde. Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. Pr\u00e9parer les exercices sur le routage. s\u00e9ance 30 (2h mardi 21/01/2025): Exercices sur le routage Correction du contr\u00f4le sur les arbres Distribution des codes passe ton hack d'abord Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 31 (4h jeudi 23/01/2025): Fin de la correction du contr\u00f4le sur les arbres Exercices sur le routage Devoirs R\u00e9viser le routage (et tout ce qui pr\u00e9c\u00e8de) pour le contr\u00f4le de la semaine prochaine. Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 32 (2h mardi 28/01/2025): Gestion des processus Exercices sur la gestion des processus Devoirs R\u00e9viser le routage (et tout ce qui pr\u00e9c\u00e8de) pour le contr\u00f4le de la semaine prochaine. Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 33 (4h jeudi 30/1/2025): Contr\u00f4le n\u00b06 portant sur le routage Exercices sur la gestion des processus Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 34 (2h mardi 04/02/2025): Exercices sur la gestion des processus Devoirs Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 35 (4h jeudi 06/02/2025): Correction du contr\u00f4le n\u00b06 portant sur le routage Exercices sur la gestion des processus Devoirs R\u00e9viser le prochain contr\u00f4le portant sur la gestion des processus (et tout ce qui pr\u00e9c\u00e8de). Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 36 (2h mardi 25/02/2025): T3 > Dichotomie Activit\u00e9 d'introduction Dichotomie version r\u00e9cursive avec slicing Devoirs R\u00e9viser le prochain contr\u00f4le portant sur la gestion des processus (et tout ce qui pr\u00e9c\u00e8de). Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 37 (4h jeudi 27/02/2025): Contr\u00f4le n\u00b07 sur les processus Exercice 1 (Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes puissance) Devoirs Exercice 2 Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es. s\u00e9ance 38 (2h jeudi 4/3/2025): Tri fusion Exercice 2 Complexit\u00e9 O(1) O(log n) O(n) O(n log n) O(n2) Devoirs Exercice 4 du sujet Am\u00e9rique du Sud J2 2022 Pr\u00e9parer les \u00e9preuves \u00e9crites et orales en r\u00e9visant r\u00e9guli\u00e8rement quelques extraits des sujets corrig\u00e9s des ann\u00e9es pass\u00e9es.", "title": "Progression et devoirs"}, {"location": "progression_et_devoirs/#a-suivre", "text": "", "title": "\u00e0 suivre"}, {"location": "remerciements/", "text": "Remerciements \u2693\ufe0e \u00e0 Vincent Bouillot, \u00e0 Franck Chambon, \u00e0 Gilles Lassus, Fabien Vergniaud, pour leurs ressources mises \u00e0 la disposition de la communaut\u00e9.", "title": "Remerciements"}, {"location": "remerciements/#remerciements", "text": "\u00e0 Vincent Bouillot, \u00e0 Franck Chambon, \u00e0 Gilles Lassus, Fabien Vergniaud, pour leurs ressources mises \u00e0 la disposition de la communaut\u00e9.", "title": "Remerciements"}, {"location": "T1_Structures_de_donnees/sommaire/", "text": "Listes Piles Files Dictionnaires Arbres Graphes", "title": "Sommaire"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/Exercices/", "text": "Exercice 1 \u00c9nonc\u00e9 Corr. Q1 Corr. Q2 Corr. Q3 Corr. Q4 Exercice 5 du sujet Centres \u00c9trangers 1 - 2021 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def maximum ( P ): if est_vide ( P ): return None m = depile ( P ) while not est_vide ( P ): val = depile ( P ) if val > m : m = val return m Avec le code ci-dessus, la pile p est vide \u00e0 la fin de l'ex\u00e9cution. Pour \u00e9viter cela, on peut par exemple cr\u00e9er une pile q temporaire qui recevra les \u00e9l\u00e9ments de p , avant de retransf\u00e9rer \u00e0 la fin du programme les \u00e9l\u00e9ments de q dans p . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def maximum ( P ): Q = creer_pile () if est_vide ( P ): return None m = depile ( P ) empile ( Q , m ) while not est_vide ( P ): val = depile ( P ) empile ( Q , val ) if val > m : m = val while not est_vide ( Q ): empile ( P , depile ( Q )) return m Q4a. On va vider la pile p dans une pile q tout en comptant le nombre d'\u00e9l\u00e9ments d\u00e9pil\u00e9s dans une variable t . On redonne ensuite \u00e0 p son \u00e9tat initial en vidant q dans p . Q4b \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def taille ( P ): if est_vide ( P ): return 0 Q = creer_pile () t = 0 while not est_vide ( P ): empile ( Q , depile ( P )) t += 1 while not est_vide ( Q ): empile ( P , depile ( Q )) return t Exercice 2 \u00c9nonc\u00e9 Corr. Q1 Corr. Q2a Corr. Q2b Corr. Q3 Corr. Q4 Exercice 1 du sujet La R\u00e9union J2 - 2022 La variable temp contient la valeur 25. p1 est identique, elle contient toujours les valeurs 25, 3 et 7. \ud83d\udc0d Script Python 1 2 3 4 def addition ( p ): nb1 = depiler ( p ) nb2 = depiler ( p ) empiler ( p , nb1 + nb2 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 p = pile_vide () empiler ( p , 3 ) empiler ( p , 5 ) addition ( p ) empiler ( p , 7 ) multiplication ( p ) Exercice 3 \u00c9nonc\u00e9 Corr. Q1a Corr. Q1b Corr. Q2a Corr. Q2b Corr. Q3 Corr. Q4 Exercice 2 du sujet M\u00e9tropole Candidats Libres J1 - 2021 \ud83d\udc0d Script Python 1 2 3 4 pile1 = Pile () pile1 . empiler ( 7 ) pile1 . empiler ( 5 ) pile1 . empiler ( 2 ) L'affichage produit est 7, 5, 5, 2 . Cas n\u00b01 : 3, 2 Cas n\u00b02 : 3, 2, 5, 7 Cas n\u00b03 : 3 Cas n\u00b04 : \u00abpile vide\u00bb La fonction mystere permet d'obtenir la pile retourn\u00e9e jusqu'\u00e0 un \u00e9l\u00e9ment particulier (s'il existe). \ud83d\udc0d Script Python 1 2 3 4 def etendre ( pile1 , pile2 ): while not pile2 . est_vide (): val = pile2 . depiler () pile1 . empiler ( val ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def supprime_toutes_occurences ( pile , element ): p_temp = Pile () while not pile . est_vide (): val = pile . depiler () if val != element : p_temp . empiler ( val ) while not p_temp . est_vide (): val = p_temp . depiler () pile . empiler ( val ) Exercice 4 \u00c9nonc\u00e9 Corr. Q1a Corr. Q1b Corr. Q2 Corr. Q3 Corr. Q4 Exercice 5 du sujet Am\u00e9rique du Nord J1 - 2021 Le contenu de la pile P sera \ud83d\udc0d Script Python | \"rouge\" | | \"vert\" | | \"jaune\" | | \"rouge\" | | \"jaune\" | _________ \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def taille_file ( F ): \"\"\"File -> Int\"\"\" F_temp = creer_file_vide () n = 0 while not est_vide ( F ): enfiler ( F_temp , defiler ( F )) n += 1 while not est_vide ( F_temp ): enfiler ( F , defiler ( F_temp )) return n \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def former_pile ( F ): \"\"\"File -> Pile\"\"\" P_temp = creer_pile_vide () P = creer_pile_vide () while not est_vide ( F ): empiler ( P_temp , defiler ( F )) while not est_vide ( P_temp ): empiler ( P , depiler ( P_temp )) return P \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def nb_elements ( F , elt ): \"\"\"File, Int -> Int\"\"\" F_temp = creer_file_vide () n = 0 while not est_vide ( F ): val = defiler ( F ) if val == elt : n += 1 enfiler ( F_temp , val ) while not est_vide ( F_temp ): enfiler ( F , deFiler ( F_temp )) return n \ud83d\udc0d Script Python 1 2 3 4 5 def verifier_contenu ( F , nb_rouge , nb_vert , nb_jaune ): \"\"\"File, Int, Int, Int -> Bool\"\"\" return nb_elements ( F , \"rouge\" ) <= nb_rouge and \\ nb_elements ( F , \"vert\" ) <= nb_vert and \\ nb_elements ( F , \"jaune\" ) <= nb_jaune Exercice 5 \u00c9nonc\u00e9 Corr. Q1 Corr. Q2 Corr. Q3 Corr. Q4 Exercice 2 du sujet Centres \u00c9trangers J1 - 2022 Il faut \u00e9crire l'instruction : \ud83d\udc0d Script Python panier_1 . enfile (( 31002 , \"caf\u00e9 noir\" , 1.50 , 50525 )) \ud83d\udc0d Script Python 1 2 3 4 def remplir ( self , panier_temp ): while not panier_temp . est_vide (): article = panier_temp . defile () self . enfile ( article ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def prix_total ( self ): total = 0 panier_temp = Panier () while not self . est_vide (): article = self . defile () total += article [ 2 ] panier_temp . enfile ( article ) self . remplir ( panier_temp ) return total \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def duree_passage_en_caisse ( self ): if self . est_vide (): return None horaire_premier = self . defile ()[ 3 ] while not self . est_vide (): horaire_dernier = self . defile ()[ 3 ] return horaire_dernier - horaire_premier Exercice 6 Cet exercice est bas\u00e9 sur l' \u00e9nigme n\u00b05 d'Advent Of Code 2018. Le but est de r\u00e9duire le plus possible une cha\u00eene de caract\u00e8res (comme dabAcCaCBAcCcaDA ) en ob\u00e9issant \u00e0 la r\u00e8gle suivante : R\u00e8gle de simplification D\u00e8s que deux lettres identiques mais de casse diff\u00e9rente (majuscule-minuscule ou minuscule-majuscule) sont c\u00f4te \u00e0 c\u00f4te dans la cha\u00eene, on les supprime de la cha\u00eene. Exemple : \ud83d\udccb Texte dabAcCaCBAcCcaDA On enl\u00e8ve le premier 'cC'. dabAaCBAcCcaDA Cela donne naissance \u00e0 un 'Aa', qu'on enl\u00e8ve. dabCBAcCcaDA On enl\u00e8ve alors 'cC' (ou 'Cc', cela revient au m\u00eame). dabCBAcaDA Plus aucune simplification n'est possible. La cha\u00eene de caract\u00e8res qu'il va falloir simplifier contient ... 50000 caract\u00e8res. 1. \u00c9laboration d'une fonction utile \u2693\ufe0e On rappelle que la fonction ord renvoie le code ASCII d'une lettre. En comparant les codes ASCII de deux lettres identiques mais de casse diff\u00e9rentes, en d\u00e9duire une fonction simplifiable qui prend en param\u00e8tres deux lettres l1 et l2 et qui renvoie un bool\u00e9en indiquant si ces deux lettres sont simplifiables. Exemples d'utilisation : \ud83d\udc0d Script Python >>> simplifiable ( 'c' , 'C' ) True >>> simplifiable ( 'C' , 'c' ) True >>> simplifiable ( 'C' , 'C' ) False Correction \ud83d\udc0d Script Python 1 2 def simplifiable ( l1 , l2 ): return abs ( ord ( l1 ) - ord ( l2 )) == 32 2. Une seule simplification de la cha\u00eene de caract\u00e8res \u2693\ufe0e \u00c9crire une fonction simplifie qui prend en param\u00e8tre une cha\u00eene de caract\u00e8re s et qui renvoie cette m\u00eame cha\u00eene de caract\u00e8res, ayant \u00e9t\u00e9 simplifi\u00e9e une fois au maximum. Principe : on parcourt la cha\u00eene et d\u00e8s qu'on trouve une simplification \u00e0 faire, on simplifie la cha\u00eene et on la renvoie imm\u00e9diatement. Exemples d'utilisation : \ud83d\udc0d Script Python >>> simplifie ( 'dabAcCaCBAcCcaDA' ) 'dabAaCBAcCcaDA' >>> simplifie ( 'dabAaCBAcCcaDA' ) 'dabCBAcCcaDA' >>> simplifie ( 'dabCBAcCcaDA' ) 'dabCBAcaDA' >>> simplifie ( 'dabCBAcaDA' ) 'dabCBAcaDA' Pour information, on rappelle la technique de slicing de cha\u00eene de caract\u00e8res : \ud83d\udc0d Script Python >>> ch = 'abcde' >>> ch [: 2 ] 'ab' >>> ch [ 2 :] 'cde' Correction \ud83d\udc0d Script Python 1 2 3 4 5 def simplifie ( s ): for i in range ( len ( s ) - 1 ): if simplifiable ( s [ i + 1 ], s [ i ]): return s [: i ] + s [ i + 2 :] return s 3. R\u00e9solution du probl\u00e8me \u2693\ufe0e Apr\u00e8s vous \u00eatre demand\u00e9 comment savoir facilement qu'une cha\u00eene n'\u00e9tait plus simplifiable, proposer une fonction reduction qui prend en param\u00e8tre une cha\u00eene s et qui renvoie cette cha\u00eene s une fois effectu\u00e9es toutes les simplifications possibles. Exemple d'utilisation : \ud83d\udc0d Script Python >>> reduction ( 'dabAcCaCBAcCcaDA' ) 'dabCBAcaDA' Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def reduction ( s ): fini = False while not fini : s_temp = s s = simplifie ( s ) if len ( s_temp ) == len ( s ): fini = True return s 4. Le vrai \u00e9nonc\u00e9 d'Advent of Code \u2693\ufe0e Dans cette \u00e9nigme n\u00b05, la r\u00e9ponse \u00e0 donner est le nombre de caract\u00e8res de la cha\u00eene une fois simplifi\u00e9e. Ce qui ne devrait pas nous poser de probl\u00e8me. Par contre, la cha\u00eene 'dabAcCaCBAcCcaDA' sur laquellle nous avons travaill\u00e9 n'est qu'un exemple... La vraie cha\u00eene contient 50000 caract\u00e8res : Anecdotique ? Pas vraiment... Effectuez la r\u00e9duction de cette cha\u00eene avec votre programme pr\u00e9c\u00e9dent. Que remarquez-vous ? Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 s = 'YyLlXxYKkbNnQqBFfxXbyYWwBhHyYTCBbCjI...' def simplifiable ( l1 , l2 ): return abs ( ord ( l1 ) - ord ( l2 )) == 32 def simplifie ( s ): for i in range ( len ( s ) - 1 ): if simplifiable ( s [ i + 1 ], s [ i ]): return s [: i ] + s [ i + 2 :] return s def reduction ( s ): fini = False while not fini : s_temp = s s = simplifie ( s ) if len ( s_temp ) == len ( s ): fini = True return s print ( len ( reduction ( s ))) Le r\u00e9sultat (9370) est loooong \u00e0 nous parvenir ! (30 secondes sur ma machine) 5. Sauv\u00e9 par une pile \u2693\ufe0e Cet exercice peut \u00eatre r\u00e9solu beaucoup plus efficacement gr\u00e2ce \u00e0 l'utilisation d'une pile... mais comment ? Vous pouvez utiliser l'impl\u00e9mentation de pile disponible ici . Aide \u00e0 la construction de l'algorithme Pour chaque lettre de la cha\u00eene : si la pile est vide, on empile cette lettre sinon, on regarde si la lettre est simplifiable avec la lettre du haut de la pile : si oui, on supprime cette lettre du haut de la pile et on passe \u00e0 la lettre suivante de la cha\u00eene si non, on empile cette lettre sur la pile, et on passe \u00e0 la suivante. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 s = 'YyLlXxYKkbNnQqBFfxXbyYWwBhHyYTCBbCjI...' p = Pile () # ne pas oublier de r\u00e9cup\u00e9rer une impl\u00e9mentation de la classe Pile()... def simplifiable ( l1 , l2 ): return abs ( ord ( l1 ) - ord ( l2 )) == 32 for lettre in s : if p . est_vide (): p . empile ( lettre ) else : sommet = p . depile () if not simplifiable ( sommet , lettre ): p . empile ( sommet ) p . empile ( lettre ) print ( p . taille ()) Le r\u00e9sultat est cette fois imm\u00e9diat : 0.04 secondes sur ma machine, soit environ 1000 fois plus rapide que le code pr\u00e9c\u00e9dent. Exercice 7 Exercice 3 du sujet Centres Etrangers J1 - 2023 Jeu du Simon Correction Q1. \ud83d\udc0d Script Python 1 2 3 4 5 def ajout ( f ): couleurs = ( \"bleu\" , \"rouge\" , \"jaune\" , \"vert\" ) indice = randint ( 0 , 3 ) enfiler ( f , couleur [ indice ]) return f Correction Q2. \ud83d\udc0d Script Python def vider ( f ): while not est_vide ( f ): defiler ( f ) Correction Q3. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def affich_seq ( sequence ): stock = creer_file_vide () ajout ( sequence ) while not est_vide ( sequence ): c = defiler ( sequence ) affichage ( c ) time . sleep ( 0.5 ) enfiler ( stock , c ) while not est_vide ( stock ): enfiler ( sequence , defiler ( stock )) Correction Q4.a. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tour_de_jeu ( sequence ): affich_seq ( sequence ) stock = creer_file_vide () while not est_vide ( sequence ): c_joueur = saisie_joueur () c_seq = defiler ( sequence ) if c_joueur == c_seq : enfiler ( stock , c_seq ) else : vider ( sequence ) while not est_vide ( stock ): enfiler ( sequence , defiler ( stock )) Correction Q4.b. Question bizarre... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tour_de_jeu_modifie ( sequence ): while True : affich_seq ( sequence ) stock = creer_file_vide () while not est_vide ( sequence ): c_joueur = saisie_joueur () c_seq = defiler ( sequence ) if c_joueur == c_seq : enfiler ( stock , c_seq ) else : vider ( sequence ) vider ( stock ) while not est_vide ( stock ): enfiler ( sequence , defiler ( stock )) ou bien \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tour_de_jeu_modifie ( sequence ): affich_seq ( sequence ) stock = creer_file_vide () while not est_vide ( sequence ): c_joueur = saisie_joueur () c_seq = defiler ( sequence ) if c_joueur == c_seq : enfiler ( stock , c_seq ) else : vider ( sequence ) print ( \"Perdu ! On rejoue !\" ) tour_de_jeu_modifie ( sequence ) while not est_vide ( stock ): enfiler ( sequence , defiler ( stock )) tour_de_jeu_modifie ( sequence )", "title": "Exercices"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/", "text": "Listes, piles, files \u2693\ufe0e Exemples de structures de donn\u00e9es lin\u00e9aires. 0. Pr\u00e9ambule : interface \u2260 impl\u00e9mentation \u2693\ufe0e Les structures que nous allons voir peuvent s'envisager sous deux aspects : le c\u00f4t\u00e9 utilisateur, qui utilisera une interface pour manipuler les donn\u00e9es. le c\u00f4t\u00e9 concepteur, qui aura choisi une impl\u00e9mentation pour construire la structure de donn\u00e9es. Un exemple d'interface et d'impl\u00e9mentation Le volant et les p\u00e9dales d'une voiture constituent une partie de son interface . L' impl\u00e9mentation va d\u00e9signer tous les m\u00e9canismes techniques qui sont mis en \u0153uvre pour que (par exemple) le mouvement de rotation du volant aboutisse \u00e0 un changement de direction des roues. La standardisation des interfaces fait qu'un utilisateur peut passer sans probl\u00e8me d'une voiture \u00e0 une autre, m\u00eame si l'impl\u00e9mentation est compl\u00e8tement diff\u00e9rente. Nous avons d\u00e9j\u00e0 abord\u00e9 ces deux aspects lors de la d\u00e9couverte de la Programmation Orient\u00e9e Objet. Le principe d'encapsulation fait que l'utilisateur n'a qu'\u00e0 conna\u00eetre l'existence des m\u00e9thodes disponibles, et non pas le contenu technique de celle-ci. Cela permet notamment de modifier le contenu technique (l'impl\u00e9mentation) sans que les habitudes de l'utilisateur (l'interface) ne soient chang\u00e9es. 1. Structures de donn\u00e9es lin\u00e9aires \u2693\ufe0e 1.1 \u00c0 chaque donn\u00e9e sa structure \u2693\ufe0e En informatique comme dans la vie courante, il est conseill\u00e9 d'adapter sa mani\u00e8re de stocker et de traiter des donn\u00e9es en fonction de la nature de celles-ci : Le serveur d'un caf\u00e9, charg\u00e9 de transporter les boissons du comptoir aux tables des clients, n'utilisera pas un sac en plastique pour faire le transport : il pr\u00e9f\u00e8rera un plateau. Le chercheur de champignons, lui, n'utilisera pas un plateau pour stocker ses trouvailles : il pr\u00e9f\u00e8rera un panier. Pour stocker des chaussettes, on pr\u00e9f\u00e8rera les entasser dans un tiroir (apr\u00e8s les avoir appair\u00e9es), plut\u00f4t que de les suspendre \u00e0 des cintres. De m\u00eame en informatique, pour chaque type de donn\u00e9es, pour chaque utilisation pr\u00e9vue, une structure particuli\u00e8re de donn\u00e9es se rev\u00e8lera (peut-\u00eatre) plus adapt\u00e9e qu'une autre. 1.1.1 Donn\u00e9es lin\u00e9aires \u2693\ufe0e Int\u00e9ressons nous par exemple aux donn\u00e9es lin\u00e9aires . Ce sont des donn\u00e9es qui ne comportent pas de hi\u00e9rarchie : toutes les donn\u00e9es sont de la m\u00eame nature et ont le m\u00eame r\u00f4le. Par exemple, un relev\u00e9 mensuel de temp\u00e9ratures, la liste des \u00e9l\u00e8ves d'une classe, un historique d'op\u00e9rations bancaires... Ces donn\u00e9es sont \u00abplates\u00bb, n'ont pas de sous-domaines : la structure de liste para\u00eet parfaitement adapt\u00e9e. Lorsque les donn\u00e9es de cette liste sont en fait des couples (comme dans le cas d'une liste de noms/num\u00e9ros de t\u00e9l\u00e9phone), alors la structure la plus adapt\u00e9e est sans doute celle du dictionnaire . Les listes et les dictionnaires sont donc des exemples de structures de donn\u00e9es lin\u00e9aires . 1.1.2 Donn\u00e9es non-lin\u00e9aires \u2693\ufe0e M\u00eame si ce n'est pas l'objet de ce cours, donnons des exemples de structures adapt\u00e9es aux donn\u00e9es non-lin\u00e9aires : Si une liste de courses est subdivis\u00e9e en \"rayon frais / bricolage / papeterie\" et que le rayon frais est lui-m\u00eame s\u00e9par\u00e9 en \"laitages / viandes / fruits & l\u00e9gumes\", alors une structure d' arbre sera plus adapt\u00e9e pour la repr\u00e9senter. Les structures arborescentes seront vues plus tard en Terminale. Enfin, si nos donn\u00e9es \u00e0 \u00e9tudier sont les relations sur les r\u00e9seaux sociaux des \u00e9l\u00e8ves d'une classe, alors la structure de graphe s'imposera d'elle-m\u00eame. Cette structure sera elle-aussi \u00e9tudi\u00e9e plus tard cette ann\u00e9e. 1.2 Comment seront trait\u00e9es ces donn\u00e9es lin\u00e9aires ? Introduction des listes, des piles et des files \u2693\ufe0e La nature des donn\u00e9es ne fait pas tout. Il faut aussi s'int\u00e9resser \u00e0 la mani\u00e8re dont on voudra les traiter : \u00c0 quelle position les faire entrer dans notre structure ? \u00c0 quel moment devront-elles en \u00e9ventuellement en sortir ? Veut-on pouvoir acc\u00e9der rapidement \u00e0 n'importe quel \u00e9l\u00e9ment de la structure, ou simplement au premier ? ou au dernier ? Lorsque ces probl\u00e9matiques d'entr\u00e9e/sortie n'interviennent pas, la structure \u00abclassique\u00bb de liste est adapt\u00e9e. Mais lorsque celle-ci est importante, il convient de diff\u00e9rencier la structure de pile de celle de file . 1.2.1 Les piles ( stack ) \u2693\ufe0e Une structure de pile (penser \u00e0 une pile d'assiette) est associ\u00e9e \u00e0 la m\u00e9thode LIFO (Last In, First Out) : les \u00e9l\u00e9ments sont empil\u00e9s les uns au-dessus des autres, et on ne peut toujours d\u00e9piler que l'\u00e9l\u00e9ment du haut de la pile. Le dernier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 \u00eatre sorti. Exemples de donn\u00e9es stock\u00e9es sous forme de pile lors de l'ex\u00e9cution d'une fonction r\u00e9cursive, le processeur empile successivement les appels \u00e0 traiter : seule l'instruction du haut de la pile peut \u00eatre trait\u00e9e. dans un navigateur internet, la liste des pages parcourues est stock\u00e9e sous forme de pile : la fonction \u00abBack\u00bb permet de \u00abd\u00e9piler\u00bb peu \u00e0 peu les pages pr\u00e9c\u00e9demment parcourues : lors d'un Devoir Surveill\u00e9, la derni\u00e8re copie remise sur le bureau du professeur est (souvent) la premi\u00e8re corrig\u00e9e. 1.2.2 Les files ( queue ) \u2693\ufe0e Une structure de file (penser \u00e0 une file d'attente) est associ\u00e9e \u00e0 la m\u00e9thode FIFO (First In, First Out) : les \u00e9l\u00e9ments sont enfil\u00e9s les uns \u00e0 la suite des autres, et on ne peut toujours d\u00e9filer que l'\u00e9l\u00e9ment du haut de la file. Le premier \u00e9l\u00e9ment \u00e0 \u00eatre arriv\u00e9 est donc le premier \u00e0 en sortir. Sinon \u00e7a r\u00e2le dans la file d'attente. Exemples de donn\u00e9es stock\u00e9es sous forme de file : les documents envoy\u00e9s \u00e0 l'imprimante sont trait\u00e9es dans une file d'impression. la \u00abqueue\u00bb \u00e0 la cantine est (normalement) trait\u00e9e sous forme de file. 1.2.3 Le probl\u00e8me du stockage : transformer les piles en files \u2693\ufe0e Dans les entrep\u00f4ts de stockage, comme dans les rayons d'un supermarch\u00e9, la structure naturelle est celle de la pile : les gens attrapent l'\u00e9l\u00e9ment situ\u00e9 devant eux (\u00aben haut de la pile\u00bb). Si les employ\u00e9s du supermarch\u00e9 remettent en rayon les produits plus r\u00e9cents sur le dessus de la pile, les produits au bas de la pile ne seront jamais choisis et p\u00e9rimeront. Ils doivent donc transformer la pile en file : lors de la mise en rayon de nouveaux produits, ceux-ci seront plac\u00e9s derri\u00e8re (\u00abau bas de la file\u00bb) afin que partent en priorit\u00e9 les produits \u00e0 date de p\u00e9remption plus courte. On passe donc du LIFO au FIFO. Certains dispositifs permettent de le faire naturellement : Ci-dessous, une file... de piles (\u00e9lectriques). Le chargement par le haut du distributeur fait que celle qui sera sortie (en bas) sera celle qui aura \u00e9t\u00e9 rentr\u00e9e en premier (par le haut). Ce FIFO est donc provoqu\u00e9 naturellement par la gravit\u00e9 (et un peu d'astuce). On notera que cette probl\u00e9matique est universelle : voir par exemple ce site . Apr\u00e8s avoir pr\u00e9sent\u00e9 rapidement ces trois types de donn\u00e9es lin\u00e9aires, nous allons maintenant les \u00e9tudier plus en d\u00e9tail, et proposer pour chacune d'elles une interface et plusieurs impl\u00e9mentations. 2. Les listes \u2693\ufe0e 2.1 D\u00e9finition g\u00e9n\u00e9rale \u2693\ufe0e Une liste est un ensemble ordonn\u00e9 d'objets. G\u00e9n\u00e9ralement, ces donn\u00e9es seront de m\u00eame type, mais ce n'est pas structurellement obligatoire. 2.2 Les listes cha\u00een\u00e9es (linked lists) \u2693\ufe0e Lorsque l'impl\u00e9mentation de la liste fait appara\u00eetre une cha\u00eene de valeurs, chacune pointant vers la suivante, on dit que la liste est une liste cha\u00een\u00e9e . Impl\u00e9mentation choisie : Une liste est caract\u00e9ris\u00e9e par un ensemble de cellules. Le lien (on dira souvent le \u00abpointeur\u00bb) de la variable est un lien vers la premi\u00e8re cellule, qui renverra elle-m\u00eame sur la deuxi\u00e8me, etc. Chaque cellule contient donc une valeur et un lien vers la cellule suivante. Une liste peut \u00eatre vide (la liste vide est not\u00e9e x ou bien None sur les sch\u00e9mas) Une cons\u00e9quence de cette impl\u00e9mentation sous forme de liste cha\u00een\u00e9e est la non-constance du temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment de liste : pour acc\u00e9der au 3\u00e8me \u00e9l\u00e9ment, il faut obligatoirement passer par les deux pr\u00e9c\u00e9dents. \u00c0 retenir : dans une liste cha\u00een\u00e9e, le temps d'acc\u00e8s aux \u00e9l\u00e9ments n'est pas constant. 2.3 Exemple d'impl\u00e9mentation minimale d'une liste cha\u00een\u00e9e \u2693\ufe0e Exemple fondateur : impl\u00e9mentation d'une liste chain\u00e9e en POO \ud83d\udc0d Script Python 1 2 3 4 class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante Cette impl\u00e9mentation rudimentaire permet bien la cr\u00e9ation d'une liste : \ud83d\udc0d Script Python >>> lst = Cellule ( 3 , Cellule ( 5 , Cellule ( 1 , None ))) La liste cr\u00e9\u00e9e est donc : Mais plus pr\u00e9cis\u00e9ment, on a : Exercice 1 \u00c9nonc\u00e9 Correction Retrouvez comment acc\u00e9der aux \u00e9l\u00e9ments 3, 5 et 1. \ud83d\udc0d Script Python >>> lst . contenu 3 >>> lst . suivante . contenu 5 >>> lst . suivante . suivante . contenu 1 On pourra remarquer que l'interface propos\u00e9e \u00e0 l'utilisateur n'est pas des plus pratiques... 2.4 Et les listes de Python ??? \u2693\ufe0e Nous connaissons d\u00e9j\u00e0 les listes de Python : \ud83d\udc0d Script Python >>> maliste = [ 3 , 1 , - 1 , 42 ] Et nous connaissons aussi (un peu) l'interface de ce type list , notamment avec les m\u00e9thodes append() ou reverse() . N\u00e9anmoins, l'impl\u00e9mentation qui a \u00e9t\u00e9 choisie par les concepteurs de Python de ce type list fait que le celui-ci se rapproche plus d'un tableau dynamique . Dans un tableau dynamique : le temps d'acc\u00e8s \u00e0 n'importe quel \u00e9l\u00e9ment est rapide. Ce temps d'acc\u00e8s est constant quelque soit l'\u00e9l\u00e9ment : on dit que l'acc\u00e8s est en \\(O(1)\\) . l'insertion d'un \u00e9l\u00e9ment au d\u00e9but ou au milieu de la liste est lente : cela oblige \u00e0 d\u00e9caler tous les \u00e9l\u00e9ments \u00e0 droite de celui-ci. Le temps pris par l'insertion est proportionnel au nombre d'\u00e9l\u00e9ments \u00e0 d\u00e9placer : on dit que l'insertion est en \\(O(n)\\) . Dans une liste cha\u00een\u00e9e : le temps d'acc\u00e8s \u00e0 n'importe quel \u00e9l\u00e9ment peut \u00eatre lent (proportionnel \u00e0 la position de l'\u00e9l\u00e9ment dans la liste). Le temps d'acc\u00e8s est en \\(O(n)\\) . l'insertion d'un \u00e9l\u00e9ment \u00e0 l'int\u00e9rieur de la liste est rapide : il y a simplement \u00e0 modifier la valeur du lien de la cellule \u00e0 gauche de l'endroit d'insertion. L'action d'ins\u00e9rer est donc en \\(O(1)\\) . Toutefois, avant d'arriver \u00e0 l'endroit d'insertion, il faut avoir parcouru toutes les cellules pr\u00e9c\u00e9dentes ! Le temps total d'insertion est donc lui aussi lin\u00e9aire, en \\(O(n)\\) . Nous nous servirons parfois du type list de Python dans la suite de ce cours, mais il ne faut pas oublier qu'il n'est pas un \u00abvrai\u00bb type list . 2.5 Un exemple d'interface pour les listes \u2693\ufe0e Imaginons que nous poss\u00e9dons une interface offrant les fonctionnalit\u00e9s suivantes : Liste() : cr\u00e9e une liste vide. est_vide : indique si la liste est vide. (renvoie un bool\u00e9en) ajoute_tete : ins\u00e8re un \u00e9l\u00e9ment (pass\u00e9 en param\u00e8tre) en t\u00eate de liste. (ne renvoie rien) renvoie_tete : renvoie la valeur de l'\u00e9l\u00e9ment en t\u00eate de liste ET le supprime de la liste. Exercice 2 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la liste lst et la valeur \u00e9ventuellement renvoy\u00e9e. \ud83d\udc0d Script Python 1. lst = Liste () 2. lst . ajoute_tete ( 3 ) 3. lst . ajoute_tete ( 5 ) 4. lst . ajoute_tete ( 1 ) 5. lst . renvoie_tete () 6. lst . est_vide () 7. lst . ajoute_tete ( 2 ) 8. lst . renvoie_tete () 9. lst . renvoie_tete () 10. lst . renvoie_tete () 11. lst . est_vide () \ud83d\udc0d Script Python 1. lst = Liste () # lst = None 2. lst . ajoute_tete ( 3 ) # lst = 3 3. lst . ajoute_tete ( 5 ) # lst = 3 5 4. lst . ajoute_tete ( 1 ) # lst = 3 5 1 5. lst . renvoie_tete () # lst = 3 5 valeur renvoy\u00e9e : 1 6. lst . est_vide () # valeur renvoy\u00e9e : False 7. lst . ajoute_tete ( 2 ) # lst = 3 5 2 8. lst . renvoie_tete () # lst = 3 5 valeur renvoy\u00e9e : 2 9. lst . renvoie_tete () # lst = 3 valeur renvoy\u00e9e : 5 10. lst . renvoie_tete () # lst = None valeur renvoy\u00e9e : 3 11. lst . est_vide () # valeur renvoy\u00e9e : True 3. Les piles \u2693\ufe0e Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une pile travaille en mode LIFO (Last In First Out). Pour \u00eatre utilis\u00e9e, l'interface d'une pile doit permettre a minima : la cr\u00e9ation d'une pile vide l'ajout d'un \u00e9l\u00e9ment dans la pile (qui sera forc\u00e9ment au dessus). On dira qu'on empile . le retrait d'un \u00e9l\u00e9ment de la pile (qui sera forc\u00e9ment celui du dessus) et le renvoi de sa valeur. On dira qu'on d\u00e9pile . 3.1 Utilisation d'une interface de pile \u2693\ufe0e Exercice 3 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la pile p et la valeur \u00e9ventuellement renvoy\u00e9e. Bien comprendre que la classe Pile() et ses m\u00e9thodes n'existent pas vraiment. Nous jouons avec son interface. On prendra pour convention que la t\u00eate de la pile est \u00e0 droite. \ud83d\udc0d Script Python 1. p = Pile () 2. p . empile ( 3 ) 3. p . empile ( 5 ) 4. p . est_vide () 4. p . empile ( 1 ) 5. p . depile () 6. p . depile () 7. p . empile ( 9 ) 8. p . depile () 9. p . depile () 10. p . est_vide () \ud83d\udc0d Script Python 1. p = Pile () # p = None 2. p . empile ( 3 ) # p = 3 3. p . empile ( 5 ) # p = 3 5 par convention 4. p . est_vide () # False 4. p . empile ( 1 ) # p = 3 5 1 5. p . depile () # p = 3 5 valeur renvoy\u00e9e : 1 6. p . depile () # p = 3 valeur renvoy\u00e9e : 5 7. p . empile ( 9 ) # p = 3 9 8. p . depile () # p = 3 valeur renvoy\u00e9e :9 9. p . depile () # p est vide valeur renvoy\u00e9e : 3 10. p . est_vide () # True 3.2 Impl\u00e9mentation(s) d'une pile \u2693\ufe0e L'objectif est de cr\u00e9er une classe Pile . L'instruction Pile() cr\u00e9era une pile vide. Chaque objet Pile disposera des m\u00e9thodes suivantes : est_vide : indique si la pile est vide (renvoie un bool\u00e9en) empile : ins\u00e8re un \u00e9l\u00e9ment (pass\u00e9 en param\u00e8tre) en haut de la pile. Ne renvoie rien. depile : renvoie la valeur de l'\u00e9l\u00e9ment en haut de la pile ET le supprime de la pile. Ces 3 m\u00e9thodes sont essentielles et se retrouveront syst\u00e9matiquement dans chaque interface. Nous y ajouterons, uniquement par commodit\u00e9, la m\u00e9thode suivante : __repr__ : permet d'afficher la pile sous forme agr\u00e9able (par ex : |3|6|2|5| ) 3.2.1 \u00c0 l'aide du type list de Python \u2693\ufe0e Exercice 4 \u00c9nonc\u00e9 Correction Cr\u00e9er la classe Pile ci-dessus. Le type list de Python est parfaitement adapt\u00e9. Des renseignements int\u00e9ressants \u00e0 son sujet peuvent \u00eatre trouv\u00e9s ici . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Pile : def __init__ ( self ): self . data = [] def est_vide ( self ): return len ( self . data ) == 0 def empile ( self , x ): self . data . append ( x ) def depile ( self ): if self . est_vide (): print ( 'Vous avez essay\u00e9 de d\u00e9piler une pile vide !' ) return None else : return self . data . pop () def __repr__ ( self ): # Hors-Programme : pour afficher s = '|' # convenablement la pile avec p for k in self . data : s = s + str ( k ) + '|' return s Test de l'impl\u00e9mentation : \ud83d\udc0d Script Python >>> p = Pile () >>> p . empile ( 5 ) >>> p . empile ( 3 ) >>> p . empile ( 7 ) >>> p | 5 | 3 | 7 | 3.2.2 \u00c0 l'aide d'une liste cha\u00een\u00e9e et de la classe Cellule cr\u00e9\u00e9e au 2.3 \u2693\ufe0e Au 2.3 nous avons cr\u00e9\u00e9 la classe Cellule : \ud83d\udc0d Script Python 1 2 3 4 class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante Exercice 5 \u00c9nonc\u00e9 Correction \u00c0 l'aide cette classe, re-cr\u00e9er une classe Pile disposant exactement de la m\u00eame interface que dans l'exercice pr\u00e9c\u00e9dent. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante class Pile : def __init__ ( self ): self . data = None def est_vide ( self ): return self . data == None def empile ( self , val ): self . data = Cellule ( val , self . data ) def depile ( self ): v = self . data . contenu #on r\u00e9cup\u00e8re la valeur \u00e0 renvoyer self . data = self . data . suivante # on supprime la 1\u00e8re cellule return v def __repr__ ( self ): s = '|' c = self . data while c != None : s += str ( c . contenu ) + '|' c = c . suivante return s Test de l'impl\u00e9mentation : \ud83d\udc0d Script Python >>> p = Pile () >>> p . empile ( 5 ) >>> p . empile ( 3 ) >>> p . empile ( 7 ) >>> print ( p ) | 7 | 3 | 5 | \u00c0 retenir : pour l'utilisateur, les interfaces du 3.2.1 et 3.2.2 sont strictement identiques. Il ne peut pas savoir, en les utilisant, l'impl\u00e9mentation qui est derri\u00e8re. 3.3 Application des piles \u2693\ufe0e Exercice 6 \u00c9nonc\u00e9 Correction Simulez une gestion de l'historique de navigation internet, en cr\u00e9ant une classe Nav qui utilisera une pile. Attention, il ne faut pas r\u00e9inventer la classe Pile , mais uniquement s'en servir ! Exemple d'utilisation : \ud83d\udc0d Script Python >>> n = Nav () >>> n . visite ( 'lemonde.fr' ) page actuelle : lemonde . fr >>> n . visite ( 'google.fr' ) page actuelle : google . fr >>> n . visite ( 'lyceemauriac.fr' ) page actuelle : lyceemauriac . fr >>> n . back () page quitt\u00e9e : lyceemauriac . fr >>> n . back () page quitt\u00e9e : google . fr \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 class Nav : def __init__ ( self ): self . pile = Pile () def visite ( self , page ): self . pile . empile ( page ) print ( 'page actuelle :' , page ) def back ( self ): page_quittee = self . pile . depile () print ( 'page quitt\u00e9e :' , page_quittee ) 4. Les files \u2693\ufe0e Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une file travaille en mode FIFO (First In First Out). Pour \u00eatre utilis\u00e9e, une interface de file doit proposer a minima : la cr\u00e9ation d'une file vide l'ajout d'un \u00e9l\u00e9ment dans la file. On dira qu'on enfile . le retrait d'un \u00e9l\u00e9ment de la file et le renvoi de sa valeur. On dira qu'on d\u00e9file . La repr\u00e9sentation la plus courante d'une file se fait horizontalement, en enfilant par la gauche et en d\u00e9filant par la droite : 4.1 Utilisation d'une interface de file \u2693\ufe0e Exercice 7 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la file f et la valeur \u00e9ventuellement renvoy\u00e9e. Par convention, on enfilera \u00e0 gauche et on d\u00e9filera \u00e0 droite . \ud83d\udc0d Script Python 1. f = File () 2. f . enfile ( 3 ) 3. f . enfile ( 5 ) 4. f . est_vide () 5. f . enfile ( 1 ) 6. f . defile () 7. f . defile () 8. f . enfile ( 9 ) 9. f . defile () 10. f . defile () 11. f . est_vide () \ud83d\udc0d Script Python 1. f est vide 2. f = 3 3. f = 5 3 4. val renvoy\u00e9e : False 5. f = 1 5 3 6. val renvoy\u00e9e : 3 , f = 1 5 7. val renvoy\u00e9e : 5 , f = 1 8. f = 9 1 9. val renvoy\u00e9e : 1 , f = 9 10. val renvoy\u00e9e : 9 , f est vide 11. val renvoy\u00e9e : True 4.2 Impl\u00e9mentation d'une file \u2693\ufe0e L'objectif est de cr\u00e9er une classe File , disposant des m\u00e9thodes suivantes : est_vide : indique si la file est vide. (renvoie un bool\u00e9en) enfile : ins\u00e8re un \u00e9l\u00e9ment (pass\u00e9 en param\u00e8tre) en queue de file. (ne renvoie rien) defile : renvoie la valeur de l'\u00e9l\u00e9ment en t\u00eate de la file ET le supprime de la file. Nous y ajouterons comme pr\u00e9c\u00e9demment la m\u00e9thode facultative suivante : __repr__ : permet d'afficher la file sous forme agr\u00e9able (par ex : |3|6|2|5| ) Exercice 8 \u00c9nonc\u00e9 Correction Cr\u00e9er la classe ci-dessus. L\u00e0 encore, le type list de Python est peut \u00eatre utilis\u00e9. Penser \u00e0 aller voir ici les m\u00e9thodes des objets de types list , notamment la m\u00e9thode insert . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class File : def __init__ ( self ): self . data = [] def est_vide ( self ): return len ( self . data ) == 0 def enfile ( self , x ): self . data . insert ( 0 , x ) def defile ( self ): if self . est_vide (): print ( 'Vous avez essay\u00e9 de d\u00e9filer une file vide !' ) return None else : return self . data . pop () def __str__ ( self ): # Hors-Programme : pour afficher s = '|' # convenablement la file avec print(p) for k in self . data : s = s + str ( k ) + '|' return s \ud83d\udc0d Script Python >>> f = File () >>> f . enfile ( 5 ) >>> f . enfile ( 8 ) >>> print ( f ) | 8 | 5 | >>> f . defile () 5 Remarque : Notre impl\u00e9mentation r\u00e9pond parfaitement \u00e0 l'interface qui \u00e9tait demand\u00e9e. Mais si le \u00abcahier des charges\u00bb obligeait \u00e0 ce que les op\u00e9rations enfile() et defile() aient lieu en temps constant (en \\(O(1)\\) ), notre impl\u00e9mentation ne conviendrait pas. En cause : notre m\u00e9thode enfile() agit en temps lin\u00e9aire ( \\(O(n)\\) ) et non pas en temps constant. L'utilisation de la structure de \u00abliste\u00bb de Python (les tableaux dynamiques ) provoque, lors de l'instruction self.data.insert(0, x) un redimensionnement de la liste. Le tableau doit \u00eatre agrandi et chaque \u00e9l\u00e9ment doit \u00eatre recopi\u00e9 dans la case suivante. Ceci nous co\u00fbte un temps lin\u00e9aire. 4.3 Impl\u00e9mentation d'une file avec deux piles \u2693\ufe0e Comment cr\u00e9er une file avec 2 piles ? L'id\u00e9e est la suivante : on cr\u00e9e une pile d'entr\u00e9e et une pile de sortie. quand on veut enfiler, on empile sur la pile d'entr\u00e9e. quand on veut d\u00e9filer, on d\u00e9pile sur la pile de sortie. si celle-ci est vide, on d\u00e9pile enti\u00e8rement la pile d'entr\u00e9e dans la pile de sortie. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # il est imp\u00e9ratif de comprendre qu'on peut choisir l'impl\u00e9mentation # de la classe Pile qu'on pr\u00e9f\u00e8re parmi les deux trait\u00e9es plus haut. # Comme elles ont la M\u00caME INTERFACE et qu'on ne va se servir que # de cette interface, leur m\u00e9canisme interne n'a aucune influence # sur le code de la classe File que nous ferons ensuite. # Par exemple, on choisit celle avec la liste cha\u00een\u00e9e : class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante class Pile : def __init__ ( self ): self . data = None def est_vide ( self ): return self . data == None def empile ( self , x ): self . data = Cellule ( x , self . data ) def depile ( self ): v = self . data . contenu #on r\u00e9cup\u00e8re la valeur \u00e0 renvoyer self . data = self . data . suivante # on supprime la 1\u00e8re cellule return v def __str__ ( self ): s = \"|\" c = self . data while c != None : s += str ( c . contenu ) + \"|\" c = c . suivante return s # ------------------------------------------------------- # Impl\u00e9mentation d'une file \u00e0 l'aide de deux piles class File : def __init__ ( self ): self . entree = Pile () self . sortie = Pile () def est_vide ( self ): return self . entree . est_vide () and self . sortie . est_vide () def enfile ( self , x ): self . entree . empile ( x ) def defile ( self ): if self . est_vide (): print ( \"File vide !\" ) return None if self . sortie . est_vide (): while not self . entree . est_vide (): self . sortie . empile ( self . entree . depile ()) return self . sortie . depile () \ud83d\udc0d Script Python >>> f = File () >>> f . enfile ( 5 ) >>> f . enfile ( 8 ) >>> f . defile () 5", "title": "Cours"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#listes-piles-files", "text": "Exemples de structures de donn\u00e9es lin\u00e9aires.", "title": "Listes, piles, files"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#0-preambule-interface-implementation", "text": "Les structures que nous allons voir peuvent s'envisager sous deux aspects : le c\u00f4t\u00e9 utilisateur, qui utilisera une interface pour manipuler les donn\u00e9es. le c\u00f4t\u00e9 concepteur, qui aura choisi une impl\u00e9mentation pour construire la structure de donn\u00e9es. Un exemple d'interface et d'impl\u00e9mentation Le volant et les p\u00e9dales d'une voiture constituent une partie de son interface . L' impl\u00e9mentation va d\u00e9signer tous les m\u00e9canismes techniques qui sont mis en \u0153uvre pour que (par exemple) le mouvement de rotation du volant aboutisse \u00e0 un changement de direction des roues. La standardisation des interfaces fait qu'un utilisateur peut passer sans probl\u00e8me d'une voiture \u00e0 une autre, m\u00eame si l'impl\u00e9mentation est compl\u00e8tement diff\u00e9rente. Nous avons d\u00e9j\u00e0 abord\u00e9 ces deux aspects lors de la d\u00e9couverte de la Programmation Orient\u00e9e Objet. Le principe d'encapsulation fait que l'utilisateur n'a qu'\u00e0 conna\u00eetre l'existence des m\u00e9thodes disponibles, et non pas le contenu technique de celle-ci. Cela permet notamment de modifier le contenu technique (l'impl\u00e9mentation) sans que les habitudes de l'utilisateur (l'interface) ne soient chang\u00e9es.", "title": "0. Pr\u00e9ambule : interface \u2260 impl\u00e9mentation"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#1-structures-de-donnees-lineaires", "text": "", "title": "1. Structures de donn\u00e9es lin\u00e9aires"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#11-a-chaque-donnee-sa-structure", "text": "En informatique comme dans la vie courante, il est conseill\u00e9 d'adapter sa mani\u00e8re de stocker et de traiter des donn\u00e9es en fonction de la nature de celles-ci : Le serveur d'un caf\u00e9, charg\u00e9 de transporter les boissons du comptoir aux tables des clients, n'utilisera pas un sac en plastique pour faire le transport : il pr\u00e9f\u00e8rera un plateau. Le chercheur de champignons, lui, n'utilisera pas un plateau pour stocker ses trouvailles : il pr\u00e9f\u00e8rera un panier. Pour stocker des chaussettes, on pr\u00e9f\u00e8rera les entasser dans un tiroir (apr\u00e8s les avoir appair\u00e9es), plut\u00f4t que de les suspendre \u00e0 des cintres. De m\u00eame en informatique, pour chaque type de donn\u00e9es, pour chaque utilisation pr\u00e9vue, une structure particuli\u00e8re de donn\u00e9es se rev\u00e8lera (peut-\u00eatre) plus adapt\u00e9e qu'une autre.", "title": "1.1 \u00c0 chaque donn\u00e9e sa structure"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#12-comment-seront-traitees-ces-donnees-lineaires-introduction-des-listes-des-piles-et-des-files", "text": "La nature des donn\u00e9es ne fait pas tout. Il faut aussi s'int\u00e9resser \u00e0 la mani\u00e8re dont on voudra les traiter : \u00c0 quelle position les faire entrer dans notre structure ? \u00c0 quel moment devront-elles en \u00e9ventuellement en sortir ? Veut-on pouvoir acc\u00e9der rapidement \u00e0 n'importe quel \u00e9l\u00e9ment de la structure, ou simplement au premier ? ou au dernier ? Lorsque ces probl\u00e9matiques d'entr\u00e9e/sortie n'interviennent pas, la structure \u00abclassique\u00bb de liste est adapt\u00e9e. Mais lorsque celle-ci est importante, il convient de diff\u00e9rencier la structure de pile de celle de file .", "title": "1.2 Comment seront trait\u00e9es ces donn\u00e9es lin\u00e9aires ? Introduction des listes, des piles et des files"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#2-les-listes", "text": "", "title": "2. Les listes"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#21-definition-generale", "text": "Une liste est un ensemble ordonn\u00e9 d'objets. G\u00e9n\u00e9ralement, ces donn\u00e9es seront de m\u00eame type, mais ce n'est pas structurellement obligatoire.", "title": "2.1 D\u00e9finition g\u00e9n\u00e9rale"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#22-les-listes-chainees-linked-lists", "text": "Lorsque l'impl\u00e9mentation de la liste fait appara\u00eetre une cha\u00eene de valeurs, chacune pointant vers la suivante, on dit que la liste est une liste cha\u00een\u00e9e . Impl\u00e9mentation choisie : Une liste est caract\u00e9ris\u00e9e par un ensemble de cellules. Le lien (on dira souvent le \u00abpointeur\u00bb) de la variable est un lien vers la premi\u00e8re cellule, qui renverra elle-m\u00eame sur la deuxi\u00e8me, etc. Chaque cellule contient donc une valeur et un lien vers la cellule suivante. Une liste peut \u00eatre vide (la liste vide est not\u00e9e x ou bien None sur les sch\u00e9mas) Une cons\u00e9quence de cette impl\u00e9mentation sous forme de liste cha\u00een\u00e9e est la non-constance du temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment de liste : pour acc\u00e9der au 3\u00e8me \u00e9l\u00e9ment, il faut obligatoirement passer par les deux pr\u00e9c\u00e9dents. \u00c0 retenir : dans une liste cha\u00een\u00e9e, le temps d'acc\u00e8s aux \u00e9l\u00e9ments n'est pas constant.", "title": "2.2 Les listes cha\u00een\u00e9es (linked lists)"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#23-exemple-dimplementation-minimale-dune-liste-chainee", "text": "Exemple fondateur : impl\u00e9mentation d'une liste chain\u00e9e en POO \ud83d\udc0d Script Python 1 2 3 4 class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante Cette impl\u00e9mentation rudimentaire permet bien la cr\u00e9ation d'une liste : \ud83d\udc0d Script Python >>> lst = Cellule ( 3 , Cellule ( 5 , Cellule ( 1 , None ))) La liste cr\u00e9\u00e9e est donc : Mais plus pr\u00e9cis\u00e9ment, on a : Exercice 1 \u00c9nonc\u00e9 Correction Retrouvez comment acc\u00e9der aux \u00e9l\u00e9ments 3, 5 et 1. \ud83d\udc0d Script Python >>> lst . contenu 3 >>> lst . suivante . contenu 5 >>> lst . suivante . suivante . contenu 1 On pourra remarquer que l'interface propos\u00e9e \u00e0 l'utilisateur n'est pas des plus pratiques...", "title": "2.3 Exemple d'impl\u00e9mentation minimale d'une liste cha\u00een\u00e9e"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#24-et-les-listes-de-python", "text": "Nous connaissons d\u00e9j\u00e0 les listes de Python : \ud83d\udc0d Script Python >>> maliste = [ 3 , 1 , - 1 , 42 ] Et nous connaissons aussi (un peu) l'interface de ce type list , notamment avec les m\u00e9thodes append() ou reverse() . N\u00e9anmoins, l'impl\u00e9mentation qui a \u00e9t\u00e9 choisie par les concepteurs de Python de ce type list fait que le celui-ci se rapproche plus d'un tableau dynamique . Dans un tableau dynamique : le temps d'acc\u00e8s \u00e0 n'importe quel \u00e9l\u00e9ment est rapide. Ce temps d'acc\u00e8s est constant quelque soit l'\u00e9l\u00e9ment : on dit que l'acc\u00e8s est en \\(O(1)\\) . l'insertion d'un \u00e9l\u00e9ment au d\u00e9but ou au milieu de la liste est lente : cela oblige \u00e0 d\u00e9caler tous les \u00e9l\u00e9ments \u00e0 droite de celui-ci. Le temps pris par l'insertion est proportionnel au nombre d'\u00e9l\u00e9ments \u00e0 d\u00e9placer : on dit que l'insertion est en \\(O(n)\\) . Dans une liste cha\u00een\u00e9e : le temps d'acc\u00e8s \u00e0 n'importe quel \u00e9l\u00e9ment peut \u00eatre lent (proportionnel \u00e0 la position de l'\u00e9l\u00e9ment dans la liste). Le temps d'acc\u00e8s est en \\(O(n)\\) . l'insertion d'un \u00e9l\u00e9ment \u00e0 l'int\u00e9rieur de la liste est rapide : il y a simplement \u00e0 modifier la valeur du lien de la cellule \u00e0 gauche de l'endroit d'insertion. L'action d'ins\u00e9rer est donc en \\(O(1)\\) . Toutefois, avant d'arriver \u00e0 l'endroit d'insertion, il faut avoir parcouru toutes les cellules pr\u00e9c\u00e9dentes ! Le temps total d'insertion est donc lui aussi lin\u00e9aire, en \\(O(n)\\) . Nous nous servirons parfois du type list de Python dans la suite de ce cours, mais il ne faut pas oublier qu'il n'est pas un \u00abvrai\u00bb type list .", "title": "2.4 Et les listes de Python ???"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#25-un-exemple-dinterface-pour-les-listes", "text": "Imaginons que nous poss\u00e9dons une interface offrant les fonctionnalit\u00e9s suivantes : Liste() : cr\u00e9e une liste vide. est_vide : indique si la liste est vide. (renvoie un bool\u00e9en) ajoute_tete : ins\u00e8re un \u00e9l\u00e9ment (pass\u00e9 en param\u00e8tre) en t\u00eate de liste. (ne renvoie rien) renvoie_tete : renvoie la valeur de l'\u00e9l\u00e9ment en t\u00eate de liste ET le supprime de la liste. Exercice 2 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la liste lst et la valeur \u00e9ventuellement renvoy\u00e9e. \ud83d\udc0d Script Python 1. lst = Liste () 2. lst . ajoute_tete ( 3 ) 3. lst . ajoute_tete ( 5 ) 4. lst . ajoute_tete ( 1 ) 5. lst . renvoie_tete () 6. lst . est_vide () 7. lst . ajoute_tete ( 2 ) 8. lst . renvoie_tete () 9. lst . renvoie_tete () 10. lst . renvoie_tete () 11. lst . est_vide () \ud83d\udc0d Script Python 1. lst = Liste () # lst = None 2. lst . ajoute_tete ( 3 ) # lst = 3 3. lst . ajoute_tete ( 5 ) # lst = 3 5 4. lst . ajoute_tete ( 1 ) # lst = 3 5 1 5. lst . renvoie_tete () # lst = 3 5 valeur renvoy\u00e9e : 1 6. lst . est_vide () # valeur renvoy\u00e9e : False 7. lst . ajoute_tete ( 2 ) # lst = 3 5 2 8. lst . renvoie_tete () # lst = 3 5 valeur renvoy\u00e9e : 2 9. lst . renvoie_tete () # lst = 3 valeur renvoy\u00e9e : 5 10. lst . renvoie_tete () # lst = None valeur renvoy\u00e9e : 3 11. lst . est_vide () # valeur renvoy\u00e9e : True", "title": "2.5 Un exemple d'interface pour les listes"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#3-les-piles", "text": "Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une pile travaille en mode LIFO (Last In First Out). Pour \u00eatre utilis\u00e9e, l'interface d'une pile doit permettre a minima : la cr\u00e9ation d'une pile vide l'ajout d'un \u00e9l\u00e9ment dans la pile (qui sera forc\u00e9ment au dessus). On dira qu'on empile . le retrait d'un \u00e9l\u00e9ment de la pile (qui sera forc\u00e9ment celui du dessus) et le renvoi de sa valeur. On dira qu'on d\u00e9pile .", "title": "3. Les piles"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#31-utilisation-dune-interface-de-pile", "text": "Exercice 3 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la pile p et la valeur \u00e9ventuellement renvoy\u00e9e. Bien comprendre que la classe Pile() et ses m\u00e9thodes n'existent pas vraiment. Nous jouons avec son interface. On prendra pour convention que la t\u00eate de la pile est \u00e0 droite. \ud83d\udc0d Script Python 1. p = Pile () 2. p . empile ( 3 ) 3. p . empile ( 5 ) 4. p . est_vide () 4. p . empile ( 1 ) 5. p . depile () 6. p . depile () 7. p . empile ( 9 ) 8. p . depile () 9. p . depile () 10. p . est_vide () \ud83d\udc0d Script Python 1. p = Pile () # p = None 2. p . empile ( 3 ) # p = 3 3. p . empile ( 5 ) # p = 3 5 par convention 4. p . est_vide () # False 4. p . empile ( 1 ) # p = 3 5 1 5. p . depile () # p = 3 5 valeur renvoy\u00e9e : 1 6. p . depile () # p = 3 valeur renvoy\u00e9e : 5 7. p . empile ( 9 ) # p = 3 9 8. p . depile () # p = 3 valeur renvoy\u00e9e :9 9. p . depile () # p est vide valeur renvoy\u00e9e : 3 10. p . est_vide () # True", "title": "3.1 Utilisation d'une interface de pile"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#32-implementations-dune-pile", "text": "L'objectif est de cr\u00e9er une classe Pile . L'instruction Pile() cr\u00e9era une pile vide. Chaque objet Pile disposera des m\u00e9thodes suivantes : est_vide : indique si la pile est vide (renvoie un bool\u00e9en) empile : ins\u00e8re un \u00e9l\u00e9ment (pass\u00e9 en param\u00e8tre) en haut de la pile. Ne renvoie rien. depile : renvoie la valeur de l'\u00e9l\u00e9ment en haut de la pile ET le supprime de la pile. Ces 3 m\u00e9thodes sont essentielles et se retrouveront syst\u00e9matiquement dans chaque interface. Nous y ajouterons, uniquement par commodit\u00e9, la m\u00e9thode suivante : __repr__ : permet d'afficher la pile sous forme agr\u00e9able (par ex : |3|6|2|5| )", "title": "3.2 Impl\u00e9mentation(s) d'une pile"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#33-application-des-piles", "text": "Exercice 6 \u00c9nonc\u00e9 Correction Simulez une gestion de l'historique de navigation internet, en cr\u00e9ant une classe Nav qui utilisera une pile. Attention, il ne faut pas r\u00e9inventer la classe Pile , mais uniquement s'en servir ! Exemple d'utilisation : \ud83d\udc0d Script Python >>> n = Nav () >>> n . visite ( 'lemonde.fr' ) page actuelle : lemonde . fr >>> n . visite ( 'google.fr' ) page actuelle : google . fr >>> n . visite ( 'lyceemauriac.fr' ) page actuelle : lyceemauriac . fr >>> n . back () page quitt\u00e9e : lyceemauriac . fr >>> n . back () page quitt\u00e9e : google . fr \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 class Nav : def __init__ ( self ): self . pile = Pile () def visite ( self , page ): self . pile . empile ( page ) print ( 'page actuelle :' , page ) def back ( self ): page_quittee = self . pile . depile () print ( 'page quitt\u00e9e :' , page_quittee )", "title": "3.3 Application des piles"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#4-les-files", "text": "Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une file travaille en mode FIFO (First In First Out). Pour \u00eatre utilis\u00e9e, une interface de file doit proposer a minima : la cr\u00e9ation d'une file vide l'ajout d'un \u00e9l\u00e9ment dans la file. On dira qu'on enfile . le retrait d'un \u00e9l\u00e9ment de la file et le renvoi de sa valeur. On dira qu'on d\u00e9file . La repr\u00e9sentation la plus courante d'une file se fait horizontalement, en enfilant par la gauche et en d\u00e9filant par la droite :", "title": "4. Les files"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#41-utilisation-dune-interface-de-file", "text": "Exercice 7 \u00c9nonc\u00e9 Correction On consid\u00e8re l'encha\u00eenement d'op\u00e9rations ci-dessous. \u00c9crire \u00e0 chaque \u00e9tape l'\u00e9tat de la file f et la valeur \u00e9ventuellement renvoy\u00e9e. Par convention, on enfilera \u00e0 gauche et on d\u00e9filera \u00e0 droite . \ud83d\udc0d Script Python 1. f = File () 2. f . enfile ( 3 ) 3. f . enfile ( 5 ) 4. f . est_vide () 5. f . enfile ( 1 ) 6. f . defile () 7. f . defile () 8. f . enfile ( 9 ) 9. f . defile () 10. f . defile () 11. f . est_vide () \ud83d\udc0d Script Python 1. f est vide 2. f = 3 3. f = 5 3 4. val renvoy\u00e9e : False 5. f = 1 5 3 6. val renvoy\u00e9e : 3 , f = 1 5 7. val renvoy\u00e9e : 5 , f = 1 8. f = 9 1 9. val renvoy\u00e9e : 1 , f = 9 10. val renvoy\u00e9e : 9 , f est vide 11. val renvoy\u00e9e : True", "title": "4.1 Utilisation d'une interface de file"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#42-implementation-dune-file", "text": "L'objectif est de cr\u00e9er une classe File , disposant des m\u00e9thodes suivantes : est_vide : indique si la file est vide. (renvoie un bool\u00e9en) enfile : ins\u00e8re un \u00e9l\u00e9ment (pass\u00e9 en param\u00e8tre) en queue de file. (ne renvoie rien) defile : renvoie la valeur de l'\u00e9l\u00e9ment en t\u00eate de la file ET le supprime de la file. Nous y ajouterons comme pr\u00e9c\u00e9demment la m\u00e9thode facultative suivante : __repr__ : permet d'afficher la file sous forme agr\u00e9able (par ex : |3|6|2|5| ) Exercice 8 \u00c9nonc\u00e9 Correction Cr\u00e9er la classe ci-dessus. L\u00e0 encore, le type list de Python est peut \u00eatre utilis\u00e9. Penser \u00e0 aller voir ici les m\u00e9thodes des objets de types list , notamment la m\u00e9thode insert . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class File : def __init__ ( self ): self . data = [] def est_vide ( self ): return len ( self . data ) == 0 def enfile ( self , x ): self . data . insert ( 0 , x ) def defile ( self ): if self . est_vide (): print ( 'Vous avez essay\u00e9 de d\u00e9filer une file vide !' ) return None else : return self . data . pop () def __str__ ( self ): # Hors-Programme : pour afficher s = '|' # convenablement la file avec print(p) for k in self . data : s = s + str ( k ) + '|' return s \ud83d\udc0d Script Python >>> f = File () >>> f . enfile ( 5 ) >>> f . enfile ( 8 ) >>> print ( f ) | 8 | 5 | >>> f . defile () 5 Remarque : Notre impl\u00e9mentation r\u00e9pond parfaitement \u00e0 l'interface qui \u00e9tait demand\u00e9e. Mais si le \u00abcahier des charges\u00bb obligeait \u00e0 ce que les op\u00e9rations enfile() et defile() aient lieu en temps constant (en \\(O(1)\\) ), notre impl\u00e9mentation ne conviendrait pas. En cause : notre m\u00e9thode enfile() agit en temps lin\u00e9aire ( \\(O(n)\\) ) et non pas en temps constant. L'utilisation de la structure de \u00abliste\u00bb de Python (les tableaux dynamiques ) provoque, lors de l'instruction self.data.insert(0, x) un redimensionnement de la liste. Le tableau doit \u00eatre agrandi et chaque \u00e9l\u00e9ment doit \u00eatre recopi\u00e9 dans la case suivante. Ceci nous co\u00fbte un temps lin\u00e9aire.", "title": "4.2 Impl\u00e9mentation d'une file"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/cours/#43-implementation-dune-file-avec-deux-piles", "text": "Comment cr\u00e9er une file avec 2 piles ? L'id\u00e9e est la suivante : on cr\u00e9e une pile d'entr\u00e9e et une pile de sortie. quand on veut enfiler, on empile sur la pile d'entr\u00e9e. quand on veut d\u00e9filer, on d\u00e9pile sur la pile de sortie. si celle-ci est vide, on d\u00e9pile enti\u00e8rement la pile d'entr\u00e9e dans la pile de sortie. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # il est imp\u00e9ratif de comprendre qu'on peut choisir l'impl\u00e9mentation # de la classe Pile qu'on pr\u00e9f\u00e8re parmi les deux trait\u00e9es plus haut. # Comme elles ont la M\u00caME INTERFACE et qu'on ne va se servir que # de cette interface, leur m\u00e9canisme interne n'a aucune influence # sur le code de la classe File que nous ferons ensuite. # Par exemple, on choisit celle avec la liste cha\u00een\u00e9e : class Cellule : def __init__ ( self , contenu , suivante ): self . contenu = contenu self . suivante = suivante class Pile : def __init__ ( self ): self . data = None def est_vide ( self ): return self . data == None def empile ( self , x ): self . data = Cellule ( x , self . data ) def depile ( self ): v = self . data . contenu #on r\u00e9cup\u00e8re la valeur \u00e0 renvoyer self . data = self . data . suivante # on supprime la 1\u00e8re cellule return v def __str__ ( self ): s = \"|\" c = self . data while c != None : s += str ( c . contenu ) + \"|\" c = c . suivante return s # ------------------------------------------------------- # Impl\u00e9mentation d'une file \u00e0 l'aide de deux piles class File : def __init__ ( self ): self . entree = Pile () self . sortie = Pile () def est_vide ( self ): return self . entree . est_vide () and self . sortie . est_vide () def enfile ( self , x ): self . entree . empile ( x ) def defile ( self ): if self . est_vide (): print ( \"File vide !\" ) return None if self . sortie . est_vide (): while not self . entree . est_vide (): self . sortie . empile ( self . entree . depile ()) return self . sortie . depile () \ud83d\udc0d Script Python >>> f = File () >>> f . enfile ( 5 ) >>> f . enfile ( 8 ) >>> f . defile () 5", "title": "4.3 Impl\u00e9mentation d'une file avec deux piles"}, {"location": "T1_Structures_de_donnees/1.1_Listes_Piles_Files/data/chaine/", "text": "\ud83d\udc0d Script Python s = 'YyLlXxYKkbNnQqBFfxXbyYWwBhHyYTCBbCjIiqwtTWQJczeEauUAZDdFfmwWMccbBOojBbXxKnNkkKsSeEsxXmxlpPLXMuULlSJqnSsNQmMmMCYyXDdvVDdtTxYmBbsSNdDnyYaAOBbouUwWiIMyYzZyPptGDbpoOPBdnNtTapPeEAHhrXxRtSjJsTPpepPGgCcEfFenNEmMGUpPugCanNAnNcEzZTtQqZzRreMmpzPpzZZJbBjxXTtEcCemMPJjXxhHTtydDmIOolLiJQqHhkKMmjVeEsSWwnNQqsNgGnLkKlcCSvdVvcCDeWPpwEvVUuNnTGhHgVZEenNQqRrTtSspjJPHhcNnYyCwoOHhcFJjaAXxDdqQfTnbBNtSsyLlYCGgWEezZiufFUhHHSshkKTvVoOtIfFTbBtTyYeqQEZnNztDdNnxYytFflLTWwSgGsmsSMXzvIikeEfFpPKdDccCTtFfqlRrLQgGqxyYXQCpuUPkQqKTeEtSsXmMmMxVDdWweuUEyYtFfboOBbBbBTuBbrReEKfAaFkoeEtTYyRroOQqcCjYyYycCtTJOLVvkKWwYylukKqnFfilEeXxLgVvqQGINQZJjlnNLzVvKkpjkKJPsSBIibQmMqXQqHhrTtRayYAECczgGZeHhFfMCbBcVvfFZzRrNlLwQqZzWnjUukKxXkKFfJuUzZqQyYfPpiIOojJFNZzhHlLnVfFvwYHhyWMmOUuqtTARWwrZNnzasSzYLlyCBbcLlKkoOZZzIiKkQiqQIRiIkKrgFfpPnexXEPpNTtOobgGBEeCDdcoOQqGQCUuhoOSnNsbBWwfFwiIFfEeZzWQEIieSmMaAsFfEeSsHKkhjOoJmvVMlLGtvVTTWwtgXSsxpPIZziKHhXXCLlcxyaeEcCAYxkLlCcEefOoFLlWweEyOnNojJZzYcXxmMWwXxydXxDFfgGYGGgxOpPoUuXRrgplLPWwqLlQEQYylLqgSsjJDsSIidIVviGnNaAFfelLVvdDHsShmCcroOOoJjSsQqqQHVFfvhiqQeEWmnNzZjJJbtTBsSjGgoOMKDdfqxXQFjJmMitTIcCkcCwrRxnNFfvVXIRDdJAXxahHZzJjzZBbjjbBJhuUAaxXHMwpPfFmMcCfuUyAfFauZUuuUzRrUjJuPZzfKlLdDhsSSsAatyYaAHhTbnNBbBQqmmiFfIxOZzoXAaAaWwMWwzZaAMhrRHHsNnSBboEeXCcxOrAaZzsSRkLqzZQPplFaIiAhHZzwWMmEeWwnplLmMQXDdYsSyWwxHhRrWwoOKhoOltTLHAaDdkgGLkKlquUPpXxdnNrRpXxPbNnbVviIGgBBzFfZIiwWDCcGggJjiIGxXxQGgqQqteENwWnTiIAAaaSsNnTVPpbBFfvtXCcDuUdDdBdhHKOokiWSCcswIcCcCKkoPSspOWwUkKuAaKkoOwhAawWaALlHCcWcJYyKkMmMmhHzZjvVtThHCDYyALlNnrRGcCVvpPgvCcMmVLhwWuUmMHUupPladDHhNnpPMTtmazZvVAakUuxXKDmMZzdGgLlABbNnMmWqQRrvVeEjSsJwJMmjTwAEQqeFfRrQqQqaqQdaADWGgtFfacCaBboVvZzDdOZzTtgGOFfGgoqBWwbxXZzsBVVvDnNhHXxdvZwWzOrRosSEeyYVvUuEebWwoOXxUuQqTqQtBbiIEXxeBHQqtTiIxXRZCtTchHQqzBktTKIitTNvVnYZzysEeSMBbKAjJpPFfavxLlXVQqKkDEMmYyenNXxtTlYbFfByLIiQqKkGPhHpFaxXAfglLYySsBpPvVbyYdnNyyYYKkXzZeEeEWwRxXreEgGUusHCPpczJjZOohsSpWtTwgGPKkvVFpPVvfSsOMmnPpNoOozezNnZksMmSIiaAEeGgoOpPuUWwDYcsYySPXCcYyoUNnCcuOZzLbBlAGguxnNwWvHhVXsPaApSPpQOoKtTVvExXekOmMoOooZzOOoIihQqHCcqmzIiZMQHhqTsSQqfFtxzwWrReETtmwNsOxXovVAeJjEaSnWMSNtTnsWsSwaAvVZJrRjfFnaANDdYzlLOoQqZysrRtTwvVWSRdAkXxKarvqQVgpPGOomkPpKMHhpPlkKDdpPLSszLlZyYBbxgGUuCdDeEcaACcXCclLRLllLIigGmMrRXxBbCcOoeELnNbBKxDdXHhkmMlTtpeEPQqzZDnNIiDBhqApPaQnNcpPCiSsqQIHiqQTsLnNlWKkNnwtWwAaThHFfGuUgSLsRrSliItFfDduQqSstTwcCKkWUhHLlSoGrbBOoRgWCcwgVvGtKkhPpBbHSsKkTFfUZEekKfcCWwHhYyFbBaAzuFrRAHvrReEVlLFfhaisVvSHvVXxlLjEeJJjgGjdDcCJhWwKkmMSXPpxsKzZwAaWkttTTaSapPXKkkrRhkgzZGCcKxXHuUKZWwzZzSsxdbBDXKkxfTtIiAaFhHmxXMnNJjUuxeEXuGgUuUzuUZjJvbBVtTpUuYykKPnNfFGGKkgoOxXggFfGrJjRoOaAOodHhxnNXcPtQqAaTmMZbBzpXeEdmzZmMkTtpPKFeEedDdDEhHqubBUQYQqykKcrRCfMSsAnPzZTtpuUNWwIiuURrdDaeECgGcyYzMIimXQqqaAQnJjwWaAeEKqQBCDdeEfeEGgaPpbBAhHKKkbmMBkOouCcrlcCdDsSLRmYyNnSRgGiFfIrcOHhUugGzZTdDtVPGgpvGgXxouLlNnlLUGgwZzHWwhPptTWfiFWwfoOsSIvsZzSVsSuSsUFGgETTkKzZtteJdIiDlLlLugjTiItFfJNnwWGiIlLKkTtnNDsSdpPUeEeEJjgGPSspzZbcjJCBAaeVPpLfSsFTXxtlBbhkFkKfuUQqKNnHkKMSshQqVvOpPrRXxZzSzZsZzHhNnWWwwqQUuBLlyYrRgGfTtFrxXUuEeYyUuKvVdDkqURFfFlLfxfFXmkKMCZAaYyTgGAatzcrNOoIntTNisSnrJjUuRHTthwWwByYmMDhHqQWzOjJoZwdhHFfboOdVvNdFDdOjJoeEOoIihHfqCcQaAmMcoJjZsDAadSeEzOSsCGeEUAcCaFaAtTnNYvVUuyZzLoiIcCOlhHfVvUuIicCeEDsSdDdrREeESsejWNnWwGgOdDuUfFcClLMEHhZzemtTEvVeXxGpPgSOUudDNfFPpnyrROoYEMmeyiIYoqVvuUJNnDdjQGgofFAaOuXKklfFdDmMLAauUSwWrXxRhHBWQqwbseEeExXbnNCcBEgGVCXQqxcwWvPPHhpraARICcQqwQPpqsStTWAaDdQxDdBbXlZzLbBdtsCcOoSOoaAEeHTthlcdDCLuUTDksSKktTqQvWOowhHCkKbxVvwWXCOoDdYycPpcPpNnCIIiiulIieELCcPrRCUujJGNMmngfFTcCvVdUuDtjJtTfNniwmMmMVvNnosSVvLlOWmMHXxWpPwXxgGhaAJjvpPlLigGBbCMmHhcIkKDuUdDeOoqaAQEJKkjrRyYzZIifFkKKRruVvNneTtpPuUEkKYIiyqCpPfFpPLlFfTtnahjJHANUuhNnIidoOpPycZHhznSsYytTUujJhHNCqzZBwKkWEejJCcHDdSshRrOwWohHbCcmabBAmMMXdDcJjCtlLTUuZztBNnbxXTuUSxwWjJXsYyLlHhMmhyYKsSkBjCcJHhMZzUuvSVvZzCcehHEFEeftnIiRrNTqVvmIiugGUTSstSsVNnDdhVkKveEHwWzZvAagGXxipPaAIvVhHhDjJBbdtTWbBFfwdDQqVHhtTtkvrptTrRPRzWgGwrRjJxtbYyqQhHBePpFfELVXxeEvNnlXjJgGxGKkgoDYypPpNnPdlwCcWzNnsSZLwcCoOrvVKkJjdDdTtDiyYyYItqQTyYmMwWSYHhrDdufkJjhHWvVwpwWylPMmzZpLESsmjJMeBbaAWwJjuQqMJjXeEaAaFffFFhnNCcZdDYyzeGgESTtoKkBbmhHedDFfHhcCdDWAawlEVvXDdxlVvioOIOYyogKkbBGLHWwhWwpPWwxRrXflLPWCciTtCcNnNmMNnnSsYyqyYlpPIiBbLrfFRmMVvQIFfZzduwtJjyMmbCNnsScCmMmptSOoEeoXuUxOsKkEWuVyYuUPpQpcCPtRrcCtFfKcCfZRrzdDFkSFYyfMmsftTlEeLECMRrmcTtQGKkgqCMNnLlxYyXaPuUcCaAqQtTAEeaMmpZznvWwVTtUkKuRrIiUuJjtTwfFjJWsSjJttTTNjJqQtIiTkMKIikmyxwWXYPLgGRccCCrPpTEetNniINnpPBzZbFFffBBbaAbOFrRfXxpRZzrFfPxyWwYUVjJvuMmPpXxxXBODdoPpGmMbSIisBgejJEwWbgGXXxxoOtTJjcHsShgGxXCzFAafsSAaZUuxTBiOooOuULlUDduDdFQqfIbdjJuUrWzZiIPFVvDdiIfpwGfFsBnBtTbvVsSNJYyXFfxbyYCPtTpKHkKzxXCcZUuuUKECcyYCcZzeIoiIMOpkKPfFdDYywWouUAjJaFtTfxXjZbBzJvFfyYjJOoMmCceBbKkEkKLlxmxXMCcCcMryYRGDdOogzQFfqHEbBtOoNOCcstTNnSoDSGgseUuLlExbdDBXkKLlJuSbBbcrRCdDBaAsWaAwtTBbVZzvqiIMmuUHtTwWfFFFfKkqQxYRWwYyeEfbBVviGzZQqCRrsSXDdxXxcvTtHOotThkKPptTpZzPCcVfFnNzIiZyIMmiVvUuYwHhuUjJdDWfQXkKxMmCtTcFfhiIDdHdsSDFEefqZzKkQROorqyZVvzRtKHWwmMjbBJUuKkRPprLlfgnNpKoOMmTtaALlbBHWdDGgwhQqOqxXiIIiYyDdzZrGcaAFfhHxEeNnpqqQQTMmqmMrlLTIeGgEmGgMZzWwATtavnNsaPpGgASZzVhHOLLbBlwWkKYyiVlFfLoOtlLTFfCOoVvjJcYkKXxpJjPHhmMZzyUaAuNNnvVtTzSsbpaAPBDwWGgbBFarzZRAfBwSRrkaACcrRizZIKkiuUQqWwIXxKQqpPzzfFZZnNnNyDdVvCmbpPYkKAZzaDuUdXQdDqzJuUTVvoOteERrdDoQqcCcbBwGgdDvcCKkVEZkKzeRrdhHCcDHhkYyATtagGVvbBFBqQBbQSsUuAjTjJvGzZpGgPCbTXnNwWJjbBhtjJmMPpQqqQuUBbEWweYKkyTXxxJIivRrvhHXxRriIIqQijJVlLIOfZzlsSLQqdyYvVJIijHTBBbbmIimMlLNnMxgGXYypPTwWteUvFGgfpPVHhoOOjJohCKkcAawPpWsSeBfFJjyYbAYyKdDbJjBPJjZzUjJTtuzLeEgjJIsSiGiIbBRrMJjCcbgGJjxRrXmMgGinNfgGFxuUkKCceEMPpmXIdDBuBbUKoOkuUXgGxEexrRxQqXXodDdDWeebBEPpxXxoOXboOqQDdBhHJRPpuUQqrjJiIXxsSjaALlSsuyYUXhHHJhbBzZPplLdFfyYDwWbauYySSssUaAASBbsJjUtTulRgVvGJjeEmFYypPZzPpqTtzSuxXBbUmMVKkvRroOwVUuiIfpPVvXxbBYAaHhGIMmjJdQqqQDisVSsvUugGSyYsSPiIpsWwhHSHhciICujJUJBbyQEhHeafFWwooOOFIimMXrRxyWFfBbQqqQwNnZaAzRrwmHYmMyxXhzAaZvVbBTEetMQGgqXxWZmMZzzRrNnXzZOoxfFJjgGgGTPpgddDYyDSsIixDdXSGgsguUMiImGymMCcyYoOPCcwNnWpiIYyjEerXxAadDKkNuUQqnQuUOoqSswDdEeXeExWoOjIGCcOolqbBQEeMmmMLFHhAJjWwvVcCnNqQaqQunNrRUXxrRQOIiuBbkEecCLREenNrjDdRrDnNwWTtzlLMmuaAIqeLKcmHCsSBbFfchQqfTtFMIijDdCKXxHPvVRrWweMmLlrREqvxXVQSsSprRPPpsyYjKdkKDNzFfZnkwWlRrLnNYBbyeEjJmMvITtiAaVuUUuJFfjMePpECcepXxPGaARrdyYDiIMmgnSsIAnbBZIioODdSszNEeFBbYaAyfFiIvVvmMfjaeEcCAhHsSQqFfJFVFAaQqfCuUPpPMmBbbnNGgjfFJqTgcCqIWMmVvoOliVvIFeEzZBqkKQbQqcCfxszZpPMmYyvIiVWwSsYkKHgGGFfLlgZzKkvVOoLgGiIRrgBsSbqqZjbBXxvVaGgAJoMPpsSmOjJaAOJjIIiizuUZYylLdKxXkgrXbBLlgGKkxnNBbWwldmMuFfULlGgFfmKkQqfLlJjFuMmPpUIiHYyIcCTtYyigGdDhnNRroOkKgGMJiIMmzfFsfbBFSXdDwACJEejcnpNniIIjJicuUCnNmMWwpPPsSRrLlPpFlMmqizsSZQqiIqQRTzZtTUuRrdDJIcCcCnVJmMjvzZAagGjoMmxXSaAsiIiIOeELlNnoPpUlVvLkKuYyOoOeQeEuaANRrxXnDDiIddUXxqWXFfuSsOoUIixzSsZYyYyYaAXxNLlXxnZzKkupPfFaEeCzZABboOaQqjkKfFJvMmVvUuVPpZzMSyYPpsOoNBySsYbktTOKGgzMKksSmMacTtCSsrRAxXPwPVUuWwlvbBBbxUkKaNngiIkBbFfJIiGgjChHcMmIiXxxXKkHKlLkeMmEkOoKdDAoOoOahKBbhSfAahJhHjJwjSsJjJmbBYenNEqQUxXykKNnXxbBrRwGgWXBbjJnRhHnNOyYoOCeEmTtFfMJjeEcsSFfeEvVnNEVlrRLjmNXWPpsSeEwtTKkbmRkKsSHhrRrRgGrUMMmmzZyvVYocCOSWwVvsfFdrdCcgGDRQAaqbfrRFBwpPMmWGgdNnJjvVDKYyPpxGKkgzDmMdZPnNpWVTtvFmKkELqQtTleTtwWclLcwWUuCTtCOnNaDdMmRrAiIgdLlDaAYyGBcOZzolaEeaZmqQbpPUuBgGdDcCgGhfVvvVFGgoOsSrRxoKkOXYXxMmCpPhHlLVvcIiEefFOodDlUVuUGgQMQqHPphmOMmolLCuUASssUuVUuvdwWDaAEeTaDdVmMvCcDdjBbZnNznNMyYRrmcCnNJVvrxXtTiXxiVSsvIvVBbxDPpdPpoVvSqDdQZkKzsOXffaAYmMGgZzguUpaTxxvVWzZWwwBRhHrSoOFhHEeyYTtfoOIEeisSsZoiGPrLIimpqQzZPMhEtTeqJjGQqyFfYgEejJvGlLbBgqQVxDXxwWdVjJlaALjJjnoONmdUfFVvuTtDmMNnmMPluULSszrRLXtTOoxSNCbBCccngnNrRbBGYhHyqQibFfJSvVsTMmtzmMZZsNXxnSzugGjXxJWwjJlVvnNAIrRAavViiIUytOCXxcnNCEeckKTtjJonXxNnYyJjMmhHqQMmFmBxGWkJszMPrkSspPJrRkzZKjQnBbWQqjGTtgoOTsLlSHhDzNnJhHPpQYygkccCCPpKGjJMmDvVCGcxXTtEUwFfkKWlLurRRrESKJreVvZrMeyYNnEDdDgGnGgNdDokKOnNiCVvxXcIzEoOemvVMOoXKkbNnvVBcYvVbBgGWwmMtTNKkGiIgOoOooOHhCqQsMmSnNJsSfQWCCcGlLeEuUgZztIiTqzZQIxZzXkMThybBEAaOgnNUDdiIilLgLlGjJIuUPArJEcCoKLlkOuUbBBTrYyEeiImMSNnlBuUbwWAueEgbBZhHgdDlLOoGocCwWfEXCcAKQqkSzZegGKktTlLCCdDIiPpcuuvsSVUXxfflDdLtmuUMqQTpYyPdDVMmvXVvxJjuUxXuUmMOClYyFuRvVcpPqBPpboJjaVvADbBdfFFilWaOoAwPpLfKkvGBbKZzcCHhwBbFfmMWUbBuKkrbAaSsCclDqbBAaYDCIiEwXxWejNYEXudCcCUudalWwgGLpWwPVvWjICcZzidDxXhHzZJTtYyeEoyUurjJRYdDTtyPhkKnNHOPpJTtjELlNdxEerRHhgGiIXMmJjDJLlDqQHFrRrRmMqQotTOEevVrRWwCkGgKJRrAkqQyJPXkKxEhTtfgGFHEDdcCcCzZYNDqQdsiIMGkKvaAsCcWwSrNnPXxwqbBQHhWrsBXxgPQqpDdUGIUuwpPcCFptTtJKkNqQnolLZcCkKRsSpvVGaKkAnpPLPKkKkoJjOxXRrUukKxbBefgGAYylRrtTLbBaxXniNFbVvBeOoPpEEdDYynMOXxopjJPuUeEoOpPLlemMYEeGEegeEQqXTtDxXcCdMmnrCcRqQhEefFHiIZHBxXbdOoDuVvUpPuYwUtdDTluUxTtXRrLLzcCZAUnMmNWZzbBnNAGgbBxXpXFRrZlLeGgXxEeJQqxOGgKkMSsyxXTVvtwWAaHhyYHhsSAoOOofFfChHsScinNcCIFupPCYTtyceEprRPewWbGJjgcMBCcCBbZzcbmGjYyhTtzUuxXZHcCMUumAaYyRjUaQqAuJrLlPpKkuODdWwoGgcCUUDduzTtZwWKYyQqQqGggsIXxiSOmdDMognUuxgGHNndDwWtTOHhoLllrRrRfvVbIvVXDdooFWwfFfOnrcCUXxBbuRQqHxLWmUuxXJjxTtzZVfFXtTwWoSDdcCshzZHPpVvTtDkjYkKrWwRUukKwWyUuOzZopPQqRqvlLVQbTtqQiIYVpPEWjjJJmbBjJMEnNelLgzCcJDdAaOoJjdDdDjyYTtRwdDAaaNMmOoGCkKcWpVvPXkKqQeExwgnHhVtkdDKCcTGYlLNnRrRETlIiNdDzrGgOonpPOlLJjsGvVgtLlLlaAzaAaAZiIYZzyVvTmuUGEeizZIDLlRrtDTtdfFcCowWOdUuyYEeDgSuUKAfkKNvdDVnGaAgFaAauonNOUQqwDdHhbTtBWgGBJjtTwqQpBbFfwWPKkZBbzyiHCchRrDdWLlwEePpZzleEJjpPgGLsStHhiIiIWwPpWwTLqNpsSPQqHyYhbBVHMXxmzXJjwWRUuZzkKJAajgGNxXYsOoSAayiiOCcouUtTlLIiyAaDdXxGgYoOTtjJgGlTNnXhHBbxVvnnNpsSPNjJIyduUwnNWWwJjKkWwYFIiRPVMmHGgNrmMJZzEeHJWMqDdQeEFfySPpklLKIvVDeztTfSFfsuUFrRTwWuOHhVvoeEVvbBkKDAwWJrRwWWfFUukWORWbBEewaAnlLLSslIJXxjUuUzeEeEZwWOoujSsHpHtThOoTtlLHJOdDSJjQIigFxqHhQYyOoYNnyXWkXZzUxBznOoNnWwlgGgsSTtocPpAaEXbBGMCcmcFftTrhHunyYlzmMnzZsSNekKEsZzuUeiIpPsSlLJjRUumMrbcCVdIiHLldDtTqKkAziIZHhEOoMmCXxcVvSswWAaCMmlGTtgpPLQOQFfqzAaVvEHhzEevVnNnQqNqTtnNpPTNpfFGnNzZZpXamoODdygDqQmMdDdyIkKiSiXxSsIiRgDdGhNnHgGlTdnNDYWwyeEvVCcXxJeEpPqQoCcOPEEelLjJoOEJjeDdqQWwyIIiLEelUuyYfFQqcshHheEHSCvVOonEeNnAaAALIilpxGnOoNOjJoDoMmruURKklLOKigGuUBnNbGgbBgGFsDYydIXkKHhNnhHToOhKkeNnEzJmMhHjmpmMPdDaAEeRZTFYyyMmeEtTMXxmUuBuUbQqQnNTeEtqCcvLlVQSMBZzYyAlbFzZdDTtRZzgEeaxXAgGLcpPHhUuCghyYKkckoFuUfOKyYOoCrdDegGpcwQqJjCcVvMmPpjeENnJfZzdDozZiIALqQlAbgGGvVgfNnMmZzFoOfiIHOvINpQSvdeECtWwbBrDdQqGgRfiXxKkYyBIibIphHUoOurYQUuqyLlTjuZSszDPpULludVFQPjJlLBbIGgiCGguhIiRDdqLlQuUsSPcCpnZzNsEefoOlLoOFDdqQzmMZSsqQhHSGgTNNgGnnZejkfFbBhrRHRrniOoIrRNeEQQqqUNnitBbTfwbgGBWwkLlOmnNgGCcDdhOhHZJjzxXodDvMjJmCcrCcgcCGRashiIHSubcCiPQqrRiIimbEHhtTlLeBaAeEjJMQqcCJqQApPENeEBvVuKSskjrTtvVRTyYCcjJxcCXGYMPpmowpPjJIaAjeLlEJSqQPUSnakKlWUnNuNNpPLlnnBbhGoOCcErPIipgGcCoOQAqQGgflnNVvFjJfLfFolLVvsSiozNnPpZjkKkBkkKKbKJQqcssSxBbuUEeOobBdXxRaArCFfMbkQqCcAaNbLdQqqQDlLvRKRisSInNnjJvMmYhurrrRtTxOHaAhorJwWWwBIBoODgGMGbBgmyNaZDfFwWJjCcuUpZMEeFfRRrhHmFfsKkDdSMdDmuUFfjJWBbwrRurRXEFUuRYyroSsOiHXSyVEeeEoOqQTtkCcVHSKWwlAxzPKoOzQWCyNnYcwKruQgGuUeEcCqUuURVvkKvVuwWGVKchvoOzZyZzJRrjYjJjJVHMmOoeELlCJjoErRPsbbFyYYDdpPdDKkZGgzhnNOnNWeGgEMmWLltwWyxXGwWganNjZZzUgGCzZyYqQZgGMmzhHaAkqQKdSsIiDfFuUIiwWRrDdlljURrVviLwWNmYyMfFKkMWsSwnNEeQDjJggGmEeWJGksSlLxbBAxxeolXxLOdDEHhyyrRYYRrZvaAVzSsSsospcCYPpyCcPLlkKxjJfFkKkEKkBXxbeKCbBDdcSvfrMmFfbBNNKgGknxXyiIYaQqAnLGgEezJTtNnlLVbWwbnlLNGAEfNndDFiITgMmEegEeGMswWAaUuBOgGBboQdYOdjJJrRbBfFIieEGgwWjCcbxXnZhEepmMXQqxgGPAanoOPmOoGhHZOrCeNmMnBiKkRghHHhGfKGgIaAiPkZHhzkKiQIiFfqIKpPpdvVOoDrzpPZjJFfNSFuaASjJNkKGKkxXKPpSskKkaABaKkyYFfAwuUWREebJjnjYyInRrNdUuDUhHuMgoOGcjJCQRLlkUuKYyxTtXQqrlLqQpPLxXsSUbFSqkKNnQTtsfmSRruRWwriJjKkKkJBbdDAtbBTagWwjZzVmMSRrsHDABbXxuBbUCJjcpSsXxMTtQqmPbBqQWofUuFZOozOTpwWnygHgGOfFSsTRrtLGTBbtcCTtvsEcCiIoOeBbJjfjJFLKkrRYjJzElEeLwWhHnNYyCrTwWtWpNCcNnNnpPFfyJjKWwlJCVDdvcOojWwLEkOoIiKEeQyYCcmwWMfpWEaaaAaAAJjAsOStNybBYsZzSAaVvmIipPMmpPcCCcAtJxaAxXXOojdDyOoYqQrWSMZQqYydDzsSmpSsiSuUsIRrjkKJhtTZzMmZzIicJjQxGgbBsZWwzSUiIbQqUlbBtRraAzZTVLpaAkyhHbOohNnHrRaAizywWIsTiIteyYtTESzsDbBERakJjKArCPdEeKkhbBYyHIsSqqQVvjfFJjJezmoBDrRfFdbvVVRrRrBbGgxAaGgjJXSKSrRpwWBbPDdhHidDQqIwAanRFfgGliDdtTzZvbRwWrGlneENLgaAvqgvCWwcVqzZBJAaEuEJjNgGneUlLzZzlqkMmjPpJaIilqHhWwXxEOogGGIPJjCoOJByYYydSsVUuxslmMLKkWwQqwzZHPphTtPLlhuHhMqQdcSEYcCrRyVvVUuvgOoGLYosSORdmMWivmMyYGgEEymMYZzezZiIBzZFXWwmEVvsSYyeBbEbpPBVvEaeVvIinNEYcFnoOFfkzpPZnNKvYySsRrpsSSLlMbBqtTdDQtTYYJjkGgKLlhJjUVZELLlUnXGgxjdDgEiNNnnSFdDdDZAasSzuYyWwhsQSsXUYFflLEGZzFfnBcaZzUbGgNvlCcMmuUBTtbLVeEUhmvVCfFcoFfcCOMHuiIXbBxHQtOWDNndwDNQcXQqKlpItsXxjJcCSzyWRtTrwOwWeEJjlLIWwKBnNrxXkKVNWCcwcCNnnbBvgGbBeECcxEeNJjTTtlLtrjmMJEekKafNnxfFLQqTmMxXNnaexhHbjJPpKkwGgLmtTMiIYdDgGygrRxXGxqQXKcCLHhlAODdoaAfgPOlNpPPXrnLqQlzynWHhSJZzWLgQqjZzvVJchHNnNbNQsSuaAtTWJDdtMRbBMSLlomMZetSsSaNnCcAaptTkKSTcPpbBCcCOkKotIiwWAiILgxAaXlLWtTuwciOWwhBQuhrRuUHwWijIiTtvoOVNNnnDaouUEnNDuUnuPYSlVvHhLhRriIYgGyHmMUrRusoUaXaACgGDXxAjckKQwWKkwWzZBGvVWwhHcCWCcwWgPxgGhEeTVvRrgGKDdkBbLMmDOUuNcbBcCMmqQVZpOoxXVBbnvVgGMmCcxuGgUVviIBMeSscCEkKeWwEpmswnNcCYydQqDkKWkKjEeJijwWVvJCngGOorgyKUuktdLagGzZFfnAakKtsYfFHhXxsSIiNdDiQnNOohCvPpVoOHZFWwUumMPetTXuRrCcUNneEGgdeDBbdYyiqQIlLlLNtTpHsSttTTBbgGcADdfdDFLlSuUeBbDAadRwWvSYysZzrcMmnNCVGgFYgqibBhZzHYyIQNUhbhcvVlLCAknXceEaYyafSzZseQqEEheeMnNStTNhDdHnCceiNKkMmbOoHhYXjJJjYFOWwIiofBbZzoOpzZXxgbpfwndDVvgieESsqPhQBcCVdNnJYyAahHjPYPpyEhtHhBLjJrXxZhHfFIiQthHqQSdcbEepEeNnPRryWwhHYvVphHHyYysSdYyYyhHDgJjcNnxRrgGNndDgGXWwTnArRaQqFfVvPpLlNeEofXxiGgIRYyrSiIGgdDwDDdKlLtTyXcCnNaqBbpTtMFbvjJQhHlLEckKZzYyiIbBZUuTtIQeEqhHAtTHBbhxXnNpPcwlLgGYeAaSNZILufFbljJiILBSCPpcAabxIiLWNKUuQqHbPpAaYQqOopPwWGtKkSsTnIhqPpQuUsuUAaSHRmMrQqhPxXSsvBtAqQZxXsRrSEDdqfFPpLTtQGgjJqfAnYRYAxokKFIfFDdPpqsNLdDBHhJPpMmjSgGsYoOQqyusSUhaSNEhgGWmXXxhHdDxMhdDeESsTtYYANpSsPTfKkTGgtjRhHrJAnNasSTtaAsSdGrRrfFXxCmMIDBbDlVKkvyrRtToOzZOXkJjHGAagfFhPogLEvhZYyxXzdQhHgGTqQgjmpPMJtTRMmPVvbPyYnbBNFBbzXxhoOHoMeEUuwWtTmzGwARoIIiaXDdKkVdDeIiEdBbZAYywWIvVJjiBgGbQpwbQMgGTtmqFfBTADdqbckKCRSsHhrIzZJaOptMmTPRRrFYySssinBUubxXYNnIDdbFfTUdDqQyzClbXxTISsgXpPXwTtWAaxGlvEuUwCcPmjuUQbBqaRulLFsSVyYHIIkKihDpPxKwIibBjDdJeyGitQqQqFgGzZQqyYQqAlyMAdDabBMnNhkHPphWwkTIEeHzZhRrZZzkKZclwzZUuDVyoWwzZQqzxupPsSUWSswXxgeEuUvVsSzuUDcCVvdQqayYASxXNBbDtCcgYyJjEmMYypJjJToOtcCndDQqKkNZzOdDlLKNJpPtOeIiefFEUtTZzyYoOXhHxchSokKOsqQHCrOsSfGgFSsCRrcTaAbBtxXuYybLgoupPUSsVvojJOUdDuOQzgGDdcCZTcjjJJaWwfFmMFnNzZqZzmUuLeWlSUTfHaCUuiRriIlaAScCBaFDQFZzrRhHAjJQQCEecoOjeEkKJiDAadTttIiSwciCcIKEArUiWKBbkKXhkPpIyYrRDkjfFwWfnNFfaAehEgGeHKDeEHtTzYyiYXxMuUNvkfFXKZzkvVxMvVRkKrCibSErRLlYtFfMmKkvpPVWwmMZGgEKkJjKFfkxXBboOcjJfGgFkTtmEOUsSIVFGQqIDdTttlLTTWzZgpPrqJxXYyPnLlNpjaASwWPqwyYfagOYAhMOcBxYdDrsSRSsRrJjOLloPpmCvVUuDdrROoRrgFFflHvVxtkKTusuUYyXmMaAxSeNYyCvVcnEYcjJPuiamMgfyzQcCPpmpTxDdZatTVLeXBbAnMzqGkWKtfFfFBRUnNuLlAMmaQMkYMmPpyanADHlFfAZzGWwVMmvDxXJAajKPpkUuPoiIOmMhIEeeNKkyEGlKEekAaxXuAGXxnGgNBrVvUlzZAaFXQqBBbbDcCdsSxbBjzdDDOxQqdkKQqQqxnxiFfHrMmlWUNnuHhnWfFgGoOepHhNnaAuUtasGRIiyYAixaAXVvSsbMEemAaaFNhHvViIiZzIIipEQqcCTtNmMGRrgNiVvIgmyYoOxGNExmCcMXtKbHlrGKxXkeLlulLYbBLsSlBbCcSyYIiwmaGGEVvZzkKStTXxsZvZZmMyJjqnwYyxFAafEllGfFNngmMscCnjJbaAVnVqQvNnfRrzGIbBiQqpPThuyYUuUhHxXjJcCOoNVvEenBZzNEqQemMpuUuPpQqrmMxXhlLSMIbbBpkKPTtpPBKjjJIqQqIYyIKsScAaAabBJoKmknNerLlGpovxXhPpHzofhdpgNnxsSsYNnBbHdDhaGwWIBRrbEeixXzJjZfRrFaAAajNnjjJowWWuIiTXIJGgjWWwfLhHlFIiwJcCCcjAqjJIkKIigAaXxJhLQqUQqrREJjRrFfeHIEePpkKiplLsPphHUwaAIpPwaaAAEQgGRruHFfmpPwWsSfKswTtWVvRrkBsSXxNnuaAfdsSgLhUuHlGtTtIiTyYKWwTiIUureTlLtEmKKBboOsgCTQrZyYtiIeEUfcCcQEeRTVvkGglOttTxoKwWksCgZzYyJjXVlLsTtgGXUxQdPoOHhMVmmhHknmMkYyaHxSsXnNhtTeqwWQPpnRXuZEezEeWJjpeEEPpVvnNtOoTtKkNrReAaAlLaFfJXxSfFCciIfkVGUuvVHnqIizOlarqnNTfFtQnNuRrLEelURkBSYysbOoEeVYyvLRrXxNnxXnzeEkxuzZbBCYSoJOqBPXxpUugttTTVSyxAWhITRViIvhHeEPfpiFSsRYytDdXNiiIqQLMtTNnEeaqlUuhHHvrnNtTSVMmhHTKkzZtRNmMcCPHcQqChqVHgovVrgGRHMBbwWHZzLliIhNmMncCNnwWPpoBAabplAaUuLiiIIhhHHeEjUuTmoyfiIFYoTtvVxUuXqVPpyYJjwWlLvbBTtaAUKmMSLlskHEpmMjYXPiyJjLboNURrwYyfFgkKGldDpPLGoOKNnfFDAadGgNpPWwHCxTtOqNQqnQeEQqzepOojFUluXxUCVvgJrRjKoWJjFfwWGgGgwEVWRrwsCcMrppPNJlLQGgzNncCqTcsSCwDdvgOIiaAbPplLBKJTtEhEVvamJjpPcCLLTJgGjtYWauUAXxdDgiBbIGBcTPMwYXPMrCmepTtZbBNEeXAIibpPSFfHwWoOOoYnNMEeQKkdDYCaAcygcnBKkDoOcMmCrBnArzGldMxanlzNuUZSsHhclLgVTgdDkEAeGIBrRVvuyYdoZVvEeqQfFbBfxXeEXjJxExtzHMpcCPMLBAaUuUlwWVqQaAYaAyVvIuunNUUPptTQwBxXBbQsuUXOoxuonNOUqQEzfJdDUeEjJBbuYyjUxZTtHFfbjJCcAaKjJUuAakBesSzZScKkwWCcCsRrrVvhHUmMMoJjLlqQTVvTvexXdWIARBbGbBcBbMzogXxGOCUkPoAotTOktyYMqnNQbNqxXZzLmLNaVvhlLEeGgIwWPpAEmyYUNnqQTtuNXBbxNBbMmsSdDnFpPNnFvVcCncqQSsYykKCUsLlxxRNItGgRUurTqpwWPumwWwFTtqUctTVPpzZHVvInAadDNojJrZzRDUQqxXTtlLGlLkKRrghqQHzaASsJNvjaAoORrTjJaObBHhMmMmgQTUwWKNnoOkvVoqXeEyYaftTFlhHGrobeEdDvVvVsfrRFcAPpXtxXTxVujJvZzIielLESaKhxEtyYCcTLlQqGgeEecVvEeIRXbJjKHhpXsYUuVvRWQjrRJqfSsFNhHqQnHRRlLCcIkKooDiqCrRDbhDdsgGGJjKDgGdkRHGgXxPMmQNnwWlaHhAlRrLhHftTyDQnLbBJwWjMmoFpdDPXuUEWQjFfCcyYYzZvRWuUfFwrPpUOoufFbBAahHMMoVbFUYyCWoOLZjJXxZGqQwWypbsSwWcoMmOCnnVvNQnbahsSUKkAaJQfkvVOoiIrRvOKkpPCVbYyAkKecaACtTnGEAJaRHhjJOeEoaSvkKVxXYpPvMNniINnztTkZzMhjPpaAqQkiuvVSwWHsACckZzualLVWwoGPpgOxIigGRrlCYUtTuxmMcCXtkAFmuUBuXQqQqAUrkqQpAjWzZliCJtHhArdDRQqGOoZdBziIyfFYGhtTEeHVvflCrRqPrRkKZiDpPyYhHKkCcduJTtxPpYyTMeEnTtGgkKNixbjJIPpSGfMiImBbFbBnysSYnLDqQjJdXxlLwWrROjJVKxoOaJjBbADKkUuRmMrnPpKTfFityYyaxJtTkuMHzJHhtTFKkBiWiIqNcoYhHUutXXjJBYysSbKkFfoORTtuAaPFYyfpidyYDsSFGaAmMgSjJiaAdCkKjvVHdDhjJDJuUjdOofBbFjlkSpPsGYeEEeuNOHKknCOdcCPpUuTtDeEEegGTrlAnTtYkMhpPHqVXxNnIiMpniLhHpPYRPpMoOLJcpPeMJjDQqAomMOaEetWTmJkrDaAVvdCcSsqUOjJouQgkKGNnllGMmRNJjfTtAErsVJUulLxXEBYyIibExXqdDiuUjZxXzvVRlcCLgCctTCINmMLlmQDdSsEeRGgrRsSlbDZIiXtuUzZTeESnNxKkXsJjxzpPWRrYqSiPpfIgAOpHwWPlLpswwWWwDvVdVvLzFKkNXxwlLWnzmJjQqqhNnMWxXGmMgwnNdXLlHOgGZziUuWFfXLlIHhGcCqQgcBbbqQGaATtgBKkEJjHuUeyYVXQDdxshaAdDWsSfFQAqIbBRddDVGgqgGQclRrjnCcNLmLlNlGDdHhZcCmVZAazvtwnbBdXKkzsSlznfiZETdDMdDlKkJjLMGgmZcTjtTgGJEkKeWyYwPpxXtTjqQJWwvSsWtTwGgiLvEeVZznNlIPFfpcBbbBCAPRTcCsEehHqMxRQqNnaAaALbysaQOGOoaAOoZxXdYydDpPdpjmMPBgGbEYzZhHGFfKkDpPHhdEetuUhHYWKjOImPnAaeEITpPFffFZztNEgTetNfgHhHhGTFfPTtlLDChnZzNFdQUYqKFfZiITIfiTCInNjyrRDNWhHDriIKkyYsXXbBOoWjJrfyYUuFIeEXxhkKHiSsgGRwdcCKkXOoNnXaEeuOIiogGSNfpRUkKFVhouUOQCNnIuUXrTQNnnRrRcCWdRyFfkjpPJRMfYyKkvBcCJWcCwjsAasSwmMmVOoviFfUuoFfqQlLLgMTPzQGgqAaiIZkANWUvVwtqQYyTWEkYnRUGXWFfIijlaArRoYUHhzZGSsSLlsZaADbBfFzMmZKbBkgrRGwWVUSeEYsaWwOKkHdFfoTflvVEeyYxXoOMzQHsIYLDdZWSsVvXxgGQUkKcCEHExATBukAaKkNaeffFFcMiIYSWEewdqQqXRrnmDIxPplLJEUqQmhAVTcmMRIhARrpXyuWQdDnNwWqzZdzWEirRydVILocnNWoOtJjnCczyYlYuCNnFqQCxXJsSTvjagJgdvVtTyYcSAaeDvnNVKkQquUsAaRfgJjGFrkGFqQfmMoLFMmMAahwIIiJjnNitTfFUucRWOvVvrRpgGPreERcIiCGIiiIKOGggFfFfxqwNTjJHFosqipJqQMoSsOmfGgFIihcUuyaOoXFfKknNxhHIVoORWIYCULbKqjNjJnyYnNWwHhZzkrzQqZewXgGEeiVvImsmvVmJjjokKMuUpbuqoOQUTtdDvVyqjwWBCccCULlsSuMAyOAajJdlHSsyEwWykgGKwWNnssqnoOOlnDiIhxZzVrRvGtewxyYjJZRbLkKmqIAavTuUAMmxOoXaCWwWwcCctTPVvpwqfoOFQWPogGvVSBhEpPXxjyYbVvRrdMmNnWcxlFkKfLHzDdZqXWSsLXxlYwVCQLlyOQrRqaAuLUufFluirLmVyVvhHKwqqQQtrRZvKkNFfKeEGnOhWzXxZwWmChHEeIbOohHBQjJkKqsRrSZzYOQCcqwBTpZzxgGXrSzZsNeEaJrRYyxppKVvkOJjoqbEeNKBbvVwqZzdgGnSiIscCUvhYyUutXHaFsEuKSsHhheMAaGgsSzZhBbJMmNxCqdgGgGHfSlLsGgYysSRrYsVFftTtVvoiPpbzRpFYyezHmMwYjrdSyYfGlqRrncxihHIEeIqTQqycokyiYxZvNnxjJGgMmXeECchpXxPzZQzxNWvlLSnNKksVwjJqhHQnGpgTtGZVUjJuvzPnFEGgXxVRrNbOyYoBCwvxCONrRnNImMinoRZtTAhzQqQOoPkibBVxPpXaAadBcCbGBZzcCWdiILPuUTdYyubTSNRkhbXxBPTNntXKvApPatTMamVvMAUWGEvVWLAaiAfFUupEKZrRYRrRrdDyJCcoOLVvdjJDlLlRrmMjJjrRxNnioPCcWwRrpNnHETadDbpxTyasBoOVqECcMaiImzZSBcjPAapSsODiKiZnAKkwNncWhHPImTtVSAayYsdrnVPpZvWIioOzZfCcqNfPeorROoOOIiXuUustWpvxXUuUmxLlAaGbyteExDdQmMqIiIBGkdxfBHukiVvbQMutIiTbEeMzxXLUulMfFmQqfTtFcAtxbypPDPpdZBZzXxwpPBbqLBbaAjJfzZKkrWiNnIwRplbtXAEtSXxVOctmuoGgOHdDhlZXunQRWOIlYDSrRyYOobJiwWLliIZzIWqowriCnxXuMmUyEnCEzZyYNGysQqbBIiAEeXGPpAvVaGzZCSMMhZzHAPDdqlCcLpjnNUnMKynNJnNjvVepPaAEJjOtFfDdkKEYlLBHhbsSgaAgDdGUCvVcuPBKkVTtajJcCAznlLCSsSntTXkOaHoIAqQeEHNZFSBbMbhmcItTmMphOuxbzjJZhlIiRsfCuUHiwpPQqWAtTerEVsSvVRrYzZnvNqtFfmMTPptNKUutrHFfhjJlaACnnNBbYGgQqypgbEeZgHhwWyYZFFBubBUuUrRNQzZJtTuUDLqFJFOoqwfFJjWuUBbfbBOEGgDdvVXxeoFQRgGohDdHkKBAabMyTtjDdfxXwBbmSsDqntxXTlUDArRtgAOuiLPVBqFLuzZEeUEesKiXtdVvxXGOxlJwWBQqJjOPnNBIODdoURrtYyLUuNnTtdyYMjoOIXyYJRMmevVBYddkqQEewFnHhSvVqQMqQeEgGFfESsYmcsSCkEMfsSFzZmsOaRTtqpPQrtTMIeMdfpzUSsHFBbfhBbBbZzUnNxvAaVXFMVvhTtUXAaxnmkWwgBxzVHRrAaUCFgGpiUSORHQXYtHEfFbXRIBPgHhRrVvAEeEHUuheDdqQStzZxJVlLYOoYyLsrRXtTxwqPpHiaFlLsSsgIiVGgvyTehzyYTsjJJhLsMRrqQmkSsXnNMmfRqsSHhcgRLlVvnNIiYLOkcuUCKXIXbuwWUAKkaftucQmZMmzMIIUWwuHhiiqPpPamgCcGACQAGjbkKZzZpcEfeGbbBwtTCcnNCcBbWLXOrDhgGBahjYymuhHQJjdWnNxXmuUJcAXxamMXiIkbhXaSToOonJNnFfPOHhnNEfdutRjOHhlHhLAUuYqoQCUuWwhHxcPXxAMBQyYGgqilDplpwgGFKFQqfTtEBNqRXWbfONnoFnNMIyLxUINexRrXPiwvVmDdksrRTtaAFGjUOEyAzEJbtuYyQDdvVqTroOrgGRNmsSOovryWwYGejJEcsuUtTsLmIgGtMLlRVvXwWxAaQqddnJjZnaANwgUusqCOvMNnnNAGgaAcvjnnNnOAaUHZzwxwwktZzdDAaTKGgyYTZDcCdjGgJoOEenkimCHldkCcSDmMgmMWRXtTxQqxGpYzZVOovCpJnUufiIlgcrqQfvTDaJjUAfFaQAkQnwWcCUMSiwSJAuLloFfQUfPpZapSFdDgmfFHHfdrJcIYFfGHhUQqzPplLeHCczrcBzZjZhuDmEBqlLBfCeGgQqMqJognNVvMPpNnPGgNYyDdIiRqHhhHurRUmDjYypPBeWuUmqxahHCcAgANrRWmMoiIdaLlAiIlLsGuUgGnNgSWiILNHhnTxXmMtoqmoMlXghIlLOolYKkjvVGbBwWZzAgGdDOaKkAMmQkDHGxLlPSRrvVsHBoOEeaMmAsSctaUNuUGgxxpPaNSwIiIcCsSgYdDyVgLlXKyhYCcLOoIiKgnNhHYuCCLGVnkgGLbAaEcCfSAHhahZelYyTzPpZAatLUJdDdWwOyYoDrrsBiIbwYyroOqQlHMmhBEUqQKMtTmlArkByYyYoOiJPmMQOoqYyYwWnUugFfNcVVyfFjNXNnxRrRrMmMAZSszKYytYwAYQhJqQoOlDEemewxLtTKFfbyYsbBJjCcLJpMmjJrVYyWqBDFfdOoEeGcvGKkFfLKyYkewNnfFZCnsjJSBiIbYMboEEcCeyYAadDXhHUKIikbFUoWwqQOuvdgDmMeUoOOouvVdDtkXTsSACocOoGhHgGjYysSuQGUuGQqgGGzWwKTlLtSdvVuUoOgGfRLDtUdDVtTvuYxXuCIsSYyCKkyaMbBmuTdDnWvrDCbBYDqxSseEpcTiKyYkyFMHhDlfjJlTHnzNnZNIihjMBbguBbfwvNnOoVlKvdptTwWlLjJAwUKkzeEKStTtJKGxeyYXNJOonNWtBbXxxjTqsSKkrGjvVBbBqQGrqQmVvfiCckxiIXYAVjaeMmTLHhsIiIJRdDskKxXxYykKEqjWqQEeZTtxxWwlpPDdLXQduFzVvZyYltTfFsGOhcCHogSbBjbBobBOJaEbqvfllAUsSuZlLuUzGopPOgGgpPAKkFOcCzZBUubEeNnWwTBuUzvVBXpByobmJjGgsMmMmpDEhHAaQAEeayYPNELlIghjJHJLWcMmCIigllsSyuwHALsSlpPJxvTDdSstVbBQqGfFNnrnAaNogYyyYGDwogGdmMQqFAoncCNgoOXaaAAXkKMBMmbhEePpBnNlLffYoTNJjXVvKkPhCUurcyLVvlzrGgIgNdvwJeEjWVSsYGgqjnsShHxPpXueEwlZzHhHhLWRrmNnRrrzEsSeNHhhfdLfOoRluUwWmDazZAJvLlVeERrgGNVKtmbBMZzHuUMmbBVMmJuHYycChUjRrDbzlLguUYvzixMmxXFfFfXFmiIMWwKhGChHZehxqwWIWwYHXalVRrPpcZTqgGJzZjjQztTZBsKkRrSjNBBbPptTsSbncGgCyYTmhkaUKknNXxuAOtFRDnNzZlUKXNfKSjcvJlLmuUJjOZzBptTPCszZQqxXjYyJkYyKoAYyYvVzfFIvrRxXJZTPpUmbBXxKkFfEewqlfFgvVGtjsSEezZBbjxXeDyfFUuDrqINIieEWwAaEtOxxOSsAazrXxownNWoRPAQIiMmJdJLTtnPScCspexmMXqtOehkkeEefLlAauNnuULlNBHhjGoziIrIRrHscPpCbTtmMUPpeEtPIfFZzVvGgVIiFfNbVUubRApLWqnlaAWwMaeiRDAMmeGgEaIidumDHhKVVgGiIizDdZIvrRXxKkCcvCiIckMhHmsVvACrtjpWwfqQUgKqQyJHlmxXMAaTnNtvVbdAgLlzZrjTewyxXYGjUxXqMQeEgXHhwWxGjGgxnLYZzyWHhcBbWkKBNnbnWfvfyYnNdVIeEiWwOLzKeLlWwgdtTDGVvdYXxAMqQqbeEFHVblxoACcJLibuyYSQAxrOoVJRbBZQEetbZzBTJIdgxXGDrKXTAYyZzrRaAHhgKFarRkmMvmAWyYwrRWPAyYSDKyYfNPYyfmMXGgxudDeEGgWRkZzGghKvVYuVxYjHhXxJYKucaQBsSLYIYyEWwLEerRlLVoSsmacksSKqTZhHuUDMZODdNYHpWRGMzZgbBgYDdzcCjFsSUyDxhKYcgHhGzaaUSpPfVvqQzZbrRcCEeEuJjULFfGIypPyYPIimkMfFIRBbQLxhGAXzamyfFdDWUQwWwWPnNpDcCdvXhieEoAaOnTtRzSGCtTNaAHpdxXDyKkVQsbAaOXZCnrbGsSyyYodDyYQjgnNYyiHsXIiJvVrRuouwWKdmZPpUwNnzjJPWpPwPuUQMmquMeETtXBbBMahpPHgGCWJjFSMmBAjJPyYpavVWOMImuUMosUzqQZrRMmuiISCqQDEedKJoJEkhvVvVXMzGsiXLZhnEeNHzSYyHhWrvEeEeTKzZNzwykHdDMPpmhMSmwWoJdIUdZezZbohLlgVqZPJmYSMLlPCYXfAoVIPpCciNBbnIyPpRrNHhAXxOoTLltPhYycgqppTtKkQqJOvVoPdAHhaUvXvwLlJlLLlzLIilZzWwpaDHIitRxXkEFfZnNdHhioHeiPhwcebnNCxMmAerIiIoOezqQWHTthodDPCcXBUuTYyQXSseExqauUoOiEeIMcCmmMkKGxFJhijJIJsBwWfFRYyfmrHPyRQCcdTtJExXiPDjEfZNiAHNUuYHnXhWwTvaAHhOGgoCZzccfstbLlYfFyzmqjqQFXKKkXWIiyPPpkocFhhuveCczBRaJRpzFfZmzZgRrWyYwDdETtJvWCDdmiRKkgGtTqUuNnKkwWkKUkKecWGjaAyYyYqFxSsXfbBQieeEdDECFfSxXWwExUuEtTjJUuYETtMYlYWwrRzxGDSJjwomQqaChHbBvVSZOonYmMjJYyHzJmpdsSDuMvVmCXTvsKfPVvKlzKYyoRKTtpdRrPPamMeEcnGbLisSTtgEJjfgzZNnbBMmXxtTXgkiSlLsiIjnFhgNnVkKseEtaoOYyoTKmfFcpKPBDcLDdBVOoCFDNMmtbSwqiIlyYfFZZVCcTSpPwWhHNndDdwWiaYZgDrRHhZPEYTtXOomMrxXQaAMMfziIKMgLlpPkaAcCqhHKyYvGgXbBxKuuUaAvuUtFKkjIDXFHpBbuUmFfMPipKbshYeEyYzeWBbwjvVJYxXpmMBbqcCSCGgRmOgvSsyjQotyYHwjRPuDItNTtnkPEepfTtFkKsSkKPpkBuMkKmjJFfVTSSZzsyRxZFNfNniRrFjJJlLQwJjXxzzjUgObHfFFpxXWwPMnKkVjQqjrbHUfPpIdXJHkCrRDdsSczZKZzwuUqQfufosBbWWgGwwSOIilmzZifsLbjJKXcVvuUyYDafnyYfFNFHvBbbusEeuUSUhGZzgTPurWjMxraUGHgGqyhhyRowJtkFfeEfmMcCYFFfIvRVPBbjGgxXXxJpaNJXxaLlxhopRvqhgFPgJgKCTtBAabnMmkKbTVvOZBCQqTxDwccCCvamMQMmuMmoOUzZjdflEzyCGgRcfFCCcsSTWeEQMmuYnjFyYHgukoOUiwWWeEmtqVvtThwWkKtkKTFdDfwMmQmXxMMeEyAatTUIalXSsxbSsIbvVMSSsYRrsxQXxTSwWyYKTtvCtTTPkdIHhlLnVvlGghdSXxCTjscnmMqcCmMsSFfPHFoOgTKwCdeiHotQqgELMHgkeNKkmMnzZhHNnddGgDDUSCoCySssuUSYcOFWwfpPJrSsKPkKkKkKNOonmeEYOTtoAahGeEgHdYZzBkKkaAKwRUurAEPpueEVvVqndEHhKkinVvaAKkIsdJiInNyXMaAmxqQtaASVqTUMoSsRnfFIZyYMmqQXbBSlxVvRIPjUSTxXvVnfFJjDdOoDKkdeENJVvqYLPprRWdqUyYueEnoOuUEeNEFlXbBxPfhtTCWweEnGgokqQkKGgKBlSsdzCtTcOSmiqxFpWuLXxBRSsHuEEemLwYyGdTJjtDIiDhTtFfHdhHGGRTfFGgCeEcgCetsVxTUiiHNvXxVJgJXjJZZNBNnVounXicRrCIRnoLDjXxEcCwWMmeJmmMyHRPpqdOoRzUZzTxRpzZhUZzuFdUEsHLRUVgVvVRrCzBbcyYaNwiIaBdWwLXlqQLEexrhmhlDZUPoAFfXOUoOakKUuiEFxkZzvVHhkAaYMmSqQUpsymBbwLlqOuWKRJjXDdMmFfxUumMaArHhnlnkvmujJRrwWUDcIsSodVvvJoOjBbebBoROorKkFfMmRkoDvRDANnkKpPdQqExLzZlBbxiIQqaPphowxyJMmWeqzgGZFfystTSgRrSzzZCcRXpPRJjGgyYlsZqQuIoOWIilxYyYHgZJuTtUjTtjJbtDmgCmMcgGgydXkKJxBvYltQDdAHQqDOEYvkivVxjjuNxXBbEbBtSUlScNdNiKeECckoOoEgRAYcCmMyswWaASbqWpPRrakBtvpMwAXMdZotAsXpPAaxXEhDdHwafqQjpNniZkKzLcjkkIeQCPKtJseFDFYyNIEqEeQIiVjtYpPDfpYPOKktTEVYpPhkNwtTdNpPawXVvttUIiuZsdONtaytVvrVYyqFeeQgrRZRcCrAtkKAZdTbBtvbXlRrcXxAfrmzBbJjZrwIQqtTUuiOoWsckbKvVkBKbbXxBBuUCbRDZKREkoOJFjeKUqQKIiOoFvsBSRrGBbbvVAHdRVQcCatVvVbzpfXXVYmJmTVaCckWwKspPZHhySTjICwgGmCcMaFhHSUmSsVtTRrKoOkMEexEACdDXxsoKbBoSCrROMSsmeEyCInAaOeoOovVZZPlLBJnLlTNWvMmmuqExXebmkuIXxReDNGwssSSYUMNvsJjSKCNaUuAWUpPuqqQzqMmLlBeEkDXffpfXEdDFGHZDTTBbeGgAfmxXxHfImMdGUtTbhHBGpLlPlLgugDiFhXxcCHhwZzSsWXMFaEtkKtdzhgGgfexFEiIePFFxdKNnbMmSsQZQxXwFfnckVnpPmuyWgoOFfndErFfiUKMBaAQUMVwntyYNjbpzzOrNqQnRkKEoNiFfcSQkKqsYoWwcsOkOkKEeScaUueXSsmqQmMRrvMusNnIifAnNNnWGgciJtsYzSAvtMjMyZzqemgGMEQvGgxaAxFwaTtzZAWPZBvTAqAaQqvrDhaBgsbSVfbBkuSskETtJfjKGgerRrkzNndrBcCiIxXSRSsYyMTrEeRtRFajJCLZzxBVgMmGDoOzaTaYyzAaGqEEfQvRvVUuTYFfATnoDSzTTxWAnDuUWnKHuUyveyYtToMmpyPFrYyRXxdEbaABeyTTtUuJveiQqnrMmRfdfEswmMWSWwkKSjTkpfFcqEiJjKKJClIUuPyYXTtxJFbCcBAKkWeiIxSiIaTOLlzholLOHZzDmxaWmPVTbKAImMiwQBartTGeHnNhOoOInDxXnCsMmLusTaAexXnUJJXcCIvVKVoVJXxjvOyFhHfeodhVXxvaBIibqUvVueEJjTLSszZyHhVbXjxXoOxDYRcCtgGTrGGMdTBYyKkdbBDzGhyXLwoOiUzSdDLzZrxrZsGYMfFmQqQqQEwjYXWOnNBbHAFhHfXXeDiIaAadaArVBbdOKrOPpEMmVDODdiCLldMVKNLMmWwXxNkwUoQGgWMaAYSPusyYKkyKvVKXfeIAPpuoxiDdIaOpuzdLHMTQTtTtqBbtPpHRlxXDbAWFsSfnEpHhPeAowWdDOMmCZcvGvurlhSeuDfHiIPrXtuZoOrDQOorhMmbBbBYMRPpbBDdKkuUrdlOHhmMNrxNUOUuvbnzzdDxiIjGjNndDnSshIIsSutXgGlvVLvSEeTEcGOoQFfyYqtrggIiGggWlMeUhHhrblWwUwPfXQIMsoZNJvVjWwnDLbONEecvVtTHFprRLfeOoQDxXwlyQmMqQAajtsBbRruJpicCrXLsuUxZzziNrHhOmuKAapPkWwtQvsTYkKodDOjpPDSiYyNjJMmJxXjIBbeDNQvEyYDdeUeaWbyZzQpPqbPcCpWwBDoOeEOVvyYoyMWQqwpkRjcsuEKoeEOGhmtUuTleGTOhHhxXIEDcWlLktGfrRhpQqAapPQNNnCSJqQtcsDHLNiDKptcVkstqXSysmBimMxXBLGkKCcCcgAiLluVvYmqiImMWuUWwHQZtTzeETMwIWwuKUGhfIiDdTtJNyhHUqwtzXxSYyAasZKkhHuUcCrcYUuZeLFDJzZafFAkhSsHKqAaorRpPOAViINnnNWBbpPdXtcbzooHhOkKtDdBkKNckGnNjGpfGkKyYyYHQVrPOHXAjnLlAvQqPprVZziyYoOfAayYytTPHhpFlLKTjWOrYHHYQhgWwuARpPgGXmJyYwRUptGvVguUHBVFTLBbltfhWcCwveEVAdtTCxkBlSFIMvVLUuFUFUuWAaiqQiIIhjxNnDiFuhBRJJOovNNnmfhBoGuJZZWqjfIFnfzXrBbYstvmMUbKwWBbQqBbeEOonNKBbePpSshHETidUprzZJWEepPkKhTOqkKZyYzJYrXxRVGoMrcsLlQPydDEZycCIiYymMjJHSBkPIhfCcmMtTKkxdiJfTVqQupPUUhHkMmSDdsVkQPpKJjWwTtBbGmkPpZFmHhXxiImfFqRxHhyeHzZhMOPpojJMmHvVhmMmNGgnXxpyYwGrRYygWzZzdGzyAIrRDVvqNnQstzZvzzNnlLLcCQWsBrOoRTyYrRkKfFLlnBbdfMmhHcvxeEXblCdbgDdGpkYyYyPwWCaAMkdaADtOYCcyATSvGyYHRrfoONJvVbBiIIxXKGzZxGFBbeEesSGBbICclBgNHhCApRrPppDPkeErOkZLkdDpFkaASVtxcUrRsSPMjZheMmElLyNzscAnNMOWsdUuhHgXZySQaAqsLymCccCeybBeXekKgGscIJgwCQqECNncupPjJQrcCIbBMsScwJjVjeGvVMPrjArbqQKkZEVDaAdUHHfCOKpWwYwxkxfbPSspfFBJQMoOZBTSFhFfHCTiMmQqHhITttVtHxNhSsdDynhrRaItTnBbzFeJIiPpdpAaIHhejDqHhQqrYRPpIirphRsSFfMmMFrDdbSnNEFfeDdlLjHjfXgaRrSsJjAAtbxpTtOwTtZEiRGgEalLlrRjJHaAhaApPbBzZLhHufvVaAFCcUXcRiIgGrBECfFWHIipIEhOTtFfIaAKkEeuoOUDzeKyYrCcQqsSThdAPZjNnWwWGgVZzvVxVuDpjeEaAPPQGCHpaAanfFYivOaFxycJjvVpmEesyMoOgTtGjpzQvGHOBZYLlUJjuyzEnNzDuWwiDjOThwWwWHtJQqjMsmKYaIiAWZnktEeEeVRwslxoOiIIPpWwSgZmxwWfFHKeQqjOHhjkUuaKkAgGqVuUvQcOmYcCyMJjimmMowbsfNsSnwhHcAmbxGgqiIXxQzZmMmGgUZmMzqQppTtZvVLlWrxXpPRukKzMhHkKIiBbDkUOUWTtDdwjxqQSXxhIGJqQqOYgBnNRGgNcoEeOFfzxyYoWwBSqOovYfhHqQFyYAaPhsSncgsZrvVGgNwWWRrwQqqQIHxVkKcQqCeEquwYMALlZxaKBbkgzZSCkSsKLuUlcyYCcsHIiwWXlqrimKMpjJYigzZDdlecCBqQGoOgFsuAAZKkgGCykHvVXuUdYufJZvVMmyaAGzZlLmMVvGmgrwOoPhynoHhhHzqHhQdqzZQeEDmdoOOWwonNztQCAMUuOtTXxvleiylbqACLEeTtKklUkWaAoOcCwUuyyXvUycmMCUuXxvVkHKrwFfWwUFpnFmhHMkhlLHdsMmapXxwKkaMVDdKXxSsGghHAfkGatxkHhKkRiVvjqzrjvRXaWwqsBbPpUBIljaOXyYLBvhfBQmaGdDgyIiDtTLlEkZlTtorUuRvFVFwNsLlSuUwZzCCcTtwlNndDVvNwWXJqmQuIiJgMmaAAXxaxXWEtJRGXIixaDBXxLeESshjYqQkGQquFPJVvTRcaSYFfyuDnNdqAcCyYjJaQUFFUuffQqdDdMUDdrFkKfIVvEAmTTttZhlLHzbBWwXxekKBbELNNnQwlpVaUuAvPPUuarBvBnvwWfFipDdTuCcgGKPpkKkBHhxXSsSZcCzHhaAhijdyYDJRrRaAZOgJbnRrUFEKKHEoTQEyYNljDjMOomUuqFfaxXNnprbBOcCQqORZoXXoTeniRrNnQaARdBbYdEJPpJiITBbLQTtkKWTcCFfOoVvtJjMupPsStzjtTViZyaYyOScdDknNKboMjVCJsXxkIcCiFnxkufFLcCdrfToKHIiXxMtLlJbqJQtdDzCvLVvApPwWxSYyEeshmMyOoiBbaAQXHEzcgHkfIZVbBYNnyyDdGZzZBdRrvhTkvRrnyYLKklFfWwsSjdMLyYrFlDFVvHIikKnZRfFMnNkKUNCZzcqFfQqQJQyXxvVDduUDnGlLiNnRSZzsZYCRKkcHwWpxXxntOMmyFFbHmOoCcxlLxGOafDdnNnNJYyjolLODBbIiOWdOrRAaRguqqQGgQUXjQPpfQqFqahzZWUYLYyLGAawMjJmljlIWwiLGienpbBquUedPSxXNnPpMBOYbgGkKPNnXxxbqQZbqQtMmBbBRjJrVeEveNnEbofatTGSsgaLLFVQBeAnNsSLRrfmMpPUNnTtDHhUucCuUqXzwiIJMmMmQBbeWwXSrjiSltEAJvayKSsIgGFOomMMRgbYIZziyyYJgRQtJXUuTwjnxEXgkjTskZrRunNWajJPDdSrRsDVkLGgWFMmUiIGmqQJVZzfFvtGgLsyYoOSFLrRdmfYItCnNYygGPNnXyYQdycdKkRVMiImwNGgFfdDpvVPtUsSngGNcCnNYyHFfhAYcicUyaATdBblrFDsTtkZggDdgCcqUJgCOxXcatxQqWwKWwYyTEdGDkKVLlfBXxRGgruxXLKklOoxeOBFfmysSNcYyVvzWmMWHfFhwLlElRrglLVCiSsIgbQwvzZRPVvjSslPpkKNyYWwnSBOoklXWpPaAEMdtTLjHqyYyhHaWPpyTkLljdDJamnJYTmMtBbvvCRrhHXxndDLYylYymMGUTtuNymMVvxXrRpjIZzFfbKRaLRgGbKkBrkuHhebEUueZzmUuMLRWAaSOoWwRRjuVmMvEzHsFeBlWwqQOoKNvgMCcmlcbSsBcUydDqQGklyHYTtkxGvtTzZGidDWshHnAXpNnPXGgGgnuSmMsArRMmTCSjKkYyJjJsjJbhVvQqpXZzghdfFIiKCcqQfFOoqoagZzJyTmMtLiHGIBrRbivVxLmOEeQqMQOlLlyYwpPjJDOwiIJjnIiaGXQMwEeWwXxxXkKEFfbJcCrRdMAaNSsvEeVnvpPVQXKkxaAroOnAWwapPpmqQGOjQfFmpPUyYxXuEcFbVvUuUuQbeMdrRUuXxUHzJYyBwTtqQuUWbbCRZhEZuFfHhCcgyiCWwjRDFhhMGPpfAasPAzOoFuqOpPUaRrjswWWITtsmmMuNBbKkfFMmqKdDaquxXAdtVtTFRMmnNCGjJUuLFUUuuNjPiIcUuybBPgXsSrwGdeEsjJKvVYyDLwuUWhcMIuUKpPNpPqQsNnSztIiJfFgGQqjWILliWGgXyYLlWhwWuoSsiaAIcSsCNvVNCcJVoOCqQrRcCxXwWaXxYyTtGOogmVocQKkhHRYyrSRrGWzGgJjNDDfFrmTiMlSqQSCgIirRDqwWQdygGvGgVXxwWwWgGwJxXjWYutTURVMaAnRVtTvtUTBeLlEjeuUZeEaYqEeQeEeLlgGDdouJlLNnFfgVvfGgSKMbBWwWbxXBIpEniuXlYmMimOoBwxrdDZzQnbekXxfWOoPLlLlLPdZzDddDLIbmapCXcpPqyYOQyCVvcaPpoJrHhfnNFTNnUDFPpoKknBbNONEenQqeopHyYtbBThjyYNUuOtsAMmxHeEBHhKQqxGgZzEeCjuUMwDaAqLlUMJTtHRrUukKAbrvVRHdRoxlBpPgEFeCPpdDPMmHhzlLBJgDyYdaqcaMApCUTFBxiiIxmMolJjyrGuuUUCABbacCjJQrFmMxOhHoKiOoISHhlHNnjStUurRZHmMEtYpgGPGKkpPSfVvAIhfFQWNnKkKkSlyVXxvmMvjPpXTsaHhGpbirxAaBehQqkKKkTyxqhrostToOufFIVvVEevPiYyItTfcuOoxXJjhvZXbMmGKMNufFHtTmfuuZUaRrAuPFogGnNODyYmEiIAakPpKiejJOoEmhHhHAoSRreEeqQgGKMHhBbyYcCOKkoyemsazZAwRuUrWhHNeEfWKlLIiDkKDAmMagRrGybhHEroOjxifFJmrRDsSlTufFWwibpobjLiIXogIlLiDTxIsSAaIikOyWWwwYoSlfyYQbvplIUosSDdaGTitfFTEeYGgySsIadfFRrCcCcuLaAlLNQZzLlFfdAaSsFfsSMXxMmBbWVvFJoOjJwWYmdDOWtTPpwbBrfjjJLlmVvMfdceECDQldjkZzKqnbqQffhHzGzPpBGPNtwWTfFcbBLRTknTQIiOoaAnNkXaABbxKnugdDZTtnNzGUVNnNZzyveREaZzzZIhcFHeEhSrLHtTBgGzZXUoHRrPnNUuiCJjMHgGmMBJjuUmsfzmuUMnVvhMmHhRraixXOhAoKxsiIfFSNjcCJqQVvsclLNZUvVjJulLWwuCcUNQIiqnvwWCcSsbRroOpAaGyMmeToIiYwWkmNrRuJEePQpapPkKmmscgSHhskKgxaSYSsgnecNeYYyNcdDlLIRiIWOUuQwjBsdSsAayLiQqowrqNUxzLUMGgmMrRlLTCQqovzZsTeaxuUTBSssSLPatTuUAuUFlAaQxXWbHhzYBXDnNdWwTiRrIXxaCLdZzfFDCcdDlZmBUmMmqBKkIiIKXtTxUhbpPFXDKwWgdDbhHiXTeEYBrRVbBvpPgXMuVnNPwTSIiUxIioELlpnNBbFSslLSsNQqnnQeEkKFdDwVzvdDiINvVRDSsEevTtMiTMmZztpwCWaNiIzIkIdRroTySsYtJTOonNtCZzbsMAmEyYedDenNQvbwWSAYtXPBAtehOIrJjRXGgqQzrvVaqRrQAhBbHbBexXvVERhHcCVvkezZPfHhFGgaIljJwegwumAarRVkbBxpHKrnNnstOoBUDJjtwWpBblDwxQBbdDQBbqTDdtqXbAasSgEsSYyeDAJjxXvIuUKxwWXpqZHazrnNcXVfZzFWcoOnvefvVNgXZqHVzXxXyIqQYKOCYZzsStQiXCUfFgGuOodDNWUuwLlQLgtTNnFsDRJyQqWyYhUuWwZEfPrZBbBIOTvSyRKkrRrSsFhDQcXEjJxXenXxMmjHQqwCcWmEHovVnNOJjkAbBqQAaaUDdtTeSdDIifqQAVFfvhKWIiwkxTHuNfsSSsLYzZylFiIDRrpPPpQWknBrRQPPXjAnRPtboOaAZcCzmMrRWTtoLlkKylLiLlLlcMDdlLwHohTtmJjMHiINCcgknrRSslLFfVmMzUuTqQWpPkYvMlRfFIUUoYOcGgCoqvJjNnVnNcSsvWTtymTtMwxQAahXCwHhDYyBJeXxnNHbsXuUxOptViQMlBrzMjOgxXGoJmXphHoOgGPWEmMTgpPXHdxXkKNbBLgGtToNQUunNoOSSYSseYhLfVvFxXDoYaYbOoBXxymbJRrYyQYBPmpPDdqcCQEeOJxdVvDGgXpXxxXPpooOOPoOMPpMSMseEbBQqSrNnYyCcRxWERKicCIcCJQkdDBgGlTtucyiwPpWXxwIAadDirviAqQYCdDwWzZHBqNnbBeEQbNnjPIQSOcCfhtnWKkQXRrGJBbjokganFfNrRcCAxXMVvmVowrKxXkCnNQqWHmflDdEXxeOgKSvVaAGgdEsClLDGjOoGAJVlVvLtjcokSmMgGVvaAsKqqQQOfcUyLSsnUoOuNZNTwhHGdDgmMsSCOalDdLqQDzZdADdliFtTfvDaAYRrkKxXIeMmwZEeDwUYxPzZaHaAirCtvxXxKkXayYHMmMuejXidMdDNxQqQDcCsEeymCEAAaraRrARnhcCHKUbLlJjaAtabBXehcCeoOuqwDdEeXxzlQqyilLSDdbBhqZmUuwWLFtxLlcuUCXOqQDhoASyshHuvdpPzmpPMgGguKkkKkKyOhHdDLJyYbBwxgsSurNyXxKesJjOonRrNSXxuwnagGtTtMmTKptmbBGlOWwIcCIieEoOMOoWSscCSJjFfbmMVFPpmFfrzZKYlLrDwrNdDNnjJqtRRUurxwWicWwqHvwWfurOoPFnsnfFEejoOJNZzVvUAtvVTxlLxDBbxqQxSUuSsSeCciIEFfBbsRZEeBbzdwsQJjqSjQqWyYwJniIdRbBrYuUJiEeoOctIGqQGggFivVtGgzQqCHnNhfhHQqFdDcWwkQyuqDGgWfFwfTtHcKkSssSdAapLlElLetFnTEtGeLlTtGCceEeEgnicCNpMioJkAaXxwyvlDdLVTgyeBbpJNIinPdDDDwGgxsEegGSXKkFjJeEvnNVjJOofWzgXxoirRISsqAHhSbBYBlrXkKGgmLlUuQStrplLazZVdDTWwttCzmvVtKkeNnzIFNZJkKjDdqSdDsQxXBbuiUuIULlZzLZxDNkKWTcCNnlSsLlLuUMlIiLzgLnMlJLCnNwQqWoOvDzSkWwdDybBYKsEeZrHhiQaqaCtTcAwdWwDYKkyHSXDTtdJjqxvEhefFeElLbbBBHhClTDdtLiqsStTQxwISsohxDFfCcmXxHQMWwLlkKZfQcCuUqZlsSWShPofFBREexXSsrbaGiFIsQQqVNnvydDwBbdBEepPNnLVMmvHhsSrqMnVvicAEeaGrJsSuUIQOoeehHjTtJjNKkdDnsSrRmMvhHDOmModSReaFnrgLaAGgNnLGgQqDdRKjMtmMwTzZdmEpPYoOkKylLwWCjNnlQqmTtvRkKEeDdMmrVeErylINPZzecCEmvQpPmKyeENaUuMmuUoOLqQGgRtSsUuUXxuocNhDdonUNnxXWwdzZeyYiIEDygyYKDnNdVvLJJYycDjJIsaAbBsSeZzEfIUrxBbtTxSsTUuyOFfCFfnAnNaCxXCcHhcTtQQqQMmqpPwIbfeRrtcCrRTEjrRMmZhbfFQJQqrRXxjNgGnqBmUKsSsSjXwMmtTZzDdWApPdDLlPuUpYWwTItEekMmEKkkKeNHhoOpPdaBbVvPpYhHyAXaAkqQvolNtTdDNqQHyYhtTgWwsEeiBXRrImtXjntTNUIzpKkQqQcvVBbLFdDjJgZbDzgaTjckKILwBbJQqaKkPoOKYyRuNnaxUbMfaKJjnNDduUTrRycCcLXvQqcCAUKaShwWsUMmInNKJuxXUHmKRrhlLHZsoIiOSUTtuRrrRmVykpPMmKsAwWIiyYWwrAjEeaeXxgNMmEQZzqNnaBvyYcBboObBoVBTmGgMtbjJCcJjAaKFqjuHABNqNjTtJtHhBbTlLwWgYyGBfFtTbBPYgzzNnlbBwcujaAJFffFQqfBgjJGvOmmPpcCVJjyJJjqwLMmlextTfOlNgGqdYuUFnNJjRrbBeEjJLqxXpeRrEETtrRelLeEhrYygSHBdcbeEBQIdOOirrheEwryfFSKkKkxMmPkJiIzLlZjUiIuBAaxriCtTqQXrRHlLkAXxsmMflCcLHSshFVqCcQULWwlvyNnRrSsNnoOQFfqkKYMmaCSBZzvNnVORgLAqQxMmUAauQOWwutGHhgqxHKkFfhXGKkoAtmpPHDdhlFvVfLMJeEuUVnjZQqueETtdanLlNoUuiIzZOAOCLlcUuiiKkIHVvhhvCdDCcfBbnEeNTtCcUuSswWbBFAaupPQfWIiMUQinrIiXXeESuNfVvfJjnMeaiHcCAnynNYlMltTuUIiQntFfTBmTuURdUuDrUufFGggGQqKaOpKucZuUKkDdPpmCgrNnaiKkWwwXxDuUxXEVaMmAtBbtOmuTtRtTdDEhzKkXuJjDdFZeriOoIRuZzUoOgGHhWVvwSqiIbWqiMBbIimRrvkXxAaKhHsGgjJSsSEeLubyYYfFylzZmjJwoOWmXqQBbLlxhZRrTXxXCcewKkyYCcWFzODHhyYxXSsUbigEaeKGtvGCANnalLkQqKzKknrRPpZLuUNAXmDLckKCxXgZWwROoaNtTMmbQqRdbNPpCGwaAlLWqmgGyJjhWwsBaACcavVxnzPEMcRmFfQMmqHhckKCpxrbBdDtTrRVvkKRyWmSsptCHhbwyBbTtlAaLllgGMAeHeoOjkBbIioGDdVWDDddKDdkVvJjtQNnkKZJjnNqjsYySPdDXxhHpzZnPtTRmSxXveFfOkGcLnNufJPEZoXvZzVchnkKxXkOogWulnNLnOBlzyYZYIpxvVBbyPpJkKoOPehaAoOuQlLOdDEeORrMXxtJpoOPmMiInNfFuUTtPTtObBLlsiIFfSCcyYltTLmjJhOoOGhvQpnrIiTtNnVvcCvsAaRVhtTLQUIiuAlLmlItTnjOoJPpLljJxTraAHhLluUrRfIPFppBbPNFfnWgGwDQGgRrqzZhHdDdrlLtbBcCEeiHUuwcCaDdXYsvGDcCdbGvVfFvVMmgIiwWeHhEQLlotSbBsTkKjHhOsjJycnTtNTtUuQjJqUXKZNryYRXWwxiIlVzZvDFfpPdKrRrRANneEKkVdDvLoZNZzVvnxXtTQNhBbgGgvKMmFIcCiIiTtXxTTttsJjjoaAORrHhEnTePyYwZwWiIzlJjLpPxXcCUxcCxXrNEAKWwNSsKMMvEGgejJmGgVvpDqXcCuxlLUUuOXxoWwvVuSvxTtpMmPGcSOXYyZgMmGpPzuedDEUToLKtIiuUrqCFuwWTIiXxVfdDFvzZrRXxzRrRjUuSsJqtxXJBbGgaAjcGBPYypbSkkGgiIMhHRtkDFUbqQKSkFMhUBbqesSgGyhHYWieEWQqXxuSPhulHjGiuUpxXPQGgaAaPpTtoONEenUuixtUwOJJyFfYrRiIgrRAKCcRrkySXGPDIivFftSsTMmjJWwXxWwVEeDdAaHFOlLZVOtcWwCTPgcCREGgKMOorRbBGDdgkAarRvVOuMmUjeECpPVlLvkiiQiKkCcJkimsHoORQqUMRDvVdrmYyOhHoPFfKlLrRkiIyYzZnTtbPpHrRtgcCgAlLaGZRrPpcCFvVHhNLlXxXYyxXKuUkxvBNSLLeXWkKNRrQYzzVTWwtzepHhPgeEuUhHgAMWWhHwsybBULlEgRxXLhBkYyTengXMGnbBGgmMvVKknejgGJGgJjyYPnhGgfFHoOfjJFfEeQqfFXxAfBbFBKkIaXwBJjbgGWxuUAargNPpnSAAvVgGaTPGgEoOnNEewGgNtOoYyTwshHSrUuRzwWdDZUuqQfFDdoOsmMSQqLRhIPoeEOAapPoXBbEetTxOpXhHNXDXEeoIidDdrtTRQAaqbBZJfLuRbXxgaUIiLgeBbYqQnEiHjvxXVJbBkTtKpdBbgaeEGMmmMgLhtTdiIaoSsoOONaAGgAKmqrbsSmDdMfFdDTkwfFKlLaAgQcCZmNQqnNaxEVvlBbvvSsVjJAzXtPMqZYVvFGAifDdFIAaRrIUpGgNnCAayUqQXdDgGhpYyPLfHRGgKAakrhGnKkbBNcMObBPpopPvkbgGsSBjJKdDGgVKkyhHXbComgGHaUuyjJoFfGAFUuWryYbIiQqBRQpcCsQRGdDTtIiGgwAaNnNntigfpMmPDdviMmZfFzMmjJKkupDVvdcXxZzkKCPooOePpMKjJCzYyZHhfFQqeWwzTyMmlAaLOoeMmsUIigGMmuLlBIaAoOcCcmiIKYyVnDdmEeyeEqQIuUCcMmZgRrGhdkEMmnNXxFJKdiHFfNnhKHxTtkwWwIZzuJJjjRaeQqxuUXktTRrCWsTAaIBbqqoOafZNnzqdtTwWSsfAaAzZbsZzFKeEkfLuUIcpPAJjhFtchHCJjwmMgGxXFfWusQFfqDLXsSxwFfZzfFWwElPpMQCccCjJnNfAOoCtqGlBzZUwWIHhwWiuUCGgcsSRroRuEoTjnkMmhaAuUHlLokKTtKkjPRrOoXxSspNwWXxniIPRrPpeBbOoGTlXxLdvVUDduZznsnNlPRrbqQBSsPplLpLgGZzZmMliEeILquAajJEnNeWwUZzdDVvGgQGunPpNUwWCvVcUgGuXZOSsNTtnYvdDdWLuUFfCzMmoOaAzZvVzeHWwhEiiICctKMDdmpPHhKHmIimcCYLBbvXxVafqQjJTCcIrRgnNbBtWwZFnNjNnBbqQJfzTYEWkXdHihRnNiIrCOocXxvfUrrRAftTtTFDdaAsSPpwWJYyVoORrvbBNnMJjpmMWlsSOBboLiIeVzZAaLLwWlzZSsgxGNnitBiCcILqQccfFCZYsShyXxYIwWiHutBiyMuUOocCJIijwWmyYNIfnNOoFSLlfrpPrRQqVvoFfAgGuUjiBPpqQQawWtceEcCBbCcbBCPpqyYQlvVLWPYCcyBkgLlGFfKbziIZqLlRrYyeELlcCaiIaAzDbBvwWxAzZRrNiInOoiOraWgZwWOZBqQbNnfwWpBprNnpTtPIiGtyYqDMlLmQqHVWwqrFfRQelCcDdGNnOpXxdDKDdcVvCxopPYLdfrRFuUpHhCcPjJjJiIeEdijhVvHJcRODdogGDdgcLUnNSslLulCDXxTXxtFdDtnbVvByYaykKyHwHensAFfpvVPHBbQqRrbvrRZoOyYzTtfwWFUuVlcChHnSQpPrRifOaAXayryNEeaFYylQfFeQqukKUzaiIOoTbVpGgHiNUugyGPpgBgeEGUuhknwlnMmKkNLlvpcCPXbBxVXIiBsUlizFXxfnlLoOtTsEyWCIiGgkKhUbBuHaDdeHhEizNXxnCDdeqVBfjJYyFiaAIfsSofFOmPQAxYkdjJWsFHhOMmIitpPRrqQRrJjxXfFCNnOowOocCWGkiIKYhaAPBoOCDsTqzRlbhHTHepGgPpKkJjnNpPDviBbIrRbqHpdDQgbBJjfFrGgRGrRrRIGNvVWFpPPRrBGkKGgUupjJPkKPyCcEgGeRrCcOdDoxyBCAacTtWwHhnIqZzQLlwuUWEsmEEHeicCIFMIimlLAFfAnNCxNCcsSyYTtkKKaoPpOHPpfFfFBHuvVnGyzZkeEKtTfvRVoOrXxERrRrDdiIsDdfFaGgKkzvVQgGJjhHqZCjJhPnoOEDTtuifFhHIURrxpPxXEsSbBpsloOLeESgGfzvVhkKoOcHhXxfFHDdiIqAaISsnrRyZzSTyYyYKwWkNFGOogRrVvfsSAXxlgGDbBTqQzTtNwWnZsSIiPwWpYEeGRNcIxnNOOeMmEpPPpooXSMiIWwdDgUueEGyTtYjJvwWtTmMRnoONrTtVfFiwWnNLlIuUPBeDoOdEpPbmbXXxxXwmMWXxNvPzlLvyYkKCmeEMtTZxSGgskKwbQbBqBFkKXxmhHMpPfWXBbpPEezzZnJjLRrlmMtTXxodlOxXTZztoUKkutJjRrHlLXpbBGJjwDhHdgbyYjzZPRrpJvVqFrRjJvVfjJCJaYyddxXDcpPsSxXxAKkuHhOdDzZIIiypMuUmUNGgGgdegGOAdeENnaAWwJcCIYyUqYycCbCcHooOICkKfFQIiqsSWUwlJjLGZzYyEelGLMmlgEeaKkTUuZzbxXWwBfFtlvVMmLlLKzZkaqCcvVvqQVQMtTrRmvVFfuULlOohHAzZsPAsLlTELlzOsyYmrmkMmJjKTjZzwpPUSsDfaAsSFdUtOoTuqMmnBnpPCnNGlHhwjsAjJHInNihawNHhYZaAdDNRdXxYyDxpndKkDQqLsSaOowWMmtTAyYKkiIKkooOUupUBYyVgGvUplLPfFAaubuGFxXaFfDdLlkmMbBlWIojJOiaAJjltTLBXSsSsEGgbsTtStTliILrRBpCfFJjMmULlbnNBucPAtlXFoOLlALlRdKkCcAaDUuFfFfnvVaAXVlLvRbmMNnklLqQUuigGIiorRYZUuThvVXFfxHiPLkQvVqxaAnNqQCqkmMKgBbGnkKVUuvdBHhboTqEJjehgYyhHGOonBZzoOgGkKuKkQqACMmFiIfbIijJyAaCcEeyYYmHhMpPNgIieyeEuxsSqSHUfsIeGJNmHhMsSuleFnNfMmhHzyrcCRYvuUsSzZuYyvjaAjJJVYyFfHyqvdDVlLIiQytMmXxTmsPeEVNfgnNGCYyyAPpeFfeiOoZzJjIDdMJjxrRtTfbezmXgGxGVvgqQMZXxGgVIwDrylNnesCDmFYyfwWUHzZaAwWpgGHOohPpWqBGgbqBbQipCchHnNPIQhHSGgyHhYUuXvDSsyYbHSwWsKmMkhqQjcuUpiIiJmMDqQCcuUjJdjoOgenMbBmEevVfFxXNnNQVvLATiItKGyYgGgbmMNVvoOCMmcnBpBbPpWwPPYypQLZCczZaAqQejbQGQbBVBXxVDdIHhsSsSLgGrNeEtTjJXAaXuUFfxpSsPJMXxmjJjxWsfmMFksIivOTtpPMofFNlLnAaZzOPrHhRWwpZEapPxXAQIiiDpceaAdSiIOoeQqEhHiICcJjYyZiYZIBGgdXqQxPpDgGEeYqQWQXxqbBwgVvGgGZoOXxEezZjJkKuDdAasbBSUsSzNnKPSsTtOofFIilvjJLuBuwoOWSlLHhsEeXqCvgGlLVbuUpDdPAcCAaajJBmMHgGeELjJOolTtPswRbBAdDaTaMnTgGszZoXxSaeRrEeiIEAeEuUewWwPFiItkKTqmZzMfFeljJEeQqIElLeiLaDPpdAoOAIiaLlkYeEGguUvVKjMmJlLwvVIiWYyknPhHwRceKkPpDQqdeEjJZMIimyvVmOKkPiIpoMuKkUpPlSVcCglohGYNjJPtWwwhHwWadhxXCoOcqQzLlQDmMdqZvmSsMZzrRJrRGjzZyYIEeURruUTtBbsMpPVrRvsSBulqmyYiJNBrPAeGgEaxXpYysSNxXGgnbsSIikNnKgnsUUutTfMmsnRIikFQqXxlLrhHInNbEEecRoYyeEzcCgeEjJzZdDBSoOsbMEerRpqPphHQSsNHYyzNBDiIOooyDqeXxEGgbTtSHSshxXmGaAtipPIecCpPahHgBOoBvjvVZJRrjjJBbCclMyxXYmRUugqQGFeEVAaLlkKCcskKXSlkKqQWwVvLObGgNrRnLlzZwWdoODBHhXwWXaqQaAoyYhHzZOXKgdRruUDjwWwyYMmMGdqmOoZzmMnlQqIuJRrLLcLlSshHuBbkKzvVmMZzVvnNJxXAdyYDDdLlWIiwYfFzZTwmMOowoHUuZgGzXxYBboOyyyUjJuueElbBLSsUYfWwSsNnCcmMBBoOSpeOkvgoPpOUTWwtbBkqQErRejJdDWCcwmBbmMMQqkKqZrROokpZXaLkJjshvJXxvVjKCcvYsKkxbhHBhZzkKBbeEIeEnIUuBbiNVvOofeEexUFwWDdfMrqQmzeEPmfFMdbNnBMjJzZvVtCtTuUcEeTNnpGgMnNeEkKmPmPpxXGgzmTtGgoOMJjJjmVvpPMmMAnuUNnZAazYeEdaWwAbibjRoODdXYyRpPRIiEeUgGIVvijJHypPVqQNZzrYyxXkbBrmWwyYYyRrbBMSswWMmVQyKkDdYqLllBnDSsdpYyTtDuUvVdDdiIPfFhHSyYsKsSBpPBbmcRrDtPlHhBbLaApOoTXKkSaLljeDdGgEJrRACjJDBbdOIOFMmaqRaAlpPhHXxLeXxCcixXOoRrYybBIgHTHhtwjJLAUuNsupsiWGgqQOGgxXyQJjqgFfeEtTPptJCcsSUbneaikKIwWOojuUIpIBOoXxTtcCVvUArRtTVHFfJjMooHhOKWFmMIYyuKJQqEzUuZDdbqQBztrxXHHpPhAaUYQqnNDdpPylxXoPpOdDFdDfIiMmLcIipqfvUJHhtBeETQqtNnbEXUuLlxsSeeERPFsSTcmPEepMnXxNbWwmMPpvVBDvVGgVsjJyYqPRruUTtSsFfMmZgGzDdniVSsoPpDdhBbZznrRNFBAaaaOaAFcAaCWtThHCPjGgEeJtTvwWVURruiIERHnNGlGrfYyWGgtTwPLVvMmlpBLFfHhCcsadDAScCtTabMmbBmMmOobBXxNnskKyYXhHBbHhoOxqYfLlbBDdyYRrkKtzrVvMIimMZHMmlLHiIhtBbZzMmxnPpNzZpPiSWwfndDNVvIkHhPpbBdEegNnlxXLXPJuUjoOaUCcuoOaNZWwzJVvjYyjJXxQoOINvVnNnimMdDzZqyYiYWwegFfFfGpjtLrIBbsYnNGYMAxZUuqQzPzwWgPnLltEeDdQZeZOoOooqceuUbqQLlBaWwJjWwQhXkKiITtxDvBywWYPpESnNZKkLdeEhHDNURtTCJjiIgxVvzZRrzZuUPAapeCQpPqIigxXGOoOGLBxXbNWwrRaAZpMuUmPbXuxDdiIasSEejJAKCDdvVcwqQqpsSPNnKkaAIiQpPhHfGqskmZzMKoWHbBhwtTjDzZdhrRwWPfFhJiNeEroyYBbwKRsSRrXxroOLlxXPpwjvVaoOdUVWwvStTbBstZCcEOovVdTtirRsSsCcYjnNJgrRgGjJGpeETtPmwjNnXxmMUuJjGghjtwWYyTRJjnvVhSslLvprrwWRfQqrRykKCGgTfFXxpPtcxXDOtToYnNPMmpizAauUGlLgZATtaeEtLINndDInfFrAaQqRXxruUxZhvlLmIiDGgdMUunQlMPpmKkaUuAiwWxXIZzxXfnNFeEDdIXxYWVWwvIibksGHhgeqQEGqQGDdVvgeEXzmTtMSoOhHsZxdZwxXWzxXDTtiIHhTiOoIdsSEPXxpejJgMSorIilLpPRWUuwExXeCckKNSszZRYSsyfFZnmMcCgGiILqQyYtkKenNFmxXMrRsSRrQSsROorqzZfHhrvJjMmvVVrRygvACcWruIiwWIiiIUZGwevMKyYkmYkKaACQqceEaAyCcpXxPVvymMkKBpPNnrubBUJuUiIKBYybdOoEenNDkKVvJgGjdoOCcOxvXvHhVMFxXflXxpPLeIiJjEUzZVvFfuLoOaGgFfFlLfAjJhHlwxXyYNnlQqUuBbXiIhdDPpYEevVyNSsFfKknNOfFxiBFLZxXzsShXPcpMmPCRrpNnhHNGGkaAiIKGgkKMuUvzZVzZmNnkJYHhJjyfFfFgCBTtJjgGEDdUarRhhHEeMcmMCmGgHYmuNmgGMqQnnNuUUPpPdDpddDDodDXjdGgAaDlLxXOoaFfAEzfxPbHhCcBAuUwWLeElmMaVUuvyYEeawdDueeWwEEatTljTtJaAWwMmaAuWcCyYyGgpPMmPpuUzZCcUhtTQqUuzNtTxfFyEvVmbBEexXnRrwWNNXZzCeETtcmMKksSwWRruVvUyrRYDSsdpluUNgeElLZzBbPvVrzOlLDdLlcCRrjfFIiFfmMTdDPfTtWibBguyDdYxXdDAaGxXQoObBqbtTZzSdDRzZpRrRVIDditOoKcCkTgUumSnyzZeeDmMaAdphLlHyYjYKuuUfqQFUgGSsaxXDTtdqQjrRJjtTcDdBbfOoFfhdjzZnuUxXjJejJoTtjJTtpSslzZLYkwRrWVvSsKEeVvGgOSsoOKkfFKkwyYAuyYMmUDEexqQXgGDdeEtnNTCoOccOoDUbBjJTtiIKddDDsSZzkxqQrRZzepPynoJjPpytTIinNhHasRrmMSAOloOfFLoqQYOHEEbBeehBbmMxiIXXhKkYYyyHzeyYEZYLlvVyxmMrRJFNlEeLsSlLagGAnKkgLaAlGfghHGhkKHUDduTtcdyNFfnhHQddDaALSWwsrRBxXgGRkgiIVDwWdFIPptTfIigGOQCrJjUfLQqcyYqQoOxXwWoNnTtITtrRiDYZzydzZvVHfkKFhOSsoDdFHsSeELmMQmMqHUuhcyYCuTtUuUTtiIqpPdDQldDipPIhqQFnNVwWjJvJjvVMcLBblFfZzfHhFQqCCsScmkJGgYyAuUajKUMmFfhHcHRrhTtECcgGsaSsxeAaQyYgkAaKuUjhHJbBXxQqQqTtIyYiGqjJFOXxZzzGcCuUcCUBbBbgGXeExJjTtKiIUukMmaBbLsNnjJXxMKkEemnNBlLbRtxXGgsSbWwHBbhejRwWCcabBpZzURrmMzZuqQuGWNnaAtTzZwTtEeodlLDvVdDwWeYHtpeEPeEmidsSpPDzoOZrROMWwmoUutoOTITtmMDdKickKuKkUQeEGgqwKkqFrRjcCkKcMmeMmElLnyZaBbAzCxVwWnNvOocCgGuUOooOLlnIicCZzdpPDeENhHLlZGgIiZmMzdfFHjJgGaAhjJmRHiIrRhzgGVvECcQqvVIiHhFfLlYOqQaAoyRRrjIisSksfFlLCcKrRkqQqQehHeCjBbiPpmMIJgRrtTqQtTnNcwwWWdiSsIuUoOfMmFqgGIsSaxXFfFfUsSIiHdDhuAijrIiWhHwWGgZzSsWwkKtTMmwBbPpRZNnzZFeEaAfgGVvzZIixXdpPGqQgbBtzwWlLZeEIirRfFJvzZPpVwNiIqcCKKkRJjpmZzrRlLZHhSbBAajKqQNnwVvCcgXupPULlhHrRDdMmbMGgPZzpfeLlXxEqQNFfOnNKkvVoTYulLaLUOoHhjBCmMcIrqQoOKkRCcslZMESsegGmMmZzzZpXxaAqSsQKVvkkKZzhHCcMhbBuUHIiujJrxXRWwUgyYGJvXlLjpPQqJHhdDMcCaAIimXxbBZzKksSQnNsSqQbBRrlOoIiLHAaxXBblQdDqsfFSRUuctTCpAajgGJgSsXgkKGxINjJnBhHbrRlLMmoOOzbowWOhHxXXXnKkNtAQqPmMJjGUStTsLlQqEeEeuyFLlFjJZzIFfRAtAaJeqQEwWMmjSaVvnNoOoOGgcNndyYbBFfDaAqjJsSjJvIiEehDdHcCuLsSFfYyXxXVeEvTtuUxXxNnytwWTevcCTtVEHeyYEMzejJEAxXaKkWwAAPpLVvbBCboMPpfXxSUuswFxHhXKkSsjJfvLlCcKzZkVXwEMmnNexXWkQPplLgGXxiIgPpGqQMmahHAqDliILxXdDUuKCclpPLkPbBvVuXzZNnxhHdDUpVcCrRvuSSstTZhHzjJjfOouUVvvVwWrRFRTtrJsMQqZzIisSfFBxnMbMmVvBJhKksSaAGgHDdvKktTrCcReiAafFIhHzrRZeEHhosSrNxYuDdYySYyaAsZzySssStuUTOaAoMcCWgMmGhBZzSseLyYlrREKkbHgGDdQrRUuMmqtTjYyHuAaYjXxJyUAaFCccCBbsmMrRHYykrRDiIdgGvRrVWWbBwPpwqQeqQEkzZwWKYyJUujDlCcgGOovwWVLWwdhHpPFfKGAnNZzusSXhHoOvVGFfgVuIiOZzoZPpWwzOKkoULYTtYyVxJjXHhyGgVvUuvTtpCcsSWmMpVQqvmCcZkWwSsFfoXxKnXIixmlLLwzZLlHhLlVvIiWZzlbBeEKkYlLWwLlhHfFMmycAUpPnHhnNNeRTtrEEeFfygGwdkKDtTSMmsEBsSbNnJNijsSuUtruURAWwarIQNnTtqQPpTpPCctRrAaLxBbaAiIXfNoOwLlWZzaWOFfbBAatTBbozZxZKKGgkhHdDgGkxJjXuxXUBbVuUvtTjKwWyVcCvPkKprRYqQkCcfFJjDlLLRGZzDEIienmMcCRrNGDcCWwdgiIuUKsSkozJjtTQQsSFfXxQPpVvqGlzXxZhUueEMmMpXrxXRxGgPIibBwWOUaAuomsSSsyOdNSsnQqDoKzTxXtfFZkiISXxkKavVmMAXZzyYvvVCcMmVLmMwiQGVhHpvVvUuVPLKklUuvHhtIiqvVQzZQKkRrBEQqevVpcTtGEMmMHhmrRegkGgKWwpaBbAPiTtIfxXFNnxXDdeEfadDGgaAihHSYyzZsbZbhHBZzzBNJjUupPEsDcCRrdSJjmZzvVpPJMmyYGvVgnVvUuNpftEeTFUuhqQBbSsrRkZzVkKvcJnNjJPphYyHCkzYGgDdyuUZdCcdDgGDxsSXBblEQiqQqQUlLKkZdnNOcCMmopPEeTHhtJBbllLAanoONpPKcCeOonnNNEBbSsAaUIcCiotTqUJjuAaCcflrRLBbgiJkKPOoYypRJYGOosDhHMHhnNmdeEsRrSNnbwHhWkKlsSLBFfScGfFPpgCtAvuUVaXNnxLJHhyYjlYEefuUAqJFfvVjQqOoUuWwmMoOYabBAjxrRXBiIbgyFQPpucCUqvlLWFfsKkZQkKkYTtaAycqXxQCYOoSsxXdDpPytTKMmfMrLBxoOEeXgJLljGNnHcCmMsSjAIiaXxPpaADbBMmZzRryYJeEjdKcCkhHhiIxEwzZAaOjJodsSDjbQMmqpPBQqJOmmBbMhHlaAjcCWvVwJqQZUyYTtWKkwPptyYiITsSHnNcQqCjJhxXuHhwWpmMyYdDkmMIaAiaMpPqQmMeEmvVhHGgBbBrRBbibgGBIbEkKFlLFfPpHhyYmMfgGLlWwHuEthDFSntTfLlFNWwsoiVFfbBEevVIxXXAarRylLYjJxMlLNnPpmoOPpijXIigGjJqQCkKOopPCVvmMhYyYiIfFyeEHcctLlTHNnMmNnAapBbPNnMmxtmMmnfFNjJbBMAaYykKEeBqyYQcguUUuFwWfhHmSsSngGNsMkKVhHtjJJKkChHcaqsSIiwWAabfqyYQKWLlxXxXCOkkKfFKEtUuTejZxyLNnQqoOcCleEBfFNnlLGgMcYEeTtshIiHWtTBbbFfEedZumlLMUnXxvEeIUKnNkuyYUuloiFfiiIfFIAXCcPtTpxXvmMKkVwWxwMmWaAaADdQquCzXxZTtyYidDfFIcSsUapPFfxXbBhHfFqQWtToOIiwnNjYylLgGcCOoHhCcJeEAaKkRrtQqPpRiIjJfAaFOoMmQtPiIPNnwWVvuUpXCgRQdoOCcDYFfyEeuUeEuhHmcVUuvCMmMUobBvbBcCqVvQVGYygDaAdkMZzmOoPGIiMmpPkKFaAUuhkTWwoZzPSsAxXapUBAabudDOYyfFgGSsIiGgWwreeWwEEAzZgGaYoOLCgkKGtTQqKkGgVvclwgDdGWyYpPiRrZjJzaAfFeEmMneVvbBrVvREKkRrlFfLqAaQjJaANSsSXxsoBbOLrRlsgGSYpPyPpLzsSZZzlICcJjmMFgSrRsdDvVFfJuUOojIGgFrMoOmSsCYNnbByeEccTtIilXxLUuqQKkCGgIiSJrRjxXshHkKIicCIPpifFxXyXfIiyZzGgYBKRrkmXxRrMdDgvpPVIxXiDdGgwWqLlQDdbrRBGTnNrRtbPpIihQGgZaAcCzfFvVeEvVCzZcmmMMUjDrRqtTeERrUuQddnTeaAhCcSsPpQRrqGglfKkFLZmXVqQNnmOpPSsSsiOohHJjCcXCcxkXxJjxXzZhVvkcBjXxXxbSgGpPgSsxBbdDeEpcGgCPXRRrCbjeEtTJBAaccdDfFtbQqBTAabBCHCchZzXVRraAIiLlvwWYyUupPxDiIOoxXtCcIiQqXXbBMmaArpPRogGSseRrzZcCFfEcCkKkAaBDdoOhHKkbIiyYrRLIilKOosDUudSlQqDdyYpvMmVLxXlAaiWwIWwKoOAmceTtFkKTWwcvVCTRrhHqsSPpvUgGsSwvVeTAaPMRrRdDriISUuoOsVvjJyIiYMmJjcFRrfJxXPpjdDBbKkyYBlLYaxXTjJhHtaVvAALeElgtTcCGqiIQzZMBIibIimaAcCTWbBUvVDVLlvEeWwCcTAIiJHhjKlLkatgTtxqQXQqGKkwJMWwaAmwWjIipDdmMHhpCcufFoOUwWPqQiIPuUzZpiITttTPpXxNjdDEeAaQqJDFfdQqnaAduUZzDFOdDHNnhoeLHhrmMnNDdRcTNntHTtYyPpeEWwjOoqQJhCKmMkzbBZENzZnuBbUFfcCMwWOaIiTQqNntpPTtAeEiILIirRbKyYkzZBZvhHVzsSduUxXxXzmeEwWMZPJjQqpTtXxTtpvVuUPfFHDEedhDWwIilZvVXxzcCLlsHCeEcLlGgVvgvVGsSfAxBeEbtTmUTtUuXxeEnNmMYbfQqFBlTtLuOoOoUhHghHGdDPVvKFlLURoJjOZzZzyTteEsZzOLllLoRUubBVKkvvKkJjVrRPpVDdnNvYyzZuUrRekKEWvUuLlVOTkPpPpKXNnkKyZuUzYwWZOoxXVKHLlTtWwhXxqcYyUuCaAFfBAabQbBpReyAaYEzZrQqPgGToOxXCkXHhqQxkRrKKcbAaBTtdAaNnDvHjJdDQdDUuqnNkQqlLKNnWwMVcCmMIdDigvVGwSsTtWvfPpgGFDdKkwMmzZxZzTbaASszZvhHVBmMUutDdXsUGgygGMmYuHhSWQCfBbFcRrmMNnhoOHsSAaskKGgfFAaFlLffhHFbBVXxRrhHvuUVxXDwWTtdlLDOKkoneElLNANnhdDNKknuUNeEnJjjJDuUdRrPpHadDWwDdSsFsSfdDVvTTtTxXtbnNBgGqQtdmKkPpbeEZzAscCSaHsSxPpdaADDdoIiOqQHhYyQDdYDWwvwwgGWLnNlkiKpPkIiIKOoLlWyYVMmTWwthHEerVvRsJjSrRfZzFHGgMmzfFHhZAauURMJjmrkKcXzsrRSnVvNZxiIKcCkQekKlLEHOoLlhdDCcUkwWkKdGLlaAgJYykKjVxyYXIJjBbFaAccioOMmICpTtqPpIiaAZzQqlKkLIiYGgylLQjJssSNnSCDlLdcCcUTtBcbBVUuJwWjZAhHKkaXxBbzeEKZzWwAGPpffFUTFftuFWKkwSlLsOogjJauUvVEbBefFrRFffFnKknNNqzZcCzZRrvVAaipeEekKiIEuCuUyYcUexyYZTtzcCfhHFIiDddDeEUzxXZAfFfIiFrxXRatTYyIiaAvAavVVhHMmlLWwhHIiEvGgtTcCVTtesdgXtTRWwrJjGgxuUhyYHMmqWcfzZFEeCeOosSEVvQqwgPpGnNvSUusVjJEeQXxGOoVvgGAaeMUumESEegGTtstTYyFfDotTbBAaKbBkiIwJbBuUpPZaALlvFfEedzvVZDtTmMVtFFffyFfJjmJjMYgGTzgGhHxqQXfIiFuOogDnDWLlwWdDTFftzZBbBbJHhjOocCsjOLloJSuMmNHhnsShHQNnBhHbRQwWqEePpXprRHiIVviIAMmaEefFhQqnNAaPlLRrxbjJgGaSsAtTjROzZouUKkSgGWDdwNGgnSssQqBbdDdHMJjAOoamhKkiIDBbrfFOoPpJPjJxXsSZzGgVzZvOolLpbBxXNOoHhMmnBfFbLlHDdyYhIiNbeEBXxhRrHhHnsSoEeoORrnqQNXxcvVcCCRlLrQmMYyqHpPgNnkKgGOfFiImMoGIiMWwZtTzKuUkFfmmcCvcXxCEbKkBXxuUgGjdDCwkKWeEuUuUTtVjJVvDdvnNCcPplLqQsGXxaArRZSszuYytTUsSkKHhgEkKeJOoxXeEiIxGcCgXGgFfcCGgjMaApPQqZzBfkKKkFDdgGonNrRDdEeOMmRrLlYyqQacCuUJjAePpEuUbGgBuUdDWwUfFReErSsubGgBbtTGgcCUFfFcbjUurRJrRkMMiIZzmZzmOoNSCcKkRrsRrxZmUEeDduMbBmMoBiIsMmSOoWwMmDdyYxWkfZzFoOKwxXXbAaCXVvxcsSsStBbTRzZKkzZCrsSTjJtRcekKkKErrIiRzmFfMCzZcCcZfFtTOsUuSDRrtTxXeExEeCTcCtsSGlkKVvLkcCKgIiDKZzdDkDdQqXxXmMPqQpxnNAgGGFfrRsSeEAagUrRRhHrMmuhHkKdCcNUuKknYkAaKGhHgaAyzZslLSDMmCcLCchHhHlsQYykKqAICcNnuUffFuUMGgbBbBdDVvjJmyYOsCndLlwWDNciIhHvVlDdKlLkXhHaAMmKkFfKkkMmLlKxwgGWvVLlLIbdLlFfxXmVvBbFyYfRrAiIaMrRrCoOcrOoIinNEuUiIyYhHeRUuxXrYwWRrjJbBAakVvJjKpHOohPuUyEedDKwWMOlLoFfKknNsSBbmeEAdDakhXxeEHRXUaaPHKGgreKkEReEWwzZkhpAvyUuYDdeEVxppPCqQdDULVvtGgmMeETlPpGoeEWdDyYcCmMwTtNnxQqXEeOzZwGgWTtqQKkgUAaiVyYvuUwWIrRuuTrRtyUOouxYyXIidKkNnKnoONCoOcvVnNrbBRNVvxTYytXnRroOsSFfyYwWAayUMmeXxEueUuEKknNYEZSkuaAeExXUKoOxEHhekmOQqWrRwojjYTtTjJgGPptOoGgzZlLBbywWYyvVJJjJjJgGWwsAFfaSMGgNneEehHkKEmVvbqQrZmFfSsMVvzHhkKoOIaABbCnNefFMmEcAaiZzhqQdDbJjrRYytvVLlTCKkcLleEwQqWqQmMSrRTtEeQuURrxXQxaPpAyYAaXkKTtqIHEehmMlLqQrLlROoNoJjEJjeXxOGgnfFIxXimMKkLliXBwQqWKkpYBbyPfGgFUuzpPZjNWwnJiIOoDdbdDNnKZzkmMpvoOVbBbBPlbBLxQSsqAbjJBZxlLCcjVIiaAvJXEeCcSBfFbszAFfbrFVvfNnRGgjdDImpPMfFiuZzUJvQqSsluBbUkKCJjcpPLrRiIVcCveEVlLUulZzLOowWgxXZzGqOoQWVveEIiKkwnNnNhHoOCcAoaAOEeaLlnNcCCsScFlLkaAKEMmNnaAvPiFfIpVnExXetqQTKkNlFftTXxuUUuLLlefDzZdSsqQlLTxXSstmMYCcPpeEyPaALXxRrTMmtrXpgGPvVxcCNnQqDBbdRlNJcCjFfRrIiCcOojJRrzZutpjJRwWAaZzrlLiGgKkIeEPTUgGprrouUORYySsGgRBbVvUYsAaSJqQjdDjJrRPgGxXpCZzcFtxXTzZFDUudKXxkHhftTKkxXTVvwWtWenNEIiemZzMZxXzEDdbBuUqZzuUQvVsLwiIWlSeVvwWEktTabBAKqTtjJQaLDdlAVRruIBbTtiURrvdDCbBTcCTtSbBsEeLlRrtOpPYypPohNeEnZfFzHvmMViIMmOoQqmMqmMDJjdjPpIiRrCpPcJHznNZcIiDWwdlLpPzfFZFfNulLUpdDPpPeEsSxXgGniIHhoOmMoObBKLlkAajJlFokKOfOoLGxXIiDdgqkyYuUKxXYywWooxXpGYygwWPOtTWzZwXxLNzZOonlpEeOoGgPDdlLZzmTtCfFcZwWFfUuDnNdbNnBRqeECcEenNQrKkNnzVaABbaALhFfHDdwWlvxCcXBOouUbvTtggGGVHhrRxUudCcDUgVnNqQaAvhzZHjBbywWYIirRJhXxHLuUJjlZzUuwWrRlEQqeLQqqQlTtWwveEVLaeEAmMfbGgBFWwHhzbGgBWHhwxfxXFXZNWwdDnuUvVmMGOoTDdRrBrRbNnteGRrgcCgGWwEiIZZsSzRrCvVDdcaewWEAiIBfFbzwWjuUJUvtTLlBYybBbTQqPptTtGNnQqgMUumSstsSnNtTCcfFvBbWwXxVVvGWweUuEKkCdFfTtiIDcHhcCCcOPpAaogoOJjJoOjcCRaAIiNLTtlnpPInNircCHhloOLuUvvVVqQYxiIXyMtTsSWsSJjHhWoJjUovEeVZzOuPNjJgGnIipcCkwWKOUNUunxXvVMmRyoRrOjJYrOZzmvVrRXxMPdHhbBoOxXDEeOoKknNpHyYhcCHKkrRUlLOoupPvVuUyYhAaxXoMXxgGmuTxXtGgxXsSGgdDwyYQPpKkqwXsSxmMIiRryYFfYycCJjCcOoYyzZYQGIiPpaAGggqyYgUjRrGgJbBuPpLly'", "title": "Chaine"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/", "text": "Dictionnaires \u2693\ufe0e Pr\u00e9ambule : retour sur le cours de Premi\u00e8re 0. Notion de tableau associatif \u2693\ufe0e Un tableau associatif est un type abstrait de donn\u00e9es (au m\u00eame titre que les listes, piles, files, vues pr\u00e9c\u00e9demment). Ce type abstrait de donn\u00e9es a la particularit\u00e9 de ne pas \u00eatre totalement lin\u00e9aire (ou \u00abplat\u00bb) puisqu'il associe des valeurs \u00e0 des cl\u00e9s . Il est habituellement muni des op\u00e9rations suivantes : ajout d'une nouvelle valeur associ\u00e9e \u00e0 une nouvelle cl\u00e9 (on parlera de nouveau couple cl\u00e9-valeur) modification d'une valeur associ\u00e9e \u00e0 une cl\u00e9 existante suppression d'un couple cl\u00e9-valeur r\u00e9cup\u00e9ration de la valeur associ\u00e9e \u00e0 une cl\u00e9 donn\u00e9e. Un r\u00e9pertoire t\u00e9l\u00e9phonique est un exemple de tableau associatif : les cl\u00e9s sont les noms les valeurs sont les num\u00e9ros de t\u00e9l\u00e9phone En Python, le dictionnaire est une structure native de tableau associatif. 1. Dictionnaire et temps d'acc\u00e8s aux donn\u00e9es \u2693\ufe0e 1.1 Protocole de mesure \u2693\ufe0e Le but est de cr\u00e9er une liste et un dictionnaire de m\u00eame taille (arbitraire), et de comparer ensuite le temps de recherche d'un \u00e9l\u00e9ment n'appartenant pas \u00e0 ces deux structures. Q1. Cr\u00e9er une fonction fabrique_liste qui prend en param\u00e8tre un entier nb et qui renvoie une liste compos\u00e9e de tous les entiers de 0 \u00e0 nb-1 . Correction \ud83d\udc0d Script Python def fabrique_liste ( nb ): lst = [ k for k in range ( nb )] return lst Q2. Cr\u00e9er une fonction fabrique_dict qui prend en param\u00e8tre un entier nb et qui renvoie dictionnaire compos\u00e9 de paires qui associent \u00e0 toutes les cl\u00e9s k de 0 \u00e0 nb-1 leur propre valeur k . Correction \ud83d\udc0d Script Python def fabrique_dict ( nb ): dct = { k : k for k in range ( nb )} return dct Q3. Cr\u00e9er une fonction mesures qui prend en param\u00e8tre un entier nb et qui : Cr\u00e9\u00e9 une liste et un dictionnaire de taille nb \u00e0 l'aide des fonctions pr\u00e9c\u00e9dentes. Mesure la recherche d'une valeur inexistante dans la liste, et affiche le temps de recherche. Mesure la recherche d'une valeur inexistante dans le dictionnaire, et affiche le temps de recherche. Cette recherche d'une valeur inexistante s'appelle recherche dans le pire des cas . Comment faire la recherche ? Il est imp\u00e9ratif d'utiliser le mot-cl\u00e9 in propre \u00e0 Python afin de b\u00e9n\u00e9ficier des avantages (ou inconv\u00e9nients) de chacune des deux structures. Si on cherche notre \u00e9l\u00e9ment en parcourant \u00ab\u00e0 la main\u00bb la totalit\u00e9 de la structure, on aura forc\u00e9ment un temps de recherche proportionnel au nombre d'\u00e9l\u00e9ments de la structure (et donc une complexit\u00e9 lin\u00e9aire). En utilisant le mot-cl\u00e9 in , on va laisser Python g\u00e9rer tout seul la recherche. Pour davantage de pr\u00e9cision, on pourra dans un second temps effectuer plusieurs mesures et faire une moyenne des temps obtenus. Pour rappel, l'import du module time permet d'appeler la fonction time.time() . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 import time def fabrique_liste ( nb ): lst = [ k for k in range ( nb )] return lst def fabrique_dict ( nb ): dct = { k : k for k in range ( nb )} return dct def mesures ( nb ): # \u00c0 vous Q4. Effectuer des mesures avec diff\u00e9rentes valeurs de nb . 1.2 Mesures \u2693\ufe0e Nous allons effectuer 3 mesures, avec une taille de liste et de dictionnaire augmentant d'un facteur 10 \u00e0 chaque fois. \ud83d\udc0d Console Python >>> mesures ( 10 ** 4 ) temps pour une liste de taille 10000 : 0.00023534297943115235 temps pour un dictionnaire de taille 10000 : 1.6689300537109374e-07 >>> mesures ( 10 ** 5 ) temps pour une liste de taille 100000 : 0.0012505292892456056 temps pour un dictionnaire de taille 100000 : 4.5299530029296873e-07 >>> mesures ( 10 ** 6 ) temps pour une liste de taille 1000000 : 0.012522673606872559 temps pour un dictionnaire de taille 1000000 : 2.384185791015625e-07 la recherche dans une liste prend un ordre de grandeur \u00e0 chaque fois : elle est environ 10 fois plus grande quand la taille de la liste est 10 fois plus grande. la recherche dans le dictionnaire reste dans le m\u00eame ordre de grandeur ( \\(10^{-7}\\) secondes). On remarque donc que le temps moyen de recherche dans un dictionnaire est remarquablement constant . Il ne d\u00e9pend pas du nombre d'\u00e9l\u00e9ments du dictionnaire dans lequel on cherche. On dit qu'il est en \\(O(1)\\) . 1.3 Conclusion \u2693\ufe0e Temps de recherche Il y a donc une diff\u00e9rence fondamentale \u00e0 conna\u00eetre entre les temps de recherche d'un \u00e9l\u00e9ment \u00e0 l'int\u00e9rieur : d'une liste : temps proportionnel \u00e0 la taille de la liste (ordre de complexit\u00e9 lin\u00e9aire, \\(O(n)\\) ) d'un dictionnaire : temps constant , ind\u00e9pendant de la taille du dictionnaire (ordre de complexit\u00e9 constant, \\(O(1)\\) ) Attention : en ce qui concerne les temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment, la structure de tableau dynamique des listes de Python fait que ce temps d'acc\u00e8s est aussi en temps constant (comme pour les dictionnaires). On voit alors que les listes Python ne sont pas des listes cha\u00een\u00e9es , o\u00f9 le temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment est directement proportionnel \u00e0 la position de cet \u00e9l\u00e9ment dans la liste. 1.4 One more thing... \u2693\ufe0e Int\u00e9ressons-nous maintenant \u00e0 ce qui semble \u00eatre un peu trop miraculeux : une recherche en temps constant, quelque soit la taille du dictionnaire ? Mesurons cette fois non pas la recherche dans le dictionnaire, mais la cr\u00e9ation de celui-ci : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def mesures ( nb ): tps_total = 0 for _ in range ( 10 ): t0 = time . time () lst = fabrique_liste ( nb ) delta_t = time . time () - t0 tps_total += delta_t tps_moyen_lst = tps_total / 10 tps_total = 0 for _ in range ( 10 ): t0 = time . time () d = fabrique_dict ( nb ) delta_t = time . time () - t0 tps_total += delta_t tps_moyen_d = tps_total / 10 print ( f \"temps pour liste de taille { nb } : { tps_moyen_lst } \" ) print ( f \"temps pour un dictionnaire de taille { nb } : { tps_moyen_d } \" ) \ud83d\udc0d Console Python >>> mesures ( 10 ** 5 ) temps pour liste de taille 100000 : 0.004771041870117188 temps pour un dictionnaire de taille 100000 : 0.012260651588439942 >>> mesures ( 10 ** 6 ) temps pour liste de taille 1000000 : 0.04549875259399414 temps pour un dictionnaire de taille 1000000 : 0.14215753078460694 >>> mesures ( 10 ** 7 ) temps pour liste de taille 10000000 : 0.4727184295654297 temps pour un dictionnaire de taille 10000000 : 1.302360200881958 La cr\u00e9ation des deux structures semble de complexit\u00e9 lin\u00e9aire, mais elle est surtout bien plus grande pour un dictionnaire que pour une liste... Pourquoi ? Parce que pour b\u00e9n\u00e9ficier plus tard d'une recherche en temps constant, la cr\u00e9ation du dictionnaire demande beaucoup de calculs... Petit d\u00e9tour par les fonctions de hachage : 2. Fonctions de hachage (hors-programme) \u2693\ufe0e Tout ce qui suit est hors-programme de Terminale, mais permet de comprendre comment Python arrive \u00e0 faire de la recherche en temps constant quelle que soit la taille du dictionnaire. Il est important de se rappeler qu'un dictionnaire n'est pas ordonn\u00e9 (contrairement \u00e0 l'objet \u00abdictionnaire\u00bb de la vie courante, o\u00f9 chaque mot est class\u00e9 suivant l'ordre alphab\u00e9tique). On n'acc\u00e8de pas \u00e0 une valeur suivant sa position, mais suivant sa cl\u00e9. Dans une liste, lorsqu'on veut savoir si un \u00e9l\u00e9ment appartient \u00e0 une liste (probl\u00e8me de la recherche d'\u00e9l\u00e9ment ), il n'y a pas (dans le cas g\u00e9n\u00e9ral) de meilleure m\u00e9thode que le parcours exhaustif de tous les \u00e9l\u00e9ments de la liste jusqu'\u00e0 (\u00e9ventuellement) trouver la valeur cherch\u00e9e. Dans un dictionnaire, on pourrait s'imaginer qu'il va falloir parcourir toutes les cl\u00e9s et regarder les valeurs correspondantes. Il n'en est rien. Pour comprendre cela nous allons faire un petit d\u00e9tour par les fonctions de hachage. 2.1 V\u00e9rification de l'int\u00e9grit\u00e9 \u2693\ufe0e Lorsque vous t\u00e9l\u00e9chargez un fichier important et que vous souhaitez v\u00e9rifier qu'il n'a pas \u00e9t\u00e9 corrompu lors du t\u00e9l\u00e9chargement (ou avant), vous avez parfois la possibilit\u00e9 de v\u00e9rifier l'int\u00e9grit\u00e9 de votre fichier t\u00e9l\u00e9charg\u00e9, en calculant une \u00abempreinte\u00bb de votre fichier et en la comparant avec celle que vous \u00eates cens\u00e9e obtenir : Voil\u00e0 par exemple ce qui appara\u00eet sur la page de t\u00e9l\u00e9chargement d'une iso d'ubuntu 18.04 : La cl\u00e9 MD5 propos\u00e9e pour chaque fichier est le r\u00e9sultat ce que doit donner le fichier (ici une iso d'environ 1,9 Go) lorsqu'il est \u00abhach\u00e9\u00bb par la fonction MD5. Dans notre cas, si nous t\u00e9l\u00e9chargeons ubuntu-18.04.3-desktop-amd64.iso , nous devons calculer l'empreinte du fichier t\u00e9l\u00e9charg\u00e9 et v\u00e9rifier que nous obtenons bien 72491db7ef6f3cd4b085b9fe1f232345 : Voici ce que l'on obtient si l'on utilise un Terminal: La cl\u00e9 calcul\u00e9e sur l'ordinateur correspond bien \u00e0 celle indiqu\u00e9e sur le site de t\u00e9l\u00e9chargement : le fichier est int\u00e8gre. Exemple T\u00e9l\u00e9chargez le fichier banniere.png et si vous disposez d'un Terminal, calculez son empreinte MD5 : \ud83d\udccb Texte eleve@linux:~/ md5sum banniere.png 2895bae45eb0ab36a2a8324c0208ad95 banniere.png On pourra aussi utiliser un outil en ligne sur le fabuleux site https://gchq.github.io/CyberChef du GHCQ Si votre fichier banniere.png a \u00e9t\u00e9 convenablement t\u00e9l\u00e9charg\u00e9, votre empreinte devra \u00eatre \u00e9gale \u00e0 2895bae45eb0ab36a2a8324c0208ad95 . 2.2 M\u00e9canisme de la fonction de hachage \u2693\ufe0e Quelle que soit la taille du fichier donn\u00e9 en entr\u00e9e, la fonction MD5 va le r\u00e9duire \u00e0 un mot de 128 bits. Ce mot binaire de 128 bits est repr\u00e9sent\u00e9 par une cha\u00eene de 32 caract\u00e8res (en hexad\u00e9cimal, de 0 \u00e0 f). Il y a donc \\(2^{128}\\) (de l'ordre de \\(10^{39}\\) ) empreintes MD5 diff\u00e9rentes, ce qui rend quasiment impossible le fait d'avoir un mauvais fichier qui donnerait (par un tr\u00e8s tr\u00e8s mauvais hasard) la bonne empreinte. Le m\u00e9canisme effectif de calcul de la fonction MD5 est tr\u00e8s complexe : une explication en est donn\u00e9e ici . Il est \u00e9videmment impossible de revenir en arri\u00e8re et de recr\u00e9er le fichier original \u00e0 partir de l'empreinte MD5. Dans le cas contraire, cela voudrait dire qu'on est capable de compresser sans perte un fichier de 1,9 Go en une cha\u00eene de 128 bits. Cette impossibilit\u00e9 de trouver une fonction r\u00e9ciproque \u00e0 la fonction de hachage est tr\u00e8s importante en cryptographie. En effet, les simples cha\u00eenes de caract\u00e8res peuvent aussi \u00eatre transform\u00e9es par une fonction de hachage : Quel est l'int\u00e9r\u00eat de hacher une cha\u00eene de caract\u00e8re ? La conservation des mots de passe !!! 2.3 Le stockage des mots de passe \u2693\ufe0e Les sites qui n\u00e9cessitent une authentification par login / mot de passe ne conservent pas en clair les mots de passe sur leur serveur. La moindre compromission de leur serveur serait en effet dramatique. Ce qui est conserv\u00e9 est l'empreinte du mot de passe apr\u00e8s son passage par une fonction de hachage. Par exemple, un site o\u00f9 notre mot de passe serait vive la NSI conserverait dans ses bases de donn\u00e9es l'empreinte e74fb2f94c052bbf16cea4a795145e35 . \u00c0 chaque saisie du mot de passe c\u00f4t\u00e9 client, l'empreinte est recalcul\u00e9e (c\u00f4t\u00e9 serveur), puis compar\u00e9e avec l'empreinte stock\u00e9e. Lors du transit du mot de passe, le chiffrement effectu\u00e9 par le protocole https assure la protection en cas d'interception. De cette fa\u00e7on, si le serveur est compromis, la non-r\u00e9versibilit\u00e9 de la fonction de hachage assure que le mot de passe ne peut pas \u00eatre retrouv\u00e9 par les attaquants. 2.4 La non-r\u00e9versibilit\u00e9 de la fonction de hachage (vraiment ?) \u2693\ufe0e Prenons l'empreinte MD5 bdc87b9c894da5168059e00ebffb9077 et allons fureter du c\u00f4t\u00e9 de (par exemple) https://md5.gromweb.com/ Notre empreinte ne r\u00e9siste pas bien longtemps... Re-essayons alors avec l'empreinte e74fb2f94c052bbf16cea4a795145e35 . Les empreintes des mots de passe les plus fr\u00e9quents sont stock\u00e9es dans des tables (qu'on appelle rainbow tables ou tables arc-en-ciel ) qui rendent possibles le d\u00e9chiffrage de ces empreintes. Pour contrer cela, les cryptographes rajoutent des caract\u00e8res avant hachage (le sel ), et choisissent surtout des bonnes fonctions de hachage. MD5 et SHA-1 ne sont plus utilis\u00e9es, on pr\u00e9f\u00e8re maintenant SHA-256 (voir ici ). 3. Retour aux dictionnaires \u2693\ufe0e Quel est le lien entre les fonctions de hachage et les dictionnaires ??? L'id\u00e9e essentielle est que chaque cl\u00e9 est hach\u00e9e pour donner une empreinte unique, qui est ensuite transform\u00e9e en un indice de positionnement dans un tableau. Le dictionnaire : \ud83d\udc0d Script Python d = { \"pommes\" : 3 , \"poires\" : 0 , \"bananes\" : 5 } serait donc par exemple impl\u00e9ment\u00e9 dans un tableau comme celui-ci : On peut remarquer que ce tableau laisse beaucoup de cases vides. Si je souhaite ensuite acc\u00e9der \u00e0 l'\u00e9l\u00e9ment d[\"kiwis\"] : le hash de la cha\u00eene \"kiwis\" est calcul\u00e9. Par exemple, 4512d2202 . l'indice de la position (\u00e9ventuelle) de la cl\u00e9 \"kiwis\" dans mon dictionnaire est calcul\u00e9 \u00e0 partir de ce hash 4512d2202 . Dans notre exemple, cela pourrait donner l'indice 3. Python acc\u00e8de directement \u00e0 cet indice du tableau : si la valeur de la cl\u00e9 sur cette ligne du tableau est None, cela signifie que \"kiwis\" n'est pas une cl\u00e9 existante du tableau. C'est notre cas ici car il n'y a rien \u00e0 la ligne 3. si la valeur de la cl\u00e9 sur cette ligne du tableau est bien \"kiwis\" , la valeur correspondante est renvoy\u00e9e. En r\u00e9sum\u00e9, Python sait toujours o\u00f9 aller chercher un \u00e9l\u00e9ment de son dictionnaire : soit il le trouve \u00e0 l'endroit calcul\u00e9, soit il n'y a rien \u00e0 cet endroit calcul\u00e9, ce qui veut dire que l'\u00e9l\u00e9ment ne fait pas partie du dictionnaire. Par ce m\u00e9canisme, l'acc\u00e8s \u00e0 un \u00e9l\u00e9ment du dictionnaire se fait toujours en temps constant . Il existe une mani\u00e8re de \u00abvoir\u00bb que Python utilise une fonction de hachage pour impl\u00e9menter un dictionnaire : \ud83d\udc0d Script Python mondico = {} # un nombre peut-il \u00eatre une cl\u00e9? mondico [ 4 ] = \"foo\" # une cha\u00eene de caract\u00e8res peut-elle \u00eatre une cl\u00e9 ? mondico [ \"riri\" ] = \"fifi\" # une liste peut-elle \u00eatre une cl\u00e9 ? mondico [[ 2 , 5 ]] = \"loulou\" \ud83d\udccb Texte --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-1-585560b5c422> in <module> 8 9 # une liste peut-elle \u00eatre une cl\u00e9 ? - 10 mondico[[2,5]] = \"loulou\" TypeError: unhashable type: 'list' Le message d'erreur est explicite : le type list que nous avons voulu utiliser comme cl\u00e9 n'est pas hachable, car c'est un type d'objet pouvant \u00eatre modifi\u00e9 a posteriori tout en gardant la m\u00eame r\u00e9f\u00e9rence (on dit que c'est un objet mutable ): \ud83d\udc0d Script Python a = [ 3 , 6 , 8 ] print ( id ( a )) a . append ( 12 ) print ( id ( a )) \ud83d\udccb Texte 139646950377032 139646950377032 Ce changement de valeur tout en gardant la m\u00eame r\u00e9f\u00e9rence d\u00e9truirait le principe associant \u00e0 une cl\u00e9 unique une position unique dans le tableau impl\u00e9mentant le dictionnaire. Ce probl\u00e8me ne se pose pas si la variable d\u00e9signe une cha\u00eene de caract\u00e8res, ou un nombre : \ud83d\udc0d Script Python a = 2020 print ( id ( a )) a += 1 print ( id ( a )) \ud83d\udccb Texte 139646916523440 139646916523504 Un variable contenant un entier est donc un objet immuable car si on modifie la valeur de l'entier, la r\u00e9f\u00e9rence de la variable changera aussi. Comme un dictionnaire a besoin d'avoir des cl\u00e9s dont les r\u00e9f\u00e9rences soient d\u00e9finitives, seuls les objets immuables peuvent donc servir de cl\u00e9s dans les dictionnaires.", "title": "Cours"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#dictionnaires", "text": "Pr\u00e9ambule : retour sur le cours de Premi\u00e8re", "title": "Dictionnaires"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#0-notion-de-tableau-associatif", "text": "Un tableau associatif est un type abstrait de donn\u00e9es (au m\u00eame titre que les listes, piles, files, vues pr\u00e9c\u00e9demment). Ce type abstrait de donn\u00e9es a la particularit\u00e9 de ne pas \u00eatre totalement lin\u00e9aire (ou \u00abplat\u00bb) puisqu'il associe des valeurs \u00e0 des cl\u00e9s . Il est habituellement muni des op\u00e9rations suivantes : ajout d'une nouvelle valeur associ\u00e9e \u00e0 une nouvelle cl\u00e9 (on parlera de nouveau couple cl\u00e9-valeur) modification d'une valeur associ\u00e9e \u00e0 une cl\u00e9 existante suppression d'un couple cl\u00e9-valeur r\u00e9cup\u00e9ration de la valeur associ\u00e9e \u00e0 une cl\u00e9 donn\u00e9e. Un r\u00e9pertoire t\u00e9l\u00e9phonique est un exemple de tableau associatif : les cl\u00e9s sont les noms les valeurs sont les num\u00e9ros de t\u00e9l\u00e9phone En Python, le dictionnaire est une structure native de tableau associatif.", "title": "0. Notion de tableau associatif"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#1-dictionnaire-et-temps-dacces-aux-donnees", "text": "", "title": "1. Dictionnaire et temps d'acc\u00e8s aux donn\u00e9es"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#11-protocole-de-mesure", "text": "Le but est de cr\u00e9er une liste et un dictionnaire de m\u00eame taille (arbitraire), et de comparer ensuite le temps de recherche d'un \u00e9l\u00e9ment n'appartenant pas \u00e0 ces deux structures. Q1. Cr\u00e9er une fonction fabrique_liste qui prend en param\u00e8tre un entier nb et qui renvoie une liste compos\u00e9e de tous les entiers de 0 \u00e0 nb-1 . Correction \ud83d\udc0d Script Python def fabrique_liste ( nb ): lst = [ k for k in range ( nb )] return lst Q2. Cr\u00e9er une fonction fabrique_dict qui prend en param\u00e8tre un entier nb et qui renvoie dictionnaire compos\u00e9 de paires qui associent \u00e0 toutes les cl\u00e9s k de 0 \u00e0 nb-1 leur propre valeur k . Correction \ud83d\udc0d Script Python def fabrique_dict ( nb ): dct = { k : k for k in range ( nb )} return dct Q3. Cr\u00e9er une fonction mesures qui prend en param\u00e8tre un entier nb et qui : Cr\u00e9\u00e9 une liste et un dictionnaire de taille nb \u00e0 l'aide des fonctions pr\u00e9c\u00e9dentes. Mesure la recherche d'une valeur inexistante dans la liste, et affiche le temps de recherche. Mesure la recherche d'une valeur inexistante dans le dictionnaire, et affiche le temps de recherche. Cette recherche d'une valeur inexistante s'appelle recherche dans le pire des cas . Comment faire la recherche ? Il est imp\u00e9ratif d'utiliser le mot-cl\u00e9 in propre \u00e0 Python afin de b\u00e9n\u00e9ficier des avantages (ou inconv\u00e9nients) de chacune des deux structures. Si on cherche notre \u00e9l\u00e9ment en parcourant \u00ab\u00e0 la main\u00bb la totalit\u00e9 de la structure, on aura forc\u00e9ment un temps de recherche proportionnel au nombre d'\u00e9l\u00e9ments de la structure (et donc une complexit\u00e9 lin\u00e9aire). En utilisant le mot-cl\u00e9 in , on va laisser Python g\u00e9rer tout seul la recherche. Pour davantage de pr\u00e9cision, on pourra dans un second temps effectuer plusieurs mesures et faire une moyenne des temps obtenus. Pour rappel, l'import du module time permet d'appeler la fonction time.time() . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 import time def fabrique_liste ( nb ): lst = [ k for k in range ( nb )] return lst def fabrique_dict ( nb ): dct = { k : k for k in range ( nb )} return dct def mesures ( nb ): # \u00c0 vous Q4. Effectuer des mesures avec diff\u00e9rentes valeurs de nb .", "title": "1.1 Protocole de mesure"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#12-mesures", "text": "Nous allons effectuer 3 mesures, avec une taille de liste et de dictionnaire augmentant d'un facteur 10 \u00e0 chaque fois. \ud83d\udc0d Console Python >>> mesures ( 10 ** 4 ) temps pour une liste de taille 10000 : 0.00023534297943115235 temps pour un dictionnaire de taille 10000 : 1.6689300537109374e-07 >>> mesures ( 10 ** 5 ) temps pour une liste de taille 100000 : 0.0012505292892456056 temps pour un dictionnaire de taille 100000 : 4.5299530029296873e-07 >>> mesures ( 10 ** 6 ) temps pour une liste de taille 1000000 : 0.012522673606872559 temps pour un dictionnaire de taille 1000000 : 2.384185791015625e-07 la recherche dans une liste prend un ordre de grandeur \u00e0 chaque fois : elle est environ 10 fois plus grande quand la taille de la liste est 10 fois plus grande. la recherche dans le dictionnaire reste dans le m\u00eame ordre de grandeur ( \\(10^{-7}\\) secondes). On remarque donc que le temps moyen de recherche dans un dictionnaire est remarquablement constant . Il ne d\u00e9pend pas du nombre d'\u00e9l\u00e9ments du dictionnaire dans lequel on cherche. On dit qu'il est en \\(O(1)\\) .", "title": "1.2 Mesures"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#13-conclusion", "text": "Temps de recherche Il y a donc une diff\u00e9rence fondamentale \u00e0 conna\u00eetre entre les temps de recherche d'un \u00e9l\u00e9ment \u00e0 l'int\u00e9rieur : d'une liste : temps proportionnel \u00e0 la taille de la liste (ordre de complexit\u00e9 lin\u00e9aire, \\(O(n)\\) ) d'un dictionnaire : temps constant , ind\u00e9pendant de la taille du dictionnaire (ordre de complexit\u00e9 constant, \\(O(1)\\) ) Attention : en ce qui concerne les temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment, la structure de tableau dynamique des listes de Python fait que ce temps d'acc\u00e8s est aussi en temps constant (comme pour les dictionnaires). On voit alors que les listes Python ne sont pas des listes cha\u00een\u00e9es , o\u00f9 le temps d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment est directement proportionnel \u00e0 la position de cet \u00e9l\u00e9ment dans la liste.", "title": "1.3 Conclusion"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#14-one-more-thing", "text": "Int\u00e9ressons-nous maintenant \u00e0 ce qui semble \u00eatre un peu trop miraculeux : une recherche en temps constant, quelque soit la taille du dictionnaire ? Mesurons cette fois non pas la recherche dans le dictionnaire, mais la cr\u00e9ation de celui-ci : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def mesures ( nb ): tps_total = 0 for _ in range ( 10 ): t0 = time . time () lst = fabrique_liste ( nb ) delta_t = time . time () - t0 tps_total += delta_t tps_moyen_lst = tps_total / 10 tps_total = 0 for _ in range ( 10 ): t0 = time . time () d = fabrique_dict ( nb ) delta_t = time . time () - t0 tps_total += delta_t tps_moyen_d = tps_total / 10 print ( f \"temps pour liste de taille { nb } : { tps_moyen_lst } \" ) print ( f \"temps pour un dictionnaire de taille { nb } : { tps_moyen_d } \" ) \ud83d\udc0d Console Python >>> mesures ( 10 ** 5 ) temps pour liste de taille 100000 : 0.004771041870117188 temps pour un dictionnaire de taille 100000 : 0.012260651588439942 >>> mesures ( 10 ** 6 ) temps pour liste de taille 1000000 : 0.04549875259399414 temps pour un dictionnaire de taille 1000000 : 0.14215753078460694 >>> mesures ( 10 ** 7 ) temps pour liste de taille 10000000 : 0.4727184295654297 temps pour un dictionnaire de taille 10000000 : 1.302360200881958 La cr\u00e9ation des deux structures semble de complexit\u00e9 lin\u00e9aire, mais elle est surtout bien plus grande pour un dictionnaire que pour une liste... Pourquoi ? Parce que pour b\u00e9n\u00e9ficier plus tard d'une recherche en temps constant, la cr\u00e9ation du dictionnaire demande beaucoup de calculs... Petit d\u00e9tour par les fonctions de hachage :", "title": "1.4 One more thing..."}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#2-fonctions-de-hachage-hors-programme", "text": "Tout ce qui suit est hors-programme de Terminale, mais permet de comprendre comment Python arrive \u00e0 faire de la recherche en temps constant quelle que soit la taille du dictionnaire. Il est important de se rappeler qu'un dictionnaire n'est pas ordonn\u00e9 (contrairement \u00e0 l'objet \u00abdictionnaire\u00bb de la vie courante, o\u00f9 chaque mot est class\u00e9 suivant l'ordre alphab\u00e9tique). On n'acc\u00e8de pas \u00e0 une valeur suivant sa position, mais suivant sa cl\u00e9. Dans une liste, lorsqu'on veut savoir si un \u00e9l\u00e9ment appartient \u00e0 une liste (probl\u00e8me de la recherche d'\u00e9l\u00e9ment ), il n'y a pas (dans le cas g\u00e9n\u00e9ral) de meilleure m\u00e9thode que le parcours exhaustif de tous les \u00e9l\u00e9ments de la liste jusqu'\u00e0 (\u00e9ventuellement) trouver la valeur cherch\u00e9e. Dans un dictionnaire, on pourrait s'imaginer qu'il va falloir parcourir toutes les cl\u00e9s et regarder les valeurs correspondantes. Il n'en est rien. Pour comprendre cela nous allons faire un petit d\u00e9tour par les fonctions de hachage.", "title": "2. Fonctions de hachage  (hors-programme)"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#21-verification-de-lintegrite", "text": "Lorsque vous t\u00e9l\u00e9chargez un fichier important et que vous souhaitez v\u00e9rifier qu'il n'a pas \u00e9t\u00e9 corrompu lors du t\u00e9l\u00e9chargement (ou avant), vous avez parfois la possibilit\u00e9 de v\u00e9rifier l'int\u00e9grit\u00e9 de votre fichier t\u00e9l\u00e9charg\u00e9, en calculant une \u00abempreinte\u00bb de votre fichier et en la comparant avec celle que vous \u00eates cens\u00e9e obtenir : Voil\u00e0 par exemple ce qui appara\u00eet sur la page de t\u00e9l\u00e9chargement d'une iso d'ubuntu 18.04 : La cl\u00e9 MD5 propos\u00e9e pour chaque fichier est le r\u00e9sultat ce que doit donner le fichier (ici une iso d'environ 1,9 Go) lorsqu'il est \u00abhach\u00e9\u00bb par la fonction MD5. Dans notre cas, si nous t\u00e9l\u00e9chargeons ubuntu-18.04.3-desktop-amd64.iso , nous devons calculer l'empreinte du fichier t\u00e9l\u00e9charg\u00e9 et v\u00e9rifier que nous obtenons bien 72491db7ef6f3cd4b085b9fe1f232345 : Voici ce que l'on obtient si l'on utilise un Terminal: La cl\u00e9 calcul\u00e9e sur l'ordinateur correspond bien \u00e0 celle indiqu\u00e9e sur le site de t\u00e9l\u00e9chargement : le fichier est int\u00e8gre. Exemple T\u00e9l\u00e9chargez le fichier banniere.png et si vous disposez d'un Terminal, calculez son empreinte MD5 : \ud83d\udccb Texte eleve@linux:~/ md5sum banniere.png 2895bae45eb0ab36a2a8324c0208ad95 banniere.png On pourra aussi utiliser un outil en ligne sur le fabuleux site https://gchq.github.io/CyberChef du GHCQ Si votre fichier banniere.png a \u00e9t\u00e9 convenablement t\u00e9l\u00e9charg\u00e9, votre empreinte devra \u00eatre \u00e9gale \u00e0 2895bae45eb0ab36a2a8324c0208ad95 .", "title": "2.1 V\u00e9rification de l'int\u00e9grit\u00e9"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#22-mecanisme-de-la-fonction-de-hachage", "text": "Quelle que soit la taille du fichier donn\u00e9 en entr\u00e9e, la fonction MD5 va le r\u00e9duire \u00e0 un mot de 128 bits. Ce mot binaire de 128 bits est repr\u00e9sent\u00e9 par une cha\u00eene de 32 caract\u00e8res (en hexad\u00e9cimal, de 0 \u00e0 f). Il y a donc \\(2^{128}\\) (de l'ordre de \\(10^{39}\\) ) empreintes MD5 diff\u00e9rentes, ce qui rend quasiment impossible le fait d'avoir un mauvais fichier qui donnerait (par un tr\u00e8s tr\u00e8s mauvais hasard) la bonne empreinte. Le m\u00e9canisme effectif de calcul de la fonction MD5 est tr\u00e8s complexe : une explication en est donn\u00e9e ici . Il est \u00e9videmment impossible de revenir en arri\u00e8re et de recr\u00e9er le fichier original \u00e0 partir de l'empreinte MD5. Dans le cas contraire, cela voudrait dire qu'on est capable de compresser sans perte un fichier de 1,9 Go en une cha\u00eene de 128 bits. Cette impossibilit\u00e9 de trouver une fonction r\u00e9ciproque \u00e0 la fonction de hachage est tr\u00e8s importante en cryptographie. En effet, les simples cha\u00eenes de caract\u00e8res peuvent aussi \u00eatre transform\u00e9es par une fonction de hachage : Quel est l'int\u00e9r\u00eat de hacher une cha\u00eene de caract\u00e8re ? La conservation des mots de passe !!!", "title": "2.2 M\u00e9canisme de la fonction de hachage"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#23-le-stockage-des-mots-de-passe", "text": "Les sites qui n\u00e9cessitent une authentification par login / mot de passe ne conservent pas en clair les mots de passe sur leur serveur. La moindre compromission de leur serveur serait en effet dramatique. Ce qui est conserv\u00e9 est l'empreinte du mot de passe apr\u00e8s son passage par une fonction de hachage. Par exemple, un site o\u00f9 notre mot de passe serait vive la NSI conserverait dans ses bases de donn\u00e9es l'empreinte e74fb2f94c052bbf16cea4a795145e35 . \u00c0 chaque saisie du mot de passe c\u00f4t\u00e9 client, l'empreinte est recalcul\u00e9e (c\u00f4t\u00e9 serveur), puis compar\u00e9e avec l'empreinte stock\u00e9e. Lors du transit du mot de passe, le chiffrement effectu\u00e9 par le protocole https assure la protection en cas d'interception. De cette fa\u00e7on, si le serveur est compromis, la non-r\u00e9versibilit\u00e9 de la fonction de hachage assure que le mot de passe ne peut pas \u00eatre retrouv\u00e9 par les attaquants.", "title": "2.3 Le stockage des mots de passe"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#24-la-non-reversibilite-de-la-fonction-de-hachage-vraiment", "text": "Prenons l'empreinte MD5 bdc87b9c894da5168059e00ebffb9077 et allons fureter du c\u00f4t\u00e9 de (par exemple) https://md5.gromweb.com/ Notre empreinte ne r\u00e9siste pas bien longtemps... Re-essayons alors avec l'empreinte e74fb2f94c052bbf16cea4a795145e35 . Les empreintes des mots de passe les plus fr\u00e9quents sont stock\u00e9es dans des tables (qu'on appelle rainbow tables ou tables arc-en-ciel ) qui rendent possibles le d\u00e9chiffrage de ces empreintes. Pour contrer cela, les cryptographes rajoutent des caract\u00e8res avant hachage (le sel ), et choisissent surtout des bonnes fonctions de hachage. MD5 et SHA-1 ne sont plus utilis\u00e9es, on pr\u00e9f\u00e8re maintenant SHA-256 (voir ici ).", "title": "2.4 La non-r\u00e9versibilit\u00e9 de la fonction de hachage  (vraiment ?)"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/cours/#3-retour-aux-dictionnaires", "text": "Quel est le lien entre les fonctions de hachage et les dictionnaires ??? L'id\u00e9e essentielle est que chaque cl\u00e9 est hach\u00e9e pour donner une empreinte unique, qui est ensuite transform\u00e9e en un indice de positionnement dans un tableau. Le dictionnaire : \ud83d\udc0d Script Python d = { \"pommes\" : 3 , \"poires\" : 0 , \"bananes\" : 5 } serait donc par exemple impl\u00e9ment\u00e9 dans un tableau comme celui-ci : On peut remarquer que ce tableau laisse beaucoup de cases vides. Si je souhaite ensuite acc\u00e9der \u00e0 l'\u00e9l\u00e9ment d[\"kiwis\"] : le hash de la cha\u00eene \"kiwis\" est calcul\u00e9. Par exemple, 4512d2202 . l'indice de la position (\u00e9ventuelle) de la cl\u00e9 \"kiwis\" dans mon dictionnaire est calcul\u00e9 \u00e0 partir de ce hash 4512d2202 . Dans notre exemple, cela pourrait donner l'indice 3. Python acc\u00e8de directement \u00e0 cet indice du tableau : si la valeur de la cl\u00e9 sur cette ligne du tableau est None, cela signifie que \"kiwis\" n'est pas une cl\u00e9 existante du tableau. C'est notre cas ici car il n'y a rien \u00e0 la ligne 3. si la valeur de la cl\u00e9 sur cette ligne du tableau est bien \"kiwis\" , la valeur correspondante est renvoy\u00e9e. En r\u00e9sum\u00e9, Python sait toujours o\u00f9 aller chercher un \u00e9l\u00e9ment de son dictionnaire : soit il le trouve \u00e0 l'endroit calcul\u00e9, soit il n'y a rien \u00e0 cet endroit calcul\u00e9, ce qui veut dire que l'\u00e9l\u00e9ment ne fait pas partie du dictionnaire. Par ce m\u00e9canisme, l'acc\u00e8s \u00e0 un \u00e9l\u00e9ment du dictionnaire se fait toujours en temps constant . Il existe une mani\u00e8re de \u00abvoir\u00bb que Python utilise une fonction de hachage pour impl\u00e9menter un dictionnaire : \ud83d\udc0d Script Python mondico = {} # un nombre peut-il \u00eatre une cl\u00e9? mondico [ 4 ] = \"foo\" # une cha\u00eene de caract\u00e8res peut-elle \u00eatre une cl\u00e9 ? mondico [ \"riri\" ] = \"fifi\" # une liste peut-elle \u00eatre une cl\u00e9 ? mondico [[ 2 , 5 ]] = \"loulou\" \ud83d\udccb Texte --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-1-585560b5c422> in <module> 8 9 # une liste peut-elle \u00eatre une cl\u00e9 ? - 10 mondico[[2,5]] = \"loulou\" TypeError: unhashable type: 'list' Le message d'erreur est explicite : le type list que nous avons voulu utiliser comme cl\u00e9 n'est pas hachable, car c'est un type d'objet pouvant \u00eatre modifi\u00e9 a posteriori tout en gardant la m\u00eame r\u00e9f\u00e9rence (on dit que c'est un objet mutable ): \ud83d\udc0d Script Python a = [ 3 , 6 , 8 ] print ( id ( a )) a . append ( 12 ) print ( id ( a )) \ud83d\udccb Texte 139646950377032 139646950377032 Ce changement de valeur tout en gardant la m\u00eame r\u00e9f\u00e9rence d\u00e9truirait le principe associant \u00e0 une cl\u00e9 unique une position unique dans le tableau impl\u00e9mentant le dictionnaire. Ce probl\u00e8me ne se pose pas si la variable d\u00e9signe une cha\u00eene de caract\u00e8res, ou un nombre : \ud83d\udc0d Script Python a = 2020 print ( id ( a )) a += 1 print ( id ( a )) \ud83d\udccb Texte 139646916523440 139646916523504 Un variable contenant un entier est donc un objet immuable car si on modifie la valeur de l'entier, la r\u00e9f\u00e9rence de la variable changera aussi. Comme un dictionnaire a besoin d'avoir des cl\u00e9s dont les r\u00e9f\u00e9rences soient d\u00e9finitives, seuls les objets immuables peuvent donc servir de cl\u00e9s dans les dictionnaires.", "title": "3. Retour aux dictionnaires"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/exercices/", "text": "Exercices sur les dictionnaires \u2693\ufe0e Exercice 1 : cr\u00e9ation d'une rainbow table Cr\u00e9er une fonction inverse_md5() qui va chercher dans un dictionnaire (construit pr\u00e9alablement) le mot correspondant au hash donn\u00e9 en param\u00e8tre. \u00c0 quel mot de passe correspond le hash 33da7a40473c1637f1a2e142f4925194 ? Exemple : \ud83d\udccb Texte >>> inverse_md5('0571749e2ac330a7455809c6b0e7af90') >>> 'sunshine' Aide : liste de 1000 mots de passe fr\u00e9quents : ici comment lire / convertir le contenu d'un fichier dans une liste de string : \ud83d\udc0d Script Python lst = open ( \"monfichier.txt\" ) . read () . splitlines () comment calculer du MD5 en Python : \ud83d\udc0d Script Python import hashlib result = hashlib . md5 ( 'azerty' . encode ()) print ( result . hexdigest ()) Exercice 2 Exercice 2 du sujet Centres Etrangers J1 2021", "title": "Exercice"}, {"location": "T1_Structures_de_donnees/1.2_Dictionnaires/exercices/#exercices-sur-les-dictionnaires", "text": "Exercice 1 : cr\u00e9ation d'une rainbow table Cr\u00e9er une fonction inverse_md5() qui va chercher dans un dictionnaire (construit pr\u00e9alablement) le mot correspondant au hash donn\u00e9 en param\u00e8tre. \u00c0 quel mot de passe correspond le hash 33da7a40473c1637f1a2e142f4925194 ? Exemple : \ud83d\udccb Texte >>> inverse_md5('0571749e2ac330a7455809c6b0e7af90') >>> 'sunshine' Aide : liste de 1000 mots de passe fr\u00e9quents : ici comment lire / convertir le contenu d'un fichier dans une liste de string : \ud83d\udc0d Script Python lst = open ( \"monfichier.txt\" ) . read () . splitlines () comment calculer du MD5 en Python : \ud83d\udc0d Script Python import hashlib result = hashlib . md5 ( 'azerty' . encode ()) print ( result . hexdigest ()) Exercice 2 Exercice 2 du sujet Centres Etrangers J1 2021", "title": "Exercices sur les dictionnaires"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/", "text": "Arbres \u2693\ufe0e 1. Terminologie \u2693\ufe0e 1.1 Vocabulaire \u2693\ufe0e Un arbre est une structure hi\u00e9rarchique de donn\u00e9es, compos\u00e9e de n\u0153uds. Si on adopte le vocabulaire des graphes, un arbre est un graphe non orient\u00e9, connexe, sans cycle, et dans lequel un n\u0153ud joue le r\u00f4le de racine. Chaque n\u0153ud a exactement un seul n\u0153ud p\u00e8re , \u00e0 l'exception du n\u0153ud racine qui est le seul n\u0153ud \u00e0 ne pas avoir de p\u00e8re. (oui, la racine d'une arbre est en haut ) Chaque n\u0153ud peut avoir un nombre quelconque de fils , dont il est le p\u00e8re. Les n\u0153uds qui n'ont pas de fils sont appel\u00e9s les feuilles (ou n\u0153uds externes). Les n\u0153uds qui ne sont pas des feuilles sont des n\u0153uds internes . Le nom de chaque n\u0153ud est appel\u00e9 son \u00e9tiquette . Exemples : dans l'arbre ci-dessus, C est la racine, E, Z A et G sont les feuilles. K est le p\u00e8re de A et G. F est le p\u00e8re de Z. C est le p\u00e8re de B et K B est le p\u00e8re de E et F. 1.2 Exemples d'arbres \u2693\ufe0e 1.2.1 La famille royale britannique (avant le 08 septembre 2022) \u2693\ufe0e Redessinez de mani\u00e8re plus sch\u00e9matique cet arbre. Pour quelle raison cet arbre a-t-il \u00e9t\u00e9 modifi\u00e9 par rapport \u00e0 sa version orginale (voir ici ), qui laissait appara\u00eetre les parents de chaque enfant ? 1.2.2 Un arbre en LaTeX \u2693\ufe0e Ex\u00e9cuter le code suivant dans Overleaf apr\u00e8s avoir choisi Compiler: XeLaTeX dans le menu. TeX \\documentclass [12pt] { article } \\usepackage [a4paper, margin=3cm] { geometry } \\usepackage { fontspec } \\usepackage [french] { babel } \\usepackage { hyperref } \\usepackage { tikz } \\usetikzlibrary { shapes } \\usetikzlibrary { arrows.meta,automata,positioning,shadows } \\setmainfont { Times New Roman } %\\setmainfont{OpenDyslexic} \\title { Arbres } \\date { \\today } \\author {} \\begin { document } \\maketitle \\paragraph { source: } \\url { https://tikz.dev/tikz-trees } \\paragraph { Exemple d'arbre } \\begin { center } \\begin { tikzpicture } [ every node/.style= { draw,circle,inner sep=2pt } ] \\node { racine } child { node { G1 }} child { node { D1 } child[missing] { node {}} child { node { D2 }} } ; \\end { tikzpicture } \\end { center } \\end { document } 1.2.3 Le DOM d'une page web \u2693\ufe0e DOM : Document Object Model 1.2.4 L'arborescence d'un disque dur \u2693\ufe0e Les syst\u00e8mes Unix (MacOS ou GNU/Linux) organisent leur disque dur suivant l'arborescence ci-dessous : Exercice 1 Quelque part \u00e0 l'int\u00e9rieur des dossiers contenus dans l'archive dossiers.zip se trouve un fichier tresor.txt . Quel secret renferme-t-il ? Attention, cette recherche est \u00e0 faire uniquement en ligne de commande : ls : pour lister les dossiers et fichiers d'un r\u00e9pertoire cd Dossier : pour se rendre dans le rep\u00e9rtoire Dossier cd .. : pour remonter d'un niveau dans l'arborescence unzip monarchive.zip : pour d\u00e9compresser une archive tree : pour afficher l'arborescence du r\u00e9pertoire courant sudo apt install monprog : pour installer le programme monprog si celui-ci est manquant. 1.3 Caract\u00e9ristiques d'un arbre \u2693\ufe0e 1.3.1 Outils num\u00e9riques de description \u2693\ufe0e D\u00e9finitions la taille d'un arbre est son nombre total de n\u0153uds. Ici, elle vaut 8. l' arit\u00e9 d'un n\u0153ud est son nombre de fils. Ici, l'arit\u00e9 de B vaut 2, celle de F vaut 1, celle de Z vaut 0. la profondeur d'un n\u0153ud est le nombre de n\u0153uds de son chemin le plus court vers la racine. Ici, la profondeur de G est 3 (G-K-C), la profondeur de B est 2 (B-C), la profondeur de Z est 4 (Z-F-B-C), la profondeur de C est 1. la hauteur d'un arbre est la profondeur de son n\u0153ud le plus profond. Ici, la hauteur de l'arbre est 4. Nous prendrons comme convention que : si un arbre est r\u00e9duit \u00e0 un seul n\u0153ud-racine , sa hauteur sera 1 . si un arbre est vide , sa hauteur est 0 . Cette convention est celle adopt\u00e9e dans le sujet 0 publi\u00e9 le 15/12/2020. Attention, dans certains ouvrages, l'arbre vide a pour hauteur -1, et donc l'arbre r\u00e9duit \u00e0 un seul n\u0153ud a pour hauteur 0, donc notre arbre aurait avec cette convention une hauteur 3. 1.4 Arbres binaires \u2693\ufe0e D\u00e9finition Un arbre binaire est un arbre dont chaque n\u0153ud poss\u00e8de au plus deux fils. L'arbre g\u00e9n\u00e9alogique de la famille royale britannique n'est pas un arbre binaire. L'arbre ci-dessous est lui un arbre binaire. 1.4.1 Sous-arbres d'un arbre binaire \u2693\ufe0e Chaque n\u0153ud d'un arbre binaire ne pouvant pas avoir plus de 2 fils, il est possible de s\u00e9parer le \u00abdessous\u00bb de chaque n\u0153ud en deux sous-arbres (\u00e9ventuellement vides) : le sous-arbre gauche et le sous-arbre droit . Les deux sous-arbres repr\u00e9sent\u00e9s ici sont les sous-arbres du n\u0153ud-racine T. Le n\u0153ud O admet comme sous-arbre gauche le n\u0153ud H et comme sous-arbre droit le n\u0153ud N. Les feuilles P, H et N ont pour sous-arbre gauche et pour sous-arbre droit l' arbre vide . 1.4.3 Cas des arbres binaires complets \u2693\ufe0e On rencontre tr\u00e8s souvent des arbres binaires dits complets parce qu'aucun des fils gauche ou droit n'est manquant. Taille d'un arbre complet de hauteur \\(h\\) : \\(1 + 2 + 2^2 + 2^3 + \\dots + 2^{h-1} = 2^{h} - 1\\) preuve : ceci est la somme \\(S\\) des \\(h\\) premiers termes d'une suite g\u00e9om\u00e9trique de raison 2 et de premier terme 1, d'o\u00f9 \\(S= \\frac{1-2^{h}}{1-2} = 2^{h} -1\\) . Un arbre complet de hauteur \\(h\\) (en prenant la convention que l'arbre vide a pour hauteur 0) a donc une taille \u00e9gale \u00e0 \\(2^{h}-1\\) . Remarque : On en d\u00e9duit une in\u00e9galit\u00e9 classique sur l'encadrement de la taille \\(t\\) d'un arbre binaire (non n\u00e9cessairement complet) de hauteur \\(h\\) : \\[h \\leqslant t \\leqslant 2^{h}-1\\] 2. Parcours d'arbres \u2693\ufe0e Les arbres \u00e9tant une structure hi\u00e9rarchique, leur utilisation implique la n\u00e9cessit\u00e9 d'un parcours des valeurs stock\u00e9es. Par exemple pour toutes les r\u00e9cup\u00e9rer dans un certain ordre, ou bien pour en chercher une en particulier. Il existe plusieurs mani\u00e8res de parcourir un arbre. 2.1 Parcours en largeur d'abord (BFS) \u2693\ufe0e BFS : Breadth First Search M\u00e9thode du parcours en largeur (BFS) Le parcours en largeur d'abord est un parcours \u00e9tage par \u00e9tage (de haut en bas) et de gauche \u00e0 droite. L'ordre des lettres parcourues est donc T-Y-O-P-H-N. Les trois parcours que nous allons voir maintenant sont des parcours en profondeur d'abord , ou DFS ( Depth First Search ). Ce qui signifie qu'un des deux sous-arbres sera totalement parcouru avant que l'exploration du deuxi\u00e8me ne commence. 2.2 Parcours pr\u00e9fixe \u2693\ufe0e Le parcours pr\u00e9fixe est un parcours en profondeur d'abord . M\u00e9thode du parcours pr\u00e9fixe (parfois aussi appel\u00e9 pr\u00e9ordre ) Chaque n\u0153ud est visit\u00e9 avant que ses fils le soient. On part de la racine, puis on visite son fils gauche (et \u00e9ventuellement le fils gauche de celui-ci, etc.) avant de remonter et de redescendre vers le fils droit. L'ordre des lettres parcourues est donc T-Y-P-O-H-N. 2.3 Parcours infixe \u2693\ufe0e Le parcours infixe est aussi un parcours en profondeur d'abord. M\u00e9thode du parcours infixe (parfois aussi appel\u00e9 en ordre ) Chaque n\u0153ud est visit\u00e9 apr\u00e8s son fils gauche mais avant son fils droit . On part donc de la feuille la plus \u00e0 gauche et on remonte par vagues sucessives. Un n\u0153ud ne peut pas \u00eatre visit\u00e9 si son fils gauche ne l'a pas \u00e9t\u00e9. L'ordre des lettres parcourues est donc P-Y-T-H-O-N. 2.4 Parcours postfixe \u2693\ufe0e Le parcours postfixe est aussi un parcours en profondeur d'abord. M\u00e9thode du parcours postfixe (parfois aussi appel\u00e9 post-ordre ou encore suffixe ) Chaque n\u0153ud est visit\u00e9 apr\u00e8s ses fils le soient. On part donc de la feuille la plus \u00e0 gauche, et on ne remonte \u00e0 un n\u0153ud p\u00e8re que si ses fils ont tous \u00e9t\u00e9 visit\u00e9s. L'ordre des lettres parcourues est donc P-Y-H-N-O-T. 2.5 Comment ne pas se m\u00e9langer entre le pr\u00e9 / in / post fixe ? \u2693\ufe0e pr\u00e9 veut dire avant in veut dire au milieu post veut dire apr\u00e8s Ces trois mots-cl\u00e9s parlent de la place du p\u00e8re par rapport \u00e0 ses fils. Ensuite, il faut toujours se souvenir qu'on traite le fils gauche avant le fils droit. pr\u00e9fixe : le p\u00e8re doit \u00eatre le premier par rapport \u00e0 ses fils. infixe : le p\u00e8re doit \u00eatre entre son fils gauche (trait\u00e9 en premier) et son fils droit. postfixe : le p\u00e8re ne doit \u00eatre trait\u00e9 que quand ses deux fils (gauche d'abord, droite ensuite) l'ont \u00e9t\u00e9. Un parcours pr\u00e9fixe commencera toujours par la racine, alors qu'un parcours postfixe finira toujours par la racine. Dans un parcours infixe, la racine sera \u00abau milieu\u00bb (pas n\u00e9cessairement parfaitement). Exercice 2 \u00c9nonc\u00e9 Corr. largeur Corr. pr\u00e9fixe Corr. infixe Corr. postfixe Donner le rendu de chaque parcours : Parcours en largeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe largeur : 1 2 3 4 5 6 7 8 9 pr\u00e9fixe : 1 2 4 5 7 8 3 6 9 infixe : 4 2 7 5 8 1 3 9 6 postfixe : 4 7 8 5 2 9 6 3 1 Exercice 3 \u00c9nonc\u00e9 Corr. largeur Corr. pr\u00e9fixe Corr. infixe Corr. postfixe Donner le rendu de chaque parcours : Parcours en largeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe 3. Impl\u00e9mentations d'un arbre binaire \u2693\ufe0e 3.1 En utilisant la Programmation Orient\u00e9e Objet \u2693\ufe0e Le but est d'obtenir l'interface ci-dessous. Il est \u00e0 remarquer que ce que nous allons appeler \u00abArbre\u00bb est en fait un n\u0153ud et ses deux fils gauche et droit. interface souhait\u00e9e \ud83d\udc0d Script Python >>> a = Arbre ( 4 ) # pour cr\u00e9er l'arbre dont le n\u0153ud a pour valeur 4, # et dont les sous-arbres gauche et droit sont None >>> a . left = Arbre ( 3 ) # pour donner la valeur 3 au n\u0153ud du sous-arbre gauche de a >>> a . right = Arbre ( 1 ) # pour donner la valeur 1 au n\u0153ud du sous-arbre droit de a >>> a . right . data # pour acc\u00e9der \u00e0 la valeur du fils droit de a Exercice 4 \u00c9nonc\u00e9 Correction Dessinez l'arbre cr\u00e9\u00e9 par les instructions suivantes : \ud83d\udc0d Script Python >>> a = Arbre ( 4 ) >>> a . left = Arbre ( 3 ) >>> a . right = Arbre ( 1 ) >>> a . right . left = Arbre ( 2 ) >>> a . right . right = Arbre ( 7 ) >>> a . left . left = Arbre ( 6 ) >>> a . right . right . left = Arbre ( 9 ) Impl\u00e9mentation \u2bc8 Principe : nous allons cr\u00e9er une classe Arbre , qui contiendra 3 attributs : data : la valeur du n\u0153ud (de type Int ) left : le sous-arbre gauche (de type Arbre ) right : le sous-arbre droit (de type Arbre ). Par d\u00e9faut, les attributs left et right seront \u00e0 None , qui repr\u00e9sentera l'arbre vide (ce qui n'est pas tr\u00e8s rigoureux, car None n'est pas de type Arbre ...). \u2bc8 Encapsulation ou pas ??? : Afin de respecter le paradigme de la Programmation Orient\u00e9e Objet, nous devrions jouer totalement le jeu de l' encapsulation en nous refusant d'acc\u00e9der directement aux attributs. Pour cela il faut construire des m\u00e9thodes permettant d'acc\u00e9der \u00e0 ces attributs (avec des getters , ou accesseurs en fran\u00e7ais) ou de les modifier (avec des setters , ou mutateurs en fran\u00e7ais) . 3.1.1 Impl\u00e9mentation avec encapsulation \u2693\ufe0e Classe Arbre avec encapsulation \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Arbre : def __init__ ( self , data ): self . data = data self . left = None self . right = None def set_left ( self , sousarbre ): # mutateur self . left = sousarbre def set_right ( self , sousarbre ): # mutateur self . right = sousarbre def get_left ( self ): # accesseur return self . left def get_right ( self ): # accesseur return self . right def get_data ( self ): # accesseur return self . data L'impl\u00e9mentation pr\u00e9c\u00e9dente permet d'utiliser les instructions de l'exercice pr\u00e9c\u00e9dent et de v\u00e9rifier que l'arbre a bien \u00e9t\u00e9 cr\u00e9\u00e9. \ud83d\udc0d Script Python >>> a = Arbre ( 4 ) >>> a . set_left ( Arbre ( 3 )) >>> a . set_right ( Arbre ( 1 )) >>> a . get_right () . set_left ( Arbre ( 2 )) >>> a . get_right () . set_right ( Arbre ( 7 )) >>> a . get_left () . set_left ( Arbre ( 6 )) >>> a . get_right () . get_right () . set_left ( Arbre ( 9 )) \ud83d\udc0d Script Python >>> a < __main__ . Arbre at 0x7f0100361f40 > \ud83d\udc0d Script Python >>> a . get_right () . get_left () . get_data () 2 3.1.1 Impl\u00e9mentation sans encapsulation \u2693\ufe0e Classe Arbre sans encapsulation \ud83d\udc0d Script Python 1 2 3 4 5 class Arbre : def __init__ ( self , data ): self . data = data self . left = None self . right = None C'est d\u00e9j\u00e0 fini ! \ud83d\udc0d Script Python a = Arbre ( 4 ) a . left = Arbre ( 3 ) a . right = Arbre ( 1 ) a . right . left = Arbre ( 2 ) a . right . right = Arbre ( 7 ) a . left . left = Arbre ( 6 ) a . right . right . left = Arbre ( 9 ) \ud83d\udc0d Script Python >>> a < __main__ . Arbre at 0x7f0100361f40 > \ud83d\udc0d Script Python >>> a . right . left . data 2 On voit que l'impl\u00e9mentation avec acc\u00e8s direct aux attributs est beaucoup plus simple et rapide. N\u00e9anmoins, elle peut \u00eatre consid\u00e9r\u00e9e comme incorrecte dans certains langages qui obligent \u00e0 passer par des accesseurs ou mutateurs pour lire ou modifier les attributs. 3.1.2 Repr\u00e9sentation graphique en console \u2693\ufe0e La m\u00e9thode affiche suivante (qui n'est pas \u00e0 conna\u00eetre) permet d'avoir un semblant de repr\u00e9sentation graphique de l'arbre en console : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def affiche ( self , indent = 0 ): val = self . data s = ' ' * 2 * indent + '|' + '_' + str ( val ) + ' \\n ' if self . left is not None : s += self . left . affiche ( indent + 1 ) if self . left is None and self . right is not None : s += ' ' * ( 2 * indent + 2 ) + '|' + '_' + 'None' + ' \\n ' if self . right is not None : s += self . right . affiche ( indent + 1 ) if self . right is None and self . left is not None : s += ' ' * ( 2 * indent + 2 ) + '|' + '_' + 'None' + ' \\n ' return s La repr\u00e9sentation de cet arbre : donnera alors : \ud83d\udc0d Script Python >>> print ( a . affiche ()) | _4 | _3 | _6 | _None | _1 | _2 | _7 | _9 | _None 3.2 Impl\u00e9mentation \u00e0 partir de tuples imbriqu\u00e9s \u2693\ufe0e Arbre sous forme de tuples imbriqu\u00e9s Un arbre peut se repr\u00e9senter par le tuple (valeur, sous-arbre gauche, sous-arbre droit) . L'arbre ci-dessous : est repr\u00e9sent\u00e9 par le tuple : \ud83d\udc0d Script Python >>> a = ( 2 , ( 8 , ( 6 ,(),()), ( 9 ,(),())), ( 1 , ( 7 , (),()), ())) Le sous-arbre gauche est alors a[1] et le sous-arbre droit est a[2] . \ud83d\udc0d Script Python >>> a [ 1 ] ( 8 , ( 6 , (), ()), ( 9 , (), ())) >>> a [ 2 ] ( 1 , ( 7 , (), ()), ()) Exercice 5 \u00c9nonc\u00e9 Correction \u00c9crire le tuple repr\u00e9sentant l'arbre ci-dessous. \ud83d\udc0d Script Python a = ( T ,( Y ,( P ,(),()),()),( O ,( H ,(),()),( N ,(),()))) 3.3 Impl\u00e9mentation \u00e0 partir d'une \u00absimple\u00bb liste \u2693\ufe0e De mani\u00e8re plus surprenante, il existe une m\u00e9thode pour impl\u00e9menter un arbre binaire (qui est une structure hi\u00e9rarchique) avec une liste (qui est une structure lin\u00e9aire). Ceci peut se faire par le biais d'une astuce sur les indices : Les fils du n\u0153ud d'indice i sont plac\u00e9s aux indice 2i+1 et 2i+2 . Cette m\u00e9thode est connue sous le nom de \u00abm\u00e9thode d'Eytzinger\u00bb, et utilis\u00e9e notamment en g\u00e9n\u00e9alogie pour num\u00e9roter facilement les individus d'un arbre g\u00e9n\u00e9alogique. Exemple : Pour comprendre facilement la num\u00e9rotation, il suffit de s'imaginer l'arbre complet (en rajoutant les fils vides) et de faire une num\u00e9rotation en largeur, niveau par niveau : Exercice 6 \u00c9nonc\u00e9 Correction Si on note \u0394 le sous-arbre vide, dessiner l'arbre repr\u00e9sent\u00e9 par la liste : \ud83d\udc0d Script Python a = [ 3 , 4 , \u0394 , 7 , 5 ] Remarque : parfois (comme dans le sujet 0...) la racine de l'arbre est plac\u00e9e \u00e0 l'indice 1. Dans ce cas, les fils du n\u0153ud d'indice i sont plac\u00e9s aux indice 2i et 2i+1. 4. Utilisation de l'impl\u00e9mentation : parcours, taille... \u2693\ufe0e Dans toute la suite, sauf mention contraire, on utilisera l'impl\u00e9mentation en Programmation Orient\u00e9e Objet, en version sans encapsulation (la plus simple). Nous allons cr\u00e9er des fonctions renvoyant les diff\u00e9rents parcours d'un arbre, ou encore sa taille, sa hauteur, son nombre de feuilles... Toutes ses fonctions exploiteront la structure r\u00e9cursive d'un arbre. Rappel de l'impl\u00e9mentation : \ud83d\udc0d Script Python 1 2 3 4 5 class Arbre : def __init__ ( self , data ): self . data = data self . left = None self . right = None 4.1 Parcours pr\u00e9fixe, infixe, postfixe \u2693\ufe0e 4.1.1 Parcours pr\u00e9fixe \u2693\ufe0e Parcours pr\u00e9fixe \ud83d\udc0d Script Python 1 2 3 4 5 6 def prefixe ( arbre ): if arbre is None : return None print ( arbre . data , end = '-' ) prefixe ( arbre . left ) prefixe ( arbre . right ) Exemple avec l'arbre \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 a = Arbre ( 9 ) a . left = Arbre ( 8 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 6 ) a . left . right = Arbre ( 2 ) a . right . right = Arbre ( 5 ) a . left . right . left = Arbre ( 1 ) a . right . right . left = Arbre ( 4 ) a . right . right . right = Arbre ( 3 ) \ud83d\udc0d Script Python >>> prefixe ( a ) 9 - 8 - 6 - 2 - 1 - 7 - 5 - 4 - 3 - 4.1.2 Parcours infixe \u2693\ufe0e Parcours infixe \ud83d\udc0d Script Python def infixe ( arbre ): if arbre is None : return None infixe ( arbre . left ) print ( arbre . data , end = '-' ) infixe ( arbre . right ) \ud83d\udc0d Script Python >>> infixe ( a ) 6 - 8 - 1 - 2 - 9 - 7 - 4 - 5 - 3 - 4.1.3 Parcours postfixe \u2693\ufe0e Parcours postfixe \ud83d\udc0d Script Python def postfixe ( arbre ): if arbre is None : return None postfixe ( arbre . left ) postfixe ( arbre . right ) print ( arbre . data , end = '-' ) \ud83d\udc0d Script Python >>> postfixe ( a ) 6 - 1 - 2 - 8 - 4 - 3 - 5 - 7 - 9 - Pause vid\u00e9o Regardez et appr\u00e9ciez cette vid\u00e9o \u00c0 l'aide de la vid\u00e9o, codez le parcours infixe en it\u00e9ratif. solution \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def infixe ( arbre ): parcours = [] pile = [] current = arbre while pile != [] or current is not None : if current is not None : pile . append ( current ) current = current . left else : current = pile . pop () parcours . append ( current . data ) current = current . right return parcours 4.2 Calcul de la taille d'un arbre \u2693\ufe0e Rappel : la taille d'un arbre est le nombre de ses n\u0153uds. Taille d'un arbre \ud83d\udc0d Script Python def taille ( arbre ): if arbre is None : return 0 else : return 1 + taille ( arbre . left ) + taille ( arbre . right ) Exemple avec l'arbre \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 a = Arbre ( 9 ) a . left = Arbre ( 8 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 6 ) a . left . right = Arbre ( 2 ) a . right . right = Arbre ( 5 ) a . left . right . left = Arbre ( 1 ) a . right . right . left = Arbre ( 4 ) a . right . right . right = Arbre ( 3 ) \ud83d\udc0d Script Python >>> taille ( a ) 9 4.3 Calcul de la hauteur d'un arbre \u2693\ufe0e Rappel : on prendra comme convention que l'arbre vide a pour hauteur 0. Hauteur d'un arbre \ud83d\udc0d Script Python def hauteur ( arbre ): if arbre is None : return 0 else : return 1 + max ( hauteur ( arbre . left ), hauteur ( arbre . right )) \ud83d\udc0d Script Python >>> hauteur ( a ) 4 4.4 Calcul du nombre de feuilles d'un arbre \u2693\ufe0e Rappel : une feuille est un n\u0153ud d'arit\u00e9 0, autrement dit sans fils gauche ni fils droit. Nombre de feuilles d'un arbre \ud83d\udc0d Script Python def nb_feuilles ( arbre ): if arbre is None : return 0 if ( arbre . left is None ) and ( arbre . right is None ): return 1 return nb_feuilles ( arbre . left ) + nb_feuilles ( arbre . right ) \ud83d\udc0d Script Python >>> nb_feuilles ( a ) 4 4.5 Recherche d'une valeur dans un arbre \u2693\ufe0e On renverra True ou False en fonction de la pr\u00e9sence ou non de la valeur dans l'arbre. Recherche d'une valeur dans un arbre \ud83d\udc0d Script Python def recherche ( arbre , valeur ): if arbre is None : return False if arbre . data == valeur : return True else : return recherche ( arbre . left , valeur ) or recherche ( arbre . right , valeur ) \ud83d\udc0d Script Python >>> recherche ( a , 2 ) True >>> recherche ( a , 45 ) False 4.6 Parcours en largeur \u2693\ufe0e Le parcours en largeur (BFS) est le plus simple \u00e0 faire visuellement : mais il est plus difficile \u00e0 coder que les parcours pr\u00e9fixe, infixe, postfixe. Il est n\u00e9cessaire d'utiliser une file : On place l'arbre dans la file. Tant que la file n'est pas vide, on proc\u00e8de comme suit : On d\u00e9file, donc on r\u00e9cup\u00e8re l'arbre situ\u00e9 en haut de la file. Si cet arbre n'est pas vide : On garde son \u00e9tiquette. On enfile son sous-arbre gauche, puis son sous-arbre droit. On importera l'objet Queue() du module queue de Python, qui permet de : cr\u00e9er une file vide avec file = Queue() d\u00e9filer un \u00e9l\u00e9ment par file.get() enfiler l'\u00e9l\u00e9ment a par file.put(a) savoir si la file est vide par le bool\u00e9en file.empty() \ud83d\udc0d Script Python # arbre-test # ne pas oublier de remonter plus haut dans le document pour relancer la classe Arbre a = Arbre ( 8 ) a . left = Arbre ( 4 ) a . right = Arbre ( 5 ) a . left . left = Arbre ( 2 ) a . left . right = Arbre ( 1 ) a . right . right = Arbre ( 3 ) Parcours en largeur (BFS) \ud83d\udc0d Script Python from queue import Queue def BFS ( arbre ): file = Queue () file . put ( arbre ) sol = [] while not file . empty (): a = file . get () if a is not None : sol . append ( a . data ) file . put ( a . left ) file . put ( a . right ) return sol \ud83d\udc0d Script Python >>> BFS ( a ) [ 8 , 4 , 5 , 2 , 1 , 3 ] 5. Arbres binaires de recherche (ABR) \u2693\ufe0e D\u00e9finition d'un ABR Un arbre binaire de recherche est un arbre binaire dont les valeurs des n\u0153uds (valeurs qu'on appelle \u00e9tiquettes, ou cl\u00e9s) v\u00e9rifient la propri\u00e9t\u00e9 suivante : l'\u00e9tiquette d'un n\u0153ud est sup\u00e9rieure ou \u00e9gale \u00e0 celle de chaque n\u0153ud de son sous-arbre gauche . l'\u00e9tiquette d'un n\u0153ud est strictement inf\u00e9rieure \u00e0 celle du chaque n\u0153ud de son sous-arbre droit . \u00c0 noter que l'arbre 3 (qui est bien un ABR) est appel\u00e9 arbre filiforme . L'arbre 5 n'est pas un ABR \u00e0 cause de la feuille 9, qui fait partie du sous-arbre gauche de 3 sans lui \u00eatre inf\u00e9rieure. Remarque : on pourrait aussi d\u00e9finir un ABR comme un arbre dont le parcours infixe est une suite croissante. 5.1 D\u00e9terminer si un arbre est un ABR \u2693\ufe0e Employer une m\u00e9thode r\u00e9cursive imposerait de garder en m\u00e9moire dans l'exploration des sous-arbres la valeur maximale ou minimale. Nous allons plut\u00f4t utiliser la remarque pr\u00e9c\u00e9dente, et nous servir du parcours infixe. M\u00e9thode : r\u00e9cup\u00e9rer le parcours infixe dans une liste, et faire un test sur cette liste. \u00catre ou ne pas \u00eatre un ABR \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def infixe ( arbre , s = None ): if s is None : s = [] if arbre is None : return None infixe ( arbre . left , s ) s . append ( arbre . data ) infixe ( arbre . right , s ) return s def est_ABR ( arbre ): '''renvoie un bool\u00e9en indiquant si arbre est un ABR''' parcours = infixe ( arbre ) return parcours == sorted ( parcours ) # on regarde si le parcours est \u00e9gal au parcours tri\u00e9 \ud83d\udc0d Script Python # arbres-tests #arbre n\u00b04 a = Arbre ( 5 ) a . left = Arbre ( 2 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 0 ) a . left . right = Arbre ( 3 ) a . right . left = Arbre ( 6 ) a . right . right = Arbre ( 8 ) #arbre n\u00b05 b = Arbre ( 3 ) b . left = Arbre ( 2 ) b . right = Arbre ( 5 ) b . left . left = Arbre ( 1 ) b . left . right = Arbre ( 9 ) b . right . left = Arbre ( 4 ) b . right . right = Arbre ( 6 ) \ud83d\udc0d Script Python >>> est_ABR ( a ) True >>> est_ABR ( b ) False 5.2 Rechercher une cl\u00e9 dans un ABR \u2693\ufe0e Un arbre binaire de taille \\(n\\) contient \\(n\\) cl\u00e9s (pas forc\u00e9ment diff\u00e9rentes). Pour savoir si une valeur particuli\u00e8re fait partie des cl\u00e9s, on peut parcourir tous les n\u0153uds de l'arbre, jusqu'\u00e0 trouver (ou pas) cette valeur dans l'arbre. Dans le pire des cas, il faut donc faire \\(n\\) comparaisons. Mais si l'arbre est un ABR, le fait que les valeurs soient \u00abrang\u00e9es\u00bb va consid\u00e9rablement am\u00e9liorer la vitesse de recherche de cette cl\u00e9, puisque la moiti\u00e9 de l'arbre restant sera \u00e9cart\u00e9e apr\u00e8s chaque comparaison. Recherche d'une cl\u00e9 dans un ABR \ud83d\udc0d Script Python def contient_valeur ( arbre , valeur ): if arbre is None : return False if arbre . data == valeur : return True if valeur < arbre . data : return contient_valeur ( arbre . left , valeur ) else : return contient_valeur ( arbre . right , valeur ) Exemple L'arbre a contient la valeur 8, mais l'arbre b ne la contient pas : \ud83d\udc0d Script Python >>> contient_valeur ( a , 8 ) True >>> contient_valeur ( b , 8 ) False 5.3 Co\u00fbt de la recherche dans un ABR \u00e9quilibr\u00e9 \u2693\ufe0e Imaginons un arbre \u00e9quilibr\u00e9 de taille \\(n\\) . Combien d'\u00e9tapes faudra-t-il, dans le pire des cas, pour trouver (ou pas) une cl\u00e9 particuli\u00e8re dans cet arbre ? Apr\u00e8s chaque n\u0153ud, le nombre de n\u0153uds restant \u00e0 explorer est divis\u00e9 par 2. On retrouve l\u00e0 le principe de recherche dichotomique, vu en classe de Premi\u00e8re (voir ici ). S'il faut parcourir tous les \u00e9tages de l'arbre avant de trouver (ou pas) la cl\u00e9 recherch\u00e9e, le nombre de n\u0153uds parcourus est donc \u00e9gal \u00e0 la hauteur \\(h\\) de l'arbre. Pour un arbre complet, cette hauteur v\u00e9rifie la relation \\(2^h -1= n\\) . et donc \\(2^h = n+1\\) . \\(h\\) est donc le \u00abnombre de puissance de 2\u00bb que l'on peut mettre dans \\(n+1\\) . Cette notion s'appelle le logarithme de base 2 et se note \\(\\log_2\\) . Par exemple, \\(\\log_2(64)=6\\) car \\(2^6=64\\) . Le nombre maximal de n\u0153uds \u00e0 parcourir pour rechercher une cl\u00e9 dans un ABR \u00e9quilibr\u00e9 de taille \\(n\\) est donc de l'ordre de \\(\\log_2(n)\\) , ce qui est tr\u00e8s performant ! Pour arbre contenant 1000 valeurs, 10 \u00e9tapes suffisent. Cette complexit\u00e9 logarithmique est un atout essentiel de la structure d'arbre binaire de recherche. 5.4 Insertion dans un ABR \u2693\ufe0e L'insertion d'une cl\u00e9 va se faire au niveau d'une feuille, donc au bas de l'arbre. Dans la version r\u00e9cursive de l'algorithme d'insertion, que nous allons impl\u00e9menter, il n'est pourtant pas n\u00e9cessaire de descendre manuellement dans l'arbre jusqu'au bon endroit : il suffit de distinguer dans lequel des deux sous-arbres gauche et droit doit se trouver la future cl\u00e9, et d'appeler r\u00e9cursivement la fonction d'insertion dans le sous-arbre en question. Algorithme : Si l'arbre est vide, on renvoie un nouvel objet Arbre contenant la cl\u00e9. Sinon, on compare la cl\u00e9 \u00e0 la valeur du n\u0153ud sur lequel on est positionn\u00e9 : Si la cl\u00e9 est inf\u00e9rieure \u00e0 cette valeur, on va modifier le sous-arbre gauche en le faisant pointer vers ce m\u00eame sous-arbre une fois que la cl\u00e9 y aura \u00e9t\u00e9 inject\u00e9, par un appel r\u00e9cursif. Si la cl\u00e9 est sup\u00e9rieure, on fait la m\u00eame chose avec l'arbre de droite. on renvoie le nouvel arbre ainsi cr\u00e9\u00e9. Insertion dans un ABR \ud83d\udc0d Script Python def insertion ( arbre , valeur ): if arbre is None : return Arbre ( valeur ) else : v = arbre . data if valeur <= v : arbre . left = insertion ( arbre . left , valeur ) else : arbre . right = insertion ( arbre . right , valeur ) return arbre Exemple : Nous allons ins\u00e9rer la valeur 4 dans l'arbre a et v\u00e9rifier par un parcours infixe (avant et apr\u00e8s l'insertion) que la valeur 4 a bien \u00e9t\u00e9 ins\u00e9r\u00e9e au bon endroit. \ud83d\udc0d Script Python a = Arbre ( 5 ) a . left = Arbre ( 2 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 0 ) a . left . right = Arbre ( 3 ) a . right . left = Arbre ( 6 ) a . right . right = Arbre ( 8 ) \ud83d\udc0d Script Python >>> infixe ( a ) 0 - 2 - 3 - 5 - 6 - 7 - 8 - >>> insertion ( a , 4 ) < __main__ . Arbre at 0x7f46f0507e80 > >>> infixe ( a ) 0 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - La valeur 4 a donc bien \u00e9t\u00e9 ins\u00e9r\u00e9e au bon endroit.", "title": "Cours"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#arbres", "text": "", "title": "Arbres"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#1-terminologie", "text": "", "title": "1. Terminologie"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#11-vocabulaire", "text": "Un arbre est une structure hi\u00e9rarchique de donn\u00e9es, compos\u00e9e de n\u0153uds. Si on adopte le vocabulaire des graphes, un arbre est un graphe non orient\u00e9, connexe, sans cycle, et dans lequel un n\u0153ud joue le r\u00f4le de racine. Chaque n\u0153ud a exactement un seul n\u0153ud p\u00e8re , \u00e0 l'exception du n\u0153ud racine qui est le seul n\u0153ud \u00e0 ne pas avoir de p\u00e8re. (oui, la racine d'une arbre est en haut ) Chaque n\u0153ud peut avoir un nombre quelconque de fils , dont il est le p\u00e8re. Les n\u0153uds qui n'ont pas de fils sont appel\u00e9s les feuilles (ou n\u0153uds externes). Les n\u0153uds qui ne sont pas des feuilles sont des n\u0153uds internes . Le nom de chaque n\u0153ud est appel\u00e9 son \u00e9tiquette . Exemples : dans l'arbre ci-dessus, C est la racine, E, Z A et G sont les feuilles. K est le p\u00e8re de A et G. F est le p\u00e8re de Z. C est le p\u00e8re de B et K B est le p\u00e8re de E et F.", "title": "1.1 Vocabulaire"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#12-exemples-darbres", "text": "", "title": "1.2 Exemples d'arbres"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#13-caracteristiques-dun-arbre", "text": "", "title": "1.3 Caract\u00e9ristiques d'un arbre"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#2-parcours-darbres", "text": "Les arbres \u00e9tant une structure hi\u00e9rarchique, leur utilisation implique la n\u00e9cessit\u00e9 d'un parcours des valeurs stock\u00e9es. Par exemple pour toutes les r\u00e9cup\u00e9rer dans un certain ordre, ou bien pour en chercher une en particulier. Il existe plusieurs mani\u00e8res de parcourir un arbre.", "title": "2. Parcours d'arbres"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#21-parcours-en-largeur-dabord-bfs", "text": "BFS : Breadth First Search M\u00e9thode du parcours en largeur (BFS) Le parcours en largeur d'abord est un parcours \u00e9tage par \u00e9tage (de haut en bas) et de gauche \u00e0 droite. L'ordre des lettres parcourues est donc T-Y-O-P-H-N. Les trois parcours que nous allons voir maintenant sont des parcours en profondeur d'abord , ou DFS ( Depth First Search ). Ce qui signifie qu'un des deux sous-arbres sera totalement parcouru avant que l'exploration du deuxi\u00e8me ne commence.", "title": "2.1 Parcours en largeur d'abord (BFS)"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#22-parcours-prefixe", "text": "Le parcours pr\u00e9fixe est un parcours en profondeur d'abord . M\u00e9thode du parcours pr\u00e9fixe (parfois aussi appel\u00e9 pr\u00e9ordre ) Chaque n\u0153ud est visit\u00e9 avant que ses fils le soient. On part de la racine, puis on visite son fils gauche (et \u00e9ventuellement le fils gauche de celui-ci, etc.) avant de remonter et de redescendre vers le fils droit. L'ordre des lettres parcourues est donc T-Y-P-O-H-N.", "title": "2.2 Parcours pr\u00e9fixe"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#23-parcours-infixe", "text": "Le parcours infixe est aussi un parcours en profondeur d'abord. M\u00e9thode du parcours infixe (parfois aussi appel\u00e9 en ordre ) Chaque n\u0153ud est visit\u00e9 apr\u00e8s son fils gauche mais avant son fils droit . On part donc de la feuille la plus \u00e0 gauche et on remonte par vagues sucessives. Un n\u0153ud ne peut pas \u00eatre visit\u00e9 si son fils gauche ne l'a pas \u00e9t\u00e9. L'ordre des lettres parcourues est donc P-Y-T-H-O-N.", "title": "2.3 Parcours infixe"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#24-parcours-postfixe", "text": "Le parcours postfixe est aussi un parcours en profondeur d'abord. M\u00e9thode du parcours postfixe (parfois aussi appel\u00e9 post-ordre ou encore suffixe ) Chaque n\u0153ud est visit\u00e9 apr\u00e8s ses fils le soient. On part donc de la feuille la plus \u00e0 gauche, et on ne remonte \u00e0 un n\u0153ud p\u00e8re que si ses fils ont tous \u00e9t\u00e9 visit\u00e9s. L'ordre des lettres parcourues est donc P-Y-H-N-O-T.", "title": "2.4 Parcours postfixe"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#25-comment-ne-pas-se-melanger-entre-le-pre-in-post-fixe", "text": "pr\u00e9 veut dire avant in veut dire au milieu post veut dire apr\u00e8s Ces trois mots-cl\u00e9s parlent de la place du p\u00e8re par rapport \u00e0 ses fils. Ensuite, il faut toujours se souvenir qu'on traite le fils gauche avant le fils droit. pr\u00e9fixe : le p\u00e8re doit \u00eatre le premier par rapport \u00e0 ses fils. infixe : le p\u00e8re doit \u00eatre entre son fils gauche (trait\u00e9 en premier) et son fils droit. postfixe : le p\u00e8re ne doit \u00eatre trait\u00e9 que quand ses deux fils (gauche d'abord, droite ensuite) l'ont \u00e9t\u00e9. Un parcours pr\u00e9fixe commencera toujours par la racine, alors qu'un parcours postfixe finira toujours par la racine. Dans un parcours infixe, la racine sera \u00abau milieu\u00bb (pas n\u00e9cessairement parfaitement). Exercice 2 \u00c9nonc\u00e9 Corr. largeur Corr. pr\u00e9fixe Corr. infixe Corr. postfixe Donner le rendu de chaque parcours : Parcours en largeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe largeur : 1 2 3 4 5 6 7 8 9 pr\u00e9fixe : 1 2 4 5 7 8 3 6 9 infixe : 4 2 7 5 8 1 3 9 6 postfixe : 4 7 8 5 2 9 6 3 1 Exercice 3 \u00c9nonc\u00e9 Corr. largeur Corr. pr\u00e9fixe Corr. infixe Corr. postfixe Donner le rendu de chaque parcours : Parcours en largeur Parcours pr\u00e9fixe Parcours infixe Parcours postfixe", "title": "2.5 Comment ne pas se m\u00e9langer entre le pr\u00e9 / in / post fixe ?"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#3-implementations-dun-arbre-binaire", "text": "", "title": "3. Impl\u00e9mentations d'un arbre binaire"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#31-en-utilisant-la-programmation-orientee-objet", "text": "Le but est d'obtenir l'interface ci-dessous. Il est \u00e0 remarquer que ce que nous allons appeler \u00abArbre\u00bb est en fait un n\u0153ud et ses deux fils gauche et droit. interface souhait\u00e9e \ud83d\udc0d Script Python >>> a = Arbre ( 4 ) # pour cr\u00e9er l'arbre dont le n\u0153ud a pour valeur 4, # et dont les sous-arbres gauche et droit sont None >>> a . left = Arbre ( 3 ) # pour donner la valeur 3 au n\u0153ud du sous-arbre gauche de a >>> a . right = Arbre ( 1 ) # pour donner la valeur 1 au n\u0153ud du sous-arbre droit de a >>> a . right . data # pour acc\u00e9der \u00e0 la valeur du fils droit de a Exercice 4 \u00c9nonc\u00e9 Correction Dessinez l'arbre cr\u00e9\u00e9 par les instructions suivantes : \ud83d\udc0d Script Python >>> a = Arbre ( 4 ) >>> a . left = Arbre ( 3 ) >>> a . right = Arbre ( 1 ) >>> a . right . left = Arbre ( 2 ) >>> a . right . right = Arbre ( 7 ) >>> a . left . left = Arbre ( 6 ) >>> a . right . right . left = Arbre ( 9 ) Impl\u00e9mentation \u2bc8 Principe : nous allons cr\u00e9er une classe Arbre , qui contiendra 3 attributs : data : la valeur du n\u0153ud (de type Int ) left : le sous-arbre gauche (de type Arbre ) right : le sous-arbre droit (de type Arbre ). Par d\u00e9faut, les attributs left et right seront \u00e0 None , qui repr\u00e9sentera l'arbre vide (ce qui n'est pas tr\u00e8s rigoureux, car None n'est pas de type Arbre ...). \u2bc8 Encapsulation ou pas ??? : Afin de respecter le paradigme de la Programmation Orient\u00e9e Objet, nous devrions jouer totalement le jeu de l' encapsulation en nous refusant d'acc\u00e9der directement aux attributs. Pour cela il faut construire des m\u00e9thodes permettant d'acc\u00e9der \u00e0 ces attributs (avec des getters , ou accesseurs en fran\u00e7ais) ou de les modifier (avec des setters , ou mutateurs en fran\u00e7ais) .", "title": "3.1 En utilisant la Programmation Orient\u00e9e Objet"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#32-implementation-a-partir-de-tuples-imbriques", "text": "Arbre sous forme de tuples imbriqu\u00e9s Un arbre peut se repr\u00e9senter par le tuple (valeur, sous-arbre gauche, sous-arbre droit) . L'arbre ci-dessous : est repr\u00e9sent\u00e9 par le tuple : \ud83d\udc0d Script Python >>> a = ( 2 , ( 8 , ( 6 ,(),()), ( 9 ,(),())), ( 1 , ( 7 , (),()), ())) Le sous-arbre gauche est alors a[1] et le sous-arbre droit est a[2] . \ud83d\udc0d Script Python >>> a [ 1 ] ( 8 , ( 6 , (), ()), ( 9 , (), ())) >>> a [ 2 ] ( 1 , ( 7 , (), ()), ()) Exercice 5 \u00c9nonc\u00e9 Correction \u00c9crire le tuple repr\u00e9sentant l'arbre ci-dessous. \ud83d\udc0d Script Python a = ( T ,( Y ,( P ,(),()),()),( O ,( H ,(),()),( N ,(),())))", "title": "3.2 Impl\u00e9mentation \u00e0 partir de tuples imbriqu\u00e9s"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#33-implementation-a-partir-dune-simple-liste", "text": "De mani\u00e8re plus surprenante, il existe une m\u00e9thode pour impl\u00e9menter un arbre binaire (qui est une structure hi\u00e9rarchique) avec une liste (qui est une structure lin\u00e9aire). Ceci peut se faire par le biais d'une astuce sur les indices : Les fils du n\u0153ud d'indice i sont plac\u00e9s aux indice 2i+1 et 2i+2 . Cette m\u00e9thode est connue sous le nom de \u00abm\u00e9thode d'Eytzinger\u00bb, et utilis\u00e9e notamment en g\u00e9n\u00e9alogie pour num\u00e9roter facilement les individus d'un arbre g\u00e9n\u00e9alogique. Exemple : Pour comprendre facilement la num\u00e9rotation, il suffit de s'imaginer l'arbre complet (en rajoutant les fils vides) et de faire une num\u00e9rotation en largeur, niveau par niveau : Exercice 6 \u00c9nonc\u00e9 Correction Si on note \u0394 le sous-arbre vide, dessiner l'arbre repr\u00e9sent\u00e9 par la liste : \ud83d\udc0d Script Python a = [ 3 , 4 , \u0394 , 7 , 5 ] Remarque : parfois (comme dans le sujet 0...) la racine de l'arbre est plac\u00e9e \u00e0 l'indice 1. Dans ce cas, les fils du n\u0153ud d'indice i sont plac\u00e9s aux indice 2i et 2i+1.", "title": "3.3 Impl\u00e9mentation \u00e0 partir d'une \u00absimple\u00bb liste"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#4-utilisation-de-limplementation-parcours-taille", "text": "Dans toute la suite, sauf mention contraire, on utilisera l'impl\u00e9mentation en Programmation Orient\u00e9e Objet, en version sans encapsulation (la plus simple). Nous allons cr\u00e9er des fonctions renvoyant les diff\u00e9rents parcours d'un arbre, ou encore sa taille, sa hauteur, son nombre de feuilles... Toutes ses fonctions exploiteront la structure r\u00e9cursive d'un arbre. Rappel de l'impl\u00e9mentation : \ud83d\udc0d Script Python 1 2 3 4 5 class Arbre : def __init__ ( self , data ): self . data = data self . left = None self . right = None", "title": "4. Utilisation de l'impl\u00e9mentation : parcours, taille..."}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#41-parcours-prefixe-infixe-postfixe", "text": "", "title": "4.1 Parcours pr\u00e9fixe, infixe, postfixe"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#42-calcul-de-la-taille-dun-arbre", "text": "Rappel : la taille d'un arbre est le nombre de ses n\u0153uds. Taille d'un arbre \ud83d\udc0d Script Python def taille ( arbre ): if arbre is None : return 0 else : return 1 + taille ( arbre . left ) + taille ( arbre . right ) Exemple avec l'arbre \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 a = Arbre ( 9 ) a . left = Arbre ( 8 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 6 ) a . left . right = Arbre ( 2 ) a . right . right = Arbre ( 5 ) a . left . right . left = Arbre ( 1 ) a . right . right . left = Arbre ( 4 ) a . right . right . right = Arbre ( 3 ) \ud83d\udc0d Script Python >>> taille ( a ) 9", "title": "4.2 Calcul de la taille d'un arbre"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#43-calcul-de-la-hauteur-dun-arbre", "text": "Rappel : on prendra comme convention que l'arbre vide a pour hauteur 0. Hauteur d'un arbre \ud83d\udc0d Script Python def hauteur ( arbre ): if arbre is None : return 0 else : return 1 + max ( hauteur ( arbre . left ), hauteur ( arbre . right )) \ud83d\udc0d Script Python >>> hauteur ( a ) 4", "title": "4.3 Calcul de la hauteur d'un arbre"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#44-calcul-du-nombre-de-feuilles-dun-arbre", "text": "Rappel : une feuille est un n\u0153ud d'arit\u00e9 0, autrement dit sans fils gauche ni fils droit. Nombre de feuilles d'un arbre \ud83d\udc0d Script Python def nb_feuilles ( arbre ): if arbre is None : return 0 if ( arbre . left is None ) and ( arbre . right is None ): return 1 return nb_feuilles ( arbre . left ) + nb_feuilles ( arbre . right ) \ud83d\udc0d Script Python >>> nb_feuilles ( a ) 4", "title": "4.4 Calcul du nombre de feuilles d'un arbre"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#45-recherche-dune-valeur-dans-un-arbre", "text": "On renverra True ou False en fonction de la pr\u00e9sence ou non de la valeur dans l'arbre. Recherche d'une valeur dans un arbre \ud83d\udc0d Script Python def recherche ( arbre , valeur ): if arbre is None : return False if arbre . data == valeur : return True else : return recherche ( arbre . left , valeur ) or recherche ( arbre . right , valeur ) \ud83d\udc0d Script Python >>> recherche ( a , 2 ) True >>> recherche ( a , 45 ) False", "title": "4.5 Recherche d'une valeur dans un arbre"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#46-parcours-en-largeur", "text": "Le parcours en largeur (BFS) est le plus simple \u00e0 faire visuellement : mais il est plus difficile \u00e0 coder que les parcours pr\u00e9fixe, infixe, postfixe. Il est n\u00e9cessaire d'utiliser une file : On place l'arbre dans la file. Tant que la file n'est pas vide, on proc\u00e8de comme suit : On d\u00e9file, donc on r\u00e9cup\u00e8re l'arbre situ\u00e9 en haut de la file. Si cet arbre n'est pas vide : On garde son \u00e9tiquette. On enfile son sous-arbre gauche, puis son sous-arbre droit. On importera l'objet Queue() du module queue de Python, qui permet de : cr\u00e9er une file vide avec file = Queue() d\u00e9filer un \u00e9l\u00e9ment par file.get() enfiler l'\u00e9l\u00e9ment a par file.put(a) savoir si la file est vide par le bool\u00e9en file.empty() \ud83d\udc0d Script Python # arbre-test # ne pas oublier de remonter plus haut dans le document pour relancer la classe Arbre a = Arbre ( 8 ) a . left = Arbre ( 4 ) a . right = Arbre ( 5 ) a . left . left = Arbre ( 2 ) a . left . right = Arbre ( 1 ) a . right . right = Arbre ( 3 ) Parcours en largeur (BFS) \ud83d\udc0d Script Python from queue import Queue def BFS ( arbre ): file = Queue () file . put ( arbre ) sol = [] while not file . empty (): a = file . get () if a is not None : sol . append ( a . data ) file . put ( a . left ) file . put ( a . right ) return sol \ud83d\udc0d Script Python >>> BFS ( a ) [ 8 , 4 , 5 , 2 , 1 , 3 ]", "title": "4.6 Parcours en largeur"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#5-arbres-binaires-de-recherche-abr", "text": "D\u00e9finition d'un ABR Un arbre binaire de recherche est un arbre binaire dont les valeurs des n\u0153uds (valeurs qu'on appelle \u00e9tiquettes, ou cl\u00e9s) v\u00e9rifient la propri\u00e9t\u00e9 suivante : l'\u00e9tiquette d'un n\u0153ud est sup\u00e9rieure ou \u00e9gale \u00e0 celle de chaque n\u0153ud de son sous-arbre gauche . l'\u00e9tiquette d'un n\u0153ud est strictement inf\u00e9rieure \u00e0 celle du chaque n\u0153ud de son sous-arbre droit . \u00c0 noter que l'arbre 3 (qui est bien un ABR) est appel\u00e9 arbre filiforme . L'arbre 5 n'est pas un ABR \u00e0 cause de la feuille 9, qui fait partie du sous-arbre gauche de 3 sans lui \u00eatre inf\u00e9rieure. Remarque : on pourrait aussi d\u00e9finir un ABR comme un arbre dont le parcours infixe est une suite croissante.", "title": "5. Arbres binaires de recherche (ABR)"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#51-determiner-si-un-arbre-est-un-abr", "text": "Employer une m\u00e9thode r\u00e9cursive imposerait de garder en m\u00e9moire dans l'exploration des sous-arbres la valeur maximale ou minimale. Nous allons plut\u00f4t utiliser la remarque pr\u00e9c\u00e9dente, et nous servir du parcours infixe. M\u00e9thode : r\u00e9cup\u00e9rer le parcours infixe dans une liste, et faire un test sur cette liste. \u00catre ou ne pas \u00eatre un ABR \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def infixe ( arbre , s = None ): if s is None : s = [] if arbre is None : return None infixe ( arbre . left , s ) s . append ( arbre . data ) infixe ( arbre . right , s ) return s def est_ABR ( arbre ): '''renvoie un bool\u00e9en indiquant si arbre est un ABR''' parcours = infixe ( arbre ) return parcours == sorted ( parcours ) # on regarde si le parcours est \u00e9gal au parcours tri\u00e9 \ud83d\udc0d Script Python # arbres-tests #arbre n\u00b04 a = Arbre ( 5 ) a . left = Arbre ( 2 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 0 ) a . left . right = Arbre ( 3 ) a . right . left = Arbre ( 6 ) a . right . right = Arbre ( 8 ) #arbre n\u00b05 b = Arbre ( 3 ) b . left = Arbre ( 2 ) b . right = Arbre ( 5 ) b . left . left = Arbre ( 1 ) b . left . right = Arbre ( 9 ) b . right . left = Arbre ( 4 ) b . right . right = Arbre ( 6 ) \ud83d\udc0d Script Python >>> est_ABR ( a ) True >>> est_ABR ( b ) False", "title": "5.1 D\u00e9terminer si un arbre est un ABR"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#52-rechercher-une-cle-dans-un-abr", "text": "Un arbre binaire de taille \\(n\\) contient \\(n\\) cl\u00e9s (pas forc\u00e9ment diff\u00e9rentes). Pour savoir si une valeur particuli\u00e8re fait partie des cl\u00e9s, on peut parcourir tous les n\u0153uds de l'arbre, jusqu'\u00e0 trouver (ou pas) cette valeur dans l'arbre. Dans le pire des cas, il faut donc faire \\(n\\) comparaisons. Mais si l'arbre est un ABR, le fait que les valeurs soient \u00abrang\u00e9es\u00bb va consid\u00e9rablement am\u00e9liorer la vitesse de recherche de cette cl\u00e9, puisque la moiti\u00e9 de l'arbre restant sera \u00e9cart\u00e9e apr\u00e8s chaque comparaison. Recherche d'une cl\u00e9 dans un ABR \ud83d\udc0d Script Python def contient_valeur ( arbre , valeur ): if arbre is None : return False if arbre . data == valeur : return True if valeur < arbre . data : return contient_valeur ( arbre . left , valeur ) else : return contient_valeur ( arbre . right , valeur ) Exemple L'arbre a contient la valeur 8, mais l'arbre b ne la contient pas : \ud83d\udc0d Script Python >>> contient_valeur ( a , 8 ) True >>> contient_valeur ( b , 8 ) False", "title": "5.2 Rechercher une cl\u00e9 dans un ABR"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#53-cout-de-la-recherche-dans-un-abr-equilibre", "text": "Imaginons un arbre \u00e9quilibr\u00e9 de taille \\(n\\) . Combien d'\u00e9tapes faudra-t-il, dans le pire des cas, pour trouver (ou pas) une cl\u00e9 particuli\u00e8re dans cet arbre ? Apr\u00e8s chaque n\u0153ud, le nombre de n\u0153uds restant \u00e0 explorer est divis\u00e9 par 2. On retrouve l\u00e0 le principe de recherche dichotomique, vu en classe de Premi\u00e8re (voir ici ). S'il faut parcourir tous les \u00e9tages de l'arbre avant de trouver (ou pas) la cl\u00e9 recherch\u00e9e, le nombre de n\u0153uds parcourus est donc \u00e9gal \u00e0 la hauteur \\(h\\) de l'arbre. Pour un arbre complet, cette hauteur v\u00e9rifie la relation \\(2^h -1= n\\) . et donc \\(2^h = n+1\\) . \\(h\\) est donc le \u00abnombre de puissance de 2\u00bb que l'on peut mettre dans \\(n+1\\) . Cette notion s'appelle le logarithme de base 2 et se note \\(\\log_2\\) . Par exemple, \\(\\log_2(64)=6\\) car \\(2^6=64\\) . Le nombre maximal de n\u0153uds \u00e0 parcourir pour rechercher une cl\u00e9 dans un ABR \u00e9quilibr\u00e9 de taille \\(n\\) est donc de l'ordre de \\(\\log_2(n)\\) , ce qui est tr\u00e8s performant ! Pour arbre contenant 1000 valeurs, 10 \u00e9tapes suffisent. Cette complexit\u00e9 logarithmique est un atout essentiel de la structure d'arbre binaire de recherche.", "title": "5.3  Co\u00fbt de la recherche dans un ABR \u00e9quilibr\u00e9"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/cours/#54-insertion-dans-un-abr", "text": "L'insertion d'une cl\u00e9 va se faire au niveau d'une feuille, donc au bas de l'arbre. Dans la version r\u00e9cursive de l'algorithme d'insertion, que nous allons impl\u00e9menter, il n'est pourtant pas n\u00e9cessaire de descendre manuellement dans l'arbre jusqu'au bon endroit : il suffit de distinguer dans lequel des deux sous-arbres gauche et droit doit se trouver la future cl\u00e9, et d'appeler r\u00e9cursivement la fonction d'insertion dans le sous-arbre en question. Algorithme : Si l'arbre est vide, on renvoie un nouvel objet Arbre contenant la cl\u00e9. Sinon, on compare la cl\u00e9 \u00e0 la valeur du n\u0153ud sur lequel on est positionn\u00e9 : Si la cl\u00e9 est inf\u00e9rieure \u00e0 cette valeur, on va modifier le sous-arbre gauche en le faisant pointer vers ce m\u00eame sous-arbre une fois que la cl\u00e9 y aura \u00e9t\u00e9 inject\u00e9, par un appel r\u00e9cursif. Si la cl\u00e9 est sup\u00e9rieure, on fait la m\u00eame chose avec l'arbre de droite. on renvoie le nouvel arbre ainsi cr\u00e9\u00e9. Insertion dans un ABR \ud83d\udc0d Script Python def insertion ( arbre , valeur ): if arbre is None : return Arbre ( valeur ) else : v = arbre . data if valeur <= v : arbre . left = insertion ( arbre . left , valeur ) else : arbre . right = insertion ( arbre . right , valeur ) return arbre Exemple : Nous allons ins\u00e9rer la valeur 4 dans l'arbre a et v\u00e9rifier par un parcours infixe (avant et apr\u00e8s l'insertion) que la valeur 4 a bien \u00e9t\u00e9 ins\u00e9r\u00e9e au bon endroit. \ud83d\udc0d Script Python a = Arbre ( 5 ) a . left = Arbre ( 2 ) a . right = Arbre ( 7 ) a . left . left = Arbre ( 0 ) a . left . right = Arbre ( 3 ) a . right . left = Arbre ( 6 ) a . right . right = Arbre ( 8 ) \ud83d\udc0d Script Python >>> infixe ( a ) 0 - 2 - 3 - 5 - 6 - 7 - 8 - >>> insertion ( a , 4 ) < __main__ . Arbre at 0x7f46f0507e80 > >>> infixe ( a ) 0 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - La valeur 4 a donc bien \u00e9t\u00e9 ins\u00e9r\u00e9e au bon endroit.", "title": "5.4  Insertion dans un ABR"}, {"location": "T1_Structures_de_donnees/1.3_Arbres/exercices/", "text": "Exercice 1 \u00c9nonc\u00e9 Correction Exercice 2 du sujet Nouvelle-Cal\u00e9donie J2 2022 Correction 1. C'est un arbre binaire car chaque n\u0153ud poss\u00e8de au maximum deux fils. Correction 2.a V est un dictionnaire. Correction 2.b \ud83d\udc0d Script Python V [ 'J' ] Exercice 2 \u00c9nonc\u00e9 Correction 2020, sujet 0 Question 1 D\u00e9terminer la taille et la hauteur de l\u2019arbre binaire suivant : Question 2 On d\u00e9cide de num\u00e9roter en binaire les n\u0153uds d\u2019un arbre binaire de la fa\u00e7on suivante : la racine correspond \u00e0 1 ; la num\u00e9rotation pour un fils gauche s\u2019obtient en ajoutant le chiffre 0 \u00e0 droite au num\u00e9ro de son p\u00e8re ; la num\u00e9rotation pour un fils droit s\u2019obtient en ajoutant le chiffre 1 \u00e0 droite au num\u00e9ro de son p\u00e8re ; Par exemple, dans l\u2019arbre ci-dessous, on a utilis\u00e9 ce proc\u00e9d\u00e9 pour num\u00e9roter les n\u0153uds A, B, C, E et F . Dans l\u2019exemple pr\u00e9c\u00e9dent, quel est le num\u00e9ro en binaire associ\u00e9 au n\u0153ud G ? Quel est le n\u0153ud dont le num\u00e9ro en binaire vaut 13 en d\u00e9cimal ? En notant \\(h\\) la hauteur de l\u2019arbre, sur combien de bits seront num\u00e9rot\u00e9s les n\u0153uds les plus en bas ? Justifier que pour tout arbre de hauteur \\(h\\) et de taille \\(n \\geqslant 2\\) , on a : \\(h\\leqslant n \\leqslant 2^h-1\\) Question 3 Un arbre binaire est dit complet si tous les niveaux de l\u2019arbre sont remplis. On d\u00e9cide de repr\u00e9senter un arbre binaire complet par un tableau de taille n + 1, o\u00f9 n est la taille de l\u2019arbre, de la fa\u00e7on suivante : La racine a pour indice 1 ; Le fils gauche du n\u0153ud d\u2019indice i a pour indice \\(2 \\times i\\) ; Le fils droit du n\u0153ud d\u2019indice i a pour indice \\(2 \\times i + 1\\) ; On place la taille \\(n\\) de l\u2019arbre dans la case d\u2019indice 0. R\u00e9pondre aux questions suivantes : D\u00e9terminer le tableau qui repr\u00e9sente l\u2019arbre binaire complet de l\u2019exemple pr\u00e9c\u00e9dent. On consid\u00e8re le p\u00e8re du n\u0153ud d\u2019indice \\(i\\) avec \\(i \\geqslant 2\\) . Quel est son indice dans le tableau ? Question 4 On se place dans le cas particulier d\u2019un arbre binaire de recherche complet o\u00f9 les n\u0153uds contiennent des entiers et pour lequel la valeur de chaque noeud est sup\u00e9rieure \u00e0 celles des noeuds de son fils gauche, et inf\u00e9rieure \u00e0 celles des noeuds de son fils droit. \u00c9crire une fonction recherche ayant pour param\u00e8tres un arbre arbre et un \u00e9l\u00e9ment element . Cette fonction renvoie True si element est dans l\u2019arbre et False sinon. L\u2019arbre sera repr\u00e9sent\u00e9 par un tableau comme dans la question pr\u00e9c\u00e9dente. Exercice 3 \u00c9nonc\u00e9 Correction 2021, M\u00e9tropole sujet 1 Dans cet exercice, les arbres binaires de recherche ne peuvent pas comporter plusieurs fois la m\u00eame cl\u00e9. De plus, un arbre binaire de recherche limit\u00e9 \u00e0 un n\u0153ud a une hauteur de 1. On consid\u00e8re l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci-dessous (figure 1), o\u00f9 val repr\u00e9sente un entier : 1.a Donner le nombre de feuilles de cet arbre et pr\u00e9ciser leur valeur (\u00e9tiquette). 1.b Donner le sous arbre-gauche du n\u0153ud 23. 1.c Donner la hauteur et la taille de l\u2019arbre. 1.d Donner les valeurs enti\u00e8res possibles de val pour cet arbre binaire de recherche. On suppose, pour la suite de cet exercice, que val est \u00e9gal \u00e0 16. 2. On rappelle qu\u2019un parcours infixe depuis un n\u0153ud consiste, dans l\u2019ordre, \u00e0 faire un parcours infixe sur le sous arbre-gauche, afficher le n\u0153ud puis faire un parcours infixe sur le sous-arbre droit. Dans le cas d\u2019un parcours suffixe, on fait un parcours suffixe sur le sous-arbre gauche puis un parcours suffixe sur le sous-arbre droit, avant d\u2019afficher le n\u0153ud. a. Donner les valeurs d\u2019affichage des n\u0153uds dans le cas du parcours infixe de l\u2019arbre. b . Donner les valeurs d\u2019affichage des n\u0153uds dans le cas du parcours suffixe de l\u2019arbre. 3. On consid\u00e8re la classe Noeud d\u00e9finie de la fa\u00e7on suivante en Python : a. Repr\u00e9senter l\u2019arbre construit suite \u00e0 l\u2019ex\u00e9cution de l\u2019instruction suivante : \ud83d\udc0d Script Python racine = Noeud ( 18 ) racine . insere_tout ([ 12 , 13 , 15 , 16 , 19 , 21 , 32 , 23 ]) b. \u00c9crire les deux instructions permettant de construire l\u2019arbre de la figure 1. On rappelle que le nombre val est \u00e9gal \u00e0 16. c. On consid\u00e8re l\u2019arbre tel qu\u2019il est pr\u00e9sent\u00e9 sur la figure 1. D\u00e9terminer l\u2019ordre d\u2019ex\u00e9cution des blocs (rep\u00e9r\u00e9s de 1 \u00e0 3) suite \u00e0 l\u2019application de la m\u00e9thode insere(19) au n\u0153ud racine de cet arbre. 4. \u00c9crire une m\u00e9thode recherche(self, v) qui prend en argument un entier v et renvoie la valeur True si cet entier est une \u00e9tiquette de l\u2019arbre, False sinon. 1.a. Il y a 4 feuilles, d'\u00e9tiquette 12, val , 21 et 32. 1.b. Le sous-arbre gauche du n\u0153ud 23 est 19-21. 1.c. La hauteur de l'arbre est 4. Sa taille est 9. 1.d. Les valeurs possibles de val sont 16 et 17. 2.a. Parcours infixe : 12-13-15-16-18-19-21-23-32 2.b. Parcours suffixe : 12-13-16-15-21-19-32-23-18 3.a. 3.b. \ud83d\udc0d Script Python racine = Noeud ( 18 ) racine . insere ([ 15 , 13 , 12 , 16 , 23 , 32 , 19 , 21 ]) (d'autres solutions sont possibles) 3.c. Bloc 3 - Bloc 2 - Bloc 1 4. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Noeud (): def __init__ ( self , v ): self . ag = None self . ad = None self . v = v def insere ( self , v ): n = self est_insere = False while not est_insere : if v == n . v : est_insere = True elif v < n . v : if n . ag != None : n = n . ag else : n . ag = Noeud ( v ) est_insere = True else : if n . ad != None : n = n . ad else : n . ad = Noeud ( v ) est_insere = True def insere_tout ( self , vals ): for v in vals : self . insere ( v ) def recherche ( self , v ): arbre = self while not arbre is None : if arbre . v == v : return True if v < arbre . v : arbre = arbre . ag else : arbre = arbre . ad return False racine = Noeud ( 18 ) racine . insere_tout ([ 12 , 13 , 15 , 14 , 19 , 21 , 32 , 23 ]) print ( racine . recherche ( 149 )) print ( racine . recherche ( 12 )) Exercice 4 2021, M\u00e9tropole Candidats Libres 2 On rappelle qu\u2019un arbre binaire est compos\u00e9 de n\u0153uds, chacun des n\u0153uds poss\u00e9dant \u00e9ventuellement un sous-arbre gauche et \u00e9ventuellement un sous-arbre droit. Un n\u0153ud sans sous-arbre est appel\u00e9 feuille. La taille d\u2019un arbre est le nombre de n\u0153uds qu\u2019il contient ; sa hauteur est le nombre de n\u0153uds du plus long chemin qui joint le n\u0153ud racine \u00e0 l\u2019une des feuilles. Ainsi la hauteur d\u2019un arbre r\u00e9duit \u00e0 un n\u0153ud, c\u2019est-\u00e0-dire la racine, est 1. Dans un arbre binaire de recherche, chaque n\u0153ud contient une cl\u00e9, ici un nombre entier, qui est : strictement sup\u00e9rieure \u00e0 toutes les cl\u00e9s des n\u0153uds du sous-arbre gauche ; strictement inf\u00e9rieure \u00e0 toutes les cl\u00e9s des n\u0153uds du sous-arbre droit. Un arbre binaire de recherche est dit \u00ab bien construit \u00bb s\u2019il n\u2019existe pas d\u2019arbre de hauteur inf\u00e9rieure qui pourrait contenir tous ses n\u0153uds. On consid\u00e8re l\u2019arbre binaire de recherche ci-dessous. 1.a. Quelle est la taille de l\u2019arbre ci-dessus ? 1.b. Quelle est la hauteur de l\u2019arbre ci-dessus ? corrig\u00e9 1.a. La taille de l'arbre est 7. 1.b. La hauteur de l'arbre est 4. 2. Cet arbre binaire de recherche n\u2019est pas \u00ab bien construit \u00bb. Proposer un arbre binaire de recherche contenant les m\u00eames cl\u00e9s et dont la hauteur est plus petite que celle de l\u2019arbre initial. corrig\u00e9 2. 3. Les classes Noeud et Arbre ci-dessous permettent de mettre en \u0153uvre en Python la structure d\u2019arbre binaire de recherche. La m\u00e9thode insere permet d\u2019ins\u00e9rer r\u00e9cursivement une nouvelle cl\u00e9. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Noeud : def __init__ ( self , cle ): self . cle = cle self . gauche = None self . droit = None def insere ( self , cle ): if cle < self . cle : if self . gauche == None : self . gauche = Noeud ( cle ) else : self . gauche . insere ( cle ) elif cle > self . cle : if self . droit == None : self . droit = Noeud ( cle ) else : self . droit . insere ( cle ) class Arbre : def __init__ ( self , cle ): self . racine = Noeud ( cle ) def insere ( self , cle ): self . racine . insere ( cle ) Donner la repr\u00e9sentation de l\u2019arbre cod\u00e9 par les instructions ci-dessous. \ud83d\udc0d Script Python a = Arbre ( 10 ) a . insere ( 20 ) a . insere ( 15 ) a . insere ( 12 ) a . insere ( 8 ) a . insere ( 4 ) a . insere ( 5 ) corrig\u00e9 3. 4. Pour calculer la hauteur d\u2019un arbre non vide, on a \u00e9crit la m\u00e9thode ci-dessous dans la classe Noeud. \ud83d\udc0d Script Python def hauteur ( self ): if self . gauche == None and self . droit == None : return 1 if self . gauche == None : return 1 + self . droit . hauteur () elif self . droit == None : return 1 + self . gauche . hauteur () else : hg = self . gauche . hauteur () hd = self . droit . hauteur () if hg > hd : return hg + 1 else : return hd + 1 \u00c9crire la m\u00e9thode hauteur de la classe Arbre qui renvoie la hauteur de l\u2019arbre. corrig\u00e9 4. \ud83d\udc0d Script Python 1 2 def hauteur ( self ): return self . racine . hauteur () 5. \u00c9crire les m\u00e9thodes taille des classes Noeud et Arbre permettant de calculer la taille d\u2019un arbre. corrig\u00e9 5. M\u00e9thode taille de la classe Noeud : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def taille ( self ): if self . gauche is None and self . droit is None : return 1 elif self . gauche is None : return 1 + self . droit . taille () elif self . droit is None : return 1 + self . gauche . taille () else : return 1 + self . gauche . taille () + self . droit . taille () M\u00e9thode taille de la classe Arbre : \ud83d\udc0d Script Python 1 2 def taille ( self ): return self . racine . taille () 6. On souhaite \u00e9crire une m\u00e9thode bien_construit de la classe Arbre qui renvoie la valeur True si l\u2019arbre est \u00ab bien construit \u00bb et False sinon. On rappelle que la taille maximale d\u2019un arbre binaire de recherche de hauteur \\(\u210e\\) est \\(2^h - 1\\) . 6.a Quelle est la taille minimale, not\u00e9e min d\u2019un arbre binaire de recherche \u00ab bien construit \u00bb de hauteur \\(\u210e\\) ? corrig\u00e9 6.a. La configuration minimale d'un arbre bien construit de hauteur \\(h\\) peut \u00eatre : La taille minimale min est donc \u00e9gale \u00e0 \\(2^{h-1}\\) . 6.b \u00c9crire la m\u00e9thode bien_construit demand\u00e9e. corrig\u00e9 6.b. Intuitivement, un arbre est mal construit si sa hauteur est trop grande par rapport \u00e0 sa taille (trop \u00e9tir\u00e9 ). Donc un arbre est mal construit si sa taille est trop petite par rapport \u00e0 sa hauteur. Donc un arbre de taille \\(t\\) et de hauteur \\(h\\) est mal construit si \\(t < 2^{h-1}\\) , puisqu'on a d\u00e9montr\u00e9 que \\(2^{h-1}\\) \u00e9tait la taille minimale. Pour tester si un arbre est bien construit , on va donc juste v\u00e9rifier que \\(t \\geqslant 2^{h-1}\\) : \ud83d\udc0d Script Python 1 2 3 def bien_construit ( self ): h = self . taille () return self . taille () >= 2 ** ( h - 1 ) Exercice 5 2021, Polyn\u00e9sie Cet exercice traite principalement du th\u00e8me \u00ab algorithmique, langages et programmation \u00bb et en particulier les arbres binaires de recherche. La premi\u00e8re partie aborde les arbres en mode d\u00e9branch\u00e9 via l'application d'un algorithme sur un exemple. La suivante porte sur la programmation orient\u00e9e objet. La derni\u00e8re partie fait le lien avec les algorithmes de tri. Partie A : \u00c9tude d'un exemple Consid\u00e9rons l'arbre binaire de recherche ci-dessous : Q1. Indiquer quelle valeur a le n\u0153ud racine et quels sont les fils de ce n\u0153ud. corrig\u00e9 Le n\u0153ud racine est 5 et ses fils sont 2 et 7. Q2. Indiquer quels sont les n\u0153uds de la branche qui se termine par la feuille qui a pour valeur 3. corrig\u00e9 La branche qui se termine par la feuille 3 a pour n\u0153uds 5, 2 et 3. Q3. Dessiner l\u2019arbre obtenu apr\u00e8s l\u2019ajout de la valeur 6. corrig\u00e9 Partie B : Impl\u00e9mentation en Python Voici un extrait d\u2019une impl\u00e9mentation en Python d'une classe mod\u00e9lisant un arbre binaire de recherche. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class ABR : \"\"\"Impl\u00e9mentation d\u2019un arbre binaire de recherche (ABR)\"\"\" def __init__ ( self , valeur = None ): self . valeur = valeur self . fg = None self . fd = None def estVide ( self ): return self . valeur == None def insererElement ( self , e ): if self . estVide (): self . valeur = e else : if e < self . valeur : if self . fg : self . fg . insererElement ( e ) else : self . fg = ABR ( e ) if e > self . valeur : if self . fd : self . fd . insererElement ( e ) else : self . fd = ABR ( e ) Q1. Expliquer le r\u00f4le de la fonction __init__ . corrig\u00e9 La fonction __init__ est appel\u00e9e \u00abm\u00e9thode constructeur\u00bb, c'est elle qui cr\u00e9e l'objet et le dote de tous les attributs n\u00e9cessaires. Q2. Dans cette impl\u00e9mentation, expliquer ce qui se passe si on ajoute un \u00e9l\u00e9ment d\u00e9j\u00e0 pr\u00e9sent dans l\u2019arbre. corrig\u00e9 Si on ajoute un \u00e9l\u00e9ment d\u00e9j\u00e0 pr\u00e9sent dans l'arbre, la valeur e sera \u00e9gale \u00e0 self.valeur (\u00e9ventuellement apr\u00e8s quelques appels r\u00e9cursifs). Or ce cas d'\u00e9galit\u00e9 n'est pas pr\u00e9vu par les tests : il ne se passera donc RIEN. Ceci est le comportement souhait\u00e9 puisqu'on ne veut pas avoir deux valeurs identiques dans notre ABR, ainsi qu'il est rappel\u00e9 au d\u00e9but de l'\u00e9nonc\u00e9. Q3. Recopier et compl\u00e9ter les pointill\u00e9s ci-dessous permettant de cr\u00e9er l\u2019arbre de la partie A. \ud83d\udc0d Script Python arbre = ABR ( .......... ) arbre . insererElement ( 2 ) arbre . insererElement ( .......... ) arbre . insererElement ( 7 ) arbre . insererElement ( .......... ) corrig\u00e9 \ud83d\udc0d Script Python arbre = ABR ( 5 ) arbre . insererElement ( 2 ) arbre . insererElement ( 3 ) arbre . insererElement ( 7 ) arbre . insererElement ( 8 ) Partie C : Tri par arbre binaire de recherche On souhaite trier un ensemble de valeurs enti\u00e8res distinctes gr\u00e2ce \u00e0 un arbre binaire de recherche. Pour cela, on ajoute un \u00e0 un les \u00e9l\u00e9ments de l\u2019ensemble dans un arbre initialement vide. Il ne reste plus qu\u2019\u00e0 parcourir l\u2019arbre afin de lire et de stocker dans un tableau r\u00e9sultat les valeurs dans l\u2019ordre croissant. Q1. Donner le nom du parcours qui permet de visiter les valeurs d\u2019un arbre binaire de recherche dans l\u2019ordre croissant. corrig\u00e9 Le parcours qui permet de visiter les valeurs d'un ABR dans l'ordre croissant est le parcours infixe. Q2. Comparer la complexit\u00e9 de cette m\u00e9thode de tri avec celle du tri par insertion ou du tri par s\u00e9lection. corrig\u00e9 question difficile Pour cr\u00e9er l'ABR, il faut d'abord ins\u00e9rer chacune des valeurs. La fonction insertion reposant sur une division par 2 \u00e0 chaque \u00e9tape de la taille de l'espace de recherche, on peut dire qu'elle a une complexit\u00e9 logarithmique. Mais cette op\u00e9ration est \u00e0 effectuer autant de fois qu'il y a d'\u00e9l\u00e9ments \u00e0 ins\u00e9rer : il faut donc multiplier la complexit\u00e9 logarithmique par n , ce qui fera donc une complexit\u00e9 en \\(n \\log(n)\\) . L'algorithme de parcours infixe est lui aussi lin\u00e9raire, ce qui ne change pas la complexit\u00e9 totale. Cette complexit\u00e9 est meilleure que le tris par insertion ou s\u00e9lection, qui sont de complexit\u00e9 quadratique. Exercice 6 2021, Centres \u00c9trangers, sujet 1 Un arbre binaire est soit vide, soit un n\u0153ud qui a une valeur et au plus deux fils (le sous-arbre gauche et le sous-arbre droit). X est un n\u0153ud, sa valeur est X.valeur G1 est le fils gauche de X, not\u00e9 X.fils_gauche D1 est le fils droit de X, not\u00e9 X.fils_droit Un arbre binaire de recherche est ordonn\u00e9 de la mani\u00e8re suivante : Pour chaque n\u0153ud X, les valeurs de tous les n\u0153uds du sous-arbre gauche sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X les valeurs de tous les n\u0153uds du sous-arbre droit sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X. Ainsi, par exemple, toutes les valeurs des n\u0153uds G1, G2 et G3 sont strictement inf\u00e9rieures \u00e0 la valeur du n\u0153ud X et toutes les valeurs des n\u0153uds D1, D2 et D3 sont sup\u00e9rieures ou \u00e9gales \u00e0 la valeur du n\u0153ud X. Voici un exemple d'arbre binaire de recherche dans lequel on a stock\u00e9 dans cet ordre les valeurs : [26, 3, 42, 15, 29, 19, 13, 1, 32, 37, 30] L'\u00e9tiquette d'un n\u0153ud indique la valeur du n\u0153ud suivie du nom du n\u0153ud. Les n\u0153uds ont \u00e9t\u00e9 nomm\u00e9s dans l'ordre de leur insertion dans l'arbre ci-dessous. '29, noeud04' signifie que le n\u0153ud nomm\u00e9 noeud04 poss\u00e8de la valeur 29. Q1. On ins\u00e8re la valeur 25 dans l'arbre, dans un nouveau n\u0153ud nomm\u00e9 n\u0153ud11. Recopier l'arbre binaire de recherche \u00e9tudi\u00e9 et placer la valeur 25 sur cet arbre en coloriant en rouge le chemin parcouru. Pr\u00e9ciser sous quel n\u0153ud la valeur 25 sera ins\u00e9r\u00e9e et si elle est ins\u00e9r\u00e9e en fils gauche ou en fils droit, et expliquer toutes les \u00e9tapes de la d\u00e9cision. corrig\u00e9 25 \u00e9tant plus petit que 26, on part dans son sous-arbre gauche. 25 \u00e9tant plus grand que 3, on part dans son sous-arbre droit. 25 \u00e9tant plus grand que 15, on part dans son sous-arbre droit. 25 \u00e9tant plus grand que 19, on ins\u00e8re 25 en tant que fils droit de 19. Q2. Pr\u00e9ciser toutes les valeurs enti\u00e8res que l\u2019on peut stocker dans le n\u0153ud fils gauche du n\u0153ud04 (vide pour l'instant), en respectant les r\u00e8gles sur les arbres binaires de recherche. corrig\u00e9 Les valeurs acceptables doivent \u00eatre strictement inf\u00e9rieures \u00e0 29, et sup\u00e9rieures ou \u00e9gales \u00e0 26. Ces valeurs sont donc : 26, 27 et 28. Q3. Voici un algorithme r\u00e9cursif permettant de parcourir et d'afficher les valeurs de l'arbre : \ud83d\udc0d Script Python Parcours ( A ) # A est un arbre binaire de recherche Afficher ( A . valeur ) Parcours ( A . fils_gauche ) Parcours ( A . fils_droit ) Q3.a. \u00c9crire la liste de toutes les valeurs dans l'ordre o\u00f9 elles seront affich\u00e9es. corrig\u00e9 Les valeurs seront affich\u00e9es dans l'ordre suivant : 26-3-1-15-13-19-25-42-29-32-30-37 Q3.b. Choisir le type de parcours d'arbres binaires de recherche r\u00e9alis\u00e9 parmi les propositions suivantes : Pr\u00e9fixe, Suffixe ou Infixe. corrig\u00e9 On reconnait un parcours pr\u00e9fixe. Q4. En vous inspirant de l\u2019algorithme pr\u00e9c\u00e9dent, \u00e9crire un algorithme Parcours2 permettant de parcourir et d'afficher les valeurs de l'arbre A dans l'ordre croissant. corrig\u00e9 Pour afficher les valeurs d'un ABR dans un ordre croissant, il faut utiliser un parcours infixe. Un algorithme r\u00e9cursif de parcours infixe peut \u00eatre celui-ci: \ud83d\udc0d Script Python Parcours2 ( A ) # A est un arbre binaire de recherche Parcours ( A . fils_gauche ) Afficher ( A . valeur ) Parcours ( A . fils_droit ) Exercice 7 Exercice 3 du sujet Centres Etrangers J2 - 2023 Correction Q1.a. 'Bonjour Alan !' Correction Q1.b. Ce sont des bool\u00e9ens. x vaut False , y vaut True . Correction Q1.c. \ud83d\udc0d Script Python 1 2 3 4 5 6 def occurences_lettre ( une_chaine , une_lettre ): nb = 0 for lettre in une_chaine : if lettre == une_lettre : nb += 1 return nb Correction Q3.b.. \ud83d\udc0d Script Python 1 2 3 4 5 def hauteur ( un_abr ): if un_abr . est_vide (): return 0 else : return 1 + max ( hauteur ( un_abr . sous_arbre_gauche , hauteur ( un_abr . sous_arbre_droit ) Fichier des mots fran\u00e7ais : gutemberg.txt", "title": "Exercices"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/", "text": "R\u00e9solution d'un labyrinthe \u2693\ufe0e 1. Pr\u00e9sentation du probl\u00e8me \u2693\ufe0e Consid\u00e9rons le labyrinthe suivant : Affectons une lettre \u00e0 chaque case de ce labyrinthe. Notre objectif est de trouver comment aller de A en P . 2. Mod\u00e9lisation par un graphe \u2693\ufe0e Dessiner le graphe (dont les noeuds seront des lettres) qui mod\u00e9lise ce labyrinthe. Proposer deux \u00abformes\u00bb possibles pour ce graphe. Correction 3. Impl\u00e9mentation du graphe en Python \u2693\ufe0e En utilisant la classe Graphe cr\u00e9\u00e9e en cours, impl\u00e9menter le graphe de ce labyrinthe. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Graphe : def __init__ ( self , liste_sommets ): self . liste_sommets = liste_sommets self . adjacents = { sommet : [] for sommet in liste_sommets } def ajoute_arete ( self , sommetA , sommetB ): self . adjacents [ sommetA ] . append ( sommetB ) self . adjacents [ sommetB ] . append ( sommetA ) def voisins ( self , sommet ): return self . adjacents [ sommet ] def sont_voisins ( self , sommetA , sommetB ): return sommetB in self . adjacents [ sommetA ] g = Graphe ([ 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' ]) g . ajoute_arete ( 'A' , 'E' ) g . ajoute_arete ( 'E' , 'F' ) g . ajoute_arete ( 'F' , 'B' ) g . ajoute_arete ( 'B' , 'C' ) g . ajoute_arete ( 'C' , 'G' ) g . ajoute_arete ( 'G' , 'H' ) g . ajoute_arete ( 'H' , 'D' ) g . ajoute_arete ( 'G' , 'K' ) g . ajoute_arete ( 'F' , 'J' ) g . ajoute_arete ( 'J' , 'I' ) g . ajoute_arete ( 'I' , 'M' ) g . ajoute_arete ( 'M' , 'N' ) g . ajoute_arete ( 'N' , 'O' ) g . ajoute_arete ( 'O' , 'K' ) g . ajoute_arete ( 'K' , 'L' ) g . ajoute_arete ( 'L' , 'P' ) 4. Recherche du plus court chemin \u2693\ufe0e En utilisant la fonction recherche_chemin du cours, \u00e9tablir le plus court chemin pour aller de A vers P dans ce labyrinthe. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def recherche_chemin ( g , depart , arrivee ): ''' Parcours en largeur du graphe g en partant du sommet depart, qui s'arr\u00eate d\u00e8s que le sommet arrivee est atteint. Renvoie alors le chemin du depart vers arrivee. ''' traites = [] decouverts = [ depart ] en_attente = [ depart ] parent = {} while en_attente != [] : sommet = en_attente . pop ( 0 ) voisins = g . voisins ( sommet ) for voisin in voisins : if voisin not in decouverts : decouverts . append ( voisin ) en_attente . append ( voisin ) parent [ voisin ] = sommet if voisin == arrivee : return remonte_chemin ( depart , arrivee , parent ) traites . append ( sommet ) return \"non trouv\u00e9\" def remonte_chemin ( depart , arrivee , parent ): sommet = arrivee chemin = arrivee while sommet != depart : sommet = parent [ sommet ] chemin = sommet + chemin return chemin \ud83d\udc0d Script Python >>> recherche_chemin ( g , 'A' , 'P' ) 'AEFBCGKLP' 5. Conclusion \u2693\ufe0e Sur un labyrinthe un peu plus imposant, voici l'illustration de notre m\u00e9thode de r\u00e9solution : le parcours en largeur part d\u00e9couvrir les cases dans toutes les directions. lorsque la case cherch\u00e9e (ici, la rouge) est trouv\u00e9e, on remonte \u00e0 chaque case pr\u00e9c\u00e9dente gr\u00e2ce au dictionnaire parent , et ainsi le chemin de sortie du labyrinthe est g\u00e9n\u00e9r\u00e9. Code de cette animation (en Pygame) 6. Annexe : et pourquoi pas en DFS ? \u2693\ufe0e Les parcours BFS et DFS ont tous deux la propri\u00e9t\u00e9 de parcourir la totalit\u00e9 du graphe (ils sont m\u00eame con\u00e7us pour cela). Cela a permis au parcours BFS de nous fournir une solution au labyrinthe (dont on a d\u00e9montr\u00e9 qu'elle \u00e9tait la plus courte). Que penser de solution qui sera donn\u00e9e par le DFS ? 6.1 Dans un labyrinthe parfait \u2693\ufe0e Voici un code o\u00f9 la solution est d'abord recherch\u00e9e par BFS (cases explor\u00e9es en bleu clair, chemin trouv\u00e9 marqu\u00e9 en bleu), puis en DFS (cases explor\u00e9es en rose, chemin trouv\u00e9 marqu\u00e9 en rouge). anim_laby_DFSvsBFS_laby_parfait.py Que remarquez-vous ??? 6.2 Dans un labyrinthe non parfait \u2693\ufe0e Changeons de code pour un labyrinthe d\u00e9g\u00e9n\u00e9r\u00e9 : anim_laby_DFSvsBFS_laby_degenere.py Que remarquez-vous ??? Explications Notre labyrinthe con\u00e7u de mani\u00e8re al\u00e9atoire poss\u00e8de une propri\u00e9t\u00e9 remarquable (d\u00fb son algorithme de construction) : chaque case peut \u00eatre reli\u00e9e \u00e0 une autre par un chemin unique . On dit de ces labyrinthes qu'ils sont parfaits . Donc, dans notre code du 6.1 (labyrinthe parfait), le DFS va lui aussi trouver le chemin le plus court... puisqu'il y en a qu'un seul ! De plus, la m\u00e9thode d'exploration en profondeur va de plus rendre le DFS plus rapide que le BFS, quasiment tout le temps. Ce qui fait que pour un labyrinthe parfait, le DFS est plus int\u00e9ressant que le BFS. Mais si le labyrinthe n'est plus parfait (code du 6.2), le DFS va trouver une solution qui ne sera pas obligatoirement la meilleure... S'il y a plusieurs solutions possibles, absolument rien ne garantit que la premi\u00e8re solution trouv\u00e9e par le DFS (sur laquelle il s'arr\u00eatera) sera la meilleure !", "title": "TP Labyrinthe"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#resolution-dun-labyrinthe", "text": "", "title": "R\u00e9solution d'un labyrinthe"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#1-presentation-du-probleme", "text": "Consid\u00e9rons le labyrinthe suivant : Affectons une lettre \u00e0 chaque case de ce labyrinthe. Notre objectif est de trouver comment aller de A en P .", "title": "1. Pr\u00e9sentation du probl\u00e8me"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#2-modelisation-par-un-graphe", "text": "Dessiner le graphe (dont les noeuds seront des lettres) qui mod\u00e9lise ce labyrinthe. Proposer deux \u00abformes\u00bb possibles pour ce graphe. Correction", "title": "2. Mod\u00e9lisation par un graphe"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#3-implementation-du-graphe-en-python", "text": "En utilisant la classe Graphe cr\u00e9\u00e9e en cours, impl\u00e9menter le graphe de ce labyrinthe. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Graphe : def __init__ ( self , liste_sommets ): self . liste_sommets = liste_sommets self . adjacents = { sommet : [] for sommet in liste_sommets } def ajoute_arete ( self , sommetA , sommetB ): self . adjacents [ sommetA ] . append ( sommetB ) self . adjacents [ sommetB ] . append ( sommetA ) def voisins ( self , sommet ): return self . adjacents [ sommet ] def sont_voisins ( self , sommetA , sommetB ): return sommetB in self . adjacents [ sommetA ] g = Graphe ([ 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' ]) g . ajoute_arete ( 'A' , 'E' ) g . ajoute_arete ( 'E' , 'F' ) g . ajoute_arete ( 'F' , 'B' ) g . ajoute_arete ( 'B' , 'C' ) g . ajoute_arete ( 'C' , 'G' ) g . ajoute_arete ( 'G' , 'H' ) g . ajoute_arete ( 'H' , 'D' ) g . ajoute_arete ( 'G' , 'K' ) g . ajoute_arete ( 'F' , 'J' ) g . ajoute_arete ( 'J' , 'I' ) g . ajoute_arete ( 'I' , 'M' ) g . ajoute_arete ( 'M' , 'N' ) g . ajoute_arete ( 'N' , 'O' ) g . ajoute_arete ( 'O' , 'K' ) g . ajoute_arete ( 'K' , 'L' ) g . ajoute_arete ( 'L' , 'P' )", "title": "3. Impl\u00e9mentation du graphe en Python"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#4-recherche-du-plus-court-chemin", "text": "En utilisant la fonction recherche_chemin du cours, \u00e9tablir le plus court chemin pour aller de A vers P dans ce labyrinthe. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def recherche_chemin ( g , depart , arrivee ): ''' Parcours en largeur du graphe g en partant du sommet depart, qui s'arr\u00eate d\u00e8s que le sommet arrivee est atteint. Renvoie alors le chemin du depart vers arrivee. ''' traites = [] decouverts = [ depart ] en_attente = [ depart ] parent = {} while en_attente != [] : sommet = en_attente . pop ( 0 ) voisins = g . voisins ( sommet ) for voisin in voisins : if voisin not in decouverts : decouverts . append ( voisin ) en_attente . append ( voisin ) parent [ voisin ] = sommet if voisin == arrivee : return remonte_chemin ( depart , arrivee , parent ) traites . append ( sommet ) return \"non trouv\u00e9\" def remonte_chemin ( depart , arrivee , parent ): sommet = arrivee chemin = arrivee while sommet != depart : sommet = parent [ sommet ] chemin = sommet + chemin return chemin \ud83d\udc0d Script Python >>> recherche_chemin ( g , 'A' , 'P' ) 'AEFBCGKLP'", "title": "4. Recherche du plus court chemin"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#5-conclusion", "text": "Sur un labyrinthe un peu plus imposant, voici l'illustration de notre m\u00e9thode de r\u00e9solution : le parcours en largeur part d\u00e9couvrir les cases dans toutes les directions. lorsque la case cherch\u00e9e (ici, la rouge) est trouv\u00e9e, on remonte \u00e0 chaque case pr\u00e9c\u00e9dente gr\u00e2ce au dictionnaire parent , et ainsi le chemin de sortie du labyrinthe est g\u00e9n\u00e9r\u00e9. Code de cette animation (en Pygame)", "title": "5. Conclusion"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#6-annexe-et-pourquoi-pas-en-dfs", "text": "Les parcours BFS et DFS ont tous deux la propri\u00e9t\u00e9 de parcourir la totalit\u00e9 du graphe (ils sont m\u00eame con\u00e7us pour cela). Cela a permis au parcours BFS de nous fournir une solution au labyrinthe (dont on a d\u00e9montr\u00e9 qu'elle \u00e9tait la plus courte). Que penser de solution qui sera donn\u00e9e par le DFS ?", "title": "6. Annexe : et pourquoi pas en DFS ?"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#61-dans-un-labyrinthe-parfait", "text": "Voici un code o\u00f9 la solution est d'abord recherch\u00e9e par BFS (cases explor\u00e9es en bleu clair, chemin trouv\u00e9 marqu\u00e9 en bleu), puis en DFS (cases explor\u00e9es en rose, chemin trouv\u00e9 marqu\u00e9 en rouge). anim_laby_DFSvsBFS_laby_parfait.py Que remarquez-vous ???", "title": "6.1 Dans un labyrinthe parfait"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/TP_Labyrinthe/#62-dans-un-labyrinthe-non-parfait", "text": "Changeons de code pour un labyrinthe d\u00e9g\u00e9n\u00e9r\u00e9 : anim_laby_DFSvsBFS_laby_degenere.py Que remarquez-vous ??? Explications Notre labyrinthe con\u00e7u de mani\u00e8re al\u00e9atoire poss\u00e8de une propri\u00e9t\u00e9 remarquable (d\u00fb son algorithme de construction) : chaque case peut \u00eatre reli\u00e9e \u00e0 une autre par un chemin unique . On dit de ces labyrinthes qu'ils sont parfaits . Donc, dans notre code du 6.1 (labyrinthe parfait), le DFS va lui aussi trouver le chemin le plus court... puisqu'il y en a qu'un seul ! De plus, la m\u00e9thode d'exploration en profondeur va de plus rendre le DFS plus rapide que le BFS, quasiment tout le temps. Ce qui fait que pour un labyrinthe parfait, le DFS est plus int\u00e9ressant que le BFS. Mais si le labyrinthe n'est plus parfait (code du 6.2), le DFS va trouver une solution qui ne sera pas obligatoirement la meilleure... S'il y a plusieurs solutions possibles, absolument rien ne garantit que la premi\u00e8re solution trouv\u00e9e par le DFS (sur laquelle il s'arr\u00eatera) sera la meilleure !", "title": "6.2 Dans un labyrinthe non parfait"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/", "text": "Graphes \u2693\ufe0e Ce cours est int\u00e9gralement inspir\u00e9 du cours de C\u00e9dric Gouygou , du lyc\u00e9e Marguerite de Valois d'Angoul\u00eame (16) 1. Notion de graphe et vocabulaire \u2693\ufe0e Le concept de graphe permet de r\u00e9soudre de nombreux probl\u00e8mes en math\u00e9matiques comme en informatique. C'est un outil de repr\u00e9sentation tr\u00e8s courant, et nous l'avons d\u00e9j\u00e0 rencontr\u00e9 \u00e0 plusieurs reprises, en particulier lors de l'\u00e9tude de r\u00e9seaux. 1.1 Exemples de situations \u2693\ufe0e 1.1.1 R\u00e9seau informatique \u2693\ufe0e 1.1.2 R\u00e9seau de transport \u2693\ufe0e 1.1.3 R\u00e9seau social \u2693\ufe0e 1.1.4 G\u00e9n\u00e9ralisation \u2693\ufe0e Une multitude de probl\u00e8mes concrets d'origines tr\u00e8s diverses peuvent donner lieu \u00e0 des mod\u00e9lisations par des graphes : c'est donc une structure essentielle en sciences, qui requiert un formalisme math\u00e9matique particulier que nous allons d\u00e9couvrir. L'\u00e9tude de la th\u00e9orie des graphes est un champ tr\u00e8s vaste des math\u00e9matiques : nous allons surtout nous int\u00e9resser \u00e0 l'impl\u00e9mentation en Python d'un graphe et \u00e0 diff\u00e9rents probl\u00e8mes algorithmiques qui se posent dans les graphes. 1.2 Vocabulaire \u2693\ufe0e En g\u00e9n\u00e9ral, un graphe est un ensemble d'objets, appel\u00e9s sommets ou parfois n\u0153uds ( vertex or nodes en anglais) reli\u00e9s par des ar\u00eates ou arcs (( edges en anglais)). Ce graphe peut \u00eatre non-orient\u00e9 ou orient\u00e9 . 1.2.1 Graphe non-orient\u00e9 \u2693\ufe0e Dans un graphe non-orient\u00e9 , les ar\u00eates peuvent \u00eatre emprunt\u00e9es dans les deux sens, et une cha\u00eene est une suite de sommets reli\u00e9s par des ar\u00eates, comme C - B - A - E par exemple. La longueur de cette cha\u00eene est alors 3, soit le nombre d'ar\u00eates. Les sommets B et E sont adjacents au sommet A, ce sont les voisins de A. Exemple de graphe non-orient\u00e9 : le graphe des relations d'un individu sur Facebook est non-orient\u00e9, car si on est \u00abami\u00bb avec quelqu'un la r\u00e9ciproque est vraie. 1.2.2 Graphe orient\u00e9 \u2693\ufe0e Dans un graphe orient\u00e9 , les arcs ne peuvent \u00eatre emprunt\u00e9s que dans le sens de la fl\u00e8che, et un chemin est une suite de sommets reli\u00e9s par des arcs, comme B \u2192 C \u2192 D \u2192 E par exemple. Les sommets C et D sont adjacents au sommet B (mais pas A !), ce sont les voisins de B. Exemple de graphe orient\u00e9 : le graphe des relations d'un individu sur Twitter est orient\u00e9, car on peut \u00absuivre\u00bb quelqu'un sans que cela soit r\u00e9ciproque. 1.2.3 Graphe pond\u00e9r\u00e9 \u2693\ufe0e Un graphe est pond\u00e9r\u00e9 (ou valu\u00e9) si on attribue \u00e0 chaque ar\u00eate une valeur num\u00e9rique (la plupart du temps positive), qu'on appelle mesure , poids , co\u00fbt ou valuation . Par exemple: dans le protocole OSPF, on pond\u00e8re les liaisons entre routeurs par le co\u00fbt; dans un r\u00e9seau routier entre plusieurs villes, on pond\u00e8re par les distances. 1.2.4 Connexit\u00e9 \u2693\ufe0e Un graphe est connexe s'il est d'un seul tenant: c'est-\u00e0-dire si n'importe quelle paire de sommets peut toujours \u00eatre reli\u00e9e par une cha\u00eene. Autrement un graphe est connexe s'il est \u00aben un seul morceau\u00bb. Par exemple, le graphe pr\u00e9c\u00e9dent est connexe. Mais le suivant ne l'est pas: il n'existe pas de cha\u00eene entre les sommets A et F par exemple. Il poss\u00e8de cependant deux composantes connexes : le sous-graphe compos\u00e9 des sommets A, B, C, D et E d'une part et le sous-graphe compos\u00e9 des sommets F, G et H. 2. Mod\u00e9lisations d'un graphe \u2693\ufe0e Pour mod\u00e9liser un graphe, il faut \u00e9tablir par convention une mani\u00e8re de donner les renseignements suivants : qui sont les sommets ? pour chaque sommet, quels sont ses voisins ? (et \u00e9ventuellement quel poids porte l'ar\u00eate qui les relie) 2.1 Repr\u00e9sentation par matrice d'adjacence \u2693\ufe0e Principe On classe les sommets (en les num\u00e9rotant, ou par ordre alphab\u00e9tique). on repr\u00e9sente les ar\u00eates (ou les arcs) dans une matrice, c'est-\u00e0-dire un tableau \u00e0 deux dimensions o\u00f9 on inscrit un 1 en ligne i et colonne j si les sommets de rang i et de rang j sont voisins (dits aussi adjacents ). Ce tableau s'appelle une matrice d'adjacence (on aurait tr\u00e8s bien pu l'appeler aussi matrice de voisinage ). 2.1.1 Graphe non orient\u00e9 \u2693\ufe0e Dans ce graphe non orient\u00e9, comme B est voisin de C, C est aussi voisin de B, ce qui signifie que l'ar\u00eate qui relie B et C va donner lieu \u00e0 deux \"1\" dans la matrice, situ\u00e9 de part et d'autre de la diagonale descendante (un math\u00e9maticien parlera de matrice sym\u00e9trique ). 2.1.2 Graphe orient\u00e9 \u2693\ufe0e 2.1.3 Graphe pond\u00e9r\u00e9 \u2693\ufe0e 2.1.4 Exercices \u2693\ufe0e Exercice 1 Soit un ensemble d'amis connect\u00e9s sur un r\u00e9seau social quelconque. Voici les interactions qu'on a recens\u00e9es : Andr\u00e9 est ami avec B\u00e9a, Charles, Estelle et Fabrice, B\u00e9a est amie avec Andr\u00e9, Charles, Denise et H\u00e9lo\u00efse, Charles est ami avec Andr\u00e9, B\u00e9a, Denise, Estelle, Fabrice et Gilbert, Denise est amie avec B\u00e9a, Charles et Estelle, Estelle est amie avec Andr\u00e9, Charles et Denise, Fabrice est ami avec Andr\u00e9, Charles et Gilbert, Gilbert est ami avec Charles et Fabrice, H\u00e9lo\u00efse est amie avec B\u00e9a. Q1. Repr\u00e9senter le graphe des relations dans ce r\u00e9seau social (on d\u00e9signera chaque individu par l'initiale de son pr\u00e9nom). Il est possible de faire en sorte que les ar\u00eates ne se croisent pas ! Correction Q1 Q2. Donner la matrice d'adjacence de ce graphe. Correction Q2 \\(\\pmatrix{ 0 & 1 & 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 1 & 1 & 1 & 1 & 0 \\\\ 0 & 1 & 1 & 0 & 1 & 0 & 0 & 0 \\\\ 1 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\\\ 1 & 0 & 1 & 0 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ }\\) Exercice 2 Construire les graphes correspondants aux matrices d'adjacence suivantes: Q1. \\(M_1 =\\pmatrix{ 0&1&1&1&1\\\\ 1&0&1&0&0\\\\ 1&1&0&1&0\\\\ 1&0&1&0&1\\\\ 1&0&0&1&0\\\\ }\\) Correction Q2. \\(M_2=\\pmatrix{ 0&1&1&0&1\\\\ 0&0&1&0&0\\\\ 0&0&0&1&0\\\\ 1&0&0&0&1\\\\ 0&0&0&0&0\\\\ }\\) Correction Q3. \\(M_3=\\pmatrix{ 0&5&10&50&12\\\\ 5&0&10&0&0\\\\ 10&10&0&8&0\\\\ 50&0&8&0&100\\\\ 12&0&0&100&0\\\\ }\\) Correction 2.1.5 Impl\u00e9mentation Python des matrices d'adjacence \u2693\ufe0e Matrices d'adjacence en Python Une matrice se repr\u00e9sente naturellement par une liste de listes. Exemple: La matrice \\(M_1 =\\pmatrix{ 0&1&1&1&1\\\\ 1&0&1&0&0\\\\ 1&1&0&1&0\\\\ 1&0&1&0&1\\\\ 1&0&0&1&0\\\\ }\\) , associ\u00e9e au graphe sera repr\u00e9sent\u00e9e par la variable G suivante : \ud83d\udc0d Script Python G = [[ 0 , 1 , 1 , 1 , 1 ], [ 1 , 0 , 1 , 0 , 0 ], [ 1 , 1 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 , 1 ], [ 1 , 0 , 0 , 1 , 0 ]] Complexit\u00e9 en m\u00e9moire et temps d'acc\u00e8s : Pour un graphe \u00e0 \\(n\\) sommets, la complexit\u00e9 en m\u00e9moire (appel\u00e9e aussi complexit\u00e9 spatiale ) de la repr\u00e9sentation matricielle est en \\(O(n^2)\\) . Tester si un sommet est isol\u00e9 (ou conna\u00eetre ses voisins) est en \\(O(n)\\) puisqu'il faut parcourir une ligne, mais tester si deux sommets sont adjacents (voisins) est en \\(O(1)\\) , c'est un simple acc\u00e8s au tableau. La mod\u00e9lisation d'un graphe par sa matrice d'adjacence est loin d'\u00eatre la seule mani\u00e8re de repr\u00e9senter un graphe : nous allons voir une autre mod\u00e9lisation, par liste d'adjacence . 2.2 Repr\u00e9sentation par listes d'adjacence \u2693\ufe0e Principe On associe \u00e0 chaque sommet sa liste des voisins (c'est-\u00e0-dire les sommets adjacents). On utilise pour cela un dictionnaire dont les cl\u00e9s sont les sommets et les valeurs les listes des voisins. Dans le cas d'un graphe orient\u00e9 on associe \u00e0 chaque sommet la liste des successeurs (ou bien des pr\u00e9d\u00e9cesseurs , au choix). Par exemple, le graphe sera repr\u00e9sent\u00e9 par le dictionnaire : \ud83d\udc0d Script Python 1 2 3 4 5 6 G = { 'A' : [ 'B' , 'C' , 'D' , 'E' ], 'B' : [ 'A' , 'C' ], 'C' : [ 'A' , 'B' , 'D' ], 'D' : [ 'A' , 'C' , 'E' ], 'E' : [ 'A' , 'D' ] } Complexit\u00e9 en m\u00e9moire et temps d'acc\u00e8s : Pour un graphe \u00e0 \\(n\\) sommets et \\(m\\) ar\u00eates, la complexit\u00e9 spatiale de la repr\u00e9sentation en liste d'adjacence est en \\(O(n+m)\\) . C'est beaucoup mieux qu'une matrice d'adjacence lorsque le graphe comporte peu d'ar\u00eates (i.e. beaucoup de 0 dans la matrice, non stock\u00e9s avec des listes). Tester si un sommet est isol\u00e9 (ou conna\u00eetre ses voisins) est en \\(O(1)\\) puisqu'on y acc\u00e8de imm\u00e9diatement, mais tester si deux sommets sont adjacents (voisins) est en \\(O(n)\\) car il faut parcourir la liste. 2.2.1 Exercices \u2693\ufe0e Exercice 3 Construire les graphes correspondants aux listes d'adjacence suivantes. Q1. \ud83d\udc0d Script Python G1 = { 'A' : [ 'B' , 'C' ], 'B' : [ 'A' , 'C' , 'E' , 'F' ], 'C' : [ 'A' , 'B' , 'D' ], 'D' : [ 'C' , 'E' ], 'E' : [ 'B' , 'D' , 'F' ], 'F' : [ 'B' , 'E' ] } Correction Q1 Q2. \ud83d\udc0d Script Python G2 = { 'A' : [ 'B' ], 'B' : [ 'C' , 'E' ], 'C' : [ 'B' , 'D' ], 'D' : [], 'E' : [ 'A' ] } Correction Q2 3. Cr\u00e9ation d'une classe Graphe \u2693\ufe0e Dans cette partie, nous ne traiterons que des graphes non-orient\u00e9s . 3.1 Interface souhait\u00e9e \u2693\ufe0e Nous voulons que le graphe puisse \u00eatre cr\u00e9\u00e9 gr\u00e2ce aux instructions suivantes : \ud83d\udc0d Script Python g = Graphe ([ 'A' , 'B' , 'C' , 'D' , 'E' ]) g . ajoute_arete ( 'A' , 'B' ) g . ajoute_arete ( 'A' , 'C' ) g . ajoute_arete ( 'A' , 'D' ) g . ajoute_arete ( 'A' , 'E' ) g . ajoute_arete ( 'B' , 'C' ) g . ajoute_arete ( 'C' , 'D' ) g . ajoute_arete ( 'D' , 'E' ) Nous souhaitons aussi pouvoir tester si deux sommets sont voisins avec la m\u00e9thode sont_voisins : \ud83d\udc0d Script Python >>> g . sont_voisins ( 'E' , 'A' ) True >>> g . sont_voisins ( 'E' , 'B' ) False Enfin, nous voulons pouvoir obtenir facilement la liste de tous les voisins d'un sommet avec la m\u00e9thode voisins : \ud83d\udc0d Script Python >>> g . voisins ( 'C' ) [ 'A' , 'B' , 'D' ] 3.2 Conseils d'impl\u00e9mentation \u2693\ufe0e L'objet de type Graphe aura comme attributs : une liste liste_sommets (donn\u00e9e en param\u00e8tre dans la liste liste_sommets ) un dictionnaire adjacents , o\u00f9 chaque sommet se verra attribuer une liste vide [] . 3.3 Impl\u00e9mentation \u2693\ufe0e Impl\u00e9mentation d'une classe Graphe \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Graphe : def __init__ ( self , liste_sommets ): self . liste_sommets = liste_sommets self . adjacents = { sommet : [] for sommet in liste_sommets } def ajoute_arete ( self , sommetA , sommetB ): self . adjacents [ sommetA ] . append ( sommetB ) self . adjacents [ sommetB ] . append ( sommetA ) def voisins ( self , sommet ): return self . adjacents [ sommet ] def sont_voisins ( self , sommetA , sommetB ): return sommetB in self . adjacents [ sommetA ] 4. Parcours de graphes \u2693\ufe0e Algorithme de parcours Un parcours de graphe est un algorithme consistant \u00e0 explorer tous les sommets d'un graphe de proche en proche \u00e0 partir d'un sommet initial. Ces parcours sont notamment utilis\u00e9s pour rechercher un plus court chemin (et donc dans les GPS) ou pour trouver la sortie d'un labyrinthe... Parcourir simplement le dictionnaire ou la matrice d\u2019un graphe n\u2019est pas consid\u00e9r\u00e9 comme un parcours de graphe. Tous les parcours suivent plus ou moins le m\u00eame algorithme de base : On visite un sommet A . On cr\u00e9e une structure S qui contiendra au d\u00e9part l\u2019 ensemble des voisins de A . Tant que S n\u2019est pas vide : on choisit un sommet s de S on visite s on ajoute \u00e0 S tous les voisins de s pas encore visit\u00e9s Sommets visit\u00e9s Contrairement \u00e0 un parcours d'arbre, o\u00f9 les fils d'un n\u0153ud ne peuvent pas avoir \u00e9t\u00e9 visit\u00e9s avant le n\u0153ud, un voisin d'un sommet peut avoir d\u00e9j\u00e0 \u00e9t\u00e9 visit\u00e9 en tant que voisin d'un sommet pr\u00e9c\u00e9dent... Il est donc n\u00e9cessaire de m\u00e9moriser les sommets d\u00e9ja visit\u00e9s ou d\u00e9couverts (on dira qu'un sommet est d\u00e9couvert lorsqu'on l'ajoute \u00e0 S ). Le choix de la structure de l'ensemble S est pr\u00e9pond\u00e9rant: Si on choisit une file (FIFO): on visitera les sommets dans l'ordre d'arriv\u00e9e, donc les plus proches du sommet pr\u00e9c\u00e9dent. On obtient donc un parcours en largeur BFS . Si on choisit une pile (LIFO): on visitera d'abord les derniers sommets arriv\u00e9s, donc on parcourt le graphe en visitant \u00e0 chaque \u00e9tape un voisin du pr\u00e9c\u00e9dent. On obtient donc un parcours en profondeur DFS . 4.1 Le parcours en largeur (BFS, Breadth First Search) \u2693\ufe0e 4.1.1 Principe \u2693\ufe0e Exemple de parcours en largeur, avec B comme sommet de d\u00e9part: Codes couleur : vert : les sommets non encore trait\u00e9s. rouge : le sommet en cours de traitement. orange : la file d'attente des sommets qui seront bient\u00f4t trait\u00e9s. On y rajoute \u00e0 chaque fois les voisins du sommet en cours de traitement, uniquement si ils n'ont pas encore \u00e9t\u00e9 d\u00e9couverts . noir : les sommets trait\u00e9s. 4.1.2 Algorithme BFS \u2693\ufe0e On utilise : une liste traites qui recueille les sommets visit\u00e9s (c'est-\u00e0-dire qu'on a fini de traiter, apr\u00e8s avoir ajout\u00e9 ses voisins dans la file d'attente) et qui sera renvoy\u00e9e \u00e0 la fin de l'algorithme; une liste decouverts qui contient les sommets d\u00e9couverts au fur et \u00e0 mesure du parcours; une file en_attente qui contient les sommets d\u00e9couverts mais non encore visit\u00e9s. On utilisera au choix une classe File \u00e9crite plus t\u00f4t dans l'ann\u00e9e ou tout simplement une list en utilisant pop ( 0 ) (pour d\u00e9filer) et append () (pour enfiler). En d\u00e9but d'algorithme, seul le sommet de d\u00e9part depart donn\u00e9 en param\u00e8tre est d\u00e9couvert. La fonction BFS renvoie la liste des sommets dans l'ordre de visite lors du parcours en largeur. Parcours en largeur - BFS \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def BFS ( g , depart ): ''' Effectue un parcours en largeur du graphe g en partant du sommet depart, et renvoie la liste des sommets visit\u00e9s dans l'ordre du parcours. ''' traites = [] decouverts = [ depart ] en_attente = [ depart ] while en_attente != [] : sommet = en_attente . pop ( 0 ) voisins = g . voisins ( sommet ) for voisin in voisins : if voisin not in decouverts : decouverts . append ( voisin ) en_attente . append ( voisin ) traites . append ( sommet ) return traites Int\u00e9r\u00eat de la liste decouverts La liste decouverts contient tous les sommets qui ont \u00e9t\u00e9 : soit trait\u00e9s (auquel cas ils sont dans la liste traites ) soit en attente (auquel cas ils sont dans la liste en_attente ) Le test de la ligne 13 if voisin not in decouverts : permet donc de ne pas mettre en file d'attente un voisin qui est (ou a \u00e9t\u00e9) d\u00e9j\u00e0 en file d'attente. Que contient la file en_attente ? \u00c0 chaque instant, la file en_attente contient des sommets \u00e0 la distance k+1 et \u00e0 la distance k du point de d\u00e9part : Exercice 4 Gr\u00e2ce \u00e0 la classe Graphe du 3.3, ce graphe s'impl\u00e9mente par : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 g = Graphe ([ 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' ]) g . ajoute_arete ( 'A' , 'B' ) g . ajoute_arete ( 'A' , 'C' ) g . ajoute_arete ( 'B' , 'D' ) g . ajoute_arete ( 'D' , 'C' ) g . ajoute_arete ( 'B' , 'E' ) g . ajoute_arete ( 'D' , 'E' ) g . ajoute_arete ( 'E' , 'F' ) g . ajoute_arete ( 'E' , 'G' ) g . ajoute_arete ( 'F' , 'G' ) g . ajoute_arete ( 'G' , 'H' ) Q1. Donner le parcours en largeur de g gr\u00e2ce \u00e0 l'algorithme BFS, si le sommet de d\u00e9part est B. Cela correspond au parcours pr\u00e9sent\u00e9 par le gif de d\u00e9but de paragraphe. correction Q1 \ud83d\udc0d Script Python >>> BFS ( g , 'B' ) [ 'B' , 'A' , 'D' , 'E' , 'C' , 'F' , 'G' , 'H' ] Q2. Deviner le parcours en largeur de d\u00e9part D, puis de d\u00e9part G. V\u00e9rifier gr\u00e2ce \u00e0 votre algorithme. Correction Q2 \ud83d\udc0d Script Python >>> BFS ( g , 'D' ) [ 'D' , 'B' , 'C' , 'E' , 'A' , 'F' , 'G' , 'H' ] >>> BFS ( g , 'G' ) [ 'G' , 'E' , 'F' , 'H' , 'B' , 'D' , 'A' , 'C' ] 4.1.3 Application du BFS : recherche du plus court chemin \u2693\ufe0e L'algorithme BFS d\u00e9couvre les sommets \u00abpar cercles concentriques\u00bb autour du point de d\u00e9part (ainsi que le montre la structure de la file d'attente). On d\u00e9couvre d'abord tous les sommets \u00e0 la distance 1 du point de d\u00e9part, puis \u00e0 la distance 2, puis 3, etc. Un sommet situ\u00e9 \u00e0 la distance 5 sera d\u00e9couvert en tant que voisin d'un sommet \u00e0 la distance 4, qui lui-m\u00eame aura \u00e9t\u00e9 d\u00e9couvert gr\u00e2ce \u00e0 un sommet \u00e0 la distance 3, qui lui-m\u00eame... On comprend donc que si on arrive \u00e0 se souvenir du sommet \u00abparent\u00bb de chaque sommet (celui qui lui a permis d'\u00eatre d\u00e9couvert), on pourra alors reconstituer un chemin permettant de remonter au point de d\u00e9part. Nous allons pour cela nous servir d'une structure de dictionnaire pour associer \u00e0 chaque sommet son sommet-parent. Il faudra ensuite une fonction pour recr\u00e9er le chemin. Pourquoi le plus court chemin ? Comment est-on s\u00fbr qu'un chemin va \u00eatre trouv\u00e9 entre deux sommets A et B ? Si le graphe est connexe, tout parcours BFS au d\u00e9part de A va parcourir l'int\u00e9gralit\u00e9 du graphe, et donc passera par B \u00e0 un moment. Un chemin sera donc forc\u00e9ment trouv\u00e9 entre A et B. Comment est-on s\u00fbr que ce chemin trouv\u00e9 est le plus court ? La d\u00e9couverte des sommets par cercles concentriques entre A et B nous assure qu'on ne peut pas rater le point B : s'il est \u00e0 la distance k de A, il sera forc\u00e9ment visit\u00e9 puisque tous les sommets \u00e0 la distance k vont passer par la liste d'attente, apr\u00e8s les sommets de distance k-1 et avant les sommets de distance k+1 . Lorsqu'on remontera de B vers A en passant par les sommets parents successifs, il ne peut y avoir qu'un seul sommet par \u00abcouche\u00bb : le chemin sera donc exactement de longueur k , il sera donc minimal. Recherche du plus court chemin \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def recherche_chemin ( g , depart , arrivee ): ''' Parcours en largeur du graphe g en partant du sommet depart, qui s'arr\u00eate d\u00e8s que le sommet arrivee est atteint. Renvoie alors le chemin du depart vers arrivee. ''' traites = [] decouverts = [ depart ] en_attente = [ depart ] parent = {} while en_attente != [] : sommet = en_attente . pop ( 0 ) voisins = g . voisins ( sommet ) for voisin in voisins : if voisin not in decouverts : decouverts . append ( voisin ) en_attente . append ( voisin ) parent [ voisin ] = sommet if voisin == arrivee : return remonte_chemin ( depart , arrivee , parent ) traites . append ( sommet ) return \"non trouv\u00e9\" def remonte_chemin ( depart , arrivee , parent ): sommet = arrivee chemin = arrivee while sommet != depart : sommet = parent [ sommet ] chemin = sommet + chemin return chemin Exercice 5 Tester le code pr\u00e9c\u00e9dent pour trouver le plus court chemin entre A et G, entre H et C, entre B et G... 4.2 Le parcours en profondeur (DFS, Depth First Search) \u2693\ufe0e 4.2.1 Parcours DFS r\u00e9cursif \u2693\ufe0e Le parcours en profondeur est un parcours o\u00f9 on va aller \u00able plus loin possible\u00bb sans se pr\u00e9occuper des autres voisins non visit\u00e9s : on va visiter le premier de ses voisins non trait\u00e9s, qui va faire de m\u00eame, etc. Lorsqu'il n'y a plus de voisin, on revient en arri\u00e8re pour aller voir le dernier voisin non visit\u00e9. Dans un labyrinthe, ce parcours s'explique tr\u00e8s bien : on prend tous les chemins sur la droite jusqu'\u00e0 rencontrer un mur, auquel cas on revient au dernier embranchement et on prend un autre chemin, puis on repart \u00e0 droite, etc. C'est un parcours qui s'\u00e9crit naturellement de mani\u00e8re r\u00e9cursive : Parcours en profondeur - DFS \ud83d\udc0d Script Python 1 2 3 4 5 6 def DFSrec ( g , traites , actuel ): traites . append ( actuel ) for voisin in g . voisins ( actuel ): if voisin not in traites : DFSrec ( g , traites , voisin ) return traites Exercice 6 Q1. Donner (de t\u00eate) le parcours DFS de ce graphe en partant de A. Rappel : les voisins sont donn\u00e9s par ordre alphab\u00e9tique. Le premier voisin de A est donc B. Q2. V\u00e9rifier avec le code pr\u00e9c\u00e9dent. Correction Q2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Graphe : def __init__ ( self , liste_sommets ): self . liste_sommets = liste_sommets self . adjacents = { sommet : [] for sommet in liste_sommets } def ajoute_arete ( self , sommetA , sommetB ): self . adjacents [ sommetA ] . append ( sommetB ) self . adjacents [ sommetB ] . append ( sommetA ) def voisins ( self , sommet ): return self . adjacents [ sommet ] def sont_voisins ( self , sommetA , sommetB ): return sommetB in self . adjacents [ sommetA ] g = Graphe ([ 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' ]) g . ajoute_arete ( 'A' , 'B' ) g . ajoute_arete ( 'A' , 'C' ) g . ajoute_arete ( 'B' , 'D' ) g . ajoute_arete ( 'D' , 'C' ) g . ajoute_arete ( 'B' , 'E' ) g . ajoute_arete ( 'D' , 'E' ) g . ajoute_arete ( 'E' , 'F' ) g . ajoute_arete ( 'E' , 'G' ) g . ajoute_arete ( 'F' , 'G' ) g . ajoute_arete ( 'G' , 'H' ) def DFSrec ( g , traites , actuel ): traites . append ( actuel ) for voisin in g . voisins ( actuel ): if voisin not in traites : DFSrec ( g , traites , voisin ) return traites \ud83d\udc0d Script Python >>> DFSrec ( g , [], 'A' ) [ 'A' , 'B' , 'D' , 'C' , 'E' , 'F' , 'G' , 'H' ] Q3. Reprendre les questions pr\u00e9c\u00e9dentes en changeant le sommet de d\u00e9part. 4.2.2 Parcours DFS it\u00e9ratif \u2693\ufe0e Il \u00absuffit\u00bb de remplacer la file du parcours BFS par une pile . Ainsi, on partira visiter le voisin tout juste ajout\u00e9 \u00e0 la file d'attente (qui porte maintenant mal son nom, puisque c'est devenu une pile). Parcours en profondeur it\u00e9ratif - DFS \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def DFS_iteratif ( graphe , start ): traites = [] en_attente = [ start ] while en_attente != []: actuel = en_attente . pop () if actuel not in traites : voisins = g . voisins ( actuel )[:: - 1 ] for voisin in voisins : if voisin not in traites : en_attente . append ( voisin ) traites . append ( actuel ) return traites Remarques : \u00c0 la ligne 7, on inverse l'ordre des voisins pour que ce code renvoie le m\u00eame parcours quele parcours r\u00e9cursif (sinon c'est le dernier voisin ajout\u00e9 qui sera d\u00e9pil\u00e9). Cela n'est pas obligatoire : il n'y a pas \u00abun seul\u00bb parcours DFS (tout comme il n'y a pas qu'un seul BFS). Ce qui les caract\u00e9rise est la m\u00e9thode de d\u00e9couverte , plus que l'impl\u00e9mentation proprement dite. Contrairement au BFS, il est possible d'empiler un sommet d\u00e9j\u00e0 d\u00e9couvert (on v\u00e9rifie juste qu'il n'ait pas d\u00e9j\u00e0 \u00e9t\u00e9 trait\u00e9). Vous pouvez vous en apercevoir en \u00e9crivant l'\u00e9tat de la pile lors du parcours DFS it\u00e9ratif du graphe de l'exercice 6.", "title": "Cours"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#graphes", "text": "Ce cours est int\u00e9gralement inspir\u00e9 du cours de C\u00e9dric Gouygou , du lyc\u00e9e Marguerite de Valois d'Angoul\u00eame (16)", "title": "Graphes"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#1-notion-de-graphe-et-vocabulaire", "text": "Le concept de graphe permet de r\u00e9soudre de nombreux probl\u00e8mes en math\u00e9matiques comme en informatique. C'est un outil de repr\u00e9sentation tr\u00e8s courant, et nous l'avons d\u00e9j\u00e0 rencontr\u00e9 \u00e0 plusieurs reprises, en particulier lors de l'\u00e9tude de r\u00e9seaux.", "title": "1. Notion de graphe et vocabulaire"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#11-exemples-de-situations", "text": "", "title": "1.1 Exemples de situations"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#12-vocabulaire", "text": "En g\u00e9n\u00e9ral, un graphe est un ensemble d'objets, appel\u00e9s sommets ou parfois n\u0153uds ( vertex or nodes en anglais) reli\u00e9s par des ar\u00eates ou arcs (( edges en anglais)). Ce graphe peut \u00eatre non-orient\u00e9 ou orient\u00e9 .", "title": "1.2 Vocabulaire"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#2-modelisations-dun-graphe", "text": "Pour mod\u00e9liser un graphe, il faut \u00e9tablir par convention une mani\u00e8re de donner les renseignements suivants : qui sont les sommets ? pour chaque sommet, quels sont ses voisins ? (et \u00e9ventuellement quel poids porte l'ar\u00eate qui les relie)", "title": "2. Mod\u00e9lisations d'un graphe"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#21-representation-par-matrice-dadjacence", "text": "Principe On classe les sommets (en les num\u00e9rotant, ou par ordre alphab\u00e9tique). on repr\u00e9sente les ar\u00eates (ou les arcs) dans une matrice, c'est-\u00e0-dire un tableau \u00e0 deux dimensions o\u00f9 on inscrit un 1 en ligne i et colonne j si les sommets de rang i et de rang j sont voisins (dits aussi adjacents ). Ce tableau s'appelle une matrice d'adjacence (on aurait tr\u00e8s bien pu l'appeler aussi matrice de voisinage ).", "title": "2.1 Repr\u00e9sentation par matrice d'adjacence"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#22-representation-par-listes-dadjacence", "text": "Principe On associe \u00e0 chaque sommet sa liste des voisins (c'est-\u00e0-dire les sommets adjacents). On utilise pour cela un dictionnaire dont les cl\u00e9s sont les sommets et les valeurs les listes des voisins. Dans le cas d'un graphe orient\u00e9 on associe \u00e0 chaque sommet la liste des successeurs (ou bien des pr\u00e9d\u00e9cesseurs , au choix). Par exemple, le graphe sera repr\u00e9sent\u00e9 par le dictionnaire : \ud83d\udc0d Script Python 1 2 3 4 5 6 G = { 'A' : [ 'B' , 'C' , 'D' , 'E' ], 'B' : [ 'A' , 'C' ], 'C' : [ 'A' , 'B' , 'D' ], 'D' : [ 'A' , 'C' , 'E' ], 'E' : [ 'A' , 'D' ] } Complexit\u00e9 en m\u00e9moire et temps d'acc\u00e8s : Pour un graphe \u00e0 \\(n\\) sommets et \\(m\\) ar\u00eates, la complexit\u00e9 spatiale de la repr\u00e9sentation en liste d'adjacence est en \\(O(n+m)\\) . C'est beaucoup mieux qu'une matrice d'adjacence lorsque le graphe comporte peu d'ar\u00eates (i.e. beaucoup de 0 dans la matrice, non stock\u00e9s avec des listes). Tester si un sommet est isol\u00e9 (ou conna\u00eetre ses voisins) est en \\(O(1)\\) puisqu'on y acc\u00e8de imm\u00e9diatement, mais tester si deux sommets sont adjacents (voisins) est en \\(O(n)\\) car il faut parcourir la liste.", "title": "2.2 Repr\u00e9sentation par listes d'adjacence"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#3-creation-dune-classe-graphe", "text": "Dans cette partie, nous ne traiterons que des graphes non-orient\u00e9s .", "title": "3. Cr\u00e9ation d'une classe Graphe"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#31-interface-souhaitee", "text": "Nous voulons que le graphe puisse \u00eatre cr\u00e9\u00e9 gr\u00e2ce aux instructions suivantes : \ud83d\udc0d Script Python g = Graphe ([ 'A' , 'B' , 'C' , 'D' , 'E' ]) g . ajoute_arete ( 'A' , 'B' ) g . ajoute_arete ( 'A' , 'C' ) g . ajoute_arete ( 'A' , 'D' ) g . ajoute_arete ( 'A' , 'E' ) g . ajoute_arete ( 'B' , 'C' ) g . ajoute_arete ( 'C' , 'D' ) g . ajoute_arete ( 'D' , 'E' ) Nous souhaitons aussi pouvoir tester si deux sommets sont voisins avec la m\u00e9thode sont_voisins : \ud83d\udc0d Script Python >>> g . sont_voisins ( 'E' , 'A' ) True >>> g . sont_voisins ( 'E' , 'B' ) False Enfin, nous voulons pouvoir obtenir facilement la liste de tous les voisins d'un sommet avec la m\u00e9thode voisins : \ud83d\udc0d Script Python >>> g . voisins ( 'C' ) [ 'A' , 'B' , 'D' ]", "title": "3.1 Interface souhait\u00e9e"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#32-conseils-dimplementation", "text": "L'objet de type Graphe aura comme attributs : une liste liste_sommets (donn\u00e9e en param\u00e8tre dans la liste liste_sommets ) un dictionnaire adjacents , o\u00f9 chaque sommet se verra attribuer une liste vide [] .", "title": "3.2 Conseils d'impl\u00e9mentation"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#33-implementation", "text": "Impl\u00e9mentation d'une classe Graphe \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Graphe : def __init__ ( self , liste_sommets ): self . liste_sommets = liste_sommets self . adjacents = { sommet : [] for sommet in liste_sommets } def ajoute_arete ( self , sommetA , sommetB ): self . adjacents [ sommetA ] . append ( sommetB ) self . adjacents [ sommetB ] . append ( sommetA ) def voisins ( self , sommet ): return self . adjacents [ sommet ] def sont_voisins ( self , sommetA , sommetB ): return sommetB in self . adjacents [ sommetA ]", "title": "3.3 Impl\u00e9mentation"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#4-parcours-de-graphes", "text": "Algorithme de parcours Un parcours de graphe est un algorithme consistant \u00e0 explorer tous les sommets d'un graphe de proche en proche \u00e0 partir d'un sommet initial. Ces parcours sont notamment utilis\u00e9s pour rechercher un plus court chemin (et donc dans les GPS) ou pour trouver la sortie d'un labyrinthe... Parcourir simplement le dictionnaire ou la matrice d\u2019un graphe n\u2019est pas consid\u00e9r\u00e9 comme un parcours de graphe. Tous les parcours suivent plus ou moins le m\u00eame algorithme de base : On visite un sommet A . On cr\u00e9e une structure S qui contiendra au d\u00e9part l\u2019 ensemble des voisins de A . Tant que S n\u2019est pas vide : on choisit un sommet s de S on visite s on ajoute \u00e0 S tous les voisins de s pas encore visit\u00e9s Sommets visit\u00e9s Contrairement \u00e0 un parcours d'arbre, o\u00f9 les fils d'un n\u0153ud ne peuvent pas avoir \u00e9t\u00e9 visit\u00e9s avant le n\u0153ud, un voisin d'un sommet peut avoir d\u00e9j\u00e0 \u00e9t\u00e9 visit\u00e9 en tant que voisin d'un sommet pr\u00e9c\u00e9dent... Il est donc n\u00e9cessaire de m\u00e9moriser les sommets d\u00e9ja visit\u00e9s ou d\u00e9couverts (on dira qu'un sommet est d\u00e9couvert lorsqu'on l'ajoute \u00e0 S ). Le choix de la structure de l'ensemble S est pr\u00e9pond\u00e9rant: Si on choisit une file (FIFO): on visitera les sommets dans l'ordre d'arriv\u00e9e, donc les plus proches du sommet pr\u00e9c\u00e9dent. On obtient donc un parcours en largeur BFS . Si on choisit une pile (LIFO): on visitera d'abord les derniers sommets arriv\u00e9s, donc on parcourt le graphe en visitant \u00e0 chaque \u00e9tape un voisin du pr\u00e9c\u00e9dent. On obtient donc un parcours en profondeur DFS .", "title": "4.    Parcours de graphes"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#41-le-parcours-en-largeur-bfs-breadth-first-search", "text": "", "title": "4.1 Le parcours en largeur (BFS, Breadth First Search)"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#413-application-du-bfs-recherche-du-plus-court-chemin", "text": "L'algorithme BFS d\u00e9couvre les sommets \u00abpar cercles concentriques\u00bb autour du point de d\u00e9part (ainsi que le montre la structure de la file d'attente). On d\u00e9couvre d'abord tous les sommets \u00e0 la distance 1 du point de d\u00e9part, puis \u00e0 la distance 2, puis 3, etc. Un sommet situ\u00e9 \u00e0 la distance 5 sera d\u00e9couvert en tant que voisin d'un sommet \u00e0 la distance 4, qui lui-m\u00eame aura \u00e9t\u00e9 d\u00e9couvert gr\u00e2ce \u00e0 un sommet \u00e0 la distance 3, qui lui-m\u00eame... On comprend donc que si on arrive \u00e0 se souvenir du sommet \u00abparent\u00bb de chaque sommet (celui qui lui a permis d'\u00eatre d\u00e9couvert), on pourra alors reconstituer un chemin permettant de remonter au point de d\u00e9part. Nous allons pour cela nous servir d'une structure de dictionnaire pour associer \u00e0 chaque sommet son sommet-parent. Il faudra ensuite une fonction pour recr\u00e9er le chemin. Pourquoi le plus court chemin ? Comment est-on s\u00fbr qu'un chemin va \u00eatre trouv\u00e9 entre deux sommets A et B ? Si le graphe est connexe, tout parcours BFS au d\u00e9part de A va parcourir l'int\u00e9gralit\u00e9 du graphe, et donc passera par B \u00e0 un moment. Un chemin sera donc forc\u00e9ment trouv\u00e9 entre A et B. Comment est-on s\u00fbr que ce chemin trouv\u00e9 est le plus court ? La d\u00e9couverte des sommets par cercles concentriques entre A et B nous assure qu'on ne peut pas rater le point B : s'il est \u00e0 la distance k de A, il sera forc\u00e9ment visit\u00e9 puisque tous les sommets \u00e0 la distance k vont passer par la liste d'attente, apr\u00e8s les sommets de distance k-1 et avant les sommets de distance k+1 . Lorsqu'on remontera de B vers A en passant par les sommets parents successifs, il ne peut y avoir qu'un seul sommet par \u00abcouche\u00bb : le chemin sera donc exactement de longueur k , il sera donc minimal. Recherche du plus court chemin \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def recherche_chemin ( g , depart , arrivee ): ''' Parcours en largeur du graphe g en partant du sommet depart, qui s'arr\u00eate d\u00e8s que le sommet arrivee est atteint. Renvoie alors le chemin du depart vers arrivee. ''' traites = [] decouverts = [ depart ] en_attente = [ depart ] parent = {} while en_attente != [] : sommet = en_attente . pop ( 0 ) voisins = g . voisins ( sommet ) for voisin in voisins : if voisin not in decouverts : decouverts . append ( voisin ) en_attente . append ( voisin ) parent [ voisin ] = sommet if voisin == arrivee : return remonte_chemin ( depart , arrivee , parent ) traites . append ( sommet ) return \"non trouv\u00e9\" def remonte_chemin ( depart , arrivee , parent ): sommet = arrivee chemin = arrivee while sommet != depart : sommet = parent [ sommet ] chemin = sommet + chemin return chemin Exercice 5 Tester le code pr\u00e9c\u00e9dent pour trouver le plus court chemin entre A et G, entre H et C, entre B et G...", "title": "4.1.3 Application du BFS : recherche du plus court chemin"}, {"location": "T1_Structures_de_donnees/1.4_Graphes/cours/#42-le-parcours-en-profondeur-dfs-depth-first-search", "text": "", "title": "4.2 Le parcours en profondeur (DFS, Depth First Search)"}, {"location": "T2_Programmation/sommaire/", "text": "Programmation Orient\u00e9e Objet R\u00e9cursivit\u00e9 Calculabilit\u00e9 et D\u00e9cidabilit\u00e9 Pratiques de programmation", "title": "Sommaire"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/", "text": "TP : balles rebondissantes \u2693\ufe0e 1. Prise en main de Pygame \u2693\ufe0e \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) x = 300 y = 200 dx = 4 dy = - 3 couleur = ( 45 , 170 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleur , ( x , y ), RAYON ) x += dx y += dy pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.1 ) 1.1 Rajout d'un rebond sur les parois \u2693\ufe0e Modifiez le code pr\u00e9c\u00e9dent afin que la balle rebondisse sur chaque paroi (il suffit de modifier intelligemment \"les variables de vitesse\" dx et dy ). Variables de vitesse Il s'agit d'un abus de langage. En effet, la vitesse horizontale de la balle se note \\(v_x\\) pas \\(dx\\) mais \\(v_x\\) est li\u00e9e \u00e0 la variation de position horizontale \\(dx\\) par la formule \\(v_x=\\frac{dx}{dt}\\) o\u00f9 \\(dt\\) est le temps entre deux rafra\u00eechissement d'image que l'on indique dans time.sleep(dt) . Donc, \u00e0 rafra\u00eechissement d'image constant, c'est bien \\(dx\\) qui permet de fixer la vitesse horizontale de la balle. Il en est de m\u00eame pour la relation entre la vitesse verticale \\(v_y\\) et dy . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) x = 300 y = 200 dx = 4 dy = - 3 couleur = ( 45 , 170 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleur , ( x , y ), RAYON ) x += dx y += dy if ( y <= RAYON ) or ( y >= HAUTEUR - RAYON ): dy = - dy if ( x <= RAYON ) or ( x >= LARGEUR - RAYON ): dx = - dx pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.02 ) 1.2 Rajout d'une deuxi\u00e8me balle \u2693\ufe0e Attention au nommage des variables... \u00c0 compl\u00e9ter \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) dxA = 7 dyA = 4 dxB = - 5 dyB = 3 xA = LARGEUR // 3 yA = HAUTEUR // 2 xB = LARGEUR // 2 yB = HAUTEUR // 2 couleurA = ( 45 , 170 , 250 ) couleurB = ( 155 , 17 , 250 ) while True : ###################### # \u00c0 vous # ###################### pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.03 ) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) dxA = 7 dyA = 4 dxB = - 5 dyB = 3 xA = LARGEUR // 3 yA = HAUTEUR // 2 xB = LARGEUR // 2 yB = HAUTEUR // 2 couleurA = ( 45 , 170 , 250 ) couleurB = ( 155 , 17 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleurA , ( xA , yA ), RAYON ) pygame . draw . circle ( fenetre , couleurB , ( xB , yB ), RAYON ) xA += dxA yA += dyA xB += dxB yB += dyB # rebond en haut ou en bas if ( yA < RAYON ) or ( yA > HAUTEUR - RAYON ): dyA = - dyA # rebond \u00e0 gauche ou \u00e0 droite if ( xA < RAYON ) or ( xA > LARGEUR - RAYON ): dxA = - dxA # rebond en haut ou en bas if ( yB < RAYON ) or ( yB > HAUTEUR - RAYON ): dyB = - dyB # rebond \u00e0 gauche ou \u00e0 droite if ( xB < RAYON ) or ( xB > LARGEUR - RAYON ): dxB = - dxB pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.03 ) 1.3 Gestion de la collision entre les deux balles \u2693\ufe0e Q1. \u00c0 l'aide d'un sch\u00e9ma (papier-crayon !), mettez en \u00e9vidence le test devant \u00eatre r\u00e9alis\u00e9 pour d\u00e9tecter une collision. indice Q2. Impl\u00e9mentez ce test (en cr\u00e9ant pour cela une fonction distance ) et affichez \"collision\" en console lorsque les deux balles se touchent. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) dxA = 7 dyA = 4 dxB = - 5 dyB = 3 xA = LARGEUR // 3 yA = HAUTEUR // 2 xB = LARGEUR // 2 yB = HAUTEUR // 2 couleurA = ( 45 , 170 , 250 ) couleurB = ( 155 , 17 , 250 ) def distanceAB ( xA , yA , xB , yB ): return (( xA - xB ) ** 2 + ( yA - yB ) ** 2 ) ** 0.5 while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleurA , ( xA , yA ), RAYON ) pygame . draw . circle ( fenetre , couleurB , ( xB , yB ), RAYON ) xA += dxA yA += dyA xB += dxB yB += dyB # rebond en haut ou en bas if ( yA < RAYON ) or ( yA > HAUTEUR - RAYON ): dyA = - dyA # rebond \u00e0 gauche ou \u00e0 droite if ( xA < RAYON ) or ( xA > LARGEUR - RAYON ): dxA = - dxA # rebond en haut ou en bas if ( yB < RAYON ) or ( yB > HAUTEUR - RAYON ): dyB = - dyB # rebond \u00e0 gauche ou \u00e0 droite if ( xB < RAYON ) or ( xB > LARGEUR - RAYON ): dxB = - dxB if distanceAB ( xA , yA , xB , yB ) < 2 * RAYON : print ( \"collision\" ) pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.03 ) Q3. Pour donner l'illusion physique du rebond, \u00e9changez les valeurs respectives de dx et dy pour les deux balles. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) dxA = 7 dyA = 4 dxB = - 5 dyB = 3 xA = LARGEUR // 3 yA = HAUTEUR // 2 xB = LARGEUR // 2 yB = HAUTEUR // 2 couleurA = ( 45 , 170 , 250 ) couleurB = ( 155 , 17 , 250 ) def distanceAB ( xA , yA , xB , yB ): return (( xA - xB ) ** 2 + ( yA - yB ) ** 2 ) ** 0.5 while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleurA , ( xA , yA ), RAYON ) pygame . draw . circle ( fenetre , couleurB , ( xB , yB ), RAYON ) xA += dxA yA += dyA xB += dxB yB += dyB # rebond en haut ou en bas if ( yA < RAYON ) or ( yA > HAUTEUR - RAYON ): dyA = - dyA # rebond \u00e0 gauche ou \u00e0 droite if ( xA < RAYON ) or ( xA > LARGEUR - RAYON ): dxA = - dxA # rebond en haut ou en bas if ( yB < RAYON ) or ( yB > HAUTEUR - RAYON ): dyB = - dyB # rebond \u00e0 gauche ou \u00e0 droite if ( xB < RAYON ) or ( xB > LARGEUR - RAYON ): dxB = - dxB if distanceAB ( xA , yA , xB , yB ) < 2 * RAYON : dxA , dxB = dxB , dxA dyA , dyB = dyB , dyA pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.03 ) 1.4 Rajout d'une troisi\u00e8me balle et gestion du rebond avec les deux autres. \u2693\ufe0e ... vraiment ? Peut-on continuer comme pr\u00e9c\u00e9demment ? 2. La POO \u00e0 la rescousse : cr\u00e9ation d'une classe Balle \u2693\ufe0e 2.1 la classe Balle \u2693\ufe0e L'objectif est que la m\u00e9thode constructeur dote chaque nouvelle balle de valeurs al\u00e9atoires : abscisse, ordonn\u00e9e, vitesse, couleur... Pour l'al\u00e9atoire, on pourra utiliser randint(a, b) qui renvoie un nombre pseudo-al\u00e9atoire entre a et b . Il faut pour cela importer la fonction, par from random import randint Vous pouvez aussi doter votre classe Balle d'une m\u00e9thode dessine (qui affiche la balle), ainsi qu'une m\u00e9thode bouge qui la fait bouger. Cr\u00e9ez cette classe et instanciez une balle. \u00c0 compl\u00e9ter \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): # \u00e0 vous def dessine ( self ): # \u00e0 vous def bouge ( self ): # \u00e0 vous ma_balle = Balle () while True : fenetre . fill ([ 0 , 0 , 0 ]) ma_balle . dessine () ma_balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 ) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): self . x = randint ( 0 , LARGEUR ) self . y = randint ( 0 , HAUTEUR ) self . dx = randint ( 2 , 5 ) self . dy = randint ( 2 , 5 ) self . couleur = ( randint ( 0 , 255 ), randint ( 0 , 255 ), randint ( 0 , 255 )) self . taille = RAYON def dessine ( self ): pygame . draw . circle ( fenetre , self . couleur , ( self . x , self . y ), self . taille ) def bouge ( self ): self . x += self . dx self . y += self . dy if self . y < self . taille or self . y > HAUTEUR - self . taille : self . dy = - self . dy if self . x < self . taille or self . x > LARGEUR - self . taille : self . dx = - self . dx ma_balle = Balle () while True : fenetre . fill ([ 0 , 0 , 0 ]) ma_balle . dessine () ma_balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 ) 2.2 Plusieurs balles \u2693\ufe0e L'id\u00e9e est de stocker dans une liste sac_a_balles un nombre d\u00e9termin\u00e9 de balles... \u00c0 compl\u00e9ter \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 NB_BALLES = 10 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): self . x = randint ( 0 , LARGEUR ) self . y = randint ( 0 , HAUTEUR ) self . dx = randint ( 2 , 5 ) self . dy = randint ( 2 , 5 ) self . couleur = ( randint ( 0 , 255 ), randint ( 0 , 255 ), randint ( 0 , 255 )) self . taille = RAYON def dessine ( self ): pygame . draw . circle ( fenetre , self . couleur , ( self . x , self . y ), self . taille ) def bouge ( self ): self . x += self . dx self . y += self . dy if self . y < self . taille or self . y > HAUTEUR - self . taille : self . dy = - self . dy if self . x < self . taille or self . x > LARGEUR - self . taille : self . dx = - self . dx mon_sac_a_balles = # \u00e0 vous while True : fenetre . fill ([ 0 , 0 , 0 ]) for balle in mon_sac_a_balles : balle . dessine () balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 ) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 NB_BALLES = 10 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): self . x = randint ( 0 , LARGEUR ) self . y = randint ( 0 , HAUTEUR ) self . dx = randint ( 2 , 5 ) self . dy = randint ( 2 , 5 ) self . couleur = ( randint ( 0 , 255 ), randint ( 0 , 255 ), randint ( 0 , 255 )) self . taille = RAYON def dessine ( self ): pygame . draw . circle ( fenetre , self . couleur , ( self . x , self . y ), self . taille ) def bouge ( self ): self . x += self . dx self . y += self . dy if self . y < self . taille or self . y > HAUTEUR - self . taille : self . dy = - self . dy if self . x < self . taille or self . x > LARGEUR - self . taille : self . dx = - self . dx mon_sac_a_balles = [ Balle () for _ in range ( NB_BALLES )] while True : fenetre . fill ([ 0 , 0 , 0 ]) for balle in mon_sac_a_balles : balle . dessine () balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 ) 2.3 Collision de toutes les balles \u2693\ufe0e Il \u00absuffit\u00bb , dans la m\u00e9thode constructeur, de tester la collision de la balle self avec chacune des balles de notre sac_a_balles . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 NB_BALLES = 10 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): self . x = randint ( 0 , LARGEUR ) self . y = randint ( 0 , HAUTEUR ) self . dx = randint ( 2 , 5 ) self . dy = randint ( 2 , 5 ) self . couleur = ( randint ( 0 , 255 ), randint ( 0 , 255 ), randint ( 0 , 255 )) self . taille = RAYON def dessine ( self ): pygame . draw . circle ( fenetre , self . couleur , ( self . x , self . y ), self . taille ) def bouge ( self ): self . x += self . dx self . y += self . dy if self . y < self . taille or self . y > HAUTEUR - self . taille : self . dy = - self . dy if self . x < self . taille or self . x > LARGEUR - self . taille : self . dx = - self . dx for balle in mon_sac_a_balles : if ( ( self . x - balle . x ) ** 2 + ( self . y - balle . y ) ** 2 ) ** 0.5 < self . taille + balle . taille : self . dx , balle . dx = balle . dx , self . dx self . dy , balle . dy = balle . dy , self . dy mon_sac_a_balles = [] for _ in range ( NB_BALLES ): new_ball = Balle () mon_sac_a_balles . append ( new_ball ) # ces 4 derni\u00e8re lignes peuvent s'\u00e9crire par une seule liste en compr\u00e9hension : # mon_sac_a_balles = [Balle() for _ in range(NB_BALLES)] while True : fenetre . fill ([ 0 , 0 , 0 ]) for balle in mon_sac_a_balles : balle . dessine () balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 )", "title": "TP : balles rebondissantes"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#tp-balles-rebondissantes", "text": "", "title": "TP : balles rebondissantes"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#1-prise-en-main-de-pygame", "text": "\ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) x = 300 y = 200 dx = 4 dy = - 3 couleur = ( 45 , 170 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleur , ( x , y ), RAYON ) x += dx y += dy pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.1 )", "title": "1. Prise en main de Pygame"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#11-rajout-dun-rebond-sur-les-parois", "text": "Modifiez le code pr\u00e9c\u00e9dent afin que la balle rebondisse sur chaque paroi (il suffit de modifier intelligemment \"les variables de vitesse\" dx et dy ). Variables de vitesse Il s'agit d'un abus de langage. En effet, la vitesse horizontale de la balle se note \\(v_x\\) pas \\(dx\\) mais \\(v_x\\) est li\u00e9e \u00e0 la variation de position horizontale \\(dx\\) par la formule \\(v_x=\\frac{dx}{dt}\\) o\u00f9 \\(dt\\) est le temps entre deux rafra\u00eechissement d'image que l'on indique dans time.sleep(dt) . Donc, \u00e0 rafra\u00eechissement d'image constant, c'est bien \\(dx\\) qui permet de fixer la vitesse horizontale de la balle. Il en est de m\u00eame pour la relation entre la vitesse verticale \\(v_y\\) et dy . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) x = 300 y = 200 dx = 4 dy = - 3 couleur = ( 45 , 170 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleur , ( x , y ), RAYON ) x += dx y += dy if ( y <= RAYON ) or ( y >= HAUTEUR - RAYON ): dy = - dy if ( x <= RAYON ) or ( x >= LARGEUR - RAYON ): dx = - dx pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.02 )", "title": "1.1  Rajout d'un rebond sur les parois"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#12-rajout-dune-deuxieme-balle", "text": "Attention au nommage des variables... \u00c0 compl\u00e9ter \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) dxA = 7 dyA = 4 dxB = - 5 dyB = 3 xA = LARGEUR // 3 yA = HAUTEUR // 2 xB = LARGEUR // 2 yB = HAUTEUR // 2 couleurA = ( 45 , 170 , 250 ) couleurB = ( 155 , 17 , 250 ) while True : ###################### # \u00c0 vous # ###################### pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.03 ) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) dxA = 7 dyA = 4 dxB = - 5 dyB = 3 xA = LARGEUR // 3 yA = HAUTEUR // 2 xB = LARGEUR // 2 yB = HAUTEUR // 2 couleurA = ( 45 , 170 , 250 ) couleurB = ( 155 , 17 , 250 ) while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleurA , ( xA , yA ), RAYON ) pygame . draw . circle ( fenetre , couleurB , ( xB , yB ), RAYON ) xA += dxA yA += dyA xB += dxB yB += dyB # rebond en haut ou en bas if ( yA < RAYON ) or ( yA > HAUTEUR - RAYON ): dyA = - dyA # rebond \u00e0 gauche ou \u00e0 droite if ( xA < RAYON ) or ( xA > LARGEUR - RAYON ): dxA = - dxA # rebond en haut ou en bas if ( yB < RAYON ) or ( yB > HAUTEUR - RAYON ): dyB = - dyB # rebond \u00e0 gauche ou \u00e0 droite if ( xB < RAYON ) or ( xB > LARGEUR - RAYON ): dxB = - dxB pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.03 )", "title": "1.2 Rajout d'une deuxi\u00e8me balle"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#13-gestion-de-la-collision-entre-les-deux-balles", "text": "Q1. \u00c0 l'aide d'un sch\u00e9ma (papier-crayon !), mettez en \u00e9vidence le test devant \u00eatre r\u00e9alis\u00e9 pour d\u00e9tecter une collision. indice Q2. Impl\u00e9mentez ce test (en cr\u00e9ant pour cela une fonction distance ) et affichez \"collision\" en console lorsque les deux balles se touchent. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) dxA = 7 dyA = 4 dxB = - 5 dyB = 3 xA = LARGEUR // 3 yA = HAUTEUR // 2 xB = LARGEUR // 2 yB = HAUTEUR // 2 couleurA = ( 45 , 170 , 250 ) couleurB = ( 155 , 17 , 250 ) def distanceAB ( xA , yA , xB , yB ): return (( xA - xB ) ** 2 + ( yA - yB ) ** 2 ) ** 0.5 while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleurA , ( xA , yA ), RAYON ) pygame . draw . circle ( fenetre , couleurB , ( xB , yB ), RAYON ) xA += dxA yA += dyA xB += dxB yB += dyB # rebond en haut ou en bas if ( yA < RAYON ) or ( yA > HAUTEUR - RAYON ): dyA = - dyA # rebond \u00e0 gauche ou \u00e0 droite if ( xA < RAYON ) or ( xA > LARGEUR - RAYON ): dxA = - dxA # rebond en haut ou en bas if ( yB < RAYON ) or ( yB > HAUTEUR - RAYON ): dyB = - dyB # rebond \u00e0 gauche ou \u00e0 droite if ( xB < RAYON ) or ( xB > LARGEUR - RAYON ): dxB = - dxB if distanceAB ( xA , yA , xB , yB ) < 2 * RAYON : print ( \"collision\" ) pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.03 ) Q3. Pour donner l'illusion physique du rebond, \u00e9changez les valeurs respectives de dx et dy pour les deux balles. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 import pygame , sys import time from pygame.locals import * LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) dxA = 7 dyA = 4 dxB = - 5 dyB = 3 xA = LARGEUR // 3 yA = HAUTEUR // 2 xB = LARGEUR // 2 yB = HAUTEUR // 2 couleurA = ( 45 , 170 , 250 ) couleurB = ( 155 , 17 , 250 ) def distanceAB ( xA , yA , xB , yB ): return (( xA - xB ) ** 2 + ( yA - yB ) ** 2 ) ** 0.5 while True : fenetre . fill ([ 0 , 0 , 0 ]) pygame . draw . circle ( fenetre , couleurA , ( xA , yA ), RAYON ) pygame . draw . circle ( fenetre , couleurB , ( xB , yB ), RAYON ) xA += dxA yA += dyA xB += dxB yB += dyB # rebond en haut ou en bas if ( yA < RAYON ) or ( yA > HAUTEUR - RAYON ): dyA = - dyA # rebond \u00e0 gauche ou \u00e0 droite if ( xA < RAYON ) or ( xA > LARGEUR - RAYON ): dxA = - dxA # rebond en haut ou en bas if ( yB < RAYON ) or ( yB > HAUTEUR - RAYON ): dyB = - dyB # rebond \u00e0 gauche ou \u00e0 droite if ( xB < RAYON ) or ( xB > LARGEUR - RAYON ): dxB = - dxB if distanceAB ( xA , yA , xB , yB ) < 2 * RAYON : dxA , dxB = dxB , dxA dyA , dyB = dyB , dyA pygame . display . update () # routine pour pouvoir fermer \u00abproprement\u00bb la fen\u00eatre Pygame for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.03 )", "title": "1.3 Gestion de la collision entre les deux balles"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#14-rajout-dune-troisieme-balle-et-gestion-du-rebond-avec-les-deux-autres", "text": "... vraiment ? Peut-on continuer comme pr\u00e9c\u00e9demment ?", "title": "1.4 Rajout d'une troisi\u00e8me balle et gestion du rebond avec les deux autres."}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#2-la-poo-a-la-rescousse-creation-dune-classe-balle", "text": "", "title": "2. La POO \u00e0 la rescousse : cr\u00e9ation d'une classe Balle"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#21-la-classe-balle", "text": "L'objectif est que la m\u00e9thode constructeur dote chaque nouvelle balle de valeurs al\u00e9atoires : abscisse, ordonn\u00e9e, vitesse, couleur... Pour l'al\u00e9atoire, on pourra utiliser randint(a, b) qui renvoie un nombre pseudo-al\u00e9atoire entre a et b . Il faut pour cela importer la fonction, par from random import randint Vous pouvez aussi doter votre classe Balle d'une m\u00e9thode dessine (qui affiche la balle), ainsi qu'une m\u00e9thode bouge qui la fait bouger. Cr\u00e9ez cette classe et instanciez une balle. \u00c0 compl\u00e9ter \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): # \u00e0 vous def dessine ( self ): # \u00e0 vous def bouge ( self ): # \u00e0 vous ma_balle = Balle () while True : fenetre . fill ([ 0 , 0 , 0 ]) ma_balle . dessine () ma_balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 ) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): self . x = randint ( 0 , LARGEUR ) self . y = randint ( 0 , HAUTEUR ) self . dx = randint ( 2 , 5 ) self . dy = randint ( 2 , 5 ) self . couleur = ( randint ( 0 , 255 ), randint ( 0 , 255 ), randint ( 0 , 255 )) self . taille = RAYON def dessine ( self ): pygame . draw . circle ( fenetre , self . couleur , ( self . x , self . y ), self . taille ) def bouge ( self ): self . x += self . dx self . y += self . dy if self . y < self . taille or self . y > HAUTEUR - self . taille : self . dy = - self . dy if self . x < self . taille or self . x > LARGEUR - self . taille : self . dx = - self . dx ma_balle = Balle () while True : fenetre . fill ([ 0 , 0 , 0 ]) ma_balle . dessine () ma_balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 )", "title": "2.1 la classe Balle"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#22-plusieurs-balles", "text": "L'id\u00e9e est de stocker dans une liste sac_a_balles un nombre d\u00e9termin\u00e9 de balles... \u00c0 compl\u00e9ter \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 NB_BALLES = 10 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): self . x = randint ( 0 , LARGEUR ) self . y = randint ( 0 , HAUTEUR ) self . dx = randint ( 2 , 5 ) self . dy = randint ( 2 , 5 ) self . couleur = ( randint ( 0 , 255 ), randint ( 0 , 255 ), randint ( 0 , 255 )) self . taille = RAYON def dessine ( self ): pygame . draw . circle ( fenetre , self . couleur , ( self . x , self . y ), self . taille ) def bouge ( self ): self . x += self . dx self . y += self . dy if self . y < self . taille or self . y > HAUTEUR - self . taille : self . dy = - self . dy if self . x < self . taille or self . x > LARGEUR - self . taille : self . dx = - self . dx mon_sac_a_balles = # \u00e0 vous while True : fenetre . fill ([ 0 , 0 , 0 ]) for balle in mon_sac_a_balles : balle . dessine () balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 ) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 NB_BALLES = 10 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): self . x = randint ( 0 , LARGEUR ) self . y = randint ( 0 , HAUTEUR ) self . dx = randint ( 2 , 5 ) self . dy = randint ( 2 , 5 ) self . couleur = ( randint ( 0 , 255 ), randint ( 0 , 255 ), randint ( 0 , 255 )) self . taille = RAYON def dessine ( self ): pygame . draw . circle ( fenetre , self . couleur , ( self . x , self . y ), self . taille ) def bouge ( self ): self . x += self . dx self . y += self . dy if self . y < self . taille or self . y > HAUTEUR - self . taille : self . dy = - self . dy if self . x < self . taille or self . x > LARGEUR - self . taille : self . dx = - self . dx mon_sac_a_balles = [ Balle () for _ in range ( NB_BALLES )] while True : fenetre . fill ([ 0 , 0 , 0 ]) for balle in mon_sac_a_balles : balle . dessine () balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 )", "title": "2.2 Plusieurs balles"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/TP/#23-collision-de-toutes-les-balles", "text": "Il \u00absuffit\u00bb , dans la m\u00e9thode constructeur, de tester la collision de la balle self avec chacune des balles de notre sac_a_balles . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import pygame , sys import time from pygame.locals import * from random import randint # randint(0,10) -> nb al\u00e9atoire entre 0 et 10 LARGEUR = 640 HAUTEUR = 480 RAYON = 20 NB_BALLES = 10 pygame . display . init () fenetre = pygame . display . set_mode (( LARGEUR , HAUTEUR )) fenetre . fill ([ 0 , 0 , 0 ]) class Balle : def __init__ ( self ): self . x = randint ( 0 , LARGEUR ) self . y = randint ( 0 , HAUTEUR ) self . dx = randint ( 2 , 5 ) self . dy = randint ( 2 , 5 ) self . couleur = ( randint ( 0 , 255 ), randint ( 0 , 255 ), randint ( 0 , 255 )) self . taille = RAYON def dessine ( self ): pygame . draw . circle ( fenetre , self . couleur , ( self . x , self . y ), self . taille ) def bouge ( self ): self . x += self . dx self . y += self . dy if self . y < self . taille or self . y > HAUTEUR - self . taille : self . dy = - self . dy if self . x < self . taille or self . x > LARGEUR - self . taille : self . dx = - self . dx for balle in mon_sac_a_balles : if ( ( self . x - balle . x ) ** 2 + ( self . y - balle . y ) ** 2 ) ** 0.5 < self . taille + balle . taille : self . dx , balle . dx = balle . dx , self . dx self . dy , balle . dy = balle . dy , self . dy mon_sac_a_balles = [] for _ in range ( NB_BALLES ): new_ball = Balle () mon_sac_a_balles . append ( new_ball ) # ces 4 derni\u00e8re lignes peuvent s'\u00e9crire par une seule liste en compr\u00e9hension : # mon_sac_a_balles = [Balle() for _ in range(NB_BALLES)] while True : fenetre . fill ([ 0 , 0 , 0 ]) for balle in mon_sac_a_balles : balle . dessine () balle . bouge () pygame . display . update () for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . display . quit () sys . exit () time . sleep ( 0.05 )", "title": "2.3 Collision de toutes les balles"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/cours/", "text": "Programmation orient\u00e9e objet \u2693\ufe0e abr\u00e9g\u00e9e par POO en fran\u00e7ais, OOP en anglais (ne pas confondre) 0. Introduction \u2693\ufe0e La POO est un paradigme de programmation, au m\u00eame titre que la programmation imp\u00e9rative (que nous pratiquons d\u00e9j\u00e0) ou la programmation fonctionnelle (qui sera \u00e9tudi\u00e9e cette ann\u00e9e en Terminale), ou encore d'autres paradigmes (la liste est longue). Un paradigme de programmation pourrait se d\u00e9finir comme une philosophie dans la mani\u00e8re de programmer : c'est un parti-pris revendiqu\u00e9 dans la mani\u00e8re d'aborder le probl\u00e8me \u00e0 r\u00e9soudre. Une fois cette d\u00e9cision prise, des outils sp\u00e9cifiques au paradigme choisi sont utilis\u00e9s. M\u00e9taphore Imaginons 3 menuisiers qui ont pour mission de fabriquer chacun un meuble. Le premier pourra d\u00e9cider d'utiliser du coll\u00e9-point\u00e9 : il assemblera les morceaux de bois en les collant puis utilisera des pointes. Ses outils seront le marteau et le pistolet \u00e0 colle. Le deuxi\u00e8me pourra d\u00e9cider de visser les morceaux de bois entre eux : son outil principal sera une visseuse. Le troisi\u00e8me pourra d\u00e9cider de faire de l'assemblage par tenons et mortaises : son outil principal sera une d\u00e9fonceuse. Pour la r\u00e9alisation de sa mission, chaque menuisier utilise un paradigme diff\u00e9rent. Qui utilise la meilleure m\u00e9thode ? Cette question n'a pas vraiment de r\u00e9ponse : certaines m\u00e9thodes sont plus rapides que d'autres, d'autres plus robustes, d'autres plus esth\u00e9tiques... Et pourquoi ne pas m\u00e9langer les paradigmes ? Rien n'interdit d'utiliser des pointes ET des vis dans la fabrication d'un meuble. La Programmation Orient\u00e9e Objet sera (surtout \u00e0 notre niveau) m\u00e9lang\u00e9e avec de la programmation imp\u00e9rative, de la programmation fonctionnelle... d'ailleurs vous avez d\u00e9j\u00e0 manipul\u00e9 des objets sans le savoir : 1. Des objets d\u00e9j\u00e0 autour de nous \u2693\ufe0e \ud83d\udc0d Script Python >>> m = [ 4 , 5 , 2 ] >>> type ( m ) list m est une liste, ou plus pr\u00e9cis\u00e9ment un objet de type list . Et en tant qu'objet de type list , il est possible de lui appliquer certaines fonctions pr\u00e9d\u00e9finies (qu'on appelera m\u00e9thodes ) : \ud83d\udc0d Script Python >>> m . reverse () La syntaxe utilis\u00e9e (le . apr\u00e8s le nom de l'objet) est sp\u00e9cifique \u00e0 la POO. Chaque fois que vous voyez cela, c'est que vous \u00eates en train de manipuler des objets. Mais qu'a donc fait cette m\u00e9thode reverse() ? \ud83d\udc0d Script Python >>> m [ 2 , 5 , 4 ] Nous ne sommes pas surpris par ce r\u00e9sultat car la personne qui a programm\u00e9 la m\u00e9thode reverse() lui a donn\u00e9 un nom explicite. Comment a-t-elle programm\u00e9 cette inversion des valeurs de la liste ? Nous n'en savons rien et cela ne nous int\u00e9resse pas. Nous sommes juste utilisateurs de cette m\u00e9thode. L'objet de type list nous a \u00e9t\u00e9 livr\u00e9 avec sa m\u00e9thode reverse() (et bien d'autres choses) et nous n'avons pas \u00e0 d\u00e9monter la bo\u00eete pour en observer les engrenages : on parle de principe d' encapsulation . On peut obtenir la liste de toutes les fonctions disponibles pour un objet de type list , par la fonction dir : \ud83d\udc0d Script Python >>> dir ( m ) [ '__add__' , '__class__' , '__contains__' , '__delattr__' , ... 'clear' , 'copy' , 'count' , 'extend' , 'index' , 'insert' , 'pop' , 'remove' , 'reverse' , 'sort' ] Les m\u00e9thodes encadr\u00e9es par un double underscore __ sont des m\u00e9thodes priv\u00e9es , a priori non destin\u00e9es \u00e0 l'utilisateur. Les m\u00e9thodes publiques , utilisables pour chaque objet de type list , sont donc append , clear , ... Comment savoir ce que font les m\u00e9thodes ? Si elles ont \u00e9t\u00e9 correctement cod\u00e9es (et elles l'ont \u00e9t\u00e9), elles poss\u00e8dent une docstring , accessible par : \ud83d\udc0d Script Python >>> m . append . __doc__ 'Append object to the end of the list.' >>> m . reverse . __doc__ 'Reverse *IN PLACE*.' 2. Cr\u00e9er son propre moule \u00e0 objets sa propre classe \u2693\ufe0e 2.1 Vocabulaire : classe, objet, instance de classe \u2693\ufe0e Jusqu'ici nous avons employ\u00e9 uniquement le mot \u00abobjet\u00bb. Il convient maintenant d'\u00eatre plus pr\u00e9cis. On d\u00e9signera par classe la structure de donn\u00e9es d\u00e9finissant une cat\u00e9gorie g\u00e9n\u00e9rique d'objets. Dans le monde animal, chat est une classe (nomm\u00e9e en r\u00e9alit\u00e9 f\u00e9lid\u00e9 ). Chaque \u00e9lement de la classe chat va se distinguer par des caract\u00e9ristiques : un \u00e2ge, une couleur de pelage, un surnom... (on appelera ces caract\u00e9ristiques des attributs ) et des fonctionnalit\u00e9s, comme la m\u00e9thode attrape_souris() . Lorsqu'on d\u00e9signe un chat en particulier, on d\u00e9signe alors un objet (bien r\u00e9el) qui est une instance de la classe (abstraite) chat . Par exemple, l' objet Larry est une instance de la classe chat . D'apr\u00e8s Wikipedia, \ud83d\udc0d Script Python larry . pelage = \"blanc et tabby\" larry . surnom = \"Chief Mouser to the Cabinet Office\" Toujours d'apr\u00e8s Wikipedia, la m\u00e9thode larry.attrape_souris() est plut\u00f4t efficace. 2.2 Cr\u00e9ation d'une classe \u2693\ufe0e 2.2.1 (mauvaise) mani\u00e8re minimale \u2693\ufe0e Cr\u00e9ons une classe \u00abvoiture\u00bb. Il suffit d'\u00e9crire : \ud83d\udc0d Script Python class Voiture : pass #pass, car pour l'instant il n'y a rien dans la d\u00e9claration de la classe (et c'est mal) La classe Voiture est cr\u00e9\u00e9e. Notez que par convention, le nom d'une classe commence toujours par une majuscule. Pour cr\u00e9er une instance de cette classe, on \u00e9crit : \ud83d\udc0d Script Python >>> titine = Voiture () titine est un objet, instance de la classe Voiture . \ud83d\udc0d Script Python >>> type ( titine ) __main__ . Voiture On peut alors donner des attributs \u00e0 cette instance : \ud83d\udc0d Script Python >>> titine . annee = 2018 >>> titine . couleur = \"verte\" >>> titine . vitesse_max = 162 Mais arr\u00eatons-l\u00e0 cette mauvaise m\u00e9thode. Si on d\u00e9sire cr\u00e9er une classe \u00abvoiture\u00bb, c'est pour cr\u00e9er un concept g\u00e9n\u00e9rique de voiture et d'en sp\u00e9cifier des caract\u00e9ristiques communes : l'ann\u00e9e, la couleur, la vitesse maximale... L'id\u00e9e est donc qu'\u00e0 la cr\u00e9ation (on dira plut\u00f4t \u00e0 la construction ) de chaque objet voiture, on va lui sp\u00e9cifier directement ses attributs : 2.2.2 (bonne) mani\u00e8re : la m\u00e9thode constructeur \u2693\ufe0e La m\u00e9thode constructeur , toujours appel\u00e9e __init__() , est une m\u00e9thode (une \u00abdef\u00bb) qui sera automatiquement appel\u00e9e \u00e0 la cr\u00e9ation de l'objet. Elle va donc le doter de tous les attributs de sa classe. \ud83d\udc0d Script Python 1 2 3 4 5 6 class Voiture : def __init__ ( self , annee , coul , vmax ) : self . annee = annee self . couleur = coul self . vitesse_max = vmax self . age = 2023 - self . annee le mot-cl\u00e9 self , omnipr\u00e9sent en POO (d'autres langages utilisent this ), fait r\u00e9f\u00e9rence \u00e0 l'objet lui-m\u00eame, qui est en train d'\u00eatre construit. pour construire l'objet, 3 param\u00e8tres seront n\u00e9cessaires : annee , coul et vmax . Ils donneront respectivement leur valeur aux attributs annee , couleur et vitesse_max . dans cet exemple, les noms coul et vmax ont \u00e9t\u00e9 utilis\u00e9s pour abr\u00e9ger couleur et vitesse_max , mais il est recommand\u00e9 de garder les m\u00eames noms, m\u00eame si ce n'est pas du tout obligatoire. Construisons donc notre premi\u00e8re voiture ! \ud83d\udc0d Script Python >>> mon_bolide = Voiture ( 2012 , \"rouge\" , 190 ) \ud83d\udc0d Script Python >>> type ( mon_bolide ) __main__ . Voiture mon_bolide poss\u00e8de 4 attributs : annee , couleur et vitesse_max ont \u00e9t\u00e9 donn\u00e9s par l'utilisateur lors de la cr\u00e9ation. age s'est cr\u00e9\u00e9 \u00abtout seul\u00bb par l'instruction self.age = 2021 - self.annee . \ud83d\udc0d Script Python >>> mon_bolide . annee 2012 >>> mon_bolide . couleur 'rouge' >>> mon_bolide . vitesse_max 190 >>> mon_bolide . age 9 Observons les diff\u00e9rentes \u00e9tapes gr\u00e2ce \u00e0 PythonTutor : Bien s\u00fbr, on peut cr\u00e9er une autre voiture en suivant le m\u00eame principe : \ud83d\udc0d Script Python >>> batmobile = Voiture ( 2036 , \"noire\" , 325 ) >>> batmobile . couleur 'noire' Exercice 1 \u00c9nonc\u00e9 Correction Cr\u00e9er une classe Point permettant de cr\u00e9er un objet A , dont on r\u00e9cup\u00e8rera l'abscisse par la variable A.x et l'ordonn\u00e9e par A.y . Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> A = Point ( 3 , 5 ) >>> A . x 3 >>> A . y 5 \ud83d\udc0d Script Python 1 2 3 4 class Point : def __init__ ( self , x , y ): self . x = x self . y = y 2.2.4 Cr\u00e9er une m\u00e9thode pour notre objet \u2693\ufe0e \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 class Voiture : def __init__ ( self , annee , coul , vmax ) : self . annee = annee self . couleur = coul self . vitesse_max = vmax self . age = 2023 - self . annee def petite_annonce ( self ) : print ( \"\u00c0 vendre voiture\" , self . couleur , \"de\" , self . annee , \\ \", vitesse maximale\" , self . vitesse_max , \"km/h.\" ) Remarque : le symbole \\ est utilis\u00e9 ici pour couper une ligne trop longue. \ud83d\udc0d Script Python >>> batmobile = Voiture ( 2036 , \"noire\" , 325 ) >>> batmobile . petite_annonce () \u00c0 vendre voiture noire de 2036 , vitesse maximale 325 km / h . Nous aurions pu (ou d\u00fb) en profiter pour \u00e9crire une docstring pour notre m\u00e9thode petite_annonce() : \ud83d\udc0d Script Python class Voiture : def __init__ ( self , annee , coul , vmax ) : self . annee = annee self . couleur = coul self . vitesse_max = vmax self . age = 2023 - self . annee def petite_annonce ( self ) : \"\"\" R\u00e9dige automatiquement une petite annonce concernant le v\u00e9hicule\"\"\" print ( \"\u00c0 vendre voiture\" , self . couleur , \"de\" , self . annee , \\ \", vitesse maximale\" , self . vitesse_max , \"km/h.\" ) \ud83d\udc0d Script Python >>> batmobile = Voiture ( 2036 , \"noire\" , 325 ) >>> batmobile . petite_annonce . __doc__ ' R\u00e9dige automatiquement une petite annonce concernant le v\u00e9hicule' Que donne la commande dir pour notre objet ? \ud83d\udc0d Script Python dir ( batmobile ) \ud83d\udccb Texte ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'annee', 'couleur', 'petite_annonce', 'vitesse_max'] On y retrouve donc \u00e0 la fois les 4 attributs et l'unique m\u00e9thode que nous avons cr\u00e9\u00e9s pour notre objet. Exercice 2 \u00c9nonc\u00e9 Correction Reprendre la classe de l'exercice pr\u00e9c\u00e9dent et rajouter une m\u00e9thode distance() qui renvoie la distance du point par rapport \u00e0 l'origine du rep\u00e8re (dans un rep\u00e8re orthonorm\u00e9). Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> A = Point ( 3 , 5 ) >>> A . distance () 5.830951894845301 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 class Point : def __init__ ( self , x , y ): self . x = x self . y = y def distance ( self ) : return ( self . x ** 2 + self . y ** 2 ) ** 0.5 3. Compl\u00e9ments \u2693\ufe0e 3.1 Hors-Programme : la m\u00e9thode __str__() \u2693\ufe0e La m\u00e9thode __str__() (les doubles underscores traduisent le fait que la m\u00e9thode est priv\u00e9e ) peut red\u00e9finir la mani\u00e8re dont l'objet doit s'afficher lors qu'on le passe en param\u00e8tre \u00e0 la fonction print() . Observons comment s'affiche un objet de type Fraction lorsque rien n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9 sur son affichage. \ud83d\udc0d Script Python 1 2 3 4 class Fraction : def __init__ ( self , num , den ) : self . numerateur = num self . denominateur = den \ud83d\udc0d Script Python >>> a = Fraction ( 3 , 4 ) >>> print ( a ) < __main__ . Fraction object at 0x7f470445c828 > C'est un peu d\u00e9cevant. Rajoutons donc une m\u00e9thode __str__() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 class Fraction : def __init__ ( self , num , den ) : self . numerateur = num self . denominateur = den def __str__ ( self ): return f \" { self . numerateur } / { self . denominateur } \" \ud83d\udc0d Script Python >>> a = Fraction ( 3 , 4 ) >>> print ( a ) 3 / 4 Ce qui est nettement plus agr\u00e9able ! Exercice 3 \u00c9nonc\u00e9 Correction Modifier la m\u00e9thode __str__ afin de n'afficher que le num\u00e9rateur dans le cas o\u00f9 le d\u00e9nominateur vaut 1. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 class Fraction : def __init__ ( self , num , den ) : self . numerateur = num self . denominateur = den def __str__ ( self ): if self . denominateur == 1 : return str ( self . numerateur ) return f ' { self . numerateur } / { self . denominateur } ' 3.2 L'encapsulation pouss\u00e9e \u00e0 bout : les getters et les setters \u2693\ufe0e Imaginons la classe suivante : \ud83d\udc0d Script Python 1 2 3 4 5 class Joueur : def __init__ ( self , nom , club , age ): self . nom = nom self . club = club self . age = age Instancions le joueur Nans Ducuing \ud83d\udc0d Script Python >>> nducuing = Joueur ( \"Nans DUCUING\" , \"UBB\" , 31 ) notre cobaye 3.2.1 Les setters \u2693\ufe0e Supposons maintenant que ce joueur change de club, pour aller de l'UBB \u00e0 Perpignan. Il serait naturel de faire ceci : \ud83d\udc0d Script Python >>> nducuing . club = \"Perpignan\" Cela marche bien, mais... C'est contraire \u00e0 l'esprit de la Programmation Orient\u00e9e Objet. Ce paradigme milite pour une encapsulation des objets, qui interdisent le plus possible l'acc\u00e8s direct \u00e0 leurs attributs. Comment faire alors ? En proposant une m\u00e9thode dont l'unique travail est d'aller effectuer une modification sur l'attribut : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 class Joueur : def __init__ ( self , nom , club , age ): self . nom = nom self . club = club self . age = age def mutation ( self , nouveau_club ): self . club = nouveau_club Le changement de club se fera maintenant par l'appel : \ud83d\udc0d Script Python >>> nducuing . mutation ( \"Perpignan\" ) Ce type de m\u00e9thode s'appelle un setter . 3.2.2 Les getters \u2693\ufe0e Nous avons vu qu'aller modifier directement un attribut \u00e9tait d\u00e9fendu... mais peut-on simplement aller le consulter ? L\u00e0 encore, le concept d'encapsulation -pouss\u00e9 \u00e0 l'extr\u00eame- peut nous l'interdire. Mais si nducuing.club est interdit, comment savoir dans quel club joue notre joueur pr\u00e9f\u00e9r\u00e9 ? Une fois de plus, en construisant une m\u00e9thode qui va nous renvoyer l'\u00e9tat actuel de son attribut club : \ud83d\udc0d Script Python class Joueur : def __init__ ( self , nom , club , age ): self . nom = nom self . club = club self . age = age def mutation ( self , nouveau_club ): self . club = nouveau_club def get_club ( self ): return self . club L'acc\u00e8s \u00e0 l'attribut club de notre instance se fera donc maintenant par : \ud83d\udc0d Script Python >>> nducuing . get_club () Ce type de m\u00e9thode s'appelle un getter .", "title": "Cours"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#programmation-orientee-objet", "text": "abr\u00e9g\u00e9e par POO en fran\u00e7ais, OOP en anglais (ne pas confondre)", "title": "Programmation orient\u00e9e objet"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#0-introduction", "text": "La POO est un paradigme de programmation, au m\u00eame titre que la programmation imp\u00e9rative (que nous pratiquons d\u00e9j\u00e0) ou la programmation fonctionnelle (qui sera \u00e9tudi\u00e9e cette ann\u00e9e en Terminale), ou encore d'autres paradigmes (la liste est longue). Un paradigme de programmation pourrait se d\u00e9finir comme une philosophie dans la mani\u00e8re de programmer : c'est un parti-pris revendiqu\u00e9 dans la mani\u00e8re d'aborder le probl\u00e8me \u00e0 r\u00e9soudre. Une fois cette d\u00e9cision prise, des outils sp\u00e9cifiques au paradigme choisi sont utilis\u00e9s. M\u00e9taphore Imaginons 3 menuisiers qui ont pour mission de fabriquer chacun un meuble. Le premier pourra d\u00e9cider d'utiliser du coll\u00e9-point\u00e9 : il assemblera les morceaux de bois en les collant puis utilisera des pointes. Ses outils seront le marteau et le pistolet \u00e0 colle. Le deuxi\u00e8me pourra d\u00e9cider de visser les morceaux de bois entre eux : son outil principal sera une visseuse. Le troisi\u00e8me pourra d\u00e9cider de faire de l'assemblage par tenons et mortaises : son outil principal sera une d\u00e9fonceuse. Pour la r\u00e9alisation de sa mission, chaque menuisier utilise un paradigme diff\u00e9rent. Qui utilise la meilleure m\u00e9thode ? Cette question n'a pas vraiment de r\u00e9ponse : certaines m\u00e9thodes sont plus rapides que d'autres, d'autres plus robustes, d'autres plus esth\u00e9tiques... Et pourquoi ne pas m\u00e9langer les paradigmes ? Rien n'interdit d'utiliser des pointes ET des vis dans la fabrication d'un meuble. La Programmation Orient\u00e9e Objet sera (surtout \u00e0 notre niveau) m\u00e9lang\u00e9e avec de la programmation imp\u00e9rative, de la programmation fonctionnelle... d'ailleurs vous avez d\u00e9j\u00e0 manipul\u00e9 des objets sans le savoir :", "title": "0. Introduction"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#1-des-objets-deja-autour-de-nous", "text": "\ud83d\udc0d Script Python >>> m = [ 4 , 5 , 2 ] >>> type ( m ) list m est une liste, ou plus pr\u00e9cis\u00e9ment un objet de type list . Et en tant qu'objet de type list , il est possible de lui appliquer certaines fonctions pr\u00e9d\u00e9finies (qu'on appelera m\u00e9thodes ) : \ud83d\udc0d Script Python >>> m . reverse () La syntaxe utilis\u00e9e (le . apr\u00e8s le nom de l'objet) est sp\u00e9cifique \u00e0 la POO. Chaque fois que vous voyez cela, c'est que vous \u00eates en train de manipuler des objets. Mais qu'a donc fait cette m\u00e9thode reverse() ? \ud83d\udc0d Script Python >>> m [ 2 , 5 , 4 ] Nous ne sommes pas surpris par ce r\u00e9sultat car la personne qui a programm\u00e9 la m\u00e9thode reverse() lui a donn\u00e9 un nom explicite. Comment a-t-elle programm\u00e9 cette inversion des valeurs de la liste ? Nous n'en savons rien et cela ne nous int\u00e9resse pas. Nous sommes juste utilisateurs de cette m\u00e9thode. L'objet de type list nous a \u00e9t\u00e9 livr\u00e9 avec sa m\u00e9thode reverse() (et bien d'autres choses) et nous n'avons pas \u00e0 d\u00e9monter la bo\u00eete pour en observer les engrenages : on parle de principe d' encapsulation . On peut obtenir la liste de toutes les fonctions disponibles pour un objet de type list , par la fonction dir : \ud83d\udc0d Script Python >>> dir ( m ) [ '__add__' , '__class__' , '__contains__' , '__delattr__' , ... 'clear' , 'copy' , 'count' , 'extend' , 'index' , 'insert' , 'pop' , 'remove' , 'reverse' , 'sort' ] Les m\u00e9thodes encadr\u00e9es par un double underscore __ sont des m\u00e9thodes priv\u00e9es , a priori non destin\u00e9es \u00e0 l'utilisateur. Les m\u00e9thodes publiques , utilisables pour chaque objet de type list , sont donc append , clear , ... Comment savoir ce que font les m\u00e9thodes ? Si elles ont \u00e9t\u00e9 correctement cod\u00e9es (et elles l'ont \u00e9t\u00e9), elles poss\u00e8dent une docstring , accessible par : \ud83d\udc0d Script Python >>> m . append . __doc__ 'Append object to the end of the list.' >>> m . reverse . __doc__ 'Reverse *IN PLACE*.'", "title": "1. Des objets d\u00e9j\u00e0 autour de nous"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#2-creer-son-propre-moule-a-objets-sa-propre-classe", "text": "", "title": "2. Cr\u00e9er son propre moule \u00e0 objets sa propre classe"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#21-vocabulaire-classe-objet-instance-de-classe", "text": "Jusqu'ici nous avons employ\u00e9 uniquement le mot \u00abobjet\u00bb. Il convient maintenant d'\u00eatre plus pr\u00e9cis. On d\u00e9signera par classe la structure de donn\u00e9es d\u00e9finissant une cat\u00e9gorie g\u00e9n\u00e9rique d'objets. Dans le monde animal, chat est une classe (nomm\u00e9e en r\u00e9alit\u00e9 f\u00e9lid\u00e9 ). Chaque \u00e9lement de la classe chat va se distinguer par des caract\u00e9ristiques : un \u00e2ge, une couleur de pelage, un surnom... (on appelera ces caract\u00e9ristiques des attributs ) et des fonctionnalit\u00e9s, comme la m\u00e9thode attrape_souris() . Lorsqu'on d\u00e9signe un chat en particulier, on d\u00e9signe alors un objet (bien r\u00e9el) qui est une instance de la classe (abstraite) chat . Par exemple, l' objet Larry est une instance de la classe chat . D'apr\u00e8s Wikipedia, \ud83d\udc0d Script Python larry . pelage = \"blanc et tabby\" larry . surnom = \"Chief Mouser to the Cabinet Office\" Toujours d'apr\u00e8s Wikipedia, la m\u00e9thode larry.attrape_souris() est plut\u00f4t efficace.", "title": "2.1 Vocabulaire : classe,  objet, instance de classe"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#22-creation-dune-classe", "text": "", "title": "2.2 Cr\u00e9ation d'une classe"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/cours/#3-complements", "text": "", "title": "3. Compl\u00e9ments"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/", "text": "Exercices \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire une classe Eleve qui contiendra les attributs nom , classe et note . Instancier trois \u00e9l\u00e8ves de cette classe. \u00c9crire une fonction compare(eleve1, eleve2) qui renvoie le nom de l'\u00e9l\u00e8ve ayant la meilleure note (on ne traitera pas le cas d'\u00e9galit\u00e9). Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> riri = Eleve ( \"Henri\" , \"TG2\" , 12 ) >>> fifi = Eleve ( \"Philippe\" , \"TG6\" , 15 ) >>> loulou = Eleve ( \"Louis\" , \"TG1\" , 8 ) >>> compare ( riri , fifi ) 'Philippe' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 class Eleve : def __init__ ( self , nom , classe , note ): self . nom = nom self . classe = classe self . note = note def compare ( eleve1 , eleve2 ): if eleve1 . note > eleve2 . note : return eleve1 . nom else : return eleve2 . nom Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire une classe TriangleRect qui contiendra les attributs cote1 , cote2 et hypotenuse . La m\u00e9thode constructeur ne prendra en param\u00e8tres que cote1 et cote2 , l'attribut hypotenuse se calculera automatiquement. Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> mon_triangle = TriangleRect ( 3 , 4 ) >>> mon_triangle . cote1 3 >>> mon_triangle . cote2 4 >>> mon_triangle . hypotenuse 5.0 \ud83d\udc0d Script Python 1 2 3 4 5 class TriangleRect : def __init__ ( self , a , b ): self . cote1 = a self . cote2 = b self . hypotenuse = ( self . cote1 ** 2 + self . cote2 ** 2 ) ** 0.5 Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une classe Chrono qui contiendra les attributs heures , minutes et secondes . Doter la classe d'une m\u00e9thode affiche() qui fera affichera le temps t . Doter la classe d'une m\u00e9thode avance(s) qui fera avancer le temps t de s secondes. Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> t = Chrono ( 17 , 25 , 38 ) >>> t . heures 17 >>> t . minutes 25 >>> t . secondes 38 >>> t . affiche () 'Il est 17 heures, 25 minutes et 38 secondes' >>> t . avance ( 27 ) >>> t . affiche () 'Il est 17 heures, 26 minutes et 5 secondes' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Chrono : def __init__ ( self , h , m , s ): self . heures = h self . minutes = m self . secondes = s def affiche ( self ): print ( f \"Il est { self . heures } heures, { self . minutes } minutes \\ et { self . secondes } secondes\" def avance ( self , s ): self . secondes += s # il faut ajouter les minutes suppl\u00e9mentaires si les secondes # d\u00e9passent 60 self . minutes += self . secondes // 60 # il ne faut garder des secondes que ce qui n'a pas servi # \u00e0 fabriquer des minutes suppl\u00e9mentaires self . secondes = self . secondes % 60 # il faut ajouter les heures suppl\u00e9mentaires si les minutes # d\u00e9passent 60 self . heures += self . minutes // 60 # il ne faut garder des minutes que ce qui n'a pas servi # \u00e0 fabriquer des heures suppl\u00e9mentaires self . minutes = self . minutes % 60 Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une classe Player qui : ne prendra aucun argument lors de son instanciation. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut energie valant 3 par d\u00e9faut. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut alive valant True par d\u00e9faut. fournira \u00e0 chaque objet une m\u00e9thode blessure() qui diminue l'attribut energie de 1. fournira \u00e0 chaque objet une m\u00e9thode soin() qui augmente l'attribut energie de 1. si l'attribut energie passe \u00e0 0, l'attribut alive doit passer \u00e0 False et ne doit plus pouvoir \u00e9voluer. Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> mario = Player () >>> mario . energie 3 >>> mario . soin () >>> mario . energie 4 >>> mario . blessure () >>> mario . blessure () >>> mario . blessure () >>> mario . alive True >>> mario . blessure () >>> mario . alive False >>> mario . soin () >>> mario . alive False >>> mario . energie 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Player : def __init__ ( self ): self . energie = 3 self . alive = True def blessure ( self ): self . energie -= 1 if self . energie <= 0 : self . alive = False def soin ( self ): if self . energie > 0 : self . energie += 1 \u00c0 faire sur Capytale Exercice 5 \u00c9nonc\u00e9 Correction Cr\u00e9er une classe CompteBancaire dont la m\u00e9thode constructeur recevra en param\u00e8tres : un attribut titulaire stockant le nom du propri\u00e9taire. un attribut solde contenant le solde disponible sur le compte. Cette classe contiendra deux m\u00e9thodes retrait() et depot() qui permettront de retirer ou de d\u00e9poser de l'argent sur le compte. Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> compteGL = CompteBancaire ( \"James Bond\" , 1000 ) >>> compteGL . retrait ( 50 ) Vous avez retir\u00e9 50 euros Solde actuel du compte : 950 euros >>> compteGL . retrait ( 40000 ) Retrait impossible >>> compteGL . depot ( 10000000 ) Vous avez d\u00e9pos\u00e9 10000000 euros Solde actuel du compte : 10000950 euros Exercice 6 \u00c9nonc\u00e9 Correction Cet exercice est l'exercice 5.2 de la BNS (version 2022) . On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Carte : \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): ??? = [ ??? for couleur in range ( 1 , ??? ) for valeur in range ( 1 , ??? )] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < ??? : return ??? Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Carte : def __init__ ( self , c , v ): \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" assert c in range ( 1 , 5 ) # methode 1 assert c in [ 1 , 2 , 3 , 4 ] # methode 2 assert c >= 1 and c <= 4 # methode 3 assert c >= 1 # methode 4 assert c <= 4 # methode 4 assert 1 <= c <= 4 # methode 5 assert v >= 1 assert v <= 13 self . couleur = c self . valeur = v def getNom ( self ): \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" if ( self . valeur > 1 and self . valeur < 11 ): return str ( self . valeur ) elif self . valeur == 11 : return \"Valet\" elif self . valeur == 12 : return \"Dame\" elif self . valeur == 13 : return \"Roi\" else : return \"As\" def getCouleur ( self ): \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle)\"\"\" return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] def remplir ( self ): \"\"\"Remplit le paquet de cartes\"\"\" self . contenu = [ Carte ( couleur , valeur ) for couleur in range ( 1 , 5 ) for valeur in range ( 1 , 14 ) ] def getCarteAt ( self , pos ): \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" assert 0 <= pos < len ( self . contenu ) return self . contenu [ pos ]", "title": "Exercices"}, {"location": "T2_Programmation/2.1_Programmation_Orientee_Objet/z_Exercices/#exercices", "text": "Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire une classe Eleve qui contiendra les attributs nom , classe et note . Instancier trois \u00e9l\u00e8ves de cette classe. \u00c9crire une fonction compare(eleve1, eleve2) qui renvoie le nom de l'\u00e9l\u00e8ve ayant la meilleure note (on ne traitera pas le cas d'\u00e9galit\u00e9). Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> riri = Eleve ( \"Henri\" , \"TG2\" , 12 ) >>> fifi = Eleve ( \"Philippe\" , \"TG6\" , 15 ) >>> loulou = Eleve ( \"Louis\" , \"TG1\" , 8 ) >>> compare ( riri , fifi ) 'Philippe' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 class Eleve : def __init__ ( self , nom , classe , note ): self . nom = nom self . classe = classe self . note = note def compare ( eleve1 , eleve2 ): if eleve1 . note > eleve2 . note : return eleve1 . nom else : return eleve2 . nom Exercice 2 \u00c9nonc\u00e9 Correction \u00c9crire une classe TriangleRect qui contiendra les attributs cote1 , cote2 et hypotenuse . La m\u00e9thode constructeur ne prendra en param\u00e8tres que cote1 et cote2 , l'attribut hypotenuse se calculera automatiquement. Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> mon_triangle = TriangleRect ( 3 , 4 ) >>> mon_triangle . cote1 3 >>> mon_triangle . cote2 4 >>> mon_triangle . hypotenuse 5.0 \ud83d\udc0d Script Python 1 2 3 4 5 class TriangleRect : def __init__ ( self , a , b ): self . cote1 = a self . cote2 = b self . hypotenuse = ( self . cote1 ** 2 + self . cote2 ** 2 ) ** 0.5 Exercice 3 \u00c9nonc\u00e9 Correction \u00c9crire une classe Chrono qui contiendra les attributs heures , minutes et secondes . Doter la classe d'une m\u00e9thode affiche() qui fera affichera le temps t . Doter la classe d'une m\u00e9thode avance(s) qui fera avancer le temps t de s secondes. Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> t = Chrono ( 17 , 25 , 38 ) >>> t . heures 17 >>> t . minutes 25 >>> t . secondes 38 >>> t . affiche () 'Il est 17 heures, 25 minutes et 38 secondes' >>> t . avance ( 27 ) >>> t . affiche () 'Il est 17 heures, 26 minutes et 5 secondes' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Chrono : def __init__ ( self , h , m , s ): self . heures = h self . minutes = m self . secondes = s def affiche ( self ): print ( f \"Il est { self . heures } heures, { self . minutes } minutes \\ et { self . secondes } secondes\" def avance ( self , s ): self . secondes += s # il faut ajouter les minutes suppl\u00e9mentaires si les secondes # d\u00e9passent 60 self . minutes += self . secondes // 60 # il ne faut garder des secondes que ce qui n'a pas servi # \u00e0 fabriquer des minutes suppl\u00e9mentaires self . secondes = self . secondes % 60 # il faut ajouter les heures suppl\u00e9mentaires si les minutes # d\u00e9passent 60 self . heures += self . minutes // 60 # il ne faut garder des minutes que ce qui n'a pas servi # \u00e0 fabriquer des heures suppl\u00e9mentaires self . minutes = self . minutes % 60 Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une classe Player qui : ne prendra aucun argument lors de son instanciation. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut energie valant 3 par d\u00e9faut. affectera \u00e0 chaque objet cr\u00e9\u00e9 un attribut alive valant True par d\u00e9faut. fournira \u00e0 chaque objet une m\u00e9thode blessure() qui diminue l'attribut energie de 1. fournira \u00e0 chaque objet une m\u00e9thode soin() qui augmente l'attribut energie de 1. si l'attribut energie passe \u00e0 0, l'attribut alive doit passer \u00e0 False et ne doit plus pouvoir \u00e9voluer. Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> mario = Player () >>> mario . energie 3 >>> mario . soin () >>> mario . energie 4 >>> mario . blessure () >>> mario . blessure () >>> mario . blessure () >>> mario . alive True >>> mario . blessure () >>> mario . alive False >>> mario . soin () >>> mario . alive False >>> mario . energie 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Player : def __init__ ( self ): self . energie = 3 self . alive = True def blessure ( self ): self . energie -= 1 if self . energie <= 0 : self . alive = False def soin ( self ): if self . energie > 0 : self . energie += 1 \u00c0 faire sur Capytale Exercice 5 \u00c9nonc\u00e9 Correction Cr\u00e9er une classe CompteBancaire dont la m\u00e9thode constructeur recevra en param\u00e8tres : un attribut titulaire stockant le nom du propri\u00e9taire. un attribut solde contenant le solde disponible sur le compte. Cette classe contiendra deux m\u00e9thodes retrait() et depot() qui permettront de retirer ou de d\u00e9poser de l'argent sur le compte. Exemple d'utilisation de la classe \ud83d\udc0d Script Python >>> compteGL = CompteBancaire ( \"James Bond\" , 1000 ) >>> compteGL . retrait ( 50 ) Vous avez retir\u00e9 50 euros Solde actuel du compte : 950 euros >>> compteGL . retrait ( 40000 ) Retrait impossible >>> compteGL . depot ( 10000000 ) Vous avez d\u00e9pos\u00e9 10000000 euros Solde actuel du compte : 10000950 euros Exercice 6 \u00c9nonc\u00e9 Correction Cet exercice est l'exercice 5.2 de la BNS (version 2022) . On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Carte : \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): ??? = [ ??? for couleur in range ( 1 , ??? ) for valeur in range ( 1 , ??? )] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < ??? : return ??? Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Carte : def __init__ ( self , c , v ): \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" assert c in range ( 1 , 5 ) # methode 1 assert c in [ 1 , 2 , 3 , 4 ] # methode 2 assert c >= 1 and c <= 4 # methode 3 assert c >= 1 # methode 4 assert c <= 4 # methode 4 assert 1 <= c <= 4 # methode 5 assert v >= 1 assert v <= 13 self . couleur = c self . valeur = v def getNom ( self ): \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" if ( self . valeur > 1 and self . valeur < 11 ): return str ( self . valeur ) elif self . valeur == 11 : return \"Valet\" elif self . valeur == 12 : return \"Dame\" elif self . valeur == 13 : return \"Roi\" else : return \"As\" def getCouleur ( self ): \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle)\"\"\" return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] def remplir ( self ): \"\"\"Remplit le paquet de cartes\"\"\" self . contenu = [ Carte ( couleur , valeur ) for couleur in range ( 1 , 5 ) for valeur in range ( 1 , 14 ) ] def getCarteAt ( self , pos ): \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" assert 0 <= pos < len ( self . contenu ) return self . contenu [ pos ]", "title": "Exercices"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite/", "text": "Exercices \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction r\u00e9cursive puissance(x, n) qui calcule le nombre \\(x^n\\) . \ud83d\udc0d Script Python 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) Exercice 2 \u00c9nonc\u00e9 Correction On rappelle que le PGCD (plus grand diviseur commun de deux nombres) v\u00e9rifie la propri\u00e9t\u00e9 suivante : si la division euclidienne de \\(a\\) par \\(b\\) s'\u00e9crit \\(a = b \\times q + r\\) , alors \\(pgcd(a,b)=pgcd(b,r)\\) . Cette propri\u00e9t\u00e9 est \u00e0 la base de l'algorithme d'Euclide Exemple : \\(pgcd(24,18)=pgcd(18,6)=pgcd(6,0)\\) , donc \\(pgcd(24,18)=6\\) \u00c9crire un algorithme r\u00e9cursif pgcd(a,b) . \ud83d\udc0d Script Python 1 2 3 4 5 def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) Exercice 3 \u00c9nonc\u00e9 Correction La conjecture de Syracuse (ou de Collatz) postule ceci : Prenons un nombre \\(n\\) : si \\(n\\) est pair, on le divise par 2, sinon on le multiplie par 3 puis on ajoute 1. On recommence cette op\u00e9ration tant que possible. Au bout d'un certain temps, on finira toujours par tomber sur le nombre 1. Ecrire une fonction r\u00e9cursive syracuse(n) \u00e9crivant tous les termes de la suite de Syracuse, s'arr\u00eatant (on l'esp\u00e8re) \u00e0 la valeur 1. On appelle \u00abtemps de vol\u00bb le nombre d'\u00e9tapes n\u00e9cessaires avant de retomber sur 1. Modifier la fonction pr\u00e9c\u00e9dente afin qu'elle affiche le temps de vol pour tout nombre n . 1. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def syracuse ( n ): print ( n ) if n == 1 : return None if n % 2 == 0 : return syracuse ( n // 2 ) else : return syracuse ( 3 * n + 1 ) Remarque : comme notre fonction syracuse ne renvoie pas de valeur num\u00e9rique (elle ne fait qu'afficher une valeur), le return du test de parit\u00e9 est en fait inutile. Mais le return du cas de base est lui primordial pour que le code s'arr\u00eate ! \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def syracuse ( n ): print ( n ) if n == 1 : return None if n % 2 == 0 : syracuse ( n // 2 ) else : syracuse ( 3 * n + 1 ) 2. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def syracuse ( n , t = 0 ): print ( n ) t += 1 if n == 1 : print ( 'temps de vol :' , t ) return None if n % 2 == 0 : syracuse ( n // 2 , t ) else : syracuse ( 3 * n + 1 , t ) Exercice 4 \u00c9nonc\u00e9 Correction Reproduire le dessin suivant, \u00e0 l'aide du module turtle . turtle est un hommage au langage LOGO invent\u00e9 par Seymour Papert au MIT \u00e0 la fin des ann\u00e9es 60. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) # \u00e0 vous carre ( 200 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) def base ( c ): carre ( c ) forward ( c / 2 ) right ( 45 ) def trace ( c , n ): if n == 0 : return None else : base ( c ) c = c / ( 2 ** 0.5 ) return trace ( c , n - 1 ) trace ( 200 , 5 ) Exercice 5 \u00c9nonc\u00e9 Correction Proposer une nouvelle fonction r\u00e9cursive puissance_mod(x, n) qui calcule le nombre \\(x^n\\) . Pour optimiser la fonction d\u00e9j\u00e0 construite \u00e0 l'exercice 1, utiliser le fait que : si \\(n\\) est pair, \\(a^n=(a \\times a)^{n/2}\\) sinon \\(a^n=a \\times (a \\times a)^{(n-1)/2}\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def puissance_mod ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance_mod ( x * x , n // 2 ) else : return x * puissance_mod ( x * x , ( n - 1 ) // 2 ) Exercice 6 \u00c9nonc\u00e9 Slicing Correction \u00c9crire un algorithme r\u00e9cursif recherche(lst, m) qui recherche la pr\u00e9sence de la valeur m dans une liste tri\u00e9e (par ordre croissant) lst . Cette fonction doit renvoyer un bool\u00e9en. Aide : Les techniques de slicing (hors-programme) permettent de couper une liste en deux : \ud83d\udc0d Script Python >>> lst = [ 10 , 12 , 15 , 17 , 18 , 20 , 22 ] >>> lst [: 3 ] [ 10 , 12 , 15 ] >>> lst [ 3 :] [ 17 , 18 , 20 , 22 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def recherche ( lst , m ): \"\"\"Si la liste n'est pas tri\u00e9e\"\"\" if lst == []: return False if lst [ 0 ] == m : return True else : return recherche ( lst [ 1 :], m ) Si la liste est tri\u00e9e, il faut trouver un slicing bien plus efficace. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( lst , m ): print ( lst ) # pour voir la taille de la liste diminuer (facultatif) if lst == []: return False if len ( lst ) == 1 : #cas de base if lst [ 0 ] == m : return lst [ 0 ] == m else : #cas r\u00e9cursif mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m ) Exercice 7 \u00c9nonc\u00e9 Correction On consid\u00e8re le jeu des Tours de Hano\u00ef . Le but est de faire passer toutes les assiettes de A vers C, sachant qu'une assiette ne peut \u00eatre d\u00e9pos\u00e9e que sur une assiette de diam\u00e8tre inf\u00e9rieur. Une version jouable en ligne peut \u00eatre trouv\u00e9e ici . S'entra\u00eener et essayer d'\u00e9tablir une strat\u00e9gie de victoire. Observer les images ci-dessous : \u00c9crire une fonction r\u00e9cursive hanoi(n, depart, inter, arrivee) qui donnera la suite d'instructions (sous la forme \" A vers C\") pour faire passer une pile de taille n de A vers C en prenant B comme interm\u00e9diaire. Exemple 1: \ud83d\udc0d Console Python hanoi(1, \"A\", \"B\", \"C\") donne: \ud83d\udc0d Console Python A vers C Exemple 2: \ud83d\udc0d Console Python hanoi(2, \"A\", \"B\", \"C\") donne: \ud83d\udc0d Console Python A vers B A vers C B vers C Exemple 3: \ud83d\udc0d Console Python hanoi(3, \"A\", \"B\", \"C\") donne: \ud83d\udc0d Console Python A vers C A vers B C vers B A vers C B vers A B vers C A vers C \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def hanoi ( n , depart , inter , arrivee ): \"\"\" n : nombre d'assiettes dans la pile # depart : la pile de d\u00e9part(\"A\", \"B\" ou \"C\") # inter : la pile interm\u00e9daire(\"A\", \"B\" ou \"C\") # arrivee : la pile d'arriv\u00e9e (\"A\", \"B\" ou \"C\") \"\"\" if n == 1 : print ( depart + \" vers \" + arrivee ) else : hanoi ( n - 1 , depart , arrivee , inter ) print ( depart + \" vers \" + arrivee ) hanoi ( n - 1 , inter , depart , arrivee ) hanoi ( 3 , \"A\" , \"B\" , \"C\" ) Exercice 8 \u00c9nonc\u00e9 Correction Cet exercice a pour objectif le trac\u00e9 du flocon de Von Koch. L'id\u00e9e est de r\u00e9p\u00e9ter de mani\u00e8re r\u00e9cursive la transformation ci-dessous : chaque segment de longueur l donne naissance \u00e0 4 segments de longueur l/3 , en construisant une pointe de triangle \u00e9quilat\u00e9ral sur le deuxi\u00e8me tiers du segment. 1) Cr\u00e9er une fonction r\u00e9cursive floc(n, l) qui trace \u00e0 une \u00abprofondeur\u00bb n un segment de longueur l . Indications l'instruction de trac\u00e9 n'a lieu que quand n vaut 0. l'\u00e9tape n fait 4 appels sucessifs \u00e0 l'\u00e9tape n-1 . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 from turtle import forward , left , right , speed , mainloop def floc ( n , l ): # \u00e0 vous speed ( 0 ) floc ( 3 , 400 ) mainloop () # lance le gestionnaire de fenetres 2) Cr\u00e9er une fonction triangle(n, l) qui trace le flocon complet. Exercice 9 \u00c9nonc\u00e9 Correction Exercice de diffusion r\u00e9cursive sur Capytale Bac \u2693\ufe0e Exercice 4 du sujet Am\u00e9rique du Nord J1 correction Q1.a. Proposition 3 correction Q1.b. txt[0] vaut 'b' txt[taille-1] vaut 'r' interieur vaut 'onjou' correction Q2. \ud83d\udc0d Script Python 1 2 3 def test_palindrome (): assert palindrome ( \"kayak\" ) == True assert palindrome ( \"canoe\" ) == False On teste les deux cas possibles. correction Q3. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def palindrome_imperatif ( txt ): if len ( txt ) < 2 : return True i = 0 j = len ( txt ) - 1 while i < j : if txt [ i ] != txt [ j ]: return False i += 1 j -= 1 return True correction Q4.a. \ud83d\udc0d Script Python 1 2 3 4 5 6 def complementaire ( txt ): comp = { \"A\" : \"T\" , \"T\" : \"A\" , \"G\" : \"C\" , \"C\" : \"G\" } sol = \"\" for c in txt : sol += comp [ c ] return sol correction Q4.b \"GATCGTCTAGCA\" n'est pas un palindrome donc \"GATCGT\" n'est pas palindromique. correction Q4.c \ud83d\udc0d Script Python 1 2 3 def est_palindromique ( txt ): txt_total = txt + complementaire ( txt ) return palindrome ( txt_total ) Bibliographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.", "title": "Exercices"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite/#exercices", "text": "Exercice 1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction r\u00e9cursive puissance(x, n) qui calcule le nombre \\(x^n\\) . \ud83d\udc0d Script Python 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) Exercice 2 \u00c9nonc\u00e9 Correction On rappelle que le PGCD (plus grand diviseur commun de deux nombres) v\u00e9rifie la propri\u00e9t\u00e9 suivante : si la division euclidienne de \\(a\\) par \\(b\\) s'\u00e9crit \\(a = b \\times q + r\\) , alors \\(pgcd(a,b)=pgcd(b,r)\\) . Cette propri\u00e9t\u00e9 est \u00e0 la base de l'algorithme d'Euclide Exemple : \\(pgcd(24,18)=pgcd(18,6)=pgcd(6,0)\\) , donc \\(pgcd(24,18)=6\\) \u00c9crire un algorithme r\u00e9cursif pgcd(a,b) . \ud83d\udc0d Script Python 1 2 3 4 5 def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) Exercice 3 \u00c9nonc\u00e9 Correction La conjecture de Syracuse (ou de Collatz) postule ceci : Prenons un nombre \\(n\\) : si \\(n\\) est pair, on le divise par 2, sinon on le multiplie par 3 puis on ajoute 1. On recommence cette op\u00e9ration tant que possible. Au bout d'un certain temps, on finira toujours par tomber sur le nombre 1. Ecrire une fonction r\u00e9cursive syracuse(n) \u00e9crivant tous les termes de la suite de Syracuse, s'arr\u00eatant (on l'esp\u00e8re) \u00e0 la valeur 1. On appelle \u00abtemps de vol\u00bb le nombre d'\u00e9tapes n\u00e9cessaires avant de retomber sur 1. Modifier la fonction pr\u00e9c\u00e9dente afin qu'elle affiche le temps de vol pour tout nombre n . 1. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def syracuse ( n ): print ( n ) if n == 1 : return None if n % 2 == 0 : return syracuse ( n // 2 ) else : return syracuse ( 3 * n + 1 ) Remarque : comme notre fonction syracuse ne renvoie pas de valeur num\u00e9rique (elle ne fait qu'afficher une valeur), le return du test de parit\u00e9 est en fait inutile. Mais le return du cas de base est lui primordial pour que le code s'arr\u00eate ! \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def syracuse ( n ): print ( n ) if n == 1 : return None if n % 2 == 0 : syracuse ( n // 2 ) else : syracuse ( 3 * n + 1 ) 2. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def syracuse ( n , t = 0 ): print ( n ) t += 1 if n == 1 : print ( 'temps de vol :' , t ) return None if n % 2 == 0 : syracuse ( n // 2 , t ) else : syracuse ( 3 * n + 1 , t ) Exercice 4 \u00c9nonc\u00e9 Correction Reproduire le dessin suivant, \u00e0 l'aide du module turtle . turtle est un hommage au langage LOGO invent\u00e9 par Seymour Papert au MIT \u00e0 la fin des ann\u00e9es 60. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) # \u00e0 vous carre ( 200 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) def base ( c ): carre ( c ) forward ( c / 2 ) right ( 45 ) def trace ( c , n ): if n == 0 : return None else : base ( c ) c = c / ( 2 ** 0.5 ) return trace ( c , n - 1 ) trace ( 200 , 5 ) Exercice 5 \u00c9nonc\u00e9 Correction Proposer une nouvelle fonction r\u00e9cursive puissance_mod(x, n) qui calcule le nombre \\(x^n\\) . Pour optimiser la fonction d\u00e9j\u00e0 construite \u00e0 l'exercice 1, utiliser le fait que : si \\(n\\) est pair, \\(a^n=(a \\times a)^{n/2}\\) sinon \\(a^n=a \\times (a \\times a)^{(n-1)/2}\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def puissance_mod ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance_mod ( x * x , n // 2 ) else : return x * puissance_mod ( x * x , ( n - 1 ) // 2 ) Exercice 6 \u00c9nonc\u00e9 Slicing Correction \u00c9crire un algorithme r\u00e9cursif recherche(lst, m) qui recherche la pr\u00e9sence de la valeur m dans une liste tri\u00e9e (par ordre croissant) lst . Cette fonction doit renvoyer un bool\u00e9en. Aide : Les techniques de slicing (hors-programme) permettent de couper une liste en deux : \ud83d\udc0d Script Python >>> lst = [ 10 , 12 , 15 , 17 , 18 , 20 , 22 ] >>> lst [: 3 ] [ 10 , 12 , 15 ] >>> lst [ 3 :] [ 17 , 18 , 20 , 22 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def recherche ( lst , m ): \"\"\"Si la liste n'est pas tri\u00e9e\"\"\" if lst == []: return False if lst [ 0 ] == m : return True else : return recherche ( lst [ 1 :], m ) Si la liste est tri\u00e9e, il faut trouver un slicing bien plus efficace. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( lst , m ): print ( lst ) # pour voir la taille de la liste diminuer (facultatif) if lst == []: return False if len ( lst ) == 1 : #cas de base if lst [ 0 ] == m : return lst [ 0 ] == m else : #cas r\u00e9cursif mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m ) Exercice 7 \u00c9nonc\u00e9 Correction On consid\u00e8re le jeu des Tours de Hano\u00ef . Le but est de faire passer toutes les assiettes de A vers C, sachant qu'une assiette ne peut \u00eatre d\u00e9pos\u00e9e que sur une assiette de diam\u00e8tre inf\u00e9rieur. Une version jouable en ligne peut \u00eatre trouv\u00e9e ici . S'entra\u00eener et essayer d'\u00e9tablir une strat\u00e9gie de victoire. Observer les images ci-dessous : \u00c9crire une fonction r\u00e9cursive hanoi(n, depart, inter, arrivee) qui donnera la suite d'instructions (sous la forme \" A vers C\") pour faire passer une pile de taille n de A vers C en prenant B comme interm\u00e9diaire. Exemple 1: \ud83d\udc0d Console Python hanoi(1, \"A\", \"B\", \"C\") donne: \ud83d\udc0d Console Python A vers C Exemple 2: \ud83d\udc0d Console Python hanoi(2, \"A\", \"B\", \"C\") donne: \ud83d\udc0d Console Python A vers B A vers C B vers C Exemple 3: \ud83d\udc0d Console Python hanoi(3, \"A\", \"B\", \"C\") donne: \ud83d\udc0d Console Python A vers C A vers B C vers B A vers C B vers A B vers C A vers C \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def hanoi ( n , depart , inter , arrivee ): \"\"\" n : nombre d'assiettes dans la pile # depart : la pile de d\u00e9part(\"A\", \"B\" ou \"C\") # inter : la pile interm\u00e9daire(\"A\", \"B\" ou \"C\") # arrivee : la pile d'arriv\u00e9e (\"A\", \"B\" ou \"C\") \"\"\" if n == 1 : print ( depart + \" vers \" + arrivee ) else : hanoi ( n - 1 , depart , arrivee , inter ) print ( depart + \" vers \" + arrivee ) hanoi ( n - 1 , inter , depart , arrivee ) hanoi ( 3 , \"A\" , \"B\" , \"C\" ) Exercice 8 \u00c9nonc\u00e9 Correction Cet exercice a pour objectif le trac\u00e9 du flocon de Von Koch. L'id\u00e9e est de r\u00e9p\u00e9ter de mani\u00e8re r\u00e9cursive la transformation ci-dessous : chaque segment de longueur l donne naissance \u00e0 4 segments de longueur l/3 , en construisant une pointe de triangle \u00e9quilat\u00e9ral sur le deuxi\u00e8me tiers du segment. 1) Cr\u00e9er une fonction r\u00e9cursive floc(n, l) qui trace \u00e0 une \u00abprofondeur\u00bb n un segment de longueur l . Indications l'instruction de trac\u00e9 n'a lieu que quand n vaut 0. l'\u00e9tape n fait 4 appels sucessifs \u00e0 l'\u00e9tape n-1 . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 from turtle import forward , left , right , speed , mainloop def floc ( n , l ): # \u00e0 vous speed ( 0 ) floc ( 3 , 400 ) mainloop () # lance le gestionnaire de fenetres 2) Cr\u00e9er une fonction triangle(n, l) qui trace le flocon complet. Exercice 9 \u00c9nonc\u00e9 Correction Exercice de diffusion r\u00e9cursive sur Capytale", "title": "Exercices"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite/#bac", "text": "Exercice 4 du sujet Am\u00e9rique du Nord J1 correction Q1.a. Proposition 3 correction Q1.b. txt[0] vaut 'b' txt[taille-1] vaut 'r' interieur vaut 'onjou' correction Q2. \ud83d\udc0d Script Python 1 2 3 def test_palindrome (): assert palindrome ( \"kayak\" ) == True assert palindrome ( \"canoe\" ) == False On teste les deux cas possibles. correction Q3. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def palindrome_imperatif ( txt ): if len ( txt ) < 2 : return True i = 0 j = len ( txt ) - 1 while i < j : if txt [ i ] != txt [ j ]: return False i += 1 j -= 1 return True correction Q4.a. \ud83d\udc0d Script Python 1 2 3 4 5 6 def complementaire ( txt ): comp = { \"A\" : \"T\" , \"T\" : \"A\" , \"G\" : \"C\" , \"C\" : \"G\" } sol = \"\" for c in txt : sol += comp [ c ] return sol correction Q4.b \"GATCGTCTAGCA\" n'est pas un palindrome donc \"GATCGT\" n'est pas palindromique. correction Q4.c \ud83d\udc0d Script Python 1 2 3 def est_palindromique ( txt ): txt_total = txt + complementaire ( txt ) return palindrome ( txt_total ) Bibliographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.", "title": "Bac"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/", "text": "Exercice 1 \u2693\ufe0e \u00c9crire une fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . \ud83d\udc0d Script Python def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) \ud83d\udc0d Script Python puissance ( 2 , 10 ) \ud83d\udccb Texte 1024 Exercice 2 \u2693\ufe0e \u00c9crire une fonction r\u00e9cursive boucle(i,k) qui affiche les entiers entre i et k . Par exemple, boucle(2,5) doit afficher 2 3 4 5 \ud83d\udc0d Script Python def boucle ( i , k ): if i == k : print ( i ) else : print ( i ) boucle ( i + 1 , k ) \ud83d\udc0d Script Python boucle ( 2 , 5 ) \ud83d\udccb Texte 2 3 4 5 \ud83d\udc0d Script Python Exercice 3 \u2693\ufe0e On rappelle que le PGCD (plus grand diviseur commun de deux nombres) v\u00e9rifie la propri\u00e9t\u00e9 suivante : si la division euclidienne de \\(a\\) par \\(b\\) s'\u00e9crit \\(a = b \\times q + r\\) , alors \\(pgcd(a,b)=pgcd(b,r)\\) . Cette propri\u00e9t\u00e9 est \u00e0 la base de l'algorithme d'Euclide Exemple : \\(pgcd(24,18)=pgcd(18,6)=pgcd(6,0)\\) , donc \\(pgcd(24,18)=6\\) \u00c9crire un algorithme r\u00e9cursif pgcd(a,b) . \ud83d\udc0d Script Python def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) def pgcd2 ( a , b ): return a if b == 0 else pgcd2 ( b , a % b ) print ( pgcd ( 18 , 12 )) print ( pgcd2 ( 18 , 12 )) \ud83d\udccb Texte 6 6 Exercice 4 \u2693\ufe0e La conjecture de Syracuse (ou de Collatz) postule ceci : Prenons un nombre \\(n\\) : si \\(n\\) est pair, on le divise par 2, sinon on le multiplie par 3 puis on ajoute 1. On recommence cette op\u00e9ration tant que possible. Au bout d'un certain temps, on finira toujours par tomber sur le nombre 1. Proposer un programme r\u00e9cursif syracuse(n) \u00e9crivant tous les termes de la suite de Syracuse, s'arr\u00eatant (on l'esp\u00e8re) \u00e0 la valeur 1. \ud83d\udc0d Script Python def syracuse ( n ): print ( n ) if n == 1 : return None else : if n % 2 == 0 : return syracuse ( n // 2 ) else : return syracuse ( 3 * n + 1 ) \ud83d\udc0d Script Python syracuse ( 14 ) \ud83d\udccb Texte 14 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 Exercice 5 \u2693\ufe0e Reproduire le dessin suivant, \u00e0 l'aide du module turtle . turtle est un hommage au langage LOGO invent\u00e9 par Seymour Papert au MIT \u00e0 la fin des ann\u00e9es 60. \ud83d\udc0d Script Python from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) def base ( c ): carre ( c ) forward ( c / 2 ) right ( 45 ) def trace ( c ): if c < 5 : return None else : base ( c ) return trace ( c / ( 2 ** 0.5 )) trace ( 200 ) Exercice 6 \u2693\ufe0e Proposer une nouvelle fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . Pour optimiser la fonction d\u00e9j\u00e0 construite \u00e0 l'exercice 1, utiliser le fait que : - si \\(n\\) est pair, \\(a^n=(a \\times a)^{n/2}\\) - sinon \\(a^n=a \\times (a \\times a)^{(n-1)/2}\\) \ud83d\udc0d Script Python def puissance ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance ( x * x , n // 2 ) else : return x * puissance ( x * x ,( n - 1 ) // 2 ) \ud83d\udc0d Script Python puissance ( 10 , 3 ) \ud83d\udccb Texte 1000 \ud83d\udc0d Script Python puissance ( 10 , 6 ) \ud83d\udccb Texte 1000000 Exercice 7 \u2693\ufe0e \u00c9crire un algorithme r\u00e9cursif recherche(lst,m) qui recherche la pr\u00e9sence de la valeur m dans une liste tri\u00e9e lst . Cette fonction doit renvoyer un bool\u00e9en. \ud83d\udc0d Script Python lst = [ 5 , 6 , 9 , 12 , 17 ] \ud83d\udc0d Script Python lst [: 3 ] \ud83d\udccb Texte [5, 6, 9] \ud83d\udc0d Script Python lst [ 3 :] \ud83d\udccb Texte [12, 17] \ud83d\udc0d Script Python def recherche ( lst , m ): print ( lst ) # pour voir la taille de la liste diminuer if len ( lst ) == 1 : #cas de base if lst [ 0 ] == m : return True else : return False else : #cas r\u00e9cursif mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m ) lst = [ 5 , 6 , 9 , 12 , 17 ] recherche ( lst , 18 ) \ud83d\udccb Texte [5, 6, 9, 12, 17] [9, 12, 17] [12, 17] [17] False Exercice 8 \u2693\ufe0e On consid\u00e8re le jeu des Tours de Hano\u00ef . Le but est de faire passer toutes les assiettes de A vers C, sachant qu'une assiette ne peut \u00eatre d\u00e9pos\u00e9e que sur une assiette de diam\u00e8tre inf\u00e9rieur. Une version jouable en ligne peut \u00eatre trouv\u00e9e ici . S'entra\u00eener et essayer d'\u00e9tablir une strat\u00e9gie de victoire. Observer les images ci-dessous : \u00c9crire une fonction r\u00e9cursive hanoi(n, A, B, C) qui donnera la suite d'instructions (sous la forme \" A vers C\") pour faire passer une pile de taille n de A vers C en prenant B comme interm\u00e9diaire. \ud83d\udc0d Script Python def hanoi ( n , A , B , C ): \"\"\" n : nombre d'assiettes dans la pile # A : la pile de d\u00e9part(\"A\", \"B\" ou \"C\") # B : la pile interm\u00e9daire(\"A\", \"B\" ou \"C\") # C : la pile d'arriv\u00e9e (\"A\", \"B\" ou \"C\") \"\"\" if n == 1 : print ( A + \" vers \" + C ) else : hanoi ( n - 1 , A , C , B ) #de A vers B en passant par C print ( A + \" vers \" + C ) hanoi ( n - 1 , B , A , C ) hanoi ( 5 , \"Tower1\" , \"Tower2\" , \"Tower3\" ) \ud83d\udccb Texte Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower3 vers Tower1 Tower2 vers Tower1 Tower3 vers Tower2 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower2 vers Tower1 Tower3 vers Tower2 Tower3 vers Tower1 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Exercice 9 \u2693\ufe0e Cet exercice a pour objectif le trac\u00e9 du flocon de Von Koch. L'id\u00e9e est de r\u00e9p\u00e9ter de mani\u00e8re r\u00e9cursive la transformation ci-dessous : chaque segment de longueur l donne naissance \u00e0 4 segments de longueur l/3 , en construisant une pointe de triangle \u00e9quilat\u00e9ral sur le deuxi\u00e8me tiers du segment. 1) Cr\u00e9er une fonction r\u00e9cursive floc(n,l) qui trace \u00e0 une \u00abprofondeur\u00bb n un segment de longueur l . Indications - l'instruction de trac\u00e9 n'a lieu que quand n vaut 0. - l'\u00e9tape n fait 4 appels sucessifs \u00e0 l'\u00e9tape n-1 . 2) Cr\u00e9er une fonction triangle(n,l) qui trace le flocon complet. \ud83d\udc0d Script Python from turtle import * def floc ( n , l ): if n == 0 : forward ( l ) else : floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) right ( 120 ) floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) def triangle ( n , l ): for _ in range ( 3 ): floc ( n , l ) right ( 120 ) speed ( 0 ) triangle ( 4 , 150 ) Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. G.Lassus, Lyc\u00e9e Fran\u00e7ois Mauriac -- Bordeaux \ud83d\udc0d Script Python", "title": "2 Exercices recursivite corr"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-1", "text": "\u00c9crire une fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . \ud83d\udc0d Script Python def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) \ud83d\udc0d Script Python puissance ( 2 , 10 ) \ud83d\udccb Texte 1024", "title": "Exercice 1"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-2", "text": "\u00c9crire une fonction r\u00e9cursive boucle(i,k) qui affiche les entiers entre i et k . Par exemple, boucle(2,5) doit afficher 2 3 4 5 \ud83d\udc0d Script Python def boucle ( i , k ): if i == k : print ( i ) else : print ( i ) boucle ( i + 1 , k ) \ud83d\udc0d Script Python boucle ( 2 , 5 ) \ud83d\udccb Texte 2 3 4 5 \ud83d\udc0d Script Python", "title": "Exercice 2"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-3", "text": "On rappelle que le PGCD (plus grand diviseur commun de deux nombres) v\u00e9rifie la propri\u00e9t\u00e9 suivante : si la division euclidienne de \\(a\\) par \\(b\\) s'\u00e9crit \\(a = b \\times q + r\\) , alors \\(pgcd(a,b)=pgcd(b,r)\\) . Cette propri\u00e9t\u00e9 est \u00e0 la base de l'algorithme d'Euclide Exemple : \\(pgcd(24,18)=pgcd(18,6)=pgcd(6,0)\\) , donc \\(pgcd(24,18)=6\\) \u00c9crire un algorithme r\u00e9cursif pgcd(a,b) . \ud83d\udc0d Script Python def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) def pgcd2 ( a , b ): return a if b == 0 else pgcd2 ( b , a % b ) print ( pgcd ( 18 , 12 )) print ( pgcd2 ( 18 , 12 )) \ud83d\udccb Texte 6 6", "title": "Exercice 3"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-4", "text": "La conjecture de Syracuse (ou de Collatz) postule ceci : Prenons un nombre \\(n\\) : si \\(n\\) est pair, on le divise par 2, sinon on le multiplie par 3 puis on ajoute 1. On recommence cette op\u00e9ration tant que possible. Au bout d'un certain temps, on finira toujours par tomber sur le nombre 1. Proposer un programme r\u00e9cursif syracuse(n) \u00e9crivant tous les termes de la suite de Syracuse, s'arr\u00eatant (on l'esp\u00e8re) \u00e0 la valeur 1. \ud83d\udc0d Script Python def syracuse ( n ): print ( n ) if n == 1 : return None else : if n % 2 == 0 : return syracuse ( n // 2 ) else : return syracuse ( 3 * n + 1 ) \ud83d\udc0d Script Python syracuse ( 14 ) \ud83d\udccb Texte 14 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1", "title": "Exercice 4"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-5", "text": "Reproduire le dessin suivant, \u00e0 l'aide du module turtle . turtle est un hommage au langage LOGO invent\u00e9 par Seymour Papert au MIT \u00e0 la fin des ann\u00e9es 60. \ud83d\udc0d Script Python from turtle import * def carre ( c ): for k in range ( 4 ): forward ( c ) right ( 90 ) def base ( c ): carre ( c ) forward ( c / 2 ) right ( 45 ) def trace ( c ): if c < 5 : return None else : base ( c ) return trace ( c / ( 2 ** 0.5 )) trace ( 200 )", "title": "Exercice 5"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-6", "text": "Proposer une nouvelle fonction r\u00e9cursive puissance(x,n) qui calcule le nombre \\(x^n\\) . Pour optimiser la fonction d\u00e9j\u00e0 construite \u00e0 l'exercice 1, utiliser le fait que : - si \\(n\\) est pair, \\(a^n=(a \\times a)^{n/2}\\) - sinon \\(a^n=a \\times (a \\times a)^{(n-1)/2}\\) \ud83d\udc0d Script Python def puissance ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance ( x * x , n // 2 ) else : return x * puissance ( x * x ,( n - 1 ) // 2 ) \ud83d\udc0d Script Python puissance ( 10 , 3 ) \ud83d\udccb Texte 1000 \ud83d\udc0d Script Python puissance ( 10 , 6 ) \ud83d\udccb Texte 1000000", "title": "Exercice 6"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-7", "text": "\u00c9crire un algorithme r\u00e9cursif recherche(lst,m) qui recherche la pr\u00e9sence de la valeur m dans une liste tri\u00e9e lst . Cette fonction doit renvoyer un bool\u00e9en. \ud83d\udc0d Script Python lst = [ 5 , 6 , 9 , 12 , 17 ] \ud83d\udc0d Script Python lst [: 3 ] \ud83d\udccb Texte [5, 6, 9] \ud83d\udc0d Script Python lst [ 3 :] \ud83d\udccb Texte [12, 17] \ud83d\udc0d Script Python def recherche ( lst , m ): print ( lst ) # pour voir la taille de la liste diminuer if len ( lst ) == 1 : #cas de base if lst [ 0 ] == m : return True else : return False else : #cas r\u00e9cursif mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m ) lst = [ 5 , 6 , 9 , 12 , 17 ] recherche ( lst , 18 ) \ud83d\udccb Texte [5, 6, 9, 12, 17] [9, 12, 17] [12, 17] [17] False", "title": "Exercice 7"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-8", "text": "On consid\u00e8re le jeu des Tours de Hano\u00ef . Le but est de faire passer toutes les assiettes de A vers C, sachant qu'une assiette ne peut \u00eatre d\u00e9pos\u00e9e que sur une assiette de diam\u00e8tre inf\u00e9rieur. Une version jouable en ligne peut \u00eatre trouv\u00e9e ici . S'entra\u00eener et essayer d'\u00e9tablir une strat\u00e9gie de victoire. Observer les images ci-dessous : \u00c9crire une fonction r\u00e9cursive hanoi(n, A, B, C) qui donnera la suite d'instructions (sous la forme \" A vers C\") pour faire passer une pile de taille n de A vers C en prenant B comme interm\u00e9diaire. \ud83d\udc0d Script Python def hanoi ( n , A , B , C ): \"\"\" n : nombre d'assiettes dans la pile # A : la pile de d\u00e9part(\"A\", \"B\" ou \"C\") # B : la pile interm\u00e9daire(\"A\", \"B\" ou \"C\") # C : la pile d'arriv\u00e9e (\"A\", \"B\" ou \"C\") \"\"\" if n == 1 : print ( A + \" vers \" + C ) else : hanoi ( n - 1 , A , C , B ) #de A vers B en passant par C print ( A + \" vers \" + C ) hanoi ( n - 1 , B , A , C ) hanoi ( 5 , \"Tower1\" , \"Tower2\" , \"Tower3\" ) \ud83d\udccb Texte Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower3 vers Tower1 Tower2 vers Tower1 Tower3 vers Tower2 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower2 vers Tower1 Tower3 vers Tower2 Tower3 vers Tower1 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3 Tower1 vers Tower2 Tower3 vers Tower2 Tower1 vers Tower3 Tower2 vers Tower1 Tower2 vers Tower3 Tower1 vers Tower3", "title": "Exercice 8"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#exercice-9", "text": "Cet exercice a pour objectif le trac\u00e9 du flocon de Von Koch. L'id\u00e9e est de r\u00e9p\u00e9ter de mani\u00e8re r\u00e9cursive la transformation ci-dessous : chaque segment de longueur l donne naissance \u00e0 4 segments de longueur l/3 , en construisant une pointe de triangle \u00e9quilat\u00e9ral sur le deuxi\u00e8me tiers du segment. 1) Cr\u00e9er une fonction r\u00e9cursive floc(n,l) qui trace \u00e0 une \u00abprofondeur\u00bb n un segment de longueur l . Indications - l'instruction de trac\u00e9 n'a lieu que quand n vaut 0. - l'\u00e9tape n fait 4 appels sucessifs \u00e0 l'\u00e9tape n-1 . 2) Cr\u00e9er une fonction triangle(n,l) qui trace le flocon complet. \ud83d\udc0d Script Python from turtle import * def floc ( n , l ): if n == 0 : forward ( l ) else : floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) right ( 120 ) floc ( n - 1 , l / 3 ) left ( 60 ) floc ( n - 1 , l / 3 ) def triangle ( n , l ): for _ in range ( 3 ): floc ( n , l ) right ( 120 ) speed ( 0 ) triangle ( 4 , 150 )", "title": "Exercice 9"}, {"location": "T2_Programmation/2.2_Recursivite/2_Exercices_recursivite_corr/#bibliographie", "text": "Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. G.Lassus, Lyc\u00e9e Fran\u00e7ois Mauriac -- Bordeaux \ud83d\udc0d Script Python", "title": "Bibliographie"}, {"location": "T2_Programmation/2.2_Recursivite/cours/", "text": "R\u00e9cursivit\u00e9 \u2693\ufe0e 1. Premi\u00e8re approche \u2693\ufe0e 1.1. D\u00e9finition \u2693\ufe0e Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition. 1.2 Un tr\u00e8s mauvais exemple \u2693\ufe0e C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. \ud83d\udc0d Script Python 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : \ud83d\udc0d Script Python >>> prems () La sortie en console sera celle-ci : \ud83d\udccb Texte un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie . 1.3 La mauvaise r\u00e9putation \u2693\ufe0e Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association. 2. La r\u00e9cursivit\u00e9, \u00e7a marche ! \u2693\ufe0e Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat. 2.1 La r\u00e9cursivit\u00e9 en BD : \u2693\ufe0e Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb : 2.2 Enfin un bon exemple \u2693\ufe0e Exemple fondateur n\u00b01 \ud83d\udc0d Script Python 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere \ud83d\udc0d Script Python >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice 1 \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. \ud83d\udc0d Script Python 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice 2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: \\[ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1\\] Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (dite aussi mani\u00e8re it\u00e9rative ou mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 ) 3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9 \u2693\ufe0e 3.1 Notion de pile \u2693\ufe0e Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile (voir ici ), seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci : 3.2 Limitation de la taille de la pile \u2693\ufe0e Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? \ud83d\udc0d Script Python mystere ( 2962 ) \ud83d\udccb Texte --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ). 4. Exemples de r\u00e9cursivit\u00e9 double \u2693\ufe0e 4.1 La suite de Fibonacci \u2693\ufe0e Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice 3 \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonacci. Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. Observation sur Capytale (code cca1-1932300) avec rcviz (Module Python pour visualiser une r\u00e9cursion sous forme d'arbre avec des arguments et des valeurs de retour \u00e0 chaque n\u0153ud.) On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois... 4.2 Comparaison des performances \u2693\ufe0e Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonacci. Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . \ud83d\udc0d Script Python % timeit fibo_imperatif ( 20 ) \ud83d\udccb Texte 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) \ud83d\udc0d Script Python % timeit fibo_recursif ( 20 ) \ud83d\udccb Texte 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef) 5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle \u2693\ufe0e Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )", "title": "Cours"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#recursivite", "text": "", "title": "R\u00e9cursivit\u00e9"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#1-premiere-approche", "text": "", "title": "1. Premi\u00e8re approche"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#11-definition", "text": "Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive lorsqu'elle fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition.", "title": "1.1. D\u00e9finition"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#12-un-tres-mauvais-exemple", "text": "C'est d\u00e9j\u00e0 une premi\u00e8re chose \u00e0 comprendre : un programme peut \u00eatre appel\u00e9 par lui-m\u00eame, \u00e0 l'int\u00e9rieur de sa propre d\u00e9finition. \ud83d\udc0d Script Python 1 2 3 def prems (): print ( \"un tr\u00e8s mauvais exemple\" ) prems () Si on appelle cette fonction, par la commande : \ud83d\udc0d Script Python >>> prems () La sortie en console sera celle-ci : \ud83d\udccb Texte un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple un tr\u00e8s mauvais exemple ... \u00c9videmment, comme pr\u00e9vu, ce programme ne s'arr\u00eate pas. Nous sommes oblig\u00e9s de l'arr\u00eater manuellement. Nous sommes (volontairement) tomb\u00e9s dans un pi\u00e8ge qui sera syst\u00e9matiquement pr\u00e9sent lors d'une programmation r\u00e9cursive : le pi\u00e8ge de la boucle infinie .", "title": "1.2 Un tr\u00e8s mauvais exemple"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#13-la-mauvaise-reputation", "text": "Dans la culture informatique, la r\u00e9cursivit\u00e9 est (trop) souvent abord\u00e9e par le biais de l'auto-r\u00e9f\u00e9rence, le puits sans fin de la boucle infinie. On trouve d'ailleurs fr\u00e9quemment cette d\u00e9finition de la r\u00e9cursivit\u00e9 : Fonction r\u00e9cursive : fonction qui fait appel \u00e0 la r\u00e9cursivit\u00e9. Voir fonction r\u00e9cursive . Google fait aussi (dans toutes les langues) la m\u00eame blague lors d'une recherche sur le terme \u00abr\u00e9cursivit\u00e9\u00bb : Les acronymes r\u00e9cursifs sont aussi tr\u00e8s fr\u00e9quents... et v\u00e9hiculent avec eux le m\u00eame pi\u00e8ge : une fonction r\u00e9cursive ne serait jamais vraiment d\u00e9finie (c'est faux, nous le verrons) Par exemple : GNU (dans GNU/Linux) signifie GNU is Not Unix. On ne sait jamais vraiment ce que signifie GNU... PHP (le langage serveur) sigifie PHP: Hypertext Preprocessor VISA (les cartes bancaires) signifie VISA International Service Association.", "title": "1.3 La mauvaise r\u00e9putation"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#2-la-recursivite-ca-marche", "text": "Disons-le clairement : au-del\u00e0 de la blague pour initi\u00e9s (dont vous faites partie maintenant) la r\u00e9cursivit\u00e9 ne DOIT PAS \u00eatre associ\u00e9e \u00e0 une auto-r\u00e9f\u00e9rence vertigineuse : c'est en algorithmique une m\u00e9thode (parfois) tr\u00e8s efficace, \u00e0 condition de respecter une r\u00e8gle cruciale : l'existence d'un CAS DE BASE . Ce \u00abcas de base\u00bb sera aussi appel\u00e9 \u00abcondition d'arr\u00eat\u00bb, puisque la tr\u00e8s grande majorit\u00e9 des algorithmes r\u00e9cursifs peuvent \u00eatre per\u00e7us comme des escaliers qu'on descend marche par marche, jusqu'au sol qui assure notre arr\u00eat.", "title": "2. La r\u00e9cursivit\u00e9, \u00e7a marche !"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#21-la-recursivite-en-bd", "text": "Observez bien la descente puis la remont\u00e9e de notre vendeur de livre. Le cas de base est ici l'\u00e9tage 0. Il emp\u00eache une descente infinie. Nous coderons bient\u00f4t la fonction donnant le prix du livre en fonction de l'\u00e9tage. Pour l'instant, d\u00e9couvrons enfin \u00e0 quoi ressemble une fonction r\u00e9cursive \u00abbien \u00e9crite\u00bb :", "title": "2.1 La r\u00e9cursivit\u00e9 en BD :"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#22-enfin-un-bon-exemple", "text": "Exemple fondateur n\u00b01 \ud83d\udc0d Script Python 1 2 3 4 5 def mystere ( n ): if n == 0 : return 0 else : return n + mystere ( n - 1 ) Trois choses sont essentielles et doivent se retrouver dans tout programme r\u00e9cursif : lignes 2 et 3 : le cas de base (si n vaut 0 on renvoie vraiment une valeur, en l'occurence 0) ligne 5 : l'appel r\u00e9cursif ligne 5 : la d\u00e9cr\u00e9mentation du param\u00e8tre d'appel Utilisation de la fonction mystere \ud83d\udc0d Script Python >>> mystere ( 0 ) 0 >>> mystere ( 4 ) 10 Analyse gr\u00e2ce \u00e0 PythonTutor Que se passe-t-il lorsqu'on appelle mystere(4) ? \\[\\begin{align} \\rm{mystere(4)} &= 4+ \\rm{mystere(3)}\\\\ &= 4+ (3+\\rm{mystere(2)}) \\\\ &= 4+ (3+(2+\\rm{mystere(1)} )) \\\\ &= 4+ (3+(2+(1+\\rm{mystere(0)} ))) \\\\ &= 4+ (3+(2+(1+0 ))) \\\\ \\end{align}\\] On voit que l'existence du cas de base pour \\(n=0\\) est primordiale pour \u00e9viter la r\u00e9cursion infinie. Cette fonction mystere(n) calcule donc la somme des entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . Remarque historique mystere(100) est \u00e9gal \u00e0 5050. Une anecdote raconte que Carl Friedrich Gauss trouva cette valeur de 5050 en quelques secondes, devant son instituteur \u00e9bahi. Il venait pour cela d'inventer la formule : \\(1+2+3+\\dots+n=\\frac{n(n+1)}{2}\\) Ici, \\(1+2+3+\\dots+100=\\frac{100\\times 101)}{2}=50 \\times 101=5050\\) Exercice 1 \u00c9nonc\u00e9 Correction Coder la fonction prix(etage) de la BD pr\u00e9sent\u00e9e plus haut. \ud83d\udc0d Script Python 1 2 3 4 5 def prix ( etage ): if etage == 0 : return 3 else : return 2 * prix ( etage - 1 ) Exercice 2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction factorielle(n) (not\u00e9e \\(n!\\) en math\u00e9matiques), qui calcule le produit d'un entier \\(n\\) par les entiers positifs qui lui sont inf\u00e9rieurs: \\[ n! = n \\times (n-1) \\times (n-2) \\times \\dots \\times 3 \\times 2 \\times 1\\] Exemple : \\(5!=5\\times4\\times3\\times2\\times1=120\\) Par convention, \\(1!=1\\) Programmer de mani\u00e8re imp\u00e9rative (dite aussi mani\u00e8re it\u00e9rative ou mani\u00e8re classique ) la fonction factorielle. On l'appelera fact_imp . Programmer de fa\u00e7on r\u00e9cursive la fonction factorielle. On l'appelera fact_rec . Quelle paradigme de programmation vous a sembl\u00e9 le plus naturel ? \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def fact_imp ( n ): p = 1 for k in range ( 1 , n + 1 ): p = p * k return p def fact_rec ( n ): if n == 1 : return 1 else : return n * fact_rec ( n - 1 )", "title": "2.2 Enfin un bon exemple"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#3-le-mecanisme-interne-de-la-recursivite", "text": "", "title": "3. Le m\u00e9canisme interne de la r\u00e9cursivit\u00e9"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#31-notion-de-pile", "text": "Lors d'un appel \u00e0 une fonction r\u00e9cursive, le processeur utilise une structure de pile pour stocker les contextes d'ex\u00e9cution de chaque appel. Dans la notion de pile (voir ici ), seule l'instruction \u00aben haut de la pile\u00bb peut \u00eatre trait\u00e9e et enlev\u00e9e (on dit \u00abd\u00e9pil\u00e9e\u00bb). La pile d'appels de notre fonction mystere(5) peut donc \u00eatre sch\u00e9matis\u00e9e comme ceci :", "title": "3.1 Notion de pile"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#32-limitation-de-la-taille-de-la-pile", "text": "Nous venons de voir que notre appel \u00e0 mystere(5) g\u00e9n\u00e9rait une pile de hauteur 6 (on parlera plut\u00f4t de profondeur 6). Cette profondeur est-elle limit\u00e9e ? \ud83d\udc0d Script Python mystere ( 2962 ) \ud83d\udccb Texte --------------------------------------------------------------------------- RecursionError Traceback (most recent call last) <ipython-input-32-a97c4dde4ef8> in <module> ----> 1 mystere(2962) <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) ... last 1 frames repeated, from the frame below ... <ipython-input-1-386660a434f2> in mystere(n) 3 return 0 4 else : ----> 5 return n + mystere(n-1) RecursionError: maximum recursion depth exceeded in comparison Vous venons de provoquer un \u00abd\u00e9bordement de pile\u00bb, le c\u00e9l\u00e8bre stack overflow . De mani\u00e8re g\u00e9n\u00e9rale, les programmes r\u00e9cursifs sont souvent susceptibles de g\u00e9n\u00e9rer un trop grand nombre d'appels \u00e0 eux-m\u00eames. Il est parfois possible de les optimiser, comme nous le verrons dans le cours concernant la programmation dynamique . Nous reparlerons aussi de r\u00e9cursivit\u00e9 lorsque nous l'inscrirons dans un paradigme plus global de programmation, qui est \u00ab diviser pour r\u00e9gner \u00bb (en anglais divide and conquer ).", "title": "3.2 Limitation de la taille de la pile"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#4-exemples-de-recursivite-double", "text": "", "title": "4. Exemples de r\u00e9cursivit\u00e9 double"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#41-la-suite-de-fibonacci", "text": "Consid\u00e9rons la suite num\u00e9rique ainsi d\u00e9finie : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) On a donc \\(F_2=0+1=1, F_3=F_2+F_1=1+1=2, F_4=F_3+F_2=2+1=3, F_5=F_4+F_3=3+2=5\\) ... Exercice 3 \u00c9nonc\u00e9 Correction Impl\u00e9menter de fa\u00e7on r\u00e9cursive la suite de Fibonacci. Observation de la pile d'ex\u00e9cution Appelons F(n) la fonction calculant de mani\u00e8re r\u00e9cursive le n-i\u00e8me terme de la suite. Observons en d\u00e9tail la pile d'ex\u00e9cution lors du calcul de F(4) . Analyse gr\u00e2ce \u00e0 PythonTutor On s'aper\u00e7oit notamment que : les appels r\u00e9cursifs ne sont PAS simultan\u00e9s (rappelons que la simultan\u00e9it\u00e9 n'existe th\u00e9oriquement pas en informatique). On pourrait s'imaginer que la relation \\(F_4=F_3+F_2\\) allait d\u00e9clencher deux \u00abfils\u00bb r\u00e9cursifs calculant respectivement \\(F_3\\) et \\(F_2\\) . Il n'en est rien, on va jusqu'au bout du calcul de \\(F_3\\) avant de s'int\u00e9resser \u00e0 \\(F_2\\) . cons\u00e9quence de la remarque pr\u00e9c\u00e9dente : le calcul de \\(F_2\\) s'effectue 2 fois. Une am\u00e9lioration future (appel\u00e9e m\u00e9mo\u00efsation , voir le cours de programmation dynamique) sera de conserver cette valeur de \\(F_2\\) afin d'am\u00e9liorer les calculs. Observation sur Capytale (code cca1-1932300) avec rcviz (Module Python pour visualiser une r\u00e9cursion sous forme d'arbre avec des arguments et des valeurs de retour \u00e0 chaque n\u0153ud.) On peut y construire par exemple l'arbre d'appel de fibo(6) : On y remarque (par exemple) que fibo(2) est calcul\u00e9 5 fois...", "title": "4.1 La suite de Fibonacci"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#42-comparaison-des-performances", "text": "Exercice 4 \u00c9nonc\u00e9 Correction \u00c9crire une fonction fibo_imperatif(n) qui calcule de fa\u00e7on directe ( imp\u00e9rative ) le n-i\u00e8me terme de la suite de Fibonacci. Observons gr\u00e2ce au module timeit le temps moyen pris pour calculer \\(F(20)\\) avec les deux fonctions fibo_imperatif() et fibo_recursif() . \ud83d\udc0d Script Python % timeit fibo_imperatif ( 20 ) \ud83d\udccb Texte 1.02 \u00b5s \u00b1 14 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each) \ud83d\udc0d Script Python % timeit fibo_recursif ( 20 ) \ud83d\udccb Texte 2.35 ms \u00b1 10.8 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) La programmation r\u00e9cursive apparait donc comme quasiment 1000 fois plus lente que l'imp\u00e9rative. Attention : cette comparaison des vitesses d'\u00e9x\u00e9cution peut \u00eatre critiqu\u00e9e car les deux programmes n'ont pas la m\u00eame complexit\u00e9 . Nous \u00e9tudierons la complexit\u00e9 au moment des algorithmes de tri. Peut-on r\u00e9sumer la r\u00e9cursivit\u00e9 \u00e0 une m\u00e9thode \u00e9l\u00e9gante mais inefficace ? Ce serait r\u00e9ducteur : l'efficacit\u00e9 c'est aussi avoir un code lisible et intuitif. Nous en reparlerons lors du parcours des arbres et des graphes. (cf aussi l'exercice sur les Tours de Hano\u00ef)", "title": "4.2 Comparaison des performances"}, {"location": "T2_Programmation/2.2_Recursivite/cours/#5-annexe-dessins-recursifs-grace-au-module-turtle", "text": "Le module turtle permet de faire des trac\u00e9s basiques. Mais d\u00e8s l'instant o\u00f9 on met de la r\u00e9cursivit\u00e9 dans le code, les r\u00e9sultats peuvent devenir tr\u00e8s surprenants, et aboutir \u00e0 des structures fractales . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * ang = 40 def trace ( n , l ): if n == 0 : return None else : forward ( l ) left ( ang ) trace ( n - 1 , 0.7 * l ) right ( 2 * ang ) trace ( n - 1 , 0.7 * l ) left ( ang ) forward ( - l ) penup () goto ( 0 , - 80 ) pendown () left ( 90 ) speed ( 0 ) trace ( 5 , 100 )", "title": "5. Annexe : dessins r\u00e9cursifs gr\u00e2ce au module turtle"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/", "text": "D\u00e9cidabilit\u00e9, calculabilit\u00e9 \u2693\ufe0e 1. Un programme comme param\u00e8tre d'un programme \u2693\ufe0e Les codes que nous manipulons ressemblent souvent \u00e0 cela : \ud83d\udc0d Script Python def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) Le programme s'appelle accueil , et pour fonctionner il a besoin d'un param\u00e8tre, qui sera ici un nombre entier n . Voici comment nous pouvons repr\u00e9senter notre machine accueil , son param\u00e8tre d'entr\u00e9e (5) et sa sortie (les 5 \u00abbonjour\u00bb) Maintenant, enregistrons le code suivant dans un fichier test.py : \ud83d\udc0d Script Python def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) accueil ( 5 ) Pour ex\u00e9cuter ce code, nous devons taper dans un terminal l'instruction suivante : python3 test.py , ce qui donnera Le programme utilis\u00e9 est alors python3 , qui prend comme param\u00e8tre le programme test.py . Ce param\u00e8tre test.py est un ensemble de caract\u00e8res qui contient les instructions que le programme python3 va interpr\u00e9ter. L'illustration correspondante sera donc : Mais nous pouvons aller encore plus loin : l'instruction python3 test.py est tap\u00e9e dans mon Terminal Linux, qui lui-m\u00eame est un programme appel\u00e9 Terminal . Et donc : Conclusion : Il n'y a donc aucun obstacle \u00e0 consid\u00e9rer un programme comme une simple donn\u00e9e, pouvant \u00eatre re\u00e7ue en param\u00e8tre par un autre programme. (voire par lui-m\u00eame !) \u00c0 titre anecdotique, on pourra ex\u00e9cuter avec int\u00e9r\u00eat cette instruction Python : a='a=%r;print(a%%a)';print(a%a) Ce type de code (magique !) existe dans tous les langages et s'appelle un quine . 2. Mon programme va-t-il s'arr\u00eater ? \u2693\ufe0e 2.1 Un exemple \u2693\ufe0e Consid\u00e9rons le programme suivant : \ud83d\udc0d Script Python def countdown ( n ): while n != 0 : print ( n ) n = n - 1 print ( \"fini\" ) En l'observant attentivement, je peux pr\u00e9voir que countdown(10) affichera les nombres de 10 \u00e0 1 avant d'\u00e9crire \"fini\". Puis le programme s'arr\u00eatera. Mais que va provoquer countdown(10.8) ? Comme la variable n ne sera jamais \u00e9gale \u00e0 0, le programme va rentrer dans une boucle infinie, il ne s'arr\u00eatera jamais. Mauvaise nouvelle. J'ai pu pr\u00e9voir ceci en regardant attentivement le code de mon programme. J'ai \u00abremarqu\u00e9\u00bb qu'une variable n non enti\u00e8re provoquerait une boucle infinie. Question : Est-ce qu'un programme d' analyse de programmes aurait pu faire cela \u00e0 ma place ? 2.2 Une machine pour pr\u00e9dire l'arr\u00eat ou non d'un programme. \u2693\ufe0e Apr\u00e8s tout, un programme est une suite d'instructions (le code-source), et peut donc \u00eatre, comme on l'a vu, le param\u00e8tre d'entr\u00e9e d'un autre programme qui l'analyserait. Un tel programme (appelons-le halt ) prendrait en entr\u00e9es : un param\u00e8tre prog (le code-source du programme) un param\u00e8tre x , qui serait le param\u00e8tre d'entr\u00e9e de prog . L'instruction halt(prog, x) renverrait True si prog(x) s'arr\u00eate, et False si prog(x) ne s'arr\u00eate pas. Exemple : halt(countdown, 10) renverrait True . halt(countdown, 10.8) renverrait False . Tentative d'\u00e9criture de halt en Python : \ud83d\udc0d Script Python def halt ( prog , x ): if \"prog(x) s'arr\u00eate\" : # mes excuses, je n'ai pas eu le temps de finir totalement ce code return True else : return False Nous en resterons l\u00e0 pour l'instant dans l'\u00e9criture de ce programme. Nous allons nous en servir pour construire d'autres programmes. 2.3 Amusons-nous avec ce programme halt . \u2693\ufe0e Consid\u00e9rons le programme : \ud83d\udc0d Script Python def sym ( prog ): if halt ( prog , prog ) == True : while True : print ( \"vers l'infini et au-del\u00e0 !\" ) else : return 1 On peut remarquer que le programme halt est appel\u00e9 avec comme param\u00e8tres prog, prog , ce qui signifie que prog se prend lui-m\u00eame en param\u00e8tre. On rappelle que ce n'est pas choquant, un code-source \u00e9tant une donn\u00e9e comme une autre. Ce programme sym re\u00e7oit donc en param\u00e8tre un programme prog , et : va rentrer dans une boucle infinie si prog(prog) s'arr\u00eate. va renvoyer 1 si prog(prog) ne s'arr\u00eate pas. 2.4 Un l\u00e9ger probl\u00e8me ... \u2693\ufe0e Puisqu'un programme peut prendre en param\u00e8tre son propre code-source, que donnerait l'appel \u00e0 sym(sym) ? Deux cas peuvent se pr\u00e9senter, suivant si halt(sym, sym) renvoie True ou False . cas n\u00b01 : halt(sym, sym) renvoie True , ce qui signifie que sym(sym) devrait s'arr\u00eater. Mais dans ce cas-l\u00e0, l'ex\u00e9cution de sym(sym) rentre dans une boucle infinie. C'est une contradiction. cas n\u00b02 : halt(sym, sym) renvoie False , ce qui signifie que sym(sym) rentre dans une boucle infinie. Mais dans ce cas-l\u00e0, l'ex\u00e9cution de sym(sym) se termine correctement et renvoie la valeur 1. C'est une contradiction. 2.5 Conclusion \u2693\ufe0e Nous venons de prouver que notre programme halt , cens\u00e9 pr\u00e9dire si un programme prog peut s'arr\u00eater sur une entr\u00e9e x , NE PEUT PAS EXISTER . Ce r\u00e9sultat th\u00e9orique, d'une importance cruciale, s'appelle le probl\u00e8me de l'arr\u00eat . Probl\u00e8me de l'arr\u00eat Il ne peut pas exister de programme universel qui prendrait en entr\u00e9es : un programme P une entr\u00e9e E de ce programme P et qui d\u00e9terminerait si ce programme P, lanc\u00e9 avec l'entr\u00e9e E, va s'arr\u00eater ou non. Ce r\u00e9sultat a \u00e9t\u00e9 d\u00e9montr\u00e9 par Alan Turing en 1936, dans un article intitul\u00e9 \u00abOn computable numbers, with an application to the Entscheidungsproblem\u00bb . Pour sa d\u00e9monstration, il pr\u00e9sente un mod\u00e8le th\u00e9orique de machine capable d'ex\u00e9cuter des instructions basiques sur un ruban infini, les machines de Turing . \u00c0 la m\u00eame \u00e9poque, le math\u00e9maticien Alonzo Church d\u00e9montre lui aussi ce th\u00e9or\u00e8me de l'arr\u00eat, mais par un moyen totalement diff\u00e9rent, en inventant le lambda-calcul . Tous deux mettent ainsi un terme au r\u00eave du math\u00e9maticien allemand David Hilbert , qui avait en 1928 pos\u00e9 la question de l'existence d'un algorithme capable de r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 n'importe quel \u00e9nonc\u00e9 math\u00e9matique pos\u00e9 sous forme d\u00e9cisionnelle (\u00abun triangle rectangle peut-il \u00eatre isoc\u00e8le ?\u00bb, \u00abexiste-t-il un nombre premier pair ?\u00bb) Cette question, appel\u00e9e \u00abprobl\u00e8me de la d\u00e9cision\u00bb, ou Entscheidungsproblem en allemand, est d\u00e9finitivement tranch\u00e9e par le probl\u00e8me de l'arr\u00eat : un tel th\u00e9or\u00e8me ne peut pas exister, puisque par exemple, aucun algorithme ne peut r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 la question \u00abce programme va-t-il s'arr\u00eater ?\u00bb. Le th\u00e9or\u00e8me de l'arr\u00eat sera \u00e9tendu plus tard par le th\u00e9or\u00e8me de Rice . Ce r\u00e9sultat d\u00e9montre que toutes les questions s\u00e9mantiques (non \u00e9videntes) au sujet d'un programme sont ind\u00e9cidables : \u00abce programme va-t-il s'arr\u00eater ?\u00bb (le th\u00e9or\u00e8me de l'arr\u00eat) \u00abce programme va renvoyer la valeur 12 ?\u00bb \u00abce programme va-t-il un jour renvoyer un message d'erreur ?\u00bb ... Rice d\u00e9montre que toutes ces questions peuvent \u00eatre ramen\u00e9es (on dit r\u00e9duites ) au th\u00e9or\u00e8me de l'arr\u00eat, qui est ind\u00e9cidable. 2. Calculabilit\u00e9 \u2693\ufe0e D\u00e9cidabilit\u00e9 et calculabilit\u00e9 Le probl\u00e8me de l'arr\u00eat est dit ind\u00e9cidable car la fonction qui le r\u00e9sout (notre brave programme halt ) n'est pas calculable . 2.1 Notion de calculabilit\u00e9 \u2693\ufe0e Qu'y a-t-il derri\u00e8re cette notion de calculabilit\u00e9 ? Cette notion, qui jette un pont entre les math\u00e9matiques (la vision de Church, pour sch\u00e9matiser) et l'informatique (la vision de Turing) n'est pas simple \u00e0 d\u00e9finir ! Le calcul math\u00e9matique peut se r\u00e9duire \u00e0 une succession d'op\u00e9rations \u00e9l\u00e9mentaires (songez \u00e0 la multiplication enti\u00e8re comme une s\u00e9rie d'additions). Les nombres calculables sont les nombres qui sont g\u00e9n\u00e9rables en un nombre fini d'op\u00e9rations \u00e9l\u00e9mentaires. De la m\u00eame mani\u00e8re, une fonction math\u00e9matique sera dite calculable s'il existe une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires permettant de passer d'un nombre x \u00e0 son image f(x). On retrouve cette notion d'op\u00e9rations \u00e9l\u00e9mentaires dans les machines de Turing . Cette machine (th\u00e9orique) permet de simuler tout ce qu'un programme informatique (une suite d'instructions) est capable d'ex\u00e9cuter. Un algorithme peut se r\u00e9duire \u00e0 une suite d'op\u00e9rations \u00e9lementaires, comme une fonction math\u00e9matique peut se r\u00e9duire \u00e0 une suite de calculs. D\u00e8s lors, on pourra consid\u00e9rer un algorithme comme une fonction. Turing a d\u00e9montr\u00e9 que l'ensemble des fonctions calculables, au sens de Church, \u00e9tait \u00e9quivalent \u00e0 l'ensemble des fonctions programmables sur sa machine. Certaines fonctions peuvent \u00eatre calculables, ou ne pas l'\u00eatre : c'est notamment le cas de notre fonction du probl\u00e8me de l'arr\u00eat. 2.2 Langages Turing-complets \u2693\ufe0e Ce r\u00e9sultat ne d\u00e9pend pas du langage utilis\u00e9 : le fait que nous ayons utilis\u00e9 Python au paragraphe pr\u00e9c\u00e9dent n'a pas d'influence sur notre d\u00e9monstration. Nous savons depuis les machines de Turing que tous nos langages de programmation sont Turing-complets : ils sont tous capables de faire la m\u00eame chose (avec plus ou moins de facilit\u00e9 !). Scratch, C, Python, Java, Basic, Haskell, Brainfuck... tous ces langages sont th\u00e9oriquement \u00e9quivalents : la calculabilit\u00e9 ne d\u00e9pend pas du langage utilis\u00e9 . 2.3 (HP) Calculable, oui, mais facilement ? -> 1 million de $ \u00e0 gagner ci-dessous. \u2693\ufe0e L'\u00e9tude de la calculabilit\u00e9 d'une fonction (\u00e0 prendre au sens le plus large, c'est-\u00e0-dire un algorithme) ne se limite pas \u00e0 un choix binaire : \u00abcalculable\u00bb vs \u00abnon calculable\u00bb. Parmi les fonctions calculables, certaines peuvent l'\u00eatre rapidement, et d'autre beaucoup moins. On retrouve alors la notion bien connue de complexit\u00e9 algorithmique, qui permet de classifier les algorithmes suivant leur d\u00e9pendance \u00e0 la taille de leurs donn\u00e9es d'entr\u00e9e (voir le cours de Premi\u00e8re). On peut regrouper les probl\u00e8mes suivant la complexit\u00e9 de l'algorithme qui permet de les r\u00e9soudre. 2.3.1 la classe P \u2693\ufe0e D\u00e9finition de la classe P On dira que sont de \u00abclasse P\u00bb tous les probl\u00e8mes dont l'algorithme de recherche de solution est de complexit\u00e9 polynomiale . Que retrouve-t-on dans la classe P ? Tous les probl\u00e8mes dont la solution est un algorithme de complexit\u00e9 lin\u00e9raire, quadratique, logarithmique... Tout mais surtout pas un algorithme de complexit\u00e9 exponentielle. Pour le r\u00e9sumer tr\u00e8s grossi\u00e8rement, un probl\u00e8me de classe P est un probl\u00e8me que l'on sait r\u00e9soudre en temps raisonnable (m\u00eame grand). le probl\u00e8me du tri d'une liste est dans P. le probl\u00e8me de la factorisation d'un grand nombre (sur lequel repose la s\u00e9curit\u00e9 du RSA) n'est a priori pas dans P. le probl\u00e8me de la primalit\u00e9 (\u00abce nombre est-il premier ?\u00bb) a longtemps \u00e9t\u00e9 consid\u00e9r\u00e9 comme n'\u00e9tant pas dans P... jusqu'en 2002, o\u00f9 a \u00e9t\u00e9 d\u00e9couvert le test de primalit\u00e9 AKS , de complexit\u00e9 polynomiale (d'ordre 6). Ce test est donc maintenant dans P. 2.3.2 la classe NP \u2693\ufe0e D\u00e9finition de la classe NP On dira que sont de \u00abclasse NP\u00bb tous les probl\u00e8mes dont l'algorithme de recherche de solution est Non-d\u00e9terministe Polynomial . Warning : NP ne signifie pas Non-Polynomial !!! Que veut dire la formulation \u00abnon-d\u00e9terministe polynomial\u00bb ? Cela fait r\u00e9f\u00e9rence \u00e0 ce que serait capable de faire une machine de Turing (donc, n'importe quel ordinateur) travaillant de mani\u00e8re non-d\u00e9terministe , donc capable d'explorer simultan\u00e9ment plusieurs solutions possibles. On peut imaginer un arbre dont le parcours se ferait simultan\u00e9ment dans toutes les branches, et non en largeur ou profondeur comme nous l'avons vu. Sur une machine non-d\u00e9terministe, si la solution \u00e0 un probl\u00e8me se trouve en temps polynomial, alors ce probl\u00e8me appartient \u00e0 la classe NP. Tr\u00e8s bien, mais les machines non-d\u00e9terministes... cela n'existe pas r\u00e9ellement. Comment caract\u00e9riser concr\u00e8tement cette classe de probl\u00e8me ? Si la solution peut \u00eatre trouv\u00e9e de mani\u00e8re polynomiale par une machine non-d\u00e9terministe, une machine d\u00e9terministe qui aurait de la chance en partant directement vers la bonne solution la trouverait elle aussi de mani\u00e8re polynomiale. On simplifie souvent cela en disant \u00abla v\u00e9rification de la solution est polynomiale\u00bb. Cela nous donnne cette d\u00e9finition plus accessible de la classe NP : D\u00e9finition (plus simple) de la classe NP On dira que sont de \u00abclasse NP\u00bb tous les probl\u00e8mes dont l'algorithme de v\u00e9rification de solution est polynomial . Pour le r\u00e9sumer tr\u00e8s grossi\u00e8rement, un probl\u00e8me de classe NP est un probl\u00e8me dont on sait v\u00e9rifier facilement si une solution propos\u00e9e marche ou pas : la r\u00e9solution d'un sudoku est dans NP : si quelqu'un vous montre un sudoku rempli, vous pouvez tr\u00e8s rapidement lui dire si sa solution est valable ou pas. la factorisation d'un nombre est dans NP : si quelqu'un vous propose 4567*6037 comme d\u00e9composition de 27570979, vous pouvez tr\u00e8s rapidement lui dire s'il a raison. (oui.) le probl\u00e8me du sac \u00e0 dos (en version d\u00e9cisionnelle) est dans NP. Une proposition de butin peut facilement \u00eatre examin\u00e9e pour savoir si elle est possible ou non. le probl\u00e8me du voyageur de commerce (ou TSP : Traveller Sales Problem), en version d\u00e9cisionnelle, est dans NP. Si on vous propose un trajet, vous pouvez facilement v\u00e9rifier que sa longueur est (par exemple) inf\u00e9rieure \u00e0 150 km. Malheureusement, aucun de ces probl\u00e8mes cit\u00e9s n'a (\u00e0 ce jour) d'algorithme de r\u00e9solution meilleur qu'exponentiel... 2.2.3 P = NP, ou pas ? \u2693\ufe0e Tous les probl\u00e8mes de P ont une solution qui peut \u00eatre trouv\u00e9e de mani\u00e8re polynomiale. Donc \u00e9videmment, la v\u00e9rification de cette solution est aussi polynomiale. Donc tous les probl\u00e8mes de P sont dans NP. On dit que P est inclus dans NP, que l'on \u00e9crit P \u2282 NP . Voici une capture d'\u00e9cran de l'excellente vid\u00e9o Nos algorithmes pourraient-ils \u00eatre BEAUCOUP plus rapides ? (P=NP ?) de l'excellent David Louapre : On y retrouve (en vert) la classe P, qui contient les algorithmes de tri. En blanc, la classe NP, qui contient les probl\u00e8mes de factorisation, du sudoku, du sac-\u00e0-dos... Si quelqu'un trouve un jour un algorithme de polynomial de factorisation, alors le probl\u00e8me de factorisation viendra se ranger dans P. (accessoirement, le RSA sera sans doute d\u00e9truit par cette d\u00e9couverte, sauf si l'ordre de complexit\u00e9 est tr\u00e8s grand) Mais certains de ces probl\u00e8mes dans NP ont une propri\u00e9t\u00e9 remarquable : la r\u00e9solution polynomiale d'un seul d'entre eux ferait ramener la totalit\u00e9 des probl\u00e8mes NP dans P. On dit que ces probl\u00e8mes sont NP-complets (marqu\u00e9s en rouge ci-dessus) Concr\u00e8tement, si vous trouvez une solution polynomiale de r\u00e9solution du sudoku, vous entrainez avec lui dans P tous les autres probl\u00e8mes NP, et vous aurez ainsi prouv\u00e9 que P = NP. Accessoirement, vous gagnerez aussi le prix d' un million de dollars promis par la fondation Clay \u00e0 qui tranchera cette question... (prix que vous partagerez bien \u00e9videmment avec votre professeur de NSI) Actuellement, \u00e0 part le grand Donald Knuth , la plupart des chercheurs qui travaillent \u00e0 ce probl\u00e8me sont plut\u00f4t pessimistes, et pensent que P \u2260 NP. Cela signifie qu'ils pensent que certains probl\u00e8mes ne pourront jamais avoir une solution polynomiale. Alors, P = NP ou P \u2260 NP ? R\u00e9ponse peut-\u00eatre un jour... Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://interstices.info/pnp-elementaire-ma-chere-watson/ https://interstices.info/alan-turing-du-calculable-a-lindecidable/ https://www.labri.fr/perso/betrema/MC/MC8.html https://scienceetonnante.com/2020/07/17/est-ce-que-p-np/", "title": "D\u00e9cidabilit\u00e9, calculabilit\u00e9"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#decidabilite-calculabilite", "text": "", "title": "D\u00e9cidabilit\u00e9, calculabilit\u00e9"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#1-un-programme-comme-parametre-dun-programme", "text": "Les codes que nous manipulons ressemblent souvent \u00e0 cela : \ud83d\udc0d Script Python def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) Le programme s'appelle accueil , et pour fonctionner il a besoin d'un param\u00e8tre, qui sera ici un nombre entier n . Voici comment nous pouvons repr\u00e9senter notre machine accueil , son param\u00e8tre d'entr\u00e9e (5) et sa sortie (les 5 \u00abbonjour\u00bb) Maintenant, enregistrons le code suivant dans un fichier test.py : \ud83d\udc0d Script Python def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) accueil ( 5 ) Pour ex\u00e9cuter ce code, nous devons taper dans un terminal l'instruction suivante : python3 test.py , ce qui donnera Le programme utilis\u00e9 est alors python3 , qui prend comme param\u00e8tre le programme test.py . Ce param\u00e8tre test.py est un ensemble de caract\u00e8res qui contient les instructions que le programme python3 va interpr\u00e9ter. L'illustration correspondante sera donc : Mais nous pouvons aller encore plus loin : l'instruction python3 test.py est tap\u00e9e dans mon Terminal Linux, qui lui-m\u00eame est un programme appel\u00e9 Terminal . Et donc : Conclusion : Il n'y a donc aucun obstacle \u00e0 consid\u00e9rer un programme comme une simple donn\u00e9e, pouvant \u00eatre re\u00e7ue en param\u00e8tre par un autre programme. (voire par lui-m\u00eame !) \u00c0 titre anecdotique, on pourra ex\u00e9cuter avec int\u00e9r\u00eat cette instruction Python : a='a=%r;print(a%%a)';print(a%a) Ce type de code (magique !) existe dans tous les langages et s'appelle un quine .", "title": "1. Un programme comme param\u00e8tre d'un programme"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#2-mon-programme-va-t-il-sarreter", "text": "", "title": "2. Mon programme va-t-il s'arr\u00eater ?"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#21-un-exemple", "text": "Consid\u00e9rons le programme suivant : \ud83d\udc0d Script Python def countdown ( n ): while n != 0 : print ( n ) n = n - 1 print ( \"fini\" ) En l'observant attentivement, je peux pr\u00e9voir que countdown(10) affichera les nombres de 10 \u00e0 1 avant d'\u00e9crire \"fini\". Puis le programme s'arr\u00eatera. Mais que va provoquer countdown(10.8) ? Comme la variable n ne sera jamais \u00e9gale \u00e0 0, le programme va rentrer dans une boucle infinie, il ne s'arr\u00eatera jamais. Mauvaise nouvelle. J'ai pu pr\u00e9voir ceci en regardant attentivement le code de mon programme. J'ai \u00abremarqu\u00e9\u00bb qu'une variable n non enti\u00e8re provoquerait une boucle infinie. Question : Est-ce qu'un programme d' analyse de programmes aurait pu faire cela \u00e0 ma place ?", "title": "2.1 Un exemple"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#22-une-machine-pour-predire-larret-ou-non-dun-programme", "text": "Apr\u00e8s tout, un programme est une suite d'instructions (le code-source), et peut donc \u00eatre, comme on l'a vu, le param\u00e8tre d'entr\u00e9e d'un autre programme qui l'analyserait. Un tel programme (appelons-le halt ) prendrait en entr\u00e9es : un param\u00e8tre prog (le code-source du programme) un param\u00e8tre x , qui serait le param\u00e8tre d'entr\u00e9e de prog . L'instruction halt(prog, x) renverrait True si prog(x) s'arr\u00eate, et False si prog(x) ne s'arr\u00eate pas. Exemple : halt(countdown, 10) renverrait True . halt(countdown, 10.8) renverrait False . Tentative d'\u00e9criture de halt en Python : \ud83d\udc0d Script Python def halt ( prog , x ): if \"prog(x) s'arr\u00eate\" : # mes excuses, je n'ai pas eu le temps de finir totalement ce code return True else : return False Nous en resterons l\u00e0 pour l'instant dans l'\u00e9criture de ce programme. Nous allons nous en servir pour construire d'autres programmes.", "title": "2.2 Une machine pour pr\u00e9dire l'arr\u00eat ou non d'un programme."}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#23-amusons-nous-avec-ce-programme-halt", "text": "Consid\u00e9rons le programme : \ud83d\udc0d Script Python def sym ( prog ): if halt ( prog , prog ) == True : while True : print ( \"vers l'infini et au-del\u00e0 !\" ) else : return 1 On peut remarquer que le programme halt est appel\u00e9 avec comme param\u00e8tres prog, prog , ce qui signifie que prog se prend lui-m\u00eame en param\u00e8tre. On rappelle que ce n'est pas choquant, un code-source \u00e9tant une donn\u00e9e comme une autre. Ce programme sym re\u00e7oit donc en param\u00e8tre un programme prog , et : va rentrer dans une boucle infinie si prog(prog) s'arr\u00eate. va renvoyer 1 si prog(prog) ne s'arr\u00eate pas.", "title": "2.3 Amusons-nous avec ce programme halt."}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#24-un-leger-probleme", "text": "Puisqu'un programme peut prendre en param\u00e8tre son propre code-source, que donnerait l'appel \u00e0 sym(sym) ? Deux cas peuvent se pr\u00e9senter, suivant si halt(sym, sym) renvoie True ou False . cas n\u00b01 : halt(sym, sym) renvoie True , ce qui signifie que sym(sym) devrait s'arr\u00eater. Mais dans ce cas-l\u00e0, l'ex\u00e9cution de sym(sym) rentre dans une boucle infinie. C'est une contradiction. cas n\u00b02 : halt(sym, sym) renvoie False , ce qui signifie que sym(sym) rentre dans une boucle infinie. Mais dans ce cas-l\u00e0, l'ex\u00e9cution de sym(sym) se termine correctement et renvoie la valeur 1. C'est une contradiction.", "title": "2.4 Un l\u00e9ger probl\u00e8me ..."}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#25-conclusion", "text": "Nous venons de prouver que notre programme halt , cens\u00e9 pr\u00e9dire si un programme prog peut s'arr\u00eater sur une entr\u00e9e x , NE PEUT PAS EXISTER . Ce r\u00e9sultat th\u00e9orique, d'une importance cruciale, s'appelle le probl\u00e8me de l'arr\u00eat . Probl\u00e8me de l'arr\u00eat Il ne peut pas exister de programme universel qui prendrait en entr\u00e9es : un programme P une entr\u00e9e E de ce programme P et qui d\u00e9terminerait si ce programme P, lanc\u00e9 avec l'entr\u00e9e E, va s'arr\u00eater ou non. Ce r\u00e9sultat a \u00e9t\u00e9 d\u00e9montr\u00e9 par Alan Turing en 1936, dans un article intitul\u00e9 \u00abOn computable numbers, with an application to the Entscheidungsproblem\u00bb . Pour sa d\u00e9monstration, il pr\u00e9sente un mod\u00e8le th\u00e9orique de machine capable d'ex\u00e9cuter des instructions basiques sur un ruban infini, les machines de Turing . \u00c0 la m\u00eame \u00e9poque, le math\u00e9maticien Alonzo Church d\u00e9montre lui aussi ce th\u00e9or\u00e8me de l'arr\u00eat, mais par un moyen totalement diff\u00e9rent, en inventant le lambda-calcul . Tous deux mettent ainsi un terme au r\u00eave du math\u00e9maticien allemand David Hilbert , qui avait en 1928 pos\u00e9 la question de l'existence d'un algorithme capable de r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 n'importe quel \u00e9nonc\u00e9 math\u00e9matique pos\u00e9 sous forme d\u00e9cisionnelle (\u00abun triangle rectangle peut-il \u00eatre isoc\u00e8le ?\u00bb, \u00abexiste-t-il un nombre premier pair ?\u00bb) Cette question, appel\u00e9e \u00abprobl\u00e8me de la d\u00e9cision\u00bb, ou Entscheidungsproblem en allemand, est d\u00e9finitivement tranch\u00e9e par le probl\u00e8me de l'arr\u00eat : un tel th\u00e9or\u00e8me ne peut pas exister, puisque par exemple, aucun algorithme ne peut r\u00e9pondre \u00aboui\u00bb ou \u00abnon\u00bb \u00e0 la question \u00abce programme va-t-il s'arr\u00eater ?\u00bb. Le th\u00e9or\u00e8me de l'arr\u00eat sera \u00e9tendu plus tard par le th\u00e9or\u00e8me de Rice . Ce r\u00e9sultat d\u00e9montre que toutes les questions s\u00e9mantiques (non \u00e9videntes) au sujet d'un programme sont ind\u00e9cidables : \u00abce programme va-t-il s'arr\u00eater ?\u00bb (le th\u00e9or\u00e8me de l'arr\u00eat) \u00abce programme va renvoyer la valeur 12 ?\u00bb \u00abce programme va-t-il un jour renvoyer un message d'erreur ?\u00bb ... Rice d\u00e9montre que toutes ces questions peuvent \u00eatre ramen\u00e9es (on dit r\u00e9duites ) au th\u00e9or\u00e8me de l'arr\u00eat, qui est ind\u00e9cidable.", "title": "2.5 Conclusion"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#2-calculabilite", "text": "D\u00e9cidabilit\u00e9 et calculabilit\u00e9 Le probl\u00e8me de l'arr\u00eat est dit ind\u00e9cidable car la fonction qui le r\u00e9sout (notre brave programme halt ) n'est pas calculable .", "title": "2. Calculabilit\u00e9"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#21-notion-de-calculabilite", "text": "Qu'y a-t-il derri\u00e8re cette notion de calculabilit\u00e9 ? Cette notion, qui jette un pont entre les math\u00e9matiques (la vision de Church, pour sch\u00e9matiser) et l'informatique (la vision de Turing) n'est pas simple \u00e0 d\u00e9finir ! Le calcul math\u00e9matique peut se r\u00e9duire \u00e0 une succession d'op\u00e9rations \u00e9l\u00e9mentaires (songez \u00e0 la multiplication enti\u00e8re comme une s\u00e9rie d'additions). Les nombres calculables sont les nombres qui sont g\u00e9n\u00e9rables en un nombre fini d'op\u00e9rations \u00e9l\u00e9mentaires. De la m\u00eame mani\u00e8re, une fonction math\u00e9matique sera dite calculable s'il existe une suite finie d'op\u00e9rations \u00e9l\u00e9mentaires permettant de passer d'un nombre x \u00e0 son image f(x). On retrouve cette notion d'op\u00e9rations \u00e9l\u00e9mentaires dans les machines de Turing . Cette machine (th\u00e9orique) permet de simuler tout ce qu'un programme informatique (une suite d'instructions) est capable d'ex\u00e9cuter. Un algorithme peut se r\u00e9duire \u00e0 une suite d'op\u00e9rations \u00e9lementaires, comme une fonction math\u00e9matique peut se r\u00e9duire \u00e0 une suite de calculs. D\u00e8s lors, on pourra consid\u00e9rer un algorithme comme une fonction. Turing a d\u00e9montr\u00e9 que l'ensemble des fonctions calculables, au sens de Church, \u00e9tait \u00e9quivalent \u00e0 l'ensemble des fonctions programmables sur sa machine. Certaines fonctions peuvent \u00eatre calculables, ou ne pas l'\u00eatre : c'est notamment le cas de notre fonction du probl\u00e8me de l'arr\u00eat.", "title": "2.1 Notion de calculabilit\u00e9"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#22-langages-turing-complets", "text": "Ce r\u00e9sultat ne d\u00e9pend pas du langage utilis\u00e9 : le fait que nous ayons utilis\u00e9 Python au paragraphe pr\u00e9c\u00e9dent n'a pas d'influence sur notre d\u00e9monstration. Nous savons depuis les machines de Turing que tous nos langages de programmation sont Turing-complets : ils sont tous capables de faire la m\u00eame chose (avec plus ou moins de facilit\u00e9 !). Scratch, C, Python, Java, Basic, Haskell, Brainfuck... tous ces langages sont th\u00e9oriquement \u00e9quivalents : la calculabilit\u00e9 ne d\u00e9pend pas du langage utilis\u00e9 .", "title": "2.2 Langages Turing-complets"}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#23-hp-calculable-oui-mais-facilement-1-million-de-a-gagner-ci-dessous", "text": "L'\u00e9tude de la calculabilit\u00e9 d'une fonction (\u00e0 prendre au sens le plus large, c'est-\u00e0-dire un algorithme) ne se limite pas \u00e0 un choix binaire : \u00abcalculable\u00bb vs \u00abnon calculable\u00bb. Parmi les fonctions calculables, certaines peuvent l'\u00eatre rapidement, et d'autre beaucoup moins. On retrouve alors la notion bien connue de complexit\u00e9 algorithmique, qui permet de classifier les algorithmes suivant leur d\u00e9pendance \u00e0 la taille de leurs donn\u00e9es d'entr\u00e9e (voir le cours de Premi\u00e8re). On peut regrouper les probl\u00e8mes suivant la complexit\u00e9 de l'algorithme qui permet de les r\u00e9soudre.", "title": "2.3 (HP) Calculable, oui, mais facilement ? -&gt; 1 million de $ \u00e0 gagner ci-dessous."}, {"location": "T2_Programmation/2.3_Calculabilite_Decidabilite/cours/#bibliographie", "text": "Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G. CONNAN, V. PETROV, G. ROZSAVOLGYI, L. SIGNAC, \u00e9ditions HATIER. https://interstices.info/pnp-elementaire-ma-chere-watson/ https://interstices.info/alan-turing-du-calculable-a-lindecidable/ https://www.labri.fr/perso/betrema/MC/MC8.html https://scienceetonnante.com/2020/07/17/est-ce-que-p-np/", "title": "Bibliographie"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/", "text": "Bonnes pratiques \u2693\ufe0e extrait du site https://realpython.com/python-pep8/ 1. Conventions syntaxiques \u2693\ufe0e La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits : Les espaces \u2693\ufe0e \u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) \ud83d\udc0d Script Python # PAS BIEN a = 3 # BIEN a = 3 \ud83d\udc0d Script Python # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : \ud83d\udc0d Script Python # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais \ud83d\udc0d Script Python # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : \ud83d\udc0d Script Python # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. \ud83d\udc0d Script Python # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/ Les conventions de nommage \u2693\ufe0e \u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. \ud83d\udc0d Script Python # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. \ud83d\udc0d Script Python # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass 2. Commentaires et docstrings \u2693\ufe0e 2.1 Commenter son code ? (ou pas) \u2693\ufe0e La n\u00e9cessit\u00e9 de commenter son code est assez controvers\u00e9e. Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. \ud83d\udc0d Script Python def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : \ud83d\udc0d Script Python def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires. 2.2 Le cas particulier des docstrings \u2693\ufe0e 2.2.1 Que sont les docstrings ? \u2693\ufe0e Les docstrings sont des commentaires normalis\u00e9s pour les fonctions, qui peuvent \u00eatre consult\u00e9s en console. Exemples : Nous connaissons la fonction len() qui permet par exemple de conna\u00eetre la longueur d'une liste pass\u00e9e en param\u00e8tre. Si nous tapons en console la commande print(len.__doc__) , nous aurons la description de cette fonction. \ud83d\udc0d Script Python >>> len . __doc__ 'Return the number of items in a container.' Il est aussi possible d'acc\u00e9der \u00e0 la docstring d'une fonction f par la commande help(f) : \ud83d\udc0d Script Python >>> help ( len ) Help on built - in function len in module builtins : len ( obj , / ) Return the number of items in a container . De m\u00eame pour la fonction range : \ud83d\udc0d Script Python >>> print ( range . __doc__ ) range ( stop ) -> range object range ( start , stop [, step ]) -> range object Return an object that produces a sequence of integers from start ( inclusive ) to stop ( exclusive ) by step . range ( i , j ) produces i , i + 1 , i + 2 , ... , j - 1. start defaults to 0 , and stop is omitted ! range ( 4 ) produces 0 , 1 , 2 , 3. These are exactly the valid indices for a list of 4 elements . When step is given , it specifies the increment ( or decrement ) . Le r\u00e9sultat de la commande help(range) est trop long pour \u00eatre repris ici, mais on y retrouve bien la docstring de la fonction range . 2.2.2 Cr\u00e9er ses propres docstrings \u2693\ufe0e Il suffit pour cela de commencer la fonction \u00e0 documenter par une ou plusieurs phrases entre triples quotes : \ud83d\udc0d Script Python def capital_apres_n_annees ( capital , taux , nombre_annees ) : \"\"\" Renvoie le capital apr\u00e8s n ann\u00e9es. capital : valeur initiale taux : taux d'int\u00e9r\u00eat exprim\u00e9 en nombre d\u00e9cimal (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d'ann\u00e9es de placement du capital \"\"\" return capital * ( 1 + taux ) ** nombre_annees Ainsi, un utilisateur pourra trouver en console le mode d'emploi de notre fonction : \ud83d\udc0d Script Python >>> help ( capital_apres_n_annees ) Help on function capital_apres_n_annees in module __main__ : capital_apres_n_annees ( capital , taux , nombre_annees ) Renvoie le capital apr\u00e8s n ann\u00e9es . capital : valeur initiale taux : taux d 'int\u00e9r\u00eat exprim\u00e9 en nombre d\u00e9cimal (ex: 0.02 pour un taux de 2 %) nombre_annees : nombre d 'ann\u00e9es de placement du capital Comme on le voit, tout cela est tr\u00e8s \u00abverbeux\u00bb. Cela peut nous para\u00eetre largement superflu puisque nos codes d\u00e9passent rarement quelques dizaines de lignes et sont lus par rarement plus de 2 personnes. Mais dans la vraie vie des d\u00e9veloppeurs, il est primordial qu'un code soit clair et document\u00e9. 3. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code \u2693\ufe0e La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : \ud83d\udc0d Script Python def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : \ud83d\udc0d Script Python >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : \ud83d\udc0d Script Python def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici . 4. Les tests \u2693\ufe0e 4.1 Pourquoi des tests ? \u2693\ufe0e Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : \ud83d\udc0d Script Python >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) \ud83d\udc0d Script Python def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : \ud83d\udc0d Script Python >>> test_valeur_absolue () ok ok ok 4.2 Revoil\u00e0 les assert \u2693\ufe0e Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : \ud83d\udc0d Script Python def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste liste pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ...). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste) 4.3 Le module doctest \u2693\ufe0e Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. \ud83d\udc0d Script Python def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : \ud83d\udc0d Script Python >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : \ud83d\udc0d Script Python >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : \ud83d\udc0d Script Python >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant. 4.3 \u00c0 propos des tests \u2693\ufe0e Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs... Bibliographie \u2693\ufe0e https://www.reddit.com/r/ProgrammerHumor/ https://fr.wikipedia.org/wiki/Test_driven_development https://www.fil.univ-lille1.fr/~L1S2API/CoursTP/tp_doctest.html", "title": "Bonnes pratiques"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#bonnes-pratiques", "text": "extrait du site https://realpython.com/python-pep8/", "title": "Bonnes pratiques"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#1-conventions-syntaxiques", "text": "La programmation est un art d\u00e9licat : un simple caract\u00e8re en trop peut provoquer une erreur pour le code tout entier (penser \u00e0 un innocent caract\u00e8re d'espace en d\u00e9but de ligne dans un code Python). Mais m\u00eame lorsqu'un code s'ex\u00e9cute sans erreur, il ne faut pas n\u00e9gliger l'aspect purement \u00abesth\u00e9tique\u00bb de celui-ci : il est n\u00e9cessaire de respecter autant que possible des conventions typographiques, qui vont standardiser le code et le rendre ainsi plus lisible. Ainsi pour chaque langage, il existe une \u00abbible\u00bb de bonnes pratiques de pr\u00e9sentation du code, qui visent \u00e0 l'uniformiser. Pour Python, cette r\u00e9f\u00e9rence s'appelle la Python Enhancement Proposal 8, plus connue sous le nom de PEP8. En voici quelques extraits :", "title": "1. Conventions syntaxiques"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#les-espaces", "text": "\u25b6 Il faut mettre une espace (oui, en typographie, on dit \u00abune\u00bb espace et non pas \u00abun\u00bb espace) avant et apr\u00e8s chaque op\u00e9rateur de comparaison, d'affectation, ou math\u00e9matique ( =, ==, >, +, *, ... ) \ud83d\udc0d Script Python # PAS BIEN a = 3 # BIEN a = 3 \ud83d\udc0d Script Python # PAS BIEN if x > 3 : print ( \"ok\" ) # BIEN if x > 3 : print ( \"ok\" ) \u25b6 Pour les op\u00e9rateurs math\u00e9matiques, on essaie de reconstituer les groupes de priorit\u00e9 (lorsqu'il y en a) : \ud83d\udc0d Script Python # PAS BIEN x = 3 * 2 # BIEN x = 3 * 2 mais \ud83d\udc0d Script Python # PAS BIEN x = 3 * 2 + 5 # BIEN x = 3 * 2 + 5 \u25b6 On ne met pas d'espace \u00e0 int\u00e9rieur des parenth\u00e8ses, des crochets ou des accolades : \ud83d\udc0d Script Python # PAS BIEN for x in range ( 5 ): print ( 'bonjour' ) # BIEN for x in range ( 5 ): print ( 'bonjour' ) \u25b6 Pour les virgules, et les deux points : pas d'espace avant mais une espace apr\u00e8s. \ud83d\udc0d Script Python # PAS BIEN if color == ( 0 , 255 , 0 ) : print ( 'vert' ) # BIEN if color == ( 0 , 255 , 0 ): print ( 'vert' ) On peut contr\u00f4ler si son code v\u00e9rifie les standards de la PEP8 sur ce site http://pep8online.com/", "title": "Les espaces"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#les-conventions-de-nommage", "text": "\u25b6 Les variables \u00e0 une lettre (comme i , j , k ) sont r\u00e9serv\u00e9es aux indices (notamment dans les boucles). \u25b6 Les autres variables doivent avoir des noms explicites, \u00e9ventuellement \u00e9crits en snake_case si plusieurs mots doivent \u00eatre reli\u00e9s. \ud83d\udc0d Script Python # PAS BIEN if d == 1 : cep += vm # BIEN if date == 1 : compte_epargne += versement_mensuel Rappel des diff\u00e9rents types de casse : snake_case : les mots sont s\u00e9par\u00e9s par des underscores. Conseill\u00e9 en Python. camelCase : les mots sont s\u00e9par\u00e9s par des majuscules mais la 1\u00e8re lettre est minuscule. Conseill\u00e9 en Javascript. PascalCase : les mots sont s\u00e9par\u00e9s par des majuscules et la 1\u00e8re lettre est majuscule. Conseill\u00e9 en C. kebab-case : les mots sont s\u00e9par\u00e9s par des tirets courts. Conseill\u00e9 en HTML - CSS. \u25b6 Cas particulier des classes en Programmation Orient\u00e9e Objet : leur nom doit commencer par une majuscule. \ud83d\udc0d Script Python # PAS BIEN class voiture : def __init__ ( self , annee , marque , modele ): #pass # BIEN class Voiture : def __init__ ( self , annee , marque , modele ): #pass", "title": "Les conventions de nommage"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#2-commentaires-et-docstrings", "text": "", "title": "2. Commentaires et docstrings"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#21-commenter-son-code-ou-pas", "text": "La n\u00e9cessit\u00e9 de commenter son code est assez controvers\u00e9e. Il est d'usage de dire qu'un code doit \u00eatre assez explicite pour que le lecteur puisse le comprendre sans avoir \u00e0 lire un commentaire. De fait, les commentaires sont parfois (souvent) superflus : Et s'ils sont r\u00e9ellement n\u00e9cessaires, il faut se poser la question : est-ce que ce code n'aurait pas pu \u00eatre plus simple ? (attention, la r\u00e9ponse n'est pas toujours oui) Exemple : Consid\u00e9rons la fonction suivante. \ud83d\udc0d Script Python def f ( c , t , n ): # c est le capital de d\u00e9part, t le taux annuel et n le nombre d'ann\u00e9es return c * ( 1 + t ) ** n #renvoie le capital apr\u00e8s n ann\u00e9es Elle est bien comment\u00e9e. Mais si on croise la fonction f() ailleurs dans le code, se souviendra-t-on de son r\u00f4le ? Il aurait mieux valu \u00e9crire : \ud83d\udc0d Script Python def capital_apres_n_annees ( capital , taux , nombre_annees ) : return capital * ( 1 + taux ) ** nombre_annees Ce code est plus long, mais assez explicite pour se passer de commentaires.", "title": "2.1 Commenter son code ? (ou pas)"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#22-le-cas-particulier-des-docstrings", "text": "", "title": "2.2 Le cas particulier des docstrings"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#3-la-programmation-defensive-des-assert-pour-securiser-le-code", "text": "La programmation d\u00e9fensive est l'art de pr\u00e9voir le pire et d'essayer de le d\u00e9tecter avant qu'il ne soit trop tard. De mani\u00e8re bien plus concr\u00e8te, il est d'usage d'essayer de r\u00e9p\u00e9rer si des donn\u00e9es (souvent des param\u00e8tres d'une fonction) sont susceptibles de cr\u00e9er des probl\u00e8mes, ou sont hors sp\u00e9cification. Un exemple : La fonction : \ud83d\udc0d Script Python def racine_carree ( x ): assert x >= 0 , 'un nombre positif ou nul est requis' return x ** 0.5 donnera, lors de l'appel \u00e0 racine_carree(-2) , le message suivant : \ud83d\udc0d Script Python >>> racine_carree ( - 2 ) Traceback ( most recent call last ): File \"<pyshell>\" , line 1 , in < module > File \"/home/gilles/Bureau/exemples_assert.py\" , line 2 , in racine_carree assert x >= 0 , 'un nombre positif ou nul est requis' AssertionError : un nombre positif ou nul est requis Un autre exemple : \ud83d\udc0d Script Python def moyenne_trimestrielle ( liste_notes ): \"\"\" calcule la moyenne des nombres de la liste liste_notes \"\"\" assert liste_notes != [] , 'liste vide' assert max ( liste_notes ) <= 20 , 'au moins une note d\u00e9passe 20' assert min ( liste_notes ) >= 0 , 'au moins une note est en dessous de 0' return sum ( liste_notes ) / len ( liste_notes ) \u00c0 ce stade, les assert sont donc pour nous juste un moyen rapide de remplacer un test if ... then ... else pour d\u00e9tecter des erreurs potentielles. Ils sont en r\u00e9alit\u00e9 plus utiles que cela : lors de la conception d'un programme, des assert sont pos\u00e9s pour v\u00e9rifier l'int\u00e9grit\u00e9 du code, mais peuvent \u00eatre d\u00e9sactiv\u00e9s \u00e0 tout moment pour en faire un code optimis\u00e9 (par la commande -O \u00e0 l'ex\u00e9cution). Tout ceci d\u00e9passe largement le cadre de notre cours. Il est \u00e0 noter aussi que les erreurs peuvent \u00eatre g\u00e9r\u00e9es par le m\u00e9canisme try ... except , qui permet de \u00ablever des exceptions\u00bb. Pour les curieux, plus de renseignements ici .", "title": "3. La programmation d\u00e9fensive : des assert pour s\u00e9curiser le code"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#4-les-tests", "text": "", "title": "4. Les tests"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#41-pourquoi-des-tests", "text": "Tester une fonction est la premi\u00e8re chose que l'on fait (normalement...) lorsqu'on vient de finir de l'\u00e9crire. Par exemple, si on vient de construire la fonction valeur_absolue(n) , il est fort probable qu'on aille taper ceci dans la console : \ud83d\udc0d Script Python >>> valeur_absolue ( - 3 ) 3 >>> valeur_absolue ( 0 ) 0 >>> valeur_absolue ( 7 ) 7 On peut regrouper tous ces tests au sein d'une m\u00eame fonction test_valeur_absolue() . On peut \u00e9crire cette fonction test_valeur_absolue() avant m\u00eame de commencer \u00e0 \u00e9crire la fonction valeur_absolue(n) . Remarque : la m\u00e9thode de d\u00e9veloppement logiciel TDD (Test Driven Developement) est bas\u00e9e en partie sur ce principe : On commence par \u00e9crire le test de la fonction. Le test \u00e9choue (forc\u00e9ment, la fonction n'est pas encore cod\u00e9e !) On \u00e9crit le code de la fonction pour que le test soit valid\u00e9. On am\u00e9liore (si possible) ce code tout en v\u00e9rifiant que le test continue \u00e0 \u00eatre valide. Revenons \u00e0 nos tests sur la fonction valeur_absolue(n) \ud83d\udc0d Script Python def test_valeur_absolue (): if valeur_absolue ( - 3 ) == 3 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 0 ) == 0 : print ( \"ok\" ) else : print ( \"erreur\" ) if valeur_absolue ( 7 ) == 7 : print ( \"ok\" ) else : print ( \"erreur\" ) En console, il suffit maintenant d'appeler la fonction test_valeur_absolue() : \ud83d\udc0d Script Python >>> test_valeur_absolue () ok ok ok", "title": "4.1 Pourquoi des tests ?"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#42-revoila-les-assert", "text": "Utiliser des assert permet d'\u00e9crire tr\u00e8s simplement les tests pr\u00e9c\u00e9dents. Reprenons notre fonction valeur_absolue() . Sa fonction test test_valeur_absolue() peut s'\u00e9crire : \ud83d\udc0d Script Python def test_valeur_absolue (): assert valeur_absolue ( - 3 ) == 3 assert valeur_absolue ( 0 ) == 0 assert valeur_absolue ( 7 ) == 7 Exercice : \u00c9crire une fonction maxi(liste) qui renvoie le plus grand \u00e9l\u00e9ment de la liste liste pass\u00e9e en param\u00e8tre (de pr\u00e9f\u00e9rence sans utiliser la fonction max() ...). Vous \u00e9crirez d'abord une fonction test_maxi() avant d'\u00e9crire la fonction maxi(liste)", "title": "4.2 Revoil\u00e0 les assert"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#43-le-module-doctest", "text": "Le module doctest permet d'\u00e9crire les tests \u00e0 l'int\u00e9rieur de la docstring d'une fonction. Consid\u00e9rons une fonction dont le but est de compter les voyelles du mot pass\u00e9 en param\u00e8tre. \ud83d\udc0d Script Python def compte_voyelles ( mot ): \"\"\" renvoie le nombre de voyelles du mot donn\u00e9 en param\u00e8tre. >>> compte_voyelles(\"python\") 2 >>> compte_voyelles(\"HTTP\") 0 >>> compte_voyelles(\"eau\") 3 \"\"\" voyelles = \"aeiou\" total = 0 for lettre in mot : if lettre in voyelles : total += 1 return total Observez bien la docstring : elle contient explicitement ce qu'on veut que renvoie le terminal lorsqu'on appellera la fonction. On \u00e9crit donc les trois chevrons >>> suivi de l'appel \u00e0 la fonction, et \u00e0 la ligne en dessous ce que nous esp\u00e9rons que la fonction nous renvoie. On peut \u00e9crire autant de tests que l'on veut. Ensuite, en console : \ud83d\udc0d Script Python >>> import doctest >>> doctest . testmod () Dans notre cas, le retour sera celui-ci : \ud83d\udc0d Script Python >>> import doctest >>> doctest . testmod () ********************************************************************** File \"voyelles.py\" , line 4 , in __main__ . compte_voyelles Failed example : compte_voyelles ( \"python\" ) Expected : 2 Got : 1 ********************************************************************** 1 items had failures : 1 of 3 in __main__ . compte_voyelles *** Test Failed *** 1 failures . TestResults ( failed = 1 , attempted = 3 ) On voit que le test compte_voyelles(\"python\") a renvoy\u00e9 la valeur 1 alors qu'on attendait 2. En regardant notre fonction, on s'aper\u00e7oit donc qu'on avait oubli\u00e9 le y dans la liste des voyelles. En corrigeant ceci, le test devient : \ud83d\udc0d Script Python >>> import doctest >>> doctest . testmod () TestResults ( failed = 0 , attempted = 3 ) Ce qui est beaucoup plus satisfaisant.", "title": "4.3 Le module doctest"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#43-a-propos-des-tests", "text": "Le comportement face aux tests en programmation doit \u00eatre le m\u00eame qu'en math\u00e9matiques : un test qui ne marche pas est plus riche d'enseignements qu'un test qui marche . En math\u00e9matiques, seule la notion de contre-exemple est fertile : si quelqu'un vous affirme que \u00abtous les nombres impairs sont premiers\u00bb , il vous suffit d'exhiber le nombre 9 pour lui prouver qu'il a tort et achever la discussion. Par contre, il aurait pu essayer de vous convaincre avec les nombres 3, 5 et 13, qui sont bien impairs et premiers. De la m\u00eame mani\u00e8re, voir qu'une fonction passe les tests que vous avez \u00e9crits ne vous assurera pas que cette fonction aura toujours le bon comportement souhait\u00e9. Elle l'aura pour les valeurs de test, mais pas forc\u00e9ment pour les autres. En revanche, si une fonction ne passe pas un des tests, vous avez la certitude qu'il y a un probl\u00e8me \u00e0 r\u00e9gler quelque part. Tout ceci en admettant, bien s\u00fbr, que vos tests eux-m\u00eames ne comportent pas d'erreurs...", "title": "4.3 \u00c0 propos des tests"}, {"location": "T2_Programmation/2.4_Pratiques_de_programmation/cours/#bibliographie", "text": "https://www.reddit.com/r/ProgrammerHumor/ https://fr.wikipedia.org/wiki/Test_driven_development https://www.fil.univ-lille1.fr/~L1S2API/CoursTP/tp_doctest.html", "title": "Bibliographie"}, {"location": "T3_Algorithmique/sommaire/", "text": "Diviser pour r\u00e9gner Programmation dynamique Recherche textuelle", "title": "Sommaire"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/", "text": "Diviser pour r\u00e9gner \u2693\ufe0e 1. Retour sur l'algorithme de dichotomie \u2693\ufe0e Nous avons vu en classe de Premi\u00e8re l'algorithme de dichotomie (du grec dikhotomia , \u00ab division en deux parties \u00bb). Notre but ici est la recherche de la pr\u00e9sence (ou non) d'un \u00e9l\u00e9ment dans une liste tri\u00e9e . Notre fonction renverra donc un bool\u00e9en. La recherche na\u00efve (\u00e9l\u00e9ment par \u00e9l\u00e9ment) est naturellement de complexit\u00e9 lin\u00e9aire. Nous allons voir que la m\u00e9thode dichotomique est plus efficace. Activit\u00e9 d'introduction 1.1 Version imp\u00e9rative \u2693\ufe0e Dichotomie version imp\u00e9rative \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = 0 i_fin = len ( tab ) - 1 while i_debut <= i_fin : i_centre = ( i_debut + i_fin ) // 2 # (1) val_centrale = tab [ i_centre ] # (2) if val_centrale == val : # (3) return True if val_centrale < val : # (4) i_debut = i_centre + 1 # (5) else : i_fin = i_centre - 1 return False on prend l'indice central on prend la valeur centrale si la valeur centrale est la valeur cherch\u00e9e... si la valeur centrale est trop petite... on ne prend pas la valeur centrale qui a d\u00e9j\u00e0 \u00e9t\u00e9 test\u00e9e Exemple d'utilisation : \ud83d\udc0d Script Python >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False \u00c0 chaque tour de la boucle while , la taille de la liste est divis\u00e9e par 2. Ceci conf\u00e8re \u00e0 cet algorithme une complexit\u00e9 logarithmique (bien meilleure qu'une complexit\u00e9 lin\u00e9aire). 1.2 Version r\u00e9cursive \u2693\ufe0e 1.2.1 Pr\u00e9ambule : le slicing \u2693\ufe0e Pour \u00e9crire simplement la version r\u00e9cursive de cet algorithme, nous allons avoir besoin de faire du slicing (d\u00e9coupage) de listes. Cette manipulation n'est pas au programme de NSI (m\u00eame si elle est tr\u00e8s simple). Attention, elle a un co\u00fbt algorithmique important, qui peut fausser notre analyse de complexit\u00e9. Exemples de slicing : \ud83d\udc0d Script Python >>> lst = [ 'a' , 'b' , 'c' , 'd' , 'e' ] >>> lst [: 2 ] [ 'a' , 'b' ] >>> lst [ 2 :] [ 'c' , 'd' , 'e' ] On comprend que : lst[:k] va renvoyer la sous-liste compos\u00e9e du premier \u00e9l\u00e9ment jusqu'\u00e0 celui d'indice k non inclus . lst[k:] va renvoyer la sous-liste compos\u00e9e du k -i\u00e8me \u00e9l\u00e9ment ( inclus ) jusqu'au dernier. plus g\u00e9n\u00e9ralement, lst[k:p] va renvoyer la sous-liste compos\u00e9e du k -i\u00e8me \u00e9l\u00e9ment ( inclus ) jusqu'au p -i\u00e8me ( non inclus ). 1.2.2 Dichotomie r\u00e9cursive avec slicing \u2693\ufe0e Dichotomie version r\u00e9cursive avec slicing \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def dichotomie_rec ( tab , val ): if len ( tab ) == 0 : return False i_centre = len ( tab ) // 2 if tab [ i_centre ] == val : return True if tab [ i_centre ] < val : return dichotomie_rec ( tab [ i_centre + 1 :], val ) # (1) else : return dichotomie_rec ( tab [: i_centre ], val ) # (2) On prend la partie droite de liste, juste apr\u00e8s l'indice central. On prend la partie gauche de liste, juste avant l'indice central. Exemple d'utilisation : \ud83d\udc0d Script Python >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> dichotomie_rec ( tab , 12 ) True >>> dichotomie_rec ( tab , 17 ) False Visualisation gr\u00e2ce \u00e0 PythonTutor: 1.2.3 Dichotomie r\u00e9cursive sans slicing \u2693\ufe0e Il est possible de programmer de mani\u00e8re r\u00e9cursive la recherche dichotomique sans toucher \u00e0 la liste, et donc en jouant uniquement sur les indices : Dichotomie version r\u00e9cursive sans slicing \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def dicho_rec_2 ( tab , val , i = 0 , j = None ): # (1) if j is None : # (2) j = len ( tab ) - 1 if i > j : return False m = ( i + j ) // 2 if tab [ m ] < val : return dicho_rec_2 ( tab , val , m + 1 , j ) elif tab [ m ] > val : return dicho_rec_2 ( tab , val , i , m - 1 ) else : return True Pour pouvoir appeler simplement la fonction sans avoir \u00e0 pr\u00e9ciser les indices, on leur donne des param\u00e8tres par d\u00e9faut. Il est impossible de donner j=len(tab)-1 par d\u00e9faut (car tab est aussi un param\u00e8tre). On passe donc par une autre valeur (ici None ) qu'on va ici intercepter. Exemple d'utilisation : \ud83d\udc0d Script Python >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> dicho_rec_2 ( tab , 12 ) True >>> dicho_rec_2 ( tab , 17 ) False 2. Diviser pour r\u00e9gner \u2693\ufe0e Les algorithmes de dichotomie pr\u00e9sent\u00e9s ci-dessous ont tous en commun de diviser par deux la taille des donn\u00e9es de travail \u00e0 chaque \u00e9tape. Cette m\u00e9thode de r\u00e9solution d'un probl\u00e8me est connue sous le nom de diviser pour r\u00e9gner , ou divide and conquer en anglais. Une d\u00e9finition pourrait \u00eatre : D\u00e9finition Un probl\u00e8me peut se r\u00e9soudre en employant le paradigme diviser pour r\u00e9gner lorsque : il est possible de d\u00e9composer ce probl\u00e8me en sous-probl\u00e8mes ind\u00e9pendants . la taille de ces sous-probl\u00e8mes est une fraction du probl\u00e8me initial Remarques : Les sous-probl\u00e8mes peuvent n\u00e9cessiter d'\u00eatre ensuite recombin\u00e9s entre eux (voir plus loin le tri fusion). Consid\u00e9rons de l'\u00e9criture r\u00e9cursive de la fonction factorielle ci-dessous : \ud83d\udc0d Script Python def factorielle ( n ): if n == 0 : return 1 else : return n * factorielle ( n - 1 ) On ne peut pas parler ici de diviser pour r\u00e9gner car la taille des donn\u00e9es \u00e0 traiter est pass\u00e9e de n \u00e0 n-1 . C'est bien une diminution (qui fait que l'algorithme fonctionne) mais il n'y a pas de division de la taille des donn\u00e9es. C'est cette division (par 2 dans le cas de la dichotomie) qui donne son efficacit\u00e9 \u00e0 ce paradigme. Le paradigme diviser pour r\u00e9gner va naturellement amener \u00e0 r\u00e9diger des programmes r\u00e9cursifs. 3. L'exponentiation rapide \u2693\ufe0e On appelle exponentiation le fait de mettre en puissance un nombre. On va donc coder, de deux mani\u00e8res diff\u00e9rentes, la puissance d'un nombre. 3.1 Algorithme classique \u2693\ufe0e Exponentiation classique \ud83d\udc0d Script Python 1 2 3 4 5 def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 ) 3.2 Algorithme utilisant diviser pour r\u00e9gner \u2693\ufe0e Nous allons nous appuyer sur la remarque math\u00e9matique suivante : Pour tout nombre \\(a\\) , si \\(n\\) est pair, \\(a^n = (a^2)^{\\frac{n}{2}}\\) si \\(n\\) est impair, \\(a^n = a \\times a^{n-1} = a \\times (a^2)^{\\frac{n-1}{2}}\\) Ainsi, dans le cas o\u00f9 \\(n\\) est pair, il suffit d'\u00e9lever \\(a\\) au carr\u00e9 (une seule op\u00e9ration) pour que l'exposant diminue de moiti\u00e9 . On peut donc programmer la fonction puissance en utilisant le paradigme diviser pour r\u00e9gner : Exponentiation rapide \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a * a , n // 2 ) else : return a * puissance_mod ( a * a , ( n - 1 ) // 2 ) 3.3 Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction Recr\u00e9er le graphique ci-dessus, qui compare les temps d'ex\u00e9cution des deux fonctions puissance et puissance_mod . Aide pour Matplotlib : le code ci-dessous \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 import matplotlib.pyplot as plt def carre ( x ): return x * x x = list ( range ( 10 )) y = [ carre ( k ) for k in x ] plt . plot ( x , y ) plt . show () donne le graphique suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import matplotlib.pyplot as plt import time def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 ) def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a * a , n // 2 ) else : return a * puissance_mod ( a * a , ( n - 1 ) // 2 ) def mesure_puissance ( n ): t0 = time . time () p = puissance ( 3 , n ) return time . time () - t0 def mesure_puissance_mod ( n ): t0 = time . time () p = puissance_mod ( 3 , n ) return time . time () - t0 4. Le tri-fusion \u2693\ufe0e En anglais le merge sort . 4.1 Preambule : l'interclassement \u2693\ufe0e Le m\u00e9canisme principal du tri fusion est la fusion de deux listes tri\u00e9es en une nouvelle liste elle aussi tri\u00e9e. On appelera ce m\u00e9canisme l' interclassement . Principe de l'interclassement de deux listes lst1 et lst2 . on part d'une liste vide lst_totale on y ajoute alternativement les \u00e9l\u00e9ments de lst1 et lst2 . Il faut pour cela g\u00e9rer s\u00e9par\u00e9ment un indice i1 pour la liste lst1 et un indice i2 pour la liste i2 . quand une liste est \u00e9puis\u00e9e, on y ajoute la totalit\u00e9 restante de l'autre liste. Exercice 2 \u00c9nonc\u00e9 Correction Coder la fonction interclassement . 4.2 La fusion \u2693\ufe0e 4.2.1 Principe \u2693\ufe0e L'id\u00e9e du tri fusion est le d\u00e9coupage de la liste originale en une multitude de listes ne contenant qu'un seul \u00e9l\u00e9ment. Ces listes \u00e9l\u00e9mentaires seront ensuite interclass\u00e9es avec la fonction pr\u00e9c\u00e9dente. Principe de l'algorithme du tri fusion : pour trier une liste, on interclasse les deux moiti\u00e9s de cette liste, pr\u00e9c\u00e9d\u00e9mment elles-m\u00eames tri\u00e9es par le tri fusion. si une liste \u00e0 trier est r\u00e9duite \u00e0 un \u00e9l\u00e9ment, elle est d\u00e9j\u00e0 tri\u00e9e. 4.2.2 Impl\u00e9mentation \u2693\ufe0e La grande force de ce tri va \u00eatre qu'il se programme simplement de mani\u00e8re r\u00e9cursive , en appelant \u00e0 chaque \u00e9tape la m\u00eame fonction mais avec une taille de liste divis\u00e9e par deux, ce qui justifie son classement parmi les algorithmes utilisants \u00abdiviser pour r\u00e9gner\u00bb. Algorithme de tri fusion ( merge sort ) \ud83d\udc0d Script Python def interclassement ( lst1 , lst2 ): lst_totale = [] n1 , n2 = len ( lst1 ), len ( lst2 ) i1 , i2 = 0 , 0 while i1 < n1 and i2 < n2 : if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :] def tri_fusion ( lst ): if len ( lst ) <= 1 : return lst else : m = len ( lst ) // 2 return interclassement ( tri_fusion ( lst [: m ]), tri_fusion ( lst [ m :])) 4.2.3 Visualisation \u2693\ufe0e Une erreur classique avec les fonctions r\u00e9cursives est de consid\u00e9rer que les appels r\u00e9cursifs sont simultan\u00e9s. Ceci est faux ! L'animation suivante montre la progression du tri : Il est aussi conseill\u00e9 d'observer l'\u00e9volution de l'algorithme gr\u00e2ce \u00e0 PythonTutor : 4.3 Complexit\u00e9 \u2693\ufe0e La division par 2 de la taille de la liste pourrait nous amener \u00e0 penser que le tri fusion est de complexit\u00e9 logarithmique, comme l'algorithme de dichotomie. Il n'en est rien. En effet, l'instruction finale interclassement(tri_fusion(lst[:m]), tri_fusion(lst[m:])) lance deux appels \u00e0 la fonction tri_fusion (avec certe des donn\u00e9es d'entr\u00e9e deux fois plus petites). On peut montrer que : Complexit\u00e9 du tri fusion L'algorithme de tri fusion est en \\(O(n \\log n)\\) . On dit qu'il est quasi-lin\u00e9aire . (ou lin\u00e9arithmique ) Une complexit\u00e9 quasi-lin\u00e9aire (en \\(O(n \\log n)\\) ) se situe \u00abentre\u00bb une complexit\u00e9 lin\u00e9aire (en \\(O(n)\\) ) et une complexit\u00e9 quadratique (en \\(O(n^2)\\) ). Mais elle est plus proche de la complexit\u00e9 lin\u00e9aire. Une jolie animation permettant de comparer les tris : Issue de ce site", "title": "Cours"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#diviser-pour-regner", "text": "", "title": "Diviser pour r\u00e9gner"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#1-retour-sur-lalgorithme-de-dichotomie", "text": "Nous avons vu en classe de Premi\u00e8re l'algorithme de dichotomie (du grec dikhotomia , \u00ab division en deux parties \u00bb). Notre but ici est la recherche de la pr\u00e9sence (ou non) d'un \u00e9l\u00e9ment dans une liste tri\u00e9e . Notre fonction renverra donc un bool\u00e9en. La recherche na\u00efve (\u00e9l\u00e9ment par \u00e9l\u00e9ment) est naturellement de complexit\u00e9 lin\u00e9aire. Nous allons voir que la m\u00e9thode dichotomique est plus efficace. Activit\u00e9 d'introduction", "title": "1. Retour sur l'algorithme de dichotomie"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#11-version-imperative", "text": "Dichotomie version imp\u00e9rative \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = 0 i_fin = len ( tab ) - 1 while i_debut <= i_fin : i_centre = ( i_debut + i_fin ) // 2 # (1) val_centrale = tab [ i_centre ] # (2) if val_centrale == val : # (3) return True if val_centrale < val : # (4) i_debut = i_centre + 1 # (5) else : i_fin = i_centre - 1 return False on prend l'indice central on prend la valeur centrale si la valeur centrale est la valeur cherch\u00e9e... si la valeur centrale est trop petite... on ne prend pas la valeur centrale qui a d\u00e9j\u00e0 \u00e9t\u00e9 test\u00e9e Exemple d'utilisation : \ud83d\udc0d Script Python >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False \u00c0 chaque tour de la boucle while , la taille de la liste est divis\u00e9e par 2. Ceci conf\u00e8re \u00e0 cet algorithme une complexit\u00e9 logarithmique (bien meilleure qu'une complexit\u00e9 lin\u00e9aire).", "title": "1.1 Version imp\u00e9rative"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#12-version-recursive", "text": "", "title": "1.2 Version r\u00e9cursive"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#2-diviser-pour-regner", "text": "Les algorithmes de dichotomie pr\u00e9sent\u00e9s ci-dessous ont tous en commun de diviser par deux la taille des donn\u00e9es de travail \u00e0 chaque \u00e9tape. Cette m\u00e9thode de r\u00e9solution d'un probl\u00e8me est connue sous le nom de diviser pour r\u00e9gner , ou divide and conquer en anglais. Une d\u00e9finition pourrait \u00eatre : D\u00e9finition Un probl\u00e8me peut se r\u00e9soudre en employant le paradigme diviser pour r\u00e9gner lorsque : il est possible de d\u00e9composer ce probl\u00e8me en sous-probl\u00e8mes ind\u00e9pendants . la taille de ces sous-probl\u00e8mes est une fraction du probl\u00e8me initial Remarques : Les sous-probl\u00e8mes peuvent n\u00e9cessiter d'\u00eatre ensuite recombin\u00e9s entre eux (voir plus loin le tri fusion). Consid\u00e9rons de l'\u00e9criture r\u00e9cursive de la fonction factorielle ci-dessous : \ud83d\udc0d Script Python def factorielle ( n ): if n == 0 : return 1 else : return n * factorielle ( n - 1 ) On ne peut pas parler ici de diviser pour r\u00e9gner car la taille des donn\u00e9es \u00e0 traiter est pass\u00e9e de n \u00e0 n-1 . C'est bien une diminution (qui fait que l'algorithme fonctionne) mais il n'y a pas de division de la taille des donn\u00e9es. C'est cette division (par 2 dans le cas de la dichotomie) qui donne son efficacit\u00e9 \u00e0 ce paradigme. Le paradigme diviser pour r\u00e9gner va naturellement amener \u00e0 r\u00e9diger des programmes r\u00e9cursifs.", "title": "2. Diviser pour r\u00e9gner"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#3-lexponentiation-rapide", "text": "On appelle exponentiation le fait de mettre en puissance un nombre. On va donc coder, de deux mani\u00e8res diff\u00e9rentes, la puissance d'un nombre.", "title": "3. L'exponentiation rapide"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#31-algorithme-classique", "text": "Exponentiation classique \ud83d\udc0d Script Python 1 2 3 4 5 def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 )", "title": "3.1 Algorithme classique"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#32-algorithme-utilisant-diviser-pour-regner", "text": "Nous allons nous appuyer sur la remarque math\u00e9matique suivante : Pour tout nombre \\(a\\) , si \\(n\\) est pair, \\(a^n = (a^2)^{\\frac{n}{2}}\\) si \\(n\\) est impair, \\(a^n = a \\times a^{n-1} = a \\times (a^2)^{\\frac{n-1}{2}}\\) Ainsi, dans le cas o\u00f9 \\(n\\) est pair, il suffit d'\u00e9lever \\(a\\) au carr\u00e9 (une seule op\u00e9ration) pour que l'exposant diminue de moiti\u00e9 . On peut donc programmer la fonction puissance en utilisant le paradigme diviser pour r\u00e9gner : Exponentiation rapide \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a * a , n // 2 ) else : return a * puissance_mod ( a * a , ( n - 1 ) // 2 )", "title": "3.2 Algorithme utilisant diviser pour r\u00e9gner"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#33-comparaison-de-la-vitesse-dexecution-des-deux-algorithmes", "text": "Exercice 1 \u00c9nonc\u00e9 Correction Recr\u00e9er le graphique ci-dessus, qui compare les temps d'ex\u00e9cution des deux fonctions puissance et puissance_mod . Aide pour Matplotlib : le code ci-dessous \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 import matplotlib.pyplot as plt def carre ( x ): return x * x x = list ( range ( 10 )) y = [ carre ( k ) for k in x ] plt . plot ( x , y ) plt . show () donne le graphique suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import matplotlib.pyplot as plt import time def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 ) def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a * a , n // 2 ) else : return a * puissance_mod ( a * a , ( n - 1 ) // 2 ) def mesure_puissance ( n ): t0 = time . time () p = puissance ( 3 , n ) return time . time () - t0 def mesure_puissance_mod ( n ): t0 = time . time () p = puissance_mod ( 3 , n ) return time . time () - t0", "title": "3.3 Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#4-le-tri-fusion", "text": "En anglais le merge sort .", "title": "4. Le tri-fusion"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#41-preambule-linterclassement", "text": "Le m\u00e9canisme principal du tri fusion est la fusion de deux listes tri\u00e9es en une nouvelle liste elle aussi tri\u00e9e. On appelera ce m\u00e9canisme l' interclassement . Principe de l'interclassement de deux listes lst1 et lst2 . on part d'une liste vide lst_totale on y ajoute alternativement les \u00e9l\u00e9ments de lst1 et lst2 . Il faut pour cela g\u00e9rer s\u00e9par\u00e9ment un indice i1 pour la liste lst1 et un indice i2 pour la liste i2 . quand une liste est \u00e9puis\u00e9e, on y ajoute la totalit\u00e9 restante de l'autre liste. Exercice 2 \u00c9nonc\u00e9 Correction Coder la fonction interclassement .", "title": "4.1 Preambule : l'interclassement"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#42-la-fusion", "text": "", "title": "4.2 La fusion"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/cours/#43-complexite", "text": "La division par 2 de la taille de la liste pourrait nous amener \u00e0 penser que le tri fusion est de complexit\u00e9 logarithmique, comme l'algorithme de dichotomie. Il n'en est rien. En effet, l'instruction finale interclassement(tri_fusion(lst[:m]), tri_fusion(lst[m:])) lance deux appels \u00e0 la fonction tri_fusion (avec certe des donn\u00e9es d'entr\u00e9e deux fois plus petites). On peut montrer que : Complexit\u00e9 du tri fusion L'algorithme de tri fusion est en \\(O(n \\log n)\\) . On dit qu'il est quasi-lin\u00e9aire . (ou lin\u00e9arithmique ) Une complexit\u00e9 quasi-lin\u00e9aire (en \\(O(n \\log n)\\) ) se situe \u00abentre\u00bb une complexit\u00e9 lin\u00e9aire (en \\(O(n)\\) ) et une complexit\u00e9 quadratique (en \\(O(n^2)\\) ). Mais elle est plus proche de la complexit\u00e9 lin\u00e9aire. Une jolie animation permettant de comparer les tris : Issue de ce site", "title": "4.3 Complexit\u00e9"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/exercices/", "text": "Exercice 1 Exercice 4 du sujet Am\u00e9rique du Sud J2 2022 Q1.b : tester son code \ud83d\udc0d Script Python >>> distance_points (( 3 , 5 ), ( 7 , 4 )) 4.123105625617661 Q2 : tester son code \ud83d\udc0d Script Python >>> distance (( 8 , 3 ), ( 5 , 6 ), ( 3 , 7 )) 1.3416407864998738 >>> distance (( 8 , 3 ), ( 5 , 6 ), ( 5 , 6 )) 4.242640687119285 Q3 : tester son code On cherche les coordonn\u00e9es du point \\(M\\) . La droite \\((AB)\\) a une \u00e9quation du type: \\(y=m\\times x+od\\) Son coefficient directeur est \\(\\displaystyle m = \\frac{\\Delta y}{\\Delta x}=\\frac{y_B-y_A}{x_B-x_A}\\) L'\u00e9quation de la droite perpendiculaire \u00e0 la droite \\((AB)\\) a un coefficient directeur \u00e9gal \u00e0 \\(-\\frac{1}{m}\\) . Son \u00e9quation est du type: \\(y=-\\frac{1}{m}x+c\\) Cette droite passant par \\(P\\) on en d\u00e9duit: \\(c=y_p+\\frac{1}{m}x_P\\) Cherchons les coordonn\u00e9es de \\(M\\) , le point d'intersection des deux droites: \\(m\\times x_M+od= -\\frac{1}{m}x_M+y_P+\\frac{1}{m}x_P\\) En en d\u00e9duit que \\(\\displaystyle x_M=\\frac{x_P+m(y_P-od)}{1+m^2}\\) Sachant que \\(\\displaystyle m = \\frac{y_B-y_A}{x_B-x_A}\\) On obtient: \\(\\displaystyle x_M=\\frac{x_P(x_B-x_A)+(y_P-od)(y_B-y_A)}{(x_B-x_A)+m(y_B-y_A)}\\) et \\(y_m=m\\times x_M + od\\) Fonction distance_point_droite : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def distance_point_droite ( p , a , b ): if b [ 0 ] == a [ 0 ]: return abs ( p [ 0 ] - a [ 0 ]) m = ( b [ 1 ] - a [ 1 ]) / ( b [ 0 ] - a [ 0 ]) od = a [ 1 ] - m * a [ 0 ] xm = ( p [ 0 ] * ( b [ 0 ] - a [ 0 ]) + ( p [ 1 ] - od ) * ( b [ 1 ] - a [ 1 ])) / ( b [ 0 ] - a [ 0 ] + m * ( b [ 1 ] - a [ 1 ])) ym = m * xm + od return distance_points ( p , ( xm , ym )) \ud83d\udc0d Script Python >>> le_plus_loin ([( 1 , 3 ), ( 2 , 7 ), ( 3 , 4 ), ( 5 , 3 )]) ( 1 , 4.0 ) Q4 : tester son code \ud83d\udc0d Script Python >>> extrait ([( 1 , 3 ), ( 2 , 7 ), ( 3 , 4 ), ( 4 , 4 ), ( 5 , 3 ), ( 6 , 2 )], 1 , 4 ) [( 2 , 7 ), ( 3 , 4 ), ( 4 , 4 ), ( 5 , 3 )] Q5 : tester son code \ud83d\udc0d Script Python >>> simplifie ([( 1 , 3 ), ( 2 , 7 ), ( 3 , 4 ), ( 4 , 4 ), ( 5 , 3 ), ( 6 , 2 )], 3 ) [( 1 , 3 ), ( 2 , 7 ), ( 3 , 4 ), ( 6 , 2 )] Bonus : mise en pratique de l'algorithme de Douglas-Peucker T\u00e9l\u00e9chargez d'abord le fichier coord_france.txt puis placez-le dans le m\u00eame dossier que le code Python ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from math import sqrt import matplotlib.pyplot as plt data = open ( 'coord_france.txt' ) . read () . splitlines () france = [] for couple in data : cpl = couple . split ( ',' ) france . append (( int ( cpl [ 0 ]), int ( cpl [ 1 ]))) def distance_points ( a , b ): ... def distance_point_droite ( p , a , b ): if b [ 0 ] == a [ 0 ]: return abs ( p [ 0 ] - a [ 0 ]) m = ( b [ 1 ] - a [ 1 ]) / ( b [ 0 ] - a [ 0 ]) od = a [ 1 ] - m * a [ 0 ] xm = ( p [ 0 ] * ( b [ 0 ] - a [ 0 ]) + ( p [ 1 ] - od ) * ( b [ 1 ] - a [ 1 ])) / ( b [ 0 ] - a [ 0 ] + m * ( b [ 1 ] - a [ 1 ])) ym = m * xm + od return distance_points ( p , ( xm , ym )) def distance ( p , a , b ): ... def le_plus_loin ( ligne ): ... def extrait ( tab , i , j ): ... def simplifie ( ligne , seuil ): ... def trace ( ligne , seuil ): new_ligne = simplifie ( ligne , seuil ) nb_segments = len ( set ( new_ligne )) x = [ p [ 0 ] for p in new_ligne ] y = [ p [ 1 ] for p in new_ligne ] plt . plot ( x , y , 'b-' , linewidth = 0.5 ) plt . text ( 195014 , 2865745 , 'seuil : ' + str ( seuil )) plt . text ( 195014 , 2864745 , 'nb segments : ' + str ( nb_segments )) plt . axis ( 'equal' ) plt . axis ( 'off' ) plt . show () trace ( france , 0 ) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 from math import sqrt import matplotlib.pyplot as plt data = open ( 'coord_france.txt' ) . read () . splitlines () france = [] for couple in data : cpl = couple . split ( ',' ) france . append (( int ( cpl [ 0 ]), int ( cpl [ 1 ]))) def distance_points ( a , b ): return sqrt (( b [ 0 ] - a [ 0 ]) ** 2 + ( b [ 1 ] - a [ 1 ]) ** 2 ) def distance_point_droite ( p , a , b ): if b [ 0 ] == a [ 0 ]: return abs ( p [ 0 ] - a [ 0 ]) m = ( b [ 1 ] - a [ 1 ]) / ( b [ 0 ] - a [ 0 ]) od = a [ 1 ] - m * a [ 0 ] xm = ( p [ 0 ] * ( b [ 0 ] - a [ 0 ]) + ( p [ 1 ] - od ) * ( b [ 1 ] - a [ 1 ])) / ( b [ 0 ] - a [ 0 ] + m * ( b [ 1 ] - a [ 1 ])) ym = m * xm + od return distance_points ( p , ( xm , ym )) def distance ( p , a , b ): if a == b : return distance_points ( p , a ) else : return distance_point_droite ( p , a , b ) def le_plus_loin ( ligne ): n = len ( ligne ) deb = ligne [ 0 ] fin = ligne [ n - 1 ] dmax = 0 indice_max = 0 for idx in range ( 1 , n - 1 ): p = ligne [ idx ] d = distance ( p , deb , fin ) if d > dmax : dmax = d indice_max = idx return ( indice_max , dmax ) def extrait ( tab , i , j ): ext = [] for k in range ( i , j + 1 ): ext . append ( tab [ k ]) return ext def simplifie ( ligne , seuil ): n = len ( ligne ) if n <= 2 : return ligne else : indice_max , dmax = le_plus_loin ( ligne ) if dmax <= seuil : return [ ligne [ 0 ], ligne [ n - 1 ]] else : return simplifie ( extrait ( ligne , 0 , indice_max ), seuil ) + simplifie ( extrait ( ligne , indice_max , n - 1 ), seuil ) def trace ( ligne , seuil ): new_ligne = simplifie ( ligne , seuil ) nb_segments = len ( set ( new_ligne )) x = [ p [ 0 ] for p in new_ligne ] y = [ p [ 1 ] for p in new_ligne ] plt . plot ( x , y , 'b-' , linewidth = 0.5 ) plt . text ( 195014 , 2865745 , 'seuil : ' + str ( seuil )) plt . text ( 195014 , 2864745 , 'nb segments : ' + str ( nb_segments )) plt . axis ( 'equal' ) plt . axis ( 'off' ) plt . show () trace ( france , 0 ) Le rendu avec un seuil \u00e9gal \u00e0 0 est celui-ci : Vous pouvez faire varier le seuil entre 0 et 5000 et observer les modifications.", "title": "Exercices"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/intro_dichotomie/", "text": "Vers l'algorithme de dichotomie \u2693\ufe0e Exemple d'utilisation : \ud83d\udc0d Script Python >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False Code \u00e0 trous, newbie version \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = ... i_fin = ... while ... <= ... : i_centre = ( ... + ... ) // 2 val_centrale = tab [ ... ] if val_centrale == val : return ... if val_centrale < val : i_debut = ... + 1 else : i_fin = ... - 1 return False Code \u00e0 trous, regular version \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = ... i_fin = ... while ... <= ... : i_centre = ... val_centrale = ... if ... == ... : return ... if ... < ... : i_debut = ... else : i_fin = ... return False Code \u00e0 trous, expert version \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' ... = ... ... = ... while ... <= ... : ... = ... ... = ... if ... == ... : return ... if ... < ... : ... = ... else : ... = ... return False Code \u00e0 trous, God version \ud83d\udc0d Script Python 1 2 def recherche_dichotomique ( tab , val ) : ... Pour tester : \ud83d\udc0d Script Python >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False", "title": "Vers l'algorithme de dichotomie"}, {"location": "T3_Algorithmique/3.1_Diviser_pour_regner/intro_dichotomie/#vers-lalgorithme-de-dichotomie", "text": "Exemple d'utilisation : \ud83d\udc0d Script Python >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False Code \u00e0 trous, newbie version \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = ... i_fin = ... while ... <= ... : i_centre = ( ... + ... ) // 2 val_centrale = tab [ ... ] if val_centrale == val : return ... if val_centrale < val : i_debut = ... + 1 else : i_fin = ... - 1 return False Code \u00e0 trous, regular version \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' i_debut = ... i_fin = ... while ... <= ... : i_centre = ... val_centrale = ... if ... == ... : return ... if ... < ... : i_debut = ... else : i_fin = ... return False Code \u00e0 trous, expert version \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tab , val ) : ''' renvoie True ou False suivant la pr\u00e9sence de la valeur val dans le tableau tri\u00e9 tab. ''' ... = ... ... = ... while ... <= ... : ... = ... ... = ... if ... == ... : return ... if ... < ... : ... = ... else : ... = ... return False Code \u00e0 trous, God version \ud83d\udc0d Script Python 1 2 def recherche_dichotomique ( tab , val ) : ... Pour tester : \ud83d\udc0d Script Python >>> tab = [ 1 , 5 , 7 , 9 , 12 , 13 ] >>> recherche_dichotomique ( tab , 12 ) True >>> recherche_dichotomique ( tab , 17 ) False", "title": "Vers l'algorithme de dichotomie"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_carre_blanc/", "text": "\u00c0 la recherche du plus grand carr\u00e9 blanc \u2693\ufe0e L'objectif est de trouver la taille du plus grand carr\u00e9 int\u00e9gralement blanc que l'on peut dessiner dans l'image ci-dessous : 1. Prise en main \u2693\ufe0e Pr\u00e9ambule T\u00e9l\u00e9charger l'image, puis cre\u00e9r une variable img gr\u00e2ce au package PIL : \ud83d\udc0d Script Python 1 2 from PIL import Image img = Image . open ( 'pgcb.bmp' ) On peut d\u00e8s lors avoir acc\u00e8s \u00e0 quelques informations : \ud83d\udc0d Script Python >>> img . size ( 600 , 600 ) L'image est donc de taille 600x600. \ud83d\udc0d Script Python >>> img . getpixel (( 0 , 0 )) ( 255 , 255 , 255 ) >>> img . getpixel (( 0 , 358 )) ( 0 , 0 , 0 ) Le pixel de coordonn\u00e9es (0, 0) est donc blanc, et le pixel (0, 358) est noir. Exercice 1 \u00c9crire une fonction est_noir qui prend en param\u00e8tre les coordonn\u00e9es d'un pixel x et y et qui renvoie True si ce pixel est noir, False sinon. Exemple : \ud83d\udc0d Script Python >>> est_noir ( 0 , 0 ) False >>> est_noir ( 0 , 358 ) True Correction \ud83d\udc0d Script Python 1 2 3 4 5 from PIL import Image img = Image . open ( 'pgcb.bmp' ) def est_noir ( x , y ): return img . getpixel (( x , y )) == ( 0 , 0 , 0 ) 1.2 Recherche manuelle \u2693\ufe0e Consid\u00e9rons le damier ci-dessous : Pour chaque case, on va inscrire \u00e0 l'int\u00e9rieur la taille du plus grand carr\u00e9 blanc possible dont la case est le coin inf\u00e9rieur droit . Par exemple : Sur une case noire, on \u00e9crira le nombre 0. Exercice 2 Recopier le damier et compl\u00e9ter toutes les cases, en commen\u00e7ant en haut \u00e0 gauche . Correction Imaginons maintenant la situation suivante, sur un autre damier que vous ne pouvez pas voir en int\u00e9gralit\u00e9 : Exercice 3 Quelle est la valeur qu'il faut \u00e9crire \u00e0 la place du point d'interrogation ? Correction Il faut \u00e9crire la valeur 3, qui est \u00e9gale \u00e0 1 + le minimum des trois cases situ\u00e9es au Nord, Ouest et Nord-Ouest. 2. La fonction pgcb \u2693\ufe0e pgcb -> plus grand carr\u00e9 blanc 2.1 Premi\u00e8re \u00e9criture \u2693\ufe0e On va \u00e9crire la fonction r\u00e9cursive pgcb , qui prend en param\u00e8tre un tuple (x,y) et qui renvoie la taille du plus grand carr\u00e9 blanc dont le pixel de coordonn\u00e9es (x,y) est le coin inf\u00e9rieur droit. Les cas de base seront : le pixel est noir : on renvoie 0 le pixel est sur la ligne du haut ou la colonne de gauche : on renvoie 1 Pour le cas g\u00e9n\u00e9ral, on s'inspirera de la partie pr\u00e9c\u00e9dente... Exercice 4 \u00c9crire le code de la fonction pgcb . Exemples d'utilisation : \ud83d\udc0d Script Python >>> pgcb ( 0 , 0 ) 1 >>> pgcb ( 3 , 2 ) 3 >>> pgcb ( 0 , 358 ) 0 2.2 Am\u00e9lioration de la fonction pgcb \u2693\ufe0e Si on teste la fonction avec le pixel de coordonn\u00e9es (300, 300) , le code ne renvoie aucun r\u00e9sultat et semble parti dans des calculs interminables. La structure r\u00e9cursive du code doit nous pousser \u00e0 la m\u00e9fiance : ne saurions-nous pas en train de lui demander de calculer plusieurs fois la m\u00eame chose ? La r\u00e9ponse est oui : si on ne regarde par exemple que les pixels diagonaux, l'appel pgcb(1, 1) aura lieu pour pgcb(2, 2) , mais aussi pour pgcb(3, 3) , pour pgcb(4, 4) , pour pgcb(5, 5) ... entre autres ! Pour \u00e9viter de refaire ces calculs, on va donc faire appel \u00e0 la technique de m\u00e9mo\u00efsation . Exercice 5 \u00c9crire la fonction pgcb_memo , identique \u00e0 la fonction pgcb mais qui m\u00e9mo\u00efse ses r\u00e9sultats. On pourra se servir d'une fonction englobante comme dans le cours sur Fibonacci. Exemple : \ud83d\udc0d Script Python >>> pgcb_memo ( 300 , 300 ) 21 3. Recherche du plus grand carr\u00e9 \u2693\ufe0e Maintenant que notre fonction est efficace, nous pouvons partir \u00e0 la recherche du pixel de l'image d'o\u00f9 peut se construire le plus grand carr\u00e9 blanc. Exercice 6 \u00c9crire une fonction total_pgcb qui va parcourir tous les pixels de l'image et renvoyer la taille du plus grand carr\u00e9 blanc qu'on puisse y inscrire, ainsi que les coordonn\u00e9es du pixel inf\u00e9rieur droit de ce carr\u00e9. Exemple : \ud83d\udc0d Script Python >>> total_pgcb () ( 51 , ( 370 , 461 )) dans la structure de votre code, penser \u00e0 r\u00e9utiliser le dictionnaire de m\u00e9mo\u00efsation...", "title": "TP Le plus grand carr\u00e9 blanc"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_carre_blanc/#a-la-recherche-du-plus-grand-carre-blanc", "text": "L'objectif est de trouver la taille du plus grand carr\u00e9 int\u00e9gralement blanc que l'on peut dessiner dans l'image ci-dessous :", "title": "\u00c0 la recherche du plus grand carr\u00e9 blanc"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_carre_blanc/#1-prise-en-main", "text": "Pr\u00e9ambule T\u00e9l\u00e9charger l'image, puis cre\u00e9r une variable img gr\u00e2ce au package PIL : \ud83d\udc0d Script Python 1 2 from PIL import Image img = Image . open ( 'pgcb.bmp' ) On peut d\u00e8s lors avoir acc\u00e8s \u00e0 quelques informations : \ud83d\udc0d Script Python >>> img . size ( 600 , 600 ) L'image est donc de taille 600x600. \ud83d\udc0d Script Python >>> img . getpixel (( 0 , 0 )) ( 255 , 255 , 255 ) >>> img . getpixel (( 0 , 358 )) ( 0 , 0 , 0 ) Le pixel de coordonn\u00e9es (0, 0) est donc blanc, et le pixel (0, 358) est noir. Exercice 1 \u00c9crire une fonction est_noir qui prend en param\u00e8tre les coordonn\u00e9es d'un pixel x et y et qui renvoie True si ce pixel est noir, False sinon. Exemple : \ud83d\udc0d Script Python >>> est_noir ( 0 , 0 ) False >>> est_noir ( 0 , 358 ) True Correction \ud83d\udc0d Script Python 1 2 3 4 5 from PIL import Image img = Image . open ( 'pgcb.bmp' ) def est_noir ( x , y ): return img . getpixel (( x , y )) == ( 0 , 0 , 0 )", "title": "1. Prise en main"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_carre_blanc/#12-recherche-manuelle", "text": "Consid\u00e9rons le damier ci-dessous : Pour chaque case, on va inscrire \u00e0 l'int\u00e9rieur la taille du plus grand carr\u00e9 blanc possible dont la case est le coin inf\u00e9rieur droit . Par exemple : Sur une case noire, on \u00e9crira le nombre 0. Exercice 2 Recopier le damier et compl\u00e9ter toutes les cases, en commen\u00e7ant en haut \u00e0 gauche . Correction Imaginons maintenant la situation suivante, sur un autre damier que vous ne pouvez pas voir en int\u00e9gralit\u00e9 : Exercice 3 Quelle est la valeur qu'il faut \u00e9crire \u00e0 la place du point d'interrogation ? Correction Il faut \u00e9crire la valeur 3, qui est \u00e9gale \u00e0 1 + le minimum des trois cases situ\u00e9es au Nord, Ouest et Nord-Ouest.", "title": "1.2 Recherche manuelle"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_carre_blanc/#2-la-fonction-pgcb", "text": "pgcb -> plus grand carr\u00e9 blanc", "title": "2. La fonction pgcb"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_carre_blanc/#21-premiere-ecriture", "text": "On va \u00e9crire la fonction r\u00e9cursive pgcb , qui prend en param\u00e8tre un tuple (x,y) et qui renvoie la taille du plus grand carr\u00e9 blanc dont le pixel de coordonn\u00e9es (x,y) est le coin inf\u00e9rieur droit. Les cas de base seront : le pixel est noir : on renvoie 0 le pixel est sur la ligne du haut ou la colonne de gauche : on renvoie 1 Pour le cas g\u00e9n\u00e9ral, on s'inspirera de la partie pr\u00e9c\u00e9dente... Exercice 4 \u00c9crire le code de la fonction pgcb . Exemples d'utilisation : \ud83d\udc0d Script Python >>> pgcb ( 0 , 0 ) 1 >>> pgcb ( 3 , 2 ) 3 >>> pgcb ( 0 , 358 ) 0", "title": "2.1 Premi\u00e8re \u00e9criture"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_carre_blanc/#22-amelioration-de-la-fonction-pgcb", "text": "Si on teste la fonction avec le pixel de coordonn\u00e9es (300, 300) , le code ne renvoie aucun r\u00e9sultat et semble parti dans des calculs interminables. La structure r\u00e9cursive du code doit nous pousser \u00e0 la m\u00e9fiance : ne saurions-nous pas en train de lui demander de calculer plusieurs fois la m\u00eame chose ? La r\u00e9ponse est oui : si on ne regarde par exemple que les pixels diagonaux, l'appel pgcb(1, 1) aura lieu pour pgcb(2, 2) , mais aussi pour pgcb(3, 3) , pour pgcb(4, 4) , pour pgcb(5, 5) ... entre autres ! Pour \u00e9viter de refaire ces calculs, on va donc faire appel \u00e0 la technique de m\u00e9mo\u00efsation . Exercice 5 \u00c9crire la fonction pgcb_memo , identique \u00e0 la fonction pgcb mais qui m\u00e9mo\u00efse ses r\u00e9sultats. On pourra se servir d'une fonction englobante comme dans le cours sur Fibonacci. Exemple : \ud83d\udc0d Script Python >>> pgcb_memo ( 300 , 300 ) 21", "title": "2.2 Am\u00e9lioration de la fonction pgcb"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_carre_blanc/#3-recherche-du-plus-grand-carre", "text": "Maintenant que notre fonction est efficace, nous pouvons partir \u00e0 la recherche du pixel de l'image d'o\u00f9 peut se construire le plus grand carr\u00e9 blanc. Exercice 6 \u00c9crire une fonction total_pgcb qui va parcourir tous les pixels de l'image et renvoyer la taille du plus grand carr\u00e9 blanc qu'on puisse y inscrire, ainsi que les coordonn\u00e9es du pixel inf\u00e9rieur droit de ce carr\u00e9. Exemple : \ud83d\udc0d Script Python >>> total_pgcb () ( 51 , ( 370 , 461 )) dans la structure de votre code, penser \u00e0 r\u00e9utiliser le dictionnaire de m\u00e9mo\u00efsation...", "title": "3. Recherche du plus grand carr\u00e9"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/", "text": "Optimisation d'une somme dans une pyramide \u2693\ufe0e Probl\u00e8me Consid\u00e9rons la pyramide ci-dessous : En partant du sommet et en descendant jusqu'en bas en prenant soit \u00e0 gauche soit \u00e0 droite, quelle est la somme maximale que l'on peut obtenir ? 1. Quelques outils \u2693\ufe0e La pyramide ci-dessus sera impl\u00e9ment\u00e9e par une liste de listes : \ud83d\udc0d Script Python pyr_exemple = [[ 3 ], [ 5 , 4 ], [ 1 , 2 , 9 ], [ 2 , 6 , 5 , 3 ], [ 5 , 8 , 9 , 7 , 9 ]] Pour g\u00e9n\u00e9rer une pyramide de hauteur n (compos\u00e9e d'entiers al\u00e9atoires entre 0 et 9) : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 from random import randint def genere_pyr ( n ): pyr = [] for k in range ( 1 , n + 1 ): lst = [ randint ( 0 , 9 ) for _ in range ( k )] pyr . append ( lst ) return pyr Pour afficher une pyramide en console : \ud83d\udc0d Script Python 1 2 3 def affiche ( pyr ): for lst in pyr : print ( \" \" * ( len ( pyr ) - len ( lst )) + \" \" . join ( str ( k ) for k in lst )) Exercice 1 Cr\u00e9er puis afficher une pyramide de hauteur 10. Correction \ud83d\udc0d Script Python >>> pyr = genere_pyr ( 10 ) >>> affiche ( pyr ) 9 9 2 8 1 7 4 0 4 0 3 4 5 7 8 4 4 7 5 8 4 7 8 1 6 0 6 0 4 3 2 0 8 2 5 8 6 0 7 9 0 9 9 0 8 3 1 7 9 2 6 9 6 5 9 2. Recherche par force brute \u2693\ufe0e 2.1 Liste de tous les parcours \u2693\ufe0e La fonction liste_parcours ci-dessous renvoie la liste de tous les trajets possibles lors de la travers\u00e9e de la pyramide pyr . Ces parcours contiennent les indices des valeurs travers\u00e9es lors du parcours. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def liste_parcours ( pyr ): file = [[ 0 ]] parcours = [] while file : trajet = file . pop ( 0 ) j = trajet [ - 1 ] trajet_left = trajet [::] trajet_right = trajet [::] niv = len ( trajet ) trajet_left . append ( j ) trajet_right . append ( j + 1 ) if len ( trajet_left ) == len ( pyr ): parcours . append ( trajet_left ) else : file . append ( trajet_left ) if len ( trajet_right ) == len ( pyr ): parcours . append ( trajet_right ) else : file . append ( trajet_right ) return parcours Exercice 2 Observez la liste des trajets pour la pyramide pyr_exemple pour en comprendre la notation. Pour une pyramide de hauteur \\(n\\) , combien y a-t-il de trajets diff\u00e9rents ? Pour une pyramide de hauteur 41, que pensez-vous du nombre de trajets diff\u00e9rents ? Correction Le nombre de trajets pour une hauteur \\(n\\) est \\(2^{n-1}\\) . Pour une pyramide de hauteur 41, cela donne \\(2^{40}\\) , soit plus de mille milliards de chemins possibles... 2.2 Valeur d'un trajet \u2693\ufe0e Exercice 3 \u00c9crire une fonction val_trajet qui prend en param\u00e8tres un trajet trajet et une pyramide pyr et qui renvoie la somme finale \u00e0 l'issue de ce trajet. Exemple : \ud83d\udc0d Script Python >>> val_trajet ([ 0 , 1 , 1 , 2 , 2 ], pyr_exemple ) 23 Correction \ud83d\udc0d Script Python 1 2 3 4 5 def val_trajet ( trajet , pyr ): s = 0 for i in range ( len ( trajet )): s += pyr [ i ][ trajet [ i ]] return s 2.3 Somme maximale par force brute \u2693\ufe0e Exercice 4 Q1. \u00c9crire une fonction max_force_brute qui prend en param\u00e8tre une pyramide pyr et qui renvoie la somme maximale parmi tous les trajets possibles. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def max_force_brute ( pyr ): trajets = liste_parcours ( pyr ) m = 0 for tr in trajets : v = val_trajet ( tr , pyr ) if v > m : m = v return m Q2. Testez votre algorithme avec pyr_exemple , ainsi qu'avec des pyramides de taille sup\u00e9rieure. Que se passe-t-il ? Correction Notre algorithme donne bien la bonne solution pour pyr_exemple , mais d\u00e8s que la taille de la pyramide augmente, le temps d'ex\u00e9cution devient beaucoup trop long et notre programme inutilisable. 3. Recherche par m\u00e9thode gloutonne \u2693\ufe0e Notre algorithme de force brute n'\u00e9tant pas utilisable, il va falloir essayer d'\u00eatre plus efficace. Pourquoi ne pas chercher une m\u00e9thode gloutonne ? Rappel : lors du parcours d'une pyramide, les deux cases sous la case [i][j] sont la case [i+1][j] et [i+1][j+1] . Exercice 5 Q1. Compl\u00e9ter la fonction max_glouton ci-dessous qui calcule de mani\u00e8re gloutonne le \u00abmeilleur\u00bb trajet d'une pyramide pyr . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def max_glouton ( pyr ): s = pyr [ 0 ][ 0 ] j = 0 for i in range ( ... , ... ): v1 = ... v2 = ... if ... > ... : ... += ... else : ... += ... j = ... return s Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def max_glouton ( pyr ): s = pyr [ 0 ][ 0 ] j = 0 for i in range ( 1 , len ( pyr )): v1 = pyr [ i ][ j ] v2 = pyr [ i ][ j + 1 ] if v1 > v2 : s += v1 else : s += v2 j = j + 1 return s Q2. Observer et analyser le r\u00e9sultat donn\u00e9 par notre algorithme sur pyr_exemple . Correction Notre algorithme renvoie 25 au lieu de 30. Il ne nous donne donc pas le meilleur r\u00e9sultat. Cela ne doit pas nous \u00e9tonner, car la succession de meilleurs choix locaux ne donne pas forc\u00e9ment le meilleur choix global. 4. Recherche par m\u00e9thode r\u00e9cursive \u2693\ufe0e Exercice 6 Observer le dessin suivant : Q1. En d\u00e9duire une fonction max_recursif qui prendra en param\u00e8tre une pyramide pyr et qui calculera de mani\u00e8re r\u00e9cursive la somme maximale. Pour extraire les deux sous-pyramides gauche et droite, on pourra utiliser le code suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def extract_sub_left_right ( pyr ): left = [] right = [] for k in range ( 1 , len ( pyr )): lst_left = [ pyr [ k ][ j ] for j in range ( k )] lst_right = [ pyr [ k ][ j + 1 ] for j in range ( k )] left . append ( lst_left ) right . append ( lst_right ) return left , right Correction \ud83d\udc0d Script Python 1 2 3 4 5 def max_recursif ( pyr ): if len ( pyr ) == 1 : return pyr [ 0 ][ 0 ] pyr_left , pyr_right = extract_sub_left_right ( pyr ) return pyr [ 0 ][ 0 ] + max ( max_recursif ( pyr_left ), max_recursif ( pyr_right )) Q2. Testez votre algorithme avec pyr_exemple , ainsi qu'avec des pyramides de taille sup\u00e9rieure. Que se passe-t-il ? Correction D\u00e8s que la hauteur de la pyramide d\u00e9passe 25 (environ) le programme devient extr\u00eamement lent et inutilisable. On retrouve le probl\u00e8me rencontr\u00e9 avec l'algorithme de force brute. 5. Optimisation de la m\u00e9thode r\u00e9cursive par programmation dynamique \u2693\ufe0e La lenteur de l'algorithme pr\u00e9c\u00e9dent vient du fait que certains calculs sont redondants. Par exemple, le calcul du maximum de la pyramide rouge sera lanc\u00e9 en tant que sous-pyramide droite de la valeur 5, et en tant que sous-pyramide gauche de la valeur 4. Si la pyramide initiale est grande, ces appels inutiles vont se multiplier et ralentir consid\u00e9rablement l'ex\u00e9cution du programme. Exercice 7 Dans le code r\u00e9cursif suivant, chaque pyramide est identifi\u00e9e par les coordonn\u00e9es de son sommet, stock\u00e9es dans le tuple pos . Pour chaque sommet de coordonn\u00e9es (i, j) , il y a aura donc un appel r\u00e9cursif pour calculer la somme maximale de la pyramide de sommet (i+1, j) et celle de sommet (i, j+1) . Ce sont ces calculs que l'on doit stocker pour \u00e9viter d'avoir \u00e0 les refaire (principe de m\u00e9mo\u00efsation ). On va donc utiliser un dictionnaire dict_max qui associera \u00e0 chaque sommet (i, j) la somme maximale de sa pyramide. Q1. Compl\u00e9ter le code suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 dict_max = {} def max_rec_dynamique ( pyr , pos = ( 0 , 0 )): i , j = pos if i == len ( pyr ) - 1 : return pyr [ ... ][ ... ] # calcul du max de la sous-pyramide gauche if ( ... , ... ) in dict_max : val_gauche = ... else : val_gauche = ... dict_max [ ... ] = ... # calcul du max de la sous-pyramide droite ... ... ... ... ... return ... + ... Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 dict_max = {} def max_rec_dynamique ( pyr , pos = ( 0 , 0 )): i , j = pos if i == len ( pyr ) - 1 : return pyr [ i ][ j ] if ( i + 1 , j ) in dict_max : val_gauche = dict_max [( i + 1 , j )] else : val_gauche = max_rec_dynamique ( pyr , ( i + 1 , j )) dict_max [( i + 1 , j )] = val_gauche if ( i + 1 , j + 1 ) in dict_max : val_droit = dict_max [( i + 1 , j + 1 )] else : val_droit = max_rec_dynamique ( pyr , ( i + 1 , j + 1 )) dict_max [( i + 1 , j + 1 )] = val_droit return pyr [ i ][ j ] + max ( val_gauche , val_droit ) Q2. Testez votre algorithme avec pyr_exemple , ainsi qu'avec des pyramides de taille sup\u00e9rieure. Que constatez-vous ? Correction On constate que notre algorithme est devenu quasi-instantan\u00e9. Il ne faut que quelques secondes pour faire trouver le maximum d'une pyramide de taille 500. 6. M\u00e9thode bottom-up \u2693\ufe0e Plus court chemin Dans la figure ci-dessus, le chemin surlign\u00e9 est le chemin de longueur minimale entre A et C. Ce chemin passe par B. On peut donc en d\u00e9duire que la portion de ce chemin entre B et C (portion rouge) est le chemin minimal entre B et C. On peut le d\u00e9montrer facilement par l'absurde : si le chemin rouge n'est pas le chemin minimal entre B et C, alors il en existe un autre qui est minimal (par exemple le violet). En emprutant ce chemin \u00e0 partir de B, on pourrait donc construire entre A et C un chemin plus court que le chemin surlign\u00e9, ce qui est impossible. De mani\u00e8re analogue, on peut affirmer ceci : si le chemin minimal passe par B, alors la portion de ce chemin minimal entre B et C est forc\u00e9ment le chemin rouge. Nous allons exploiter une id\u00e9e similaire pour maximiser le parcours dans notre pyramide. Admettons que le parcours maximal passe par la valeur 6. Ensuite, ce parcours doit passer par 8 ou par 9. Comme ce parcours est maximal, il passera forc\u00e9ment par 9. On peut donc en d\u00e9duire que si le parcours arrive \u00e0 cette valeur 6, alors cette valeur pourrait \u00eatre remplac\u00e9e par 15. Faisons de m\u00eame pour les autres valeurs de l'avant-derni\u00e8re ligne : En proc\u00e9dant de m\u00eame pour les lignes sup\u00e9rieures, on trouve la valeur maximale de 30 : Exercice 8 En s'inspirant de la m\u00e9thode pr\u00e9c\u00e9dente, \u00e9crire une fonction max_iteratif qui prend une pyramide pyr en param\u00e8tre et qui renvoie la somme maximale des parcours de cette pyramide. Effectuer des tests pour appr\u00e9cier l'efficacit\u00e9 de cette fonction. Correction \ud83d\udc0d Script Python 1 2 3 4 5 def max_iteratif ( pyr ): for i in range ( len ( pyr ) - 2 , - 1 , - 1 ): for j in range ( len ( pyr [ i ])): pyr [ i ][ j ] = pyr [ i ][ j ] + max ( pyr [ i + 1 ][ j ], pyr [ i + 1 ][ j + 1 ]) return pyr [ 0 ][ 0 ] On peut calculer que cet algorithme est de complexit\u00e9 quadratique. Il reste n\u00e9anmoins tr\u00e8s rapide, y compris pour des grandes pyramides.", "title": "TP Pyramides"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#optimisation-dune-somme-dans-une-pyramide", "text": "Probl\u00e8me Consid\u00e9rons la pyramide ci-dessous : En partant du sommet et en descendant jusqu'en bas en prenant soit \u00e0 gauche soit \u00e0 droite, quelle est la somme maximale que l'on peut obtenir ?", "title": "Optimisation d'une somme dans une pyramide"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#1-quelques-outils", "text": "La pyramide ci-dessus sera impl\u00e9ment\u00e9e par une liste de listes : \ud83d\udc0d Script Python pyr_exemple = [[ 3 ], [ 5 , 4 ], [ 1 , 2 , 9 ], [ 2 , 6 , 5 , 3 ], [ 5 , 8 , 9 , 7 , 9 ]] Pour g\u00e9n\u00e9rer une pyramide de hauteur n (compos\u00e9e d'entiers al\u00e9atoires entre 0 et 9) : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 from random import randint def genere_pyr ( n ): pyr = [] for k in range ( 1 , n + 1 ): lst = [ randint ( 0 , 9 ) for _ in range ( k )] pyr . append ( lst ) return pyr Pour afficher une pyramide en console : \ud83d\udc0d Script Python 1 2 3 def affiche ( pyr ): for lst in pyr : print ( \" \" * ( len ( pyr ) - len ( lst )) + \" \" . join ( str ( k ) for k in lst )) Exercice 1 Cr\u00e9er puis afficher une pyramide de hauteur 10. Correction \ud83d\udc0d Script Python >>> pyr = genere_pyr ( 10 ) >>> affiche ( pyr ) 9 9 2 8 1 7 4 0 4 0 3 4 5 7 8 4 4 7 5 8 4 7 8 1 6 0 6 0 4 3 2 0 8 2 5 8 6 0 7 9 0 9 9 0 8 3 1 7 9 2 6 9 6 5 9", "title": "1. Quelques outils"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#2-recherche-par-force-brute", "text": "", "title": "2. Recherche par force brute"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#21-liste-de-tous-les-parcours", "text": "La fonction liste_parcours ci-dessous renvoie la liste de tous les trajets possibles lors de la travers\u00e9e de la pyramide pyr . Ces parcours contiennent les indices des valeurs travers\u00e9es lors du parcours. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def liste_parcours ( pyr ): file = [[ 0 ]] parcours = [] while file : trajet = file . pop ( 0 ) j = trajet [ - 1 ] trajet_left = trajet [::] trajet_right = trajet [::] niv = len ( trajet ) trajet_left . append ( j ) trajet_right . append ( j + 1 ) if len ( trajet_left ) == len ( pyr ): parcours . append ( trajet_left ) else : file . append ( trajet_left ) if len ( trajet_right ) == len ( pyr ): parcours . append ( trajet_right ) else : file . append ( trajet_right ) return parcours Exercice 2 Observez la liste des trajets pour la pyramide pyr_exemple pour en comprendre la notation. Pour une pyramide de hauteur \\(n\\) , combien y a-t-il de trajets diff\u00e9rents ? Pour une pyramide de hauteur 41, que pensez-vous du nombre de trajets diff\u00e9rents ? Correction Le nombre de trajets pour une hauteur \\(n\\) est \\(2^{n-1}\\) . Pour une pyramide de hauteur 41, cela donne \\(2^{40}\\) , soit plus de mille milliards de chemins possibles...", "title": "2.1 Liste de tous les parcours"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#22-valeur-dun-trajet", "text": "Exercice 3 \u00c9crire une fonction val_trajet qui prend en param\u00e8tres un trajet trajet et une pyramide pyr et qui renvoie la somme finale \u00e0 l'issue de ce trajet. Exemple : \ud83d\udc0d Script Python >>> val_trajet ([ 0 , 1 , 1 , 2 , 2 ], pyr_exemple ) 23 Correction \ud83d\udc0d Script Python 1 2 3 4 5 def val_trajet ( trajet , pyr ): s = 0 for i in range ( len ( trajet )): s += pyr [ i ][ trajet [ i ]] return s", "title": "2.2 Valeur d'un trajet"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#23-somme-maximale-par-force-brute", "text": "Exercice 4 Q1. \u00c9crire une fonction max_force_brute qui prend en param\u00e8tre une pyramide pyr et qui renvoie la somme maximale parmi tous les trajets possibles. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def max_force_brute ( pyr ): trajets = liste_parcours ( pyr ) m = 0 for tr in trajets : v = val_trajet ( tr , pyr ) if v > m : m = v return m Q2. Testez votre algorithme avec pyr_exemple , ainsi qu'avec des pyramides de taille sup\u00e9rieure. Que se passe-t-il ? Correction Notre algorithme donne bien la bonne solution pour pyr_exemple , mais d\u00e8s que la taille de la pyramide augmente, le temps d'ex\u00e9cution devient beaucoup trop long et notre programme inutilisable.", "title": "2.3 Somme maximale par force brute"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#3-recherche-par-methode-gloutonne", "text": "Notre algorithme de force brute n'\u00e9tant pas utilisable, il va falloir essayer d'\u00eatre plus efficace. Pourquoi ne pas chercher une m\u00e9thode gloutonne ? Rappel : lors du parcours d'une pyramide, les deux cases sous la case [i][j] sont la case [i+1][j] et [i+1][j+1] . Exercice 5 Q1. Compl\u00e9ter la fonction max_glouton ci-dessous qui calcule de mani\u00e8re gloutonne le \u00abmeilleur\u00bb trajet d'une pyramide pyr . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def max_glouton ( pyr ): s = pyr [ 0 ][ 0 ] j = 0 for i in range ( ... , ... ): v1 = ... v2 = ... if ... > ... : ... += ... else : ... += ... j = ... return s Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def max_glouton ( pyr ): s = pyr [ 0 ][ 0 ] j = 0 for i in range ( 1 , len ( pyr )): v1 = pyr [ i ][ j ] v2 = pyr [ i ][ j + 1 ] if v1 > v2 : s += v1 else : s += v2 j = j + 1 return s Q2. Observer et analyser le r\u00e9sultat donn\u00e9 par notre algorithme sur pyr_exemple . Correction Notre algorithme renvoie 25 au lieu de 30. Il ne nous donne donc pas le meilleur r\u00e9sultat. Cela ne doit pas nous \u00e9tonner, car la succession de meilleurs choix locaux ne donne pas forc\u00e9ment le meilleur choix global.", "title": "3. Recherche par m\u00e9thode gloutonne"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#4-recherche-par-methode-recursive", "text": "Exercice 6 Observer le dessin suivant : Q1. En d\u00e9duire une fonction max_recursif qui prendra en param\u00e8tre une pyramide pyr et qui calculera de mani\u00e8re r\u00e9cursive la somme maximale. Pour extraire les deux sous-pyramides gauche et droite, on pourra utiliser le code suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def extract_sub_left_right ( pyr ): left = [] right = [] for k in range ( 1 , len ( pyr )): lst_left = [ pyr [ k ][ j ] for j in range ( k )] lst_right = [ pyr [ k ][ j + 1 ] for j in range ( k )] left . append ( lst_left ) right . append ( lst_right ) return left , right Correction \ud83d\udc0d Script Python 1 2 3 4 5 def max_recursif ( pyr ): if len ( pyr ) == 1 : return pyr [ 0 ][ 0 ] pyr_left , pyr_right = extract_sub_left_right ( pyr ) return pyr [ 0 ][ 0 ] + max ( max_recursif ( pyr_left ), max_recursif ( pyr_right )) Q2. Testez votre algorithme avec pyr_exemple , ainsi qu'avec des pyramides de taille sup\u00e9rieure. Que se passe-t-il ? Correction D\u00e8s que la hauteur de la pyramide d\u00e9passe 25 (environ) le programme devient extr\u00eamement lent et inutilisable. On retrouve le probl\u00e8me rencontr\u00e9 avec l'algorithme de force brute.", "title": "4. Recherche par m\u00e9thode r\u00e9cursive"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#5-optimisation-de-la-methode-recursive-par-programmation-dynamique", "text": "La lenteur de l'algorithme pr\u00e9c\u00e9dent vient du fait que certains calculs sont redondants. Par exemple, le calcul du maximum de la pyramide rouge sera lanc\u00e9 en tant que sous-pyramide droite de la valeur 5, et en tant que sous-pyramide gauche de la valeur 4. Si la pyramide initiale est grande, ces appels inutiles vont se multiplier et ralentir consid\u00e9rablement l'ex\u00e9cution du programme. Exercice 7 Dans le code r\u00e9cursif suivant, chaque pyramide est identifi\u00e9e par les coordonn\u00e9es de son sommet, stock\u00e9es dans le tuple pos . Pour chaque sommet de coordonn\u00e9es (i, j) , il y a aura donc un appel r\u00e9cursif pour calculer la somme maximale de la pyramide de sommet (i+1, j) et celle de sommet (i, j+1) . Ce sont ces calculs que l'on doit stocker pour \u00e9viter d'avoir \u00e0 les refaire (principe de m\u00e9mo\u00efsation ). On va donc utiliser un dictionnaire dict_max qui associera \u00e0 chaque sommet (i, j) la somme maximale de sa pyramide. Q1. Compl\u00e9ter le code suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 dict_max = {} def max_rec_dynamique ( pyr , pos = ( 0 , 0 )): i , j = pos if i == len ( pyr ) - 1 : return pyr [ ... ][ ... ] # calcul du max de la sous-pyramide gauche if ( ... , ... ) in dict_max : val_gauche = ... else : val_gauche = ... dict_max [ ... ] = ... # calcul du max de la sous-pyramide droite ... ... ... ... ... return ... + ... Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 dict_max = {} def max_rec_dynamique ( pyr , pos = ( 0 , 0 )): i , j = pos if i == len ( pyr ) - 1 : return pyr [ i ][ j ] if ( i + 1 , j ) in dict_max : val_gauche = dict_max [( i + 1 , j )] else : val_gauche = max_rec_dynamique ( pyr , ( i + 1 , j )) dict_max [( i + 1 , j )] = val_gauche if ( i + 1 , j + 1 ) in dict_max : val_droit = dict_max [( i + 1 , j + 1 )] else : val_droit = max_rec_dynamique ( pyr , ( i + 1 , j + 1 )) dict_max [( i + 1 , j + 1 )] = val_droit return pyr [ i ][ j ] + max ( val_gauche , val_droit ) Q2. Testez votre algorithme avec pyr_exemple , ainsi qu'avec des pyramides de taille sup\u00e9rieure. Que constatez-vous ? Correction On constate que notre algorithme est devenu quasi-instantan\u00e9. Il ne faut que quelques secondes pour faire trouver le maximum d'une pyramide de taille 500.", "title": "5. Optimisation de la m\u00e9thode r\u00e9cursive par programmation dynamique"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_pyramides/#6-methode-bottom-up", "text": "Plus court chemin Dans la figure ci-dessus, le chemin surlign\u00e9 est le chemin de longueur minimale entre A et C. Ce chemin passe par B. On peut donc en d\u00e9duire que la portion de ce chemin entre B et C (portion rouge) est le chemin minimal entre B et C. On peut le d\u00e9montrer facilement par l'absurde : si le chemin rouge n'est pas le chemin minimal entre B et C, alors il en existe un autre qui est minimal (par exemple le violet). En emprutant ce chemin \u00e0 partir de B, on pourrait donc construire entre A et C un chemin plus court que le chemin surlign\u00e9, ce qui est impossible. De mani\u00e8re analogue, on peut affirmer ceci : si le chemin minimal passe par B, alors la portion de ce chemin minimal entre B et C est forc\u00e9ment le chemin rouge. Nous allons exploiter une id\u00e9e similaire pour maximiser le parcours dans notre pyramide. Admettons que le parcours maximal passe par la valeur 6. Ensuite, ce parcours doit passer par 8 ou par 9. Comme ce parcours est maximal, il passera forc\u00e9ment par 9. On peut donc en d\u00e9duire que si le parcours arrive \u00e0 cette valeur 6, alors cette valeur pourrait \u00eatre remplac\u00e9e par 15. Faisons de m\u00eame pour les autres valeurs de l'avant-derni\u00e8re ligne : En proc\u00e9dant de m\u00eame pour les lignes sup\u00e9rieures, on trouve la valeur maximale de 30 : Exercice 8 En s'inspirant de la m\u00e9thode pr\u00e9c\u00e9dente, \u00e9crire une fonction max_iteratif qui prend une pyramide pyr en param\u00e8tre et qui renvoie la somme maximale des parcours de cette pyramide. Effectuer des tests pour appr\u00e9cier l'efficacit\u00e9 de cette fonction. Correction \ud83d\udc0d Script Python 1 2 3 4 5 def max_iteratif ( pyr ): for i in range ( len ( pyr ) - 2 , - 1 , - 1 ): for j in range ( len ( pyr [ i ])): pyr [ i ][ j ] = pyr [ i ][ j ] + max ( pyr [ i + 1 ][ j ], pyr [ i + 1 ][ j + 1 ]) return pyr [ 0 ][ 0 ] On peut calculer que cet algorithme est de complexit\u00e9 quadratique. Il reste n\u00e9anmoins tr\u00e8s rapide, y compris pour des grandes pyramides.", "title": "6. M\u00e9thode bottom-up"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_rendu_monnaie/", "text": "Optimisation de rendu de monnaie \u2693\ufe0e Probl\u00e8me Nous allons nous int\u00e9resser au probl\u00e8me suivant : \u00c9tant donn\u00e9s une liste de pi\u00e8ces pieces et une somme \u00e0 rendre somme , peut-on calculer le nombre minimal de pi\u00e8ces pour r\u00e9aliser cette somme ? Remarque importante : Dans toute la suite, on consid\u00e9rera que la somme \u00e0 rendre est un nombre entier positif, et que dans la liste de pi\u00e8ces se trouve la pi\u00e8ce de valeur 1. Ainsi, il est toujours possible de rendre la monnaie. 1. Retour sur l'algorithme glouton \u2693\ufe0e Nous avons vu en Premi\u00e8re un algorithme capable de donner une combinaison de pi\u00e8ces pour rendre la somme somme . Cet algorithme fonctionnait de mani\u00e8re gloutonne : on cherche \u00e0 rendre \u00e0 chaque fois la plus grosse pi\u00e8ce possible. Exercice 1 Compl\u00e9ter la fonction rendu_glouton qui prend en param\u00e8tres une liste de pi\u00e8ces pieces (class\u00e9es dans l'ordre croissant) et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def rendu_glouton ( pieces , somme ): i = ... # (1) nb_pieces = ... while ... > ... : if ... <= somme : nb_pieces += ... somme -= ... else : i -= ... return ... Attention, les pi\u00e8ces sont class\u00e9es dans l'ordre croissant . Exemple d'utilisation : \ud83d\udc0d Script Python >>> rendu_glouton ([ 1 , 2 , 5 ], 12 ) 3 Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def rendu_glouton ( pieces , somme ): i = len ( pieces ) - 1 nb_pieces = 0 while somme > 0 : if pieces [ i ] <= somme : nb_pieces += 1 somme -= pieces [ i ] else : i -= 1 return nb_pieces Nous savons que cet algorithme est optimal sous certaines conditions sur la composition des pi\u00e8ces. Par exemple le syst\u00e8me des euros (1, 2, 5, 10, 20, 50, 100, 200) rend l'algorithme glouton optimal (on dit que le syst\u00e8me est canonique ). Mais si le syst\u00e8me n'est pas canonique, l'algorithme glouton peut ne pas donner la meilleure solution : \ud83d\udc0d Script Python >>> rendu_glouton ([ 1 , 6 , 10 ], 12 ) 3 Notre algorithme va trouver que \\(12 = 10 + 1 + 1\\) et donc rendre 3 pi\u00e8ces, alors qu'il est possible de faire \\(12 = 6+6\\) et ne rendre que 2 pi\u00e8ces. 2. Algorithme r\u00e9cursif \u2693\ufe0e Il est possible de construire un algorithme optimal de mani\u00e8re r\u00e9cursive. Il faut pour cela faire les observations suivantes : pour rappel, le rendu est toujours possible : dans le pire des cas, le nombre de pi\u00e8ces \u00e0 rendre est \u00e9gal \u00e0 la somme de d\u00e9part (rendu effectu\u00e9 \u00e0 coups de pi\u00e8ces de 1) Si p est une pi\u00e8ce de pieces , le nombre minimal de pi\u00e8ces n\u00e9cessaires pour rendre la somme somme est \u00e9gal \u00e0 1 + le nombre minimal de pi\u00e8ces n\u00e9cessaires (contenant p ) pour rendre la somme somme - p . Cette derni\u00e8re observation est cruciale. Elle repose sur le fait qu'il suffit de ajouter 1 pi\u00e8ce (la pi\u00e8ce de valeur p ) \u00e0 la meileure combinaison qui rend somme - p pour avoir la meilleure combinaison qui rend somme (meilleure combinaison parmi celles contenant p ). On va donc passer en revue toutes les pi\u00e8ces p et mettre \u00e0 jour \u00e0 chaque fois le nombre minimal de pi\u00e8ces. Exercice 2 Compl\u00e9ter la fonction rendu_recursif qui prend en param\u00e8tres une liste de pi\u00e8ces pieces et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu_recursif ( pieces , somme ): nb_pieces = ... # (1) if somme == 0 : return ... # (2) for p in pieces : if ... <= ... : # (3) nb_pieces = min ( nb_pieces , ... + rendu_recursif ( pieces , ... )) return ... Nombre de pi\u00e8ces dans le pire des cas Cas de base Peut-on rendre la pi\u00e8ce p ? Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu_recursif ( pieces , somme ): nb_pieces = somme if somme == 0 : return 0 for p in pieces : if p <= somme : nb_pieces = min ( nb_pieces , 1 + rendu_recursif ( pieces , somme - p )) return nb_pieces Testons notre algorithme : \ud83d\udc0d Script Python >>> rendu_recursif ([ 1 , 2 , 5 ], 12 ) 3 >>> rendu_recursif ([ 1 , 6 , 10 ], 12 ) 2 Il ne se laisse pas pi\u00e8ger comme l'algorithme glouton et rend bien en 2 pi\u00e8ces la somme 12. Mais... \ud83d\udc0d Script Python >>> rendu_recursif ([ 1 , 6 , 10 ], 107 ) RecursionError : maximum recursion depth exceeded in comparison Le nombre d'appels r\u00e9cursifs de notre algorithme augmente exponentiellement avec la valeur de la somme \u00e0 rendre : on se retrouve tr\u00e8s rapidement avec des milliards d'appels r\u00e9cursifs, ce qui n'est pas g\u00e9rable. Ces appels r\u00e9cursifs ont lieu sur un nombre limit\u00e9 de valeurs : par construction de notre algorithme, si la somme \u00e0 rendre est 100, il y aura beaucoup (beaucoup) d'appels vers 99, vers 98, vers 97... jusqu'\u00e0 0. On peut donc l\u00e9gitimement penser \u00e0 m\u00e9mo\u00efser notre algorithme, en stockant les valeurs pour \u00e9viter de les recalculer. 3. Algorithme r\u00e9cursif memo\u00efs\u00e9 \u2693\ufe0e Exercice 3 Compl\u00e9ter la fonction rendu_recursif_memoise qui prend en param\u00e8tres une liste de pi\u00e8ces pieces et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. On utilisera le dictionnaire memo_rendu dans lequel on associera \u00e0 chaque somme somme son nombre de pi\u00e8ces minimal. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 memo_rendu = {} def rendu_recursif_memoise ( pieces , somme ): nb_pieces = somme if somme == 0 : return 0 for p in pieces : if p <= somme : if ... not in memo_rendu : memo_rendu [ ... ] = ... nb_pieces = ... return nb_pieces Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 memo_rendu = {} def rendu_recursif_memoise ( pieces , somme ): nb_pieces = somme if somme == 0 : return 0 for p in pieces : if p <= somme : if somme - p not in memo_rendu : memo_rendu [ somme - p ] = rendu_recursif_memoise ( pieces , somme - p ) nb_pieces = min ( nb_pieces , 1 + memo_rendu [ somme - p ]) return nb_pieces Notre algorithme est maintenant beaucoup (beaucoup) plus efficace : \ud83d\udc0d Script Python >>> rendu_recursif_memoise ([ 1 , 6 , 10 ], 107 ) 16 4. Algorithme bottom-up \u2693\ufe0e Nous avions calcul\u00e9 le \\(F_n\\) , n-i\u00e8me terme de la suite de Fibonacci en calculant d'abord \\(F_0\\) , \\(F_1\\) , \\(F_2\\) , ..., jusqu'\u00e0 \\(F_{n-1}\\) puis \\(F_n\\) . En s'inspirant de cette m\u00e9thode ( bottom-up ) nous allons ici calculer successivement tous les rendus minimaux jusqu'\u00e0 somme avant de calculer le rendu minimal de somme . Exercice 4 Compl\u00e9ter la fonction rendu_bottom_up qui prend en param\u00e8tres une liste de pi\u00e8ces pieces et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. Nous stockerons chaque rendu dans un dictionnaire rendu , initialis\u00e9 \u00e0 la valeur 0 pour la cl\u00e9 0. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu_bottom_up ( pieces , somme ): rendu = { ... } for s in range ( ... , ... ): # (1) rendu [ s ] = ... #(2) for p in pieces : if p <= s : rendu [ s ] = min ( ... , ... + ... ) return ... Attention, il faut aller jusqu'\u00e0 la valeur somme . Nombre de pi\u00e8ces dans le pire des cas. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu_bottom_up ( pieces , somme ): rendu = { 0 : 0 } for s in range ( 1 , somme + 1 ): rendu [ s ] = s for p in pieces : if p <= s : rendu [ s ] = min ( rendu [ s ], 1 + rendu [ s - p ]) return rendu [ somme ] \ud83d\udc0d Script Python >>> rendu_bottom_up ([ 1 , 6 , 10 ], 107 ) 12 Notre algorithme it\u00e9ratif est de complexit\u00e9 lin\u00e9aire (par rapport \u00e0 la variable somme ). 5. Bonus : construction d'une solution \u2693\ufe0e Nos diff\u00e9rents algorithmes avaient pour but de nous renvoyer le nombre minimal de pi\u00e8ces. Mais peut-on les modifier pour qu'ils renvoient la liste de pi\u00e8ces utilis\u00e9es ? Nous allons nous appuyer sur le dernier algorithme cr\u00e9\u00e9 (par m\u00e9thode bottom-up ). Il suffit de rajouter un dictionnaire solutions qui associera \u00e0 chaque somme la liste des pi\u00e8ces n\u00e9cessaires. Lors du parcours de toutes les pi\u00e8ces, si un nouveau nombre minimal de pi\u00e8ces est trouv\u00e9 pour la pi\u00e8ce p , il faut rajouter la pi\u00e8ce p \u00e0 la liste des solutions. Exercice 5 Compl\u00e9ter la fonction rendu_solution qui prend en param\u00e8tres une liste de pi\u00e8ces pieces et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def rendu_solution ( pieces , somme ): rendu = { 0 : 0 } solution = {} solution [ 0 ] = [] for s in range ( 1 , somme + 1 ): rendu [ s ] = s solution [ s ] = [] for p in pieces : if p <= s : if 1 + rendu [ s - p ] < rendu [ s ]: rendu [ s ] = ... solution [ s ] = ... . copy () # (1) solution [ s ] . ... return ... On effectue une copie de liste avec la m\u00e9thode copy . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def rendu_solution ( pieces , somme ): rendu = { 0 : 0 } solution = {} solution [ 0 ] = [] for s in range ( 1 , somme + 1 ): rendu [ s ] = s solution [ s ] = [] for p in pieces : if p <= s : if 1 + rendu [ s - p ] < rendu [ s ]: rendu [ s ] = 1 + rendu [ s - p ] solution [ s ] = solution [ s - p ] . copy () solution [ s ] . append ( p ) return solution [ somme ] \ud83d\udc0d Script Python >>> rendu_solution ([ 1 , 6 , 10 ], 12 ) [ 6 , 6 ] >>> rendu_solution ([ 1 , 6 , 10 ], 107 ) [ 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 6 , 1 ]", "title": "TP Rendu de monnaie"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_rendu_monnaie/#optimisation-de-rendu-de-monnaie", "text": "Probl\u00e8me Nous allons nous int\u00e9resser au probl\u00e8me suivant : \u00c9tant donn\u00e9s une liste de pi\u00e8ces pieces et une somme \u00e0 rendre somme , peut-on calculer le nombre minimal de pi\u00e8ces pour r\u00e9aliser cette somme ? Remarque importante : Dans toute la suite, on consid\u00e9rera que la somme \u00e0 rendre est un nombre entier positif, et que dans la liste de pi\u00e8ces se trouve la pi\u00e8ce de valeur 1. Ainsi, il est toujours possible de rendre la monnaie.", "title": "Optimisation de rendu de monnaie"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_rendu_monnaie/#1-retour-sur-lalgorithme-glouton", "text": "Nous avons vu en Premi\u00e8re un algorithme capable de donner une combinaison de pi\u00e8ces pour rendre la somme somme . Cet algorithme fonctionnait de mani\u00e8re gloutonne : on cherche \u00e0 rendre \u00e0 chaque fois la plus grosse pi\u00e8ce possible. Exercice 1 Compl\u00e9ter la fonction rendu_glouton qui prend en param\u00e8tres une liste de pi\u00e8ces pieces (class\u00e9es dans l'ordre croissant) et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def rendu_glouton ( pieces , somme ): i = ... # (1) nb_pieces = ... while ... > ... : if ... <= somme : nb_pieces += ... somme -= ... else : i -= ... return ... Attention, les pi\u00e8ces sont class\u00e9es dans l'ordre croissant . Exemple d'utilisation : \ud83d\udc0d Script Python >>> rendu_glouton ([ 1 , 2 , 5 ], 12 ) 3 Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def rendu_glouton ( pieces , somme ): i = len ( pieces ) - 1 nb_pieces = 0 while somme > 0 : if pieces [ i ] <= somme : nb_pieces += 1 somme -= pieces [ i ] else : i -= 1 return nb_pieces Nous savons que cet algorithme est optimal sous certaines conditions sur la composition des pi\u00e8ces. Par exemple le syst\u00e8me des euros (1, 2, 5, 10, 20, 50, 100, 200) rend l'algorithme glouton optimal (on dit que le syst\u00e8me est canonique ). Mais si le syst\u00e8me n'est pas canonique, l'algorithme glouton peut ne pas donner la meilleure solution : \ud83d\udc0d Script Python >>> rendu_glouton ([ 1 , 6 , 10 ], 12 ) 3 Notre algorithme va trouver que \\(12 = 10 + 1 + 1\\) et donc rendre 3 pi\u00e8ces, alors qu'il est possible de faire \\(12 = 6+6\\) et ne rendre que 2 pi\u00e8ces.", "title": "1. Retour sur l'algorithme glouton"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_rendu_monnaie/#2-algorithme-recursif", "text": "Il est possible de construire un algorithme optimal de mani\u00e8re r\u00e9cursive. Il faut pour cela faire les observations suivantes : pour rappel, le rendu est toujours possible : dans le pire des cas, le nombre de pi\u00e8ces \u00e0 rendre est \u00e9gal \u00e0 la somme de d\u00e9part (rendu effectu\u00e9 \u00e0 coups de pi\u00e8ces de 1) Si p est une pi\u00e8ce de pieces , le nombre minimal de pi\u00e8ces n\u00e9cessaires pour rendre la somme somme est \u00e9gal \u00e0 1 + le nombre minimal de pi\u00e8ces n\u00e9cessaires (contenant p ) pour rendre la somme somme - p . Cette derni\u00e8re observation est cruciale. Elle repose sur le fait qu'il suffit de ajouter 1 pi\u00e8ce (la pi\u00e8ce de valeur p ) \u00e0 la meileure combinaison qui rend somme - p pour avoir la meilleure combinaison qui rend somme (meilleure combinaison parmi celles contenant p ). On va donc passer en revue toutes les pi\u00e8ces p et mettre \u00e0 jour \u00e0 chaque fois le nombre minimal de pi\u00e8ces. Exercice 2 Compl\u00e9ter la fonction rendu_recursif qui prend en param\u00e8tres une liste de pi\u00e8ces pieces et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu_recursif ( pieces , somme ): nb_pieces = ... # (1) if somme == 0 : return ... # (2) for p in pieces : if ... <= ... : # (3) nb_pieces = min ( nb_pieces , ... + rendu_recursif ( pieces , ... )) return ... Nombre de pi\u00e8ces dans le pire des cas Cas de base Peut-on rendre la pi\u00e8ce p ? Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu_recursif ( pieces , somme ): nb_pieces = somme if somme == 0 : return 0 for p in pieces : if p <= somme : nb_pieces = min ( nb_pieces , 1 + rendu_recursif ( pieces , somme - p )) return nb_pieces Testons notre algorithme : \ud83d\udc0d Script Python >>> rendu_recursif ([ 1 , 2 , 5 ], 12 ) 3 >>> rendu_recursif ([ 1 , 6 , 10 ], 12 ) 2 Il ne se laisse pas pi\u00e8ger comme l'algorithme glouton et rend bien en 2 pi\u00e8ces la somme 12. Mais... \ud83d\udc0d Script Python >>> rendu_recursif ([ 1 , 6 , 10 ], 107 ) RecursionError : maximum recursion depth exceeded in comparison Le nombre d'appels r\u00e9cursifs de notre algorithme augmente exponentiellement avec la valeur de la somme \u00e0 rendre : on se retrouve tr\u00e8s rapidement avec des milliards d'appels r\u00e9cursifs, ce qui n'est pas g\u00e9rable. Ces appels r\u00e9cursifs ont lieu sur un nombre limit\u00e9 de valeurs : par construction de notre algorithme, si la somme \u00e0 rendre est 100, il y aura beaucoup (beaucoup) d'appels vers 99, vers 98, vers 97... jusqu'\u00e0 0. On peut donc l\u00e9gitimement penser \u00e0 m\u00e9mo\u00efser notre algorithme, en stockant les valeurs pour \u00e9viter de les recalculer.", "title": "2. Algorithme r\u00e9cursif"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_rendu_monnaie/#3-algorithme-recursif-memoise", "text": "Exercice 3 Compl\u00e9ter la fonction rendu_recursif_memoise qui prend en param\u00e8tres une liste de pi\u00e8ces pieces et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. On utilisera le dictionnaire memo_rendu dans lequel on associera \u00e0 chaque somme somme son nombre de pi\u00e8ces minimal. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 memo_rendu = {} def rendu_recursif_memoise ( pieces , somme ): nb_pieces = somme if somme == 0 : return 0 for p in pieces : if p <= somme : if ... not in memo_rendu : memo_rendu [ ... ] = ... nb_pieces = ... return nb_pieces Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 memo_rendu = {} def rendu_recursif_memoise ( pieces , somme ): nb_pieces = somme if somme == 0 : return 0 for p in pieces : if p <= somme : if somme - p not in memo_rendu : memo_rendu [ somme - p ] = rendu_recursif_memoise ( pieces , somme - p ) nb_pieces = min ( nb_pieces , 1 + memo_rendu [ somme - p ]) return nb_pieces Notre algorithme est maintenant beaucoup (beaucoup) plus efficace : \ud83d\udc0d Script Python >>> rendu_recursif_memoise ([ 1 , 6 , 10 ], 107 ) 16", "title": "3. Algorithme r\u00e9cursif memo\u00efs\u00e9"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_rendu_monnaie/#4-algorithme-bottom-up", "text": "Nous avions calcul\u00e9 le \\(F_n\\) , n-i\u00e8me terme de la suite de Fibonacci en calculant d'abord \\(F_0\\) , \\(F_1\\) , \\(F_2\\) , ..., jusqu'\u00e0 \\(F_{n-1}\\) puis \\(F_n\\) . En s'inspirant de cette m\u00e9thode ( bottom-up ) nous allons ici calculer successivement tous les rendus minimaux jusqu'\u00e0 somme avant de calculer le rendu minimal de somme . Exercice 4 Compl\u00e9ter la fonction rendu_bottom_up qui prend en param\u00e8tres une liste de pi\u00e8ces pieces et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. Nous stockerons chaque rendu dans un dictionnaire rendu , initialis\u00e9 \u00e0 la valeur 0 pour la cl\u00e9 0. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu_bottom_up ( pieces , somme ): rendu = { ... } for s in range ( ... , ... ): # (1) rendu [ s ] = ... #(2) for p in pieces : if p <= s : rendu [ s ] = min ( ... , ... + ... ) return ... Attention, il faut aller jusqu'\u00e0 la valeur somme . Nombre de pi\u00e8ces dans le pire des cas. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu_bottom_up ( pieces , somme ): rendu = { 0 : 0 } for s in range ( 1 , somme + 1 ): rendu [ s ] = s for p in pieces : if p <= s : rendu [ s ] = min ( rendu [ s ], 1 + rendu [ s - p ]) return rendu [ somme ] \ud83d\udc0d Script Python >>> rendu_bottom_up ([ 1 , 6 , 10 ], 107 ) 12 Notre algorithme it\u00e9ratif est de complexit\u00e9 lin\u00e9aire (par rapport \u00e0 la variable somme ).", "title": "4. Algorithme bottom-up"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/TP_rendu_monnaie/#5-bonus-construction-dune-solution", "text": "Nos diff\u00e9rents algorithmes avaient pour but de nous renvoyer le nombre minimal de pi\u00e8ces. Mais peut-on les modifier pour qu'ils renvoient la liste de pi\u00e8ces utilis\u00e9es ? Nous allons nous appuyer sur le dernier algorithme cr\u00e9\u00e9 (par m\u00e9thode bottom-up ). Il suffit de rajouter un dictionnaire solutions qui associera \u00e0 chaque somme la liste des pi\u00e8ces n\u00e9cessaires. Lors du parcours de toutes les pi\u00e8ces, si un nouveau nombre minimal de pi\u00e8ces est trouv\u00e9 pour la pi\u00e8ce p , il faut rajouter la pi\u00e8ce p \u00e0 la liste des solutions. Exercice 5 Compl\u00e9ter la fonction rendu_solution qui prend en param\u00e8tres une liste de pi\u00e8ces pieces et la somme \u00e0 rendre somme et qui renvoie le nombre minimal de pi\u00e8ces qu'il faut rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def rendu_solution ( pieces , somme ): rendu = { 0 : 0 } solution = {} solution [ 0 ] = [] for s in range ( 1 , somme + 1 ): rendu [ s ] = s solution [ s ] = [] for p in pieces : if p <= s : if 1 + rendu [ s - p ] < rendu [ s ]: rendu [ s ] = ... solution [ s ] = ... . copy () # (1) solution [ s ] . ... return ... On effectue une copie de liste avec la m\u00e9thode copy . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def rendu_solution ( pieces , somme ): rendu = { 0 : 0 } solution = {} solution [ 0 ] = [] for s in range ( 1 , somme + 1 ): rendu [ s ] = s solution [ s ] = [] for p in pieces : if p <= s : if 1 + rendu [ s - p ] < rendu [ s ]: rendu [ s ] = 1 + rendu [ s - p ] solution [ s ] = solution [ s - p ] . copy () solution [ s ] . append ( p ) return solution [ somme ] \ud83d\udc0d Script Python >>> rendu_solution ([ 1 , 6 , 10 ], 12 ) [ 6 , 6 ] >>> rendu_solution ([ 1 , 6 , 10 ], 107 ) [ 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 6 , 1 ]", "title": "5. Bonus : construction d'une solution"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/", "text": "Programmation dynamique \u2693\ufe0e 1. Retour sur la suite de Fibonacci \u2693\ufe0e 1.1 Simple et inefficace \u2693\ufe0e Comme nous l'avons d\u00e9j\u00e0 vu ici , la suite de Fibonacci d\u00e9finie par : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) se programme r\u00e9cursivement par : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Ce code, d'une grande simplicit\u00e9, est malheureusement tr\u00e8s inefficace. Exercice 1 Mesurer le temps de calcul de fibo(40) . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 import time def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) t0 = time . time () fibo ( 40 ) print ( time . time () - t0 ) Le temps de calcul est de plusieurs dizaines de secondes, sur une machine r\u00e9cente. C'est tr\u00e8s mauvais ! En cause : la multitude des appels r\u00e9cursifs nous conduit \u00e0 refaire des calculs d\u00e9j\u00e0 effectu\u00e9s. Observons l'arbre d'appels de fibo(6) : Le calcul de fibo(2) se retrouve ainsi 5 fois dans l'arbre. Pour r\u00e9soudre notre probl\u00e8me, nous l'avons divis\u00e9 en probl\u00e8mes plus petits, mais malheureusement pas ind\u00e9pendants : on dit que les probl\u00e8mes se recouvrent , ce qui nous am\u00e8ne \u00e0 refaire des choses d\u00e9j\u00e0 faites. Dans l'algorithme de dichotomie, ou du tri-fusion, les probl\u00e8mes \u00e9taient ind\u00e9pendants et ne se recouvraient pas : on ne refaisait jamais deux fois la m\u00eame chose. Ce n'est pas le cas ici. 1.2 Se souvenir des belles choses des calculs : la m\u00e9mo\u00efsation \u2693\ufe0e Comment \u00e9viter de recalculer (par exemple) 5 fois fibo(2) ? L'id\u00e9e g\u00e9n\u00e9rale est de stocker le r\u00e9sultat de chaque calcul, par exemple dans un dictionnaire. Ainsi, \u00e0 chaque demande de calcul : Soit le calcul a d\u00e9j\u00e0 \u00e9t\u00e9 effectu\u00e9 : on a donc juste \u00e0 le lire dans le dictionnaire. Soit le calcul n'a jamais \u00e9t\u00e9 effectu\u00e9 : on l'effectue, et on stocke le r\u00e9sultat dans le dictionnaire . Exercice 2 Compl\u00e9ter le code suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 dict_fibo = { 0 : 0 , 1 : 1 } def fibo ( n ): if n in dict_fibo : return ... dict_fibo [ n ] = ... + ... return ... Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 dict_fibo = { 0 : 0 , 1 : 1 } def fibo ( n ): if n in dict_fibo : return dict_fibo [ n ] dict_fibo [ n ] = fibo ( n - 1 ) + fibo ( n - 2 ) return dict_fibo [ n ] Exercice 3 Mesurer le temps de calcul de fibo(40) et comparer avec la mesure de l'exercice 1. 1.3 Quelques remarques \u2693\ufe0e 1.3.1 Juste une brute-force plus efficace ? \u2693\ufe0e Notre technique de m\u00e9mo\u00efsation ne change pas vraiment la structure du programme : on continue de calculer toutes les valeurs interm\u00e9diaires, mais on ne les calcule qu'une seule fois. 1.3.2 Suppression de la variable globale \u2693\ufe0e Dans le code pr\u00e9c\u00e9dent, le dictionnaire dict_fibo est \u00e0 l'ext\u00e9rieur de la fonction. Un dictionnaire \u00e9tant un type mutable, sa modification \u00e0 l'int\u00e9rieur de la fonction ne pose pas de probl\u00e8me. Toutefois, ce genre de pratique est d\u00e9conseill\u00e9 : si par exemple on appelle 2 fois la fonction fibo , le dictionnaire n'est pas r\u00e9initialis\u00e9 entre-temps (ce qui dans notre cas n'est pas probl\u00e9matique, mais cela pourrait l'\u00eatre). Comment \u00e9viter cela ? On peut utiliser une fonction englobante (appel\u00e9e ici fibonacci ) : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def fibonacci ( n ): dict_fibo = { 0 : 0 , 1 : 1 } def fibo ( n ): if n in dict_fibo : return dict_fibo [ n ] dict_fibo [ n ] = fibo ( n - 1 ) + fibo ( n - 2 ) return dict_fibo [ n ] return fibo ( n ) \ud83d\udc0d Script Python >>> fibonacci ( 50 ) 12586269025 Remarquez la d\u00e9finition d'une fonction \u00e0 l'int\u00e9rieur d'une autre. Cela ne pose aucun probl\u00e8me, mais attention, cette fonction n'existe pas \u00e0 l'ext\u00e9rieur de sa fonction englobante. 1.3.3 M\u00e9mo\u00efsation automatique en Python \u2693\ufe0e La fonction lru_cache du module functools permet de m\u00e9mo\u00efser automatiquement une fonction r\u00e9cursive. Il suffit, juste avant d'\u00e9crire la fonction, de mettre la ligne @lru_cache (appel\u00e9e d\u00e9corateur ). \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time from functools import lru_cache @lru_cache #(1) def fibo ( n ): #(2) if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) t0 = time . time () fibo ( 35 ) print ( time . time () - t0 ) \u00abd\u00e9corateur\u00bb de la fonction Ceci est notre VIEILLE fonction fibo , extr\u00eamement lente... Essayez en commentant / d\u00e9commentant la ligne 4... c'est magique ! 1.4 De bas en haut \u2693\ufe0e La structure r\u00e9cursive naturelle de la suite de Fibonacci nous a conduit vers un programme qui calcule (ou plut\u00f4t appelle ) les valeurs de haut en bas . (m\u00e9thode top-down ) Et si on commen\u00e7ait par le bas ? Si nous devions calculer mentalement le 6\u00e8me terme de la suite de Fibonacci, on commencerait par calculer le 3\u00e8me, puis le 4\u00e8me, puis le 5\u00e8me et enfin le 6\u00e8me. Exercice 4 Compl\u00e9ter le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibo ( n ): dict_fibo = {} dict_fibo [ 0 ] = ... dict_fibo [ 1 ] = ... for k in range ( ... , ... ): dict_fibo [ k ] = dict_fibo [ ... ] + dict_fibo [ ... ] return dict_fibo [ ... ] Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibo ( n ): dict_fibo = {} dict_fibo [ 0 ] = 0 dict_fibo [ 1 ] = 1 for k in range ( 2 , n + 1 ): dict_fibo [ k ] = dict_fibo [ k - 1 ] + dict_fibo [ k - 2 ] return dict_fibo [ n ] Cette m\u00e9thode it\u00e9rative part du bas pour aller vers le haut. On parle de m\u00e9thode bottom-up . De mani\u00e8re plus g\u00e9n\u00e9rale, cette m\u00e9thode est bas\u00e9e sur le fait de r\u00e9soudre des probl\u00e8mes de petite taille, puis de plus en plus gros, jusqu'au probl\u00e8me final. 1.5 Bilan des m\u00e9thodes employ\u00e9es \u2693\ufe0e Principes de programmation dynamique Lors d'un calcul effectu\u00e9 de mani\u00e8re r\u00e9cursive, il peut arriver que de multiples appels r\u00e9cursifs soient identiques. Pour \u00e9viter de recalculer plusieurs fois la m\u00eame chose, on peut stocker les r\u00e9sultats interm\u00e9diaires. On appelle cette technique la m\u00e9mo\u00efsation . Cette technique minimise le nombre d'op\u00e9rations et acc\u00e9l\u00e8re grandement l'ex\u00e9cution du programme. Le prix \u00e0 payer est l'utilisation d'une structure de stockage des valeurs interm\u00e9diaires, et donc une augmentation de la m\u00e9moire utilis\u00e9e par le programme. Lors d'un calcul effectu\u00e9 de mani\u00e8re it\u00e9rative, il est parfois plus simple de commencer par une \u00abpetite\u00bb version du probl\u00e8me pour progressivement remonter vers la solution du probl\u00e8me global. 2. Programmation dynamique et optimisation \u2693\ufe0e 2.1 Optimisation d'une somme dans une pyramide \u2693\ufe0e Probl\u00e8me Consid\u00e9rons la pyramide ci-dessous : En partant du sommet et en descendant soit \u00e0 gauche soit \u00e0 droite, quel chemin donne la somme maximale en arrivant en bas ? La suite : TP Pyramides 2.2 Optimisation du rendu de monnaie \u2693\ufe0e Probl\u00e8me \u00c9tant donn\u00e9s une liste de pi\u00e8ces pieces et une somme \u00e0 rendre somme , peut-on calculer le nombre minimal de pi\u00e8ces pour r\u00e9aliser cette somme ? La suite : TP Rendu de monnaie", "title": "Cours"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#programmation-dynamique", "text": "", "title": "Programmation dynamique"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#1-retour-sur-la-suite-de-fibonacci", "text": "", "title": "1. Retour sur la suite de Fibonacci"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#11-simple-et-inefficace", "text": "Comme nous l'avons d\u00e9j\u00e0 vu ici , la suite de Fibonacci d\u00e9finie par : \\(F_0 = 0\\) \\(F_1 = 1\\) \\(\\forall n \\in \\mathbb{N}, F_{n+2} = F_{n+1}+F_n\\) se programme r\u00e9cursivement par : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) Ce code, d'une grande simplicit\u00e9, est malheureusement tr\u00e8s inefficace. Exercice 1 Mesurer le temps de calcul de fibo(40) . Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 import time def fibo ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibo ( n - 1 ) + fibo ( n - 2 ) t0 = time . time () fibo ( 40 ) print ( time . time () - t0 ) Le temps de calcul est de plusieurs dizaines de secondes, sur une machine r\u00e9cente. C'est tr\u00e8s mauvais ! En cause : la multitude des appels r\u00e9cursifs nous conduit \u00e0 refaire des calculs d\u00e9j\u00e0 effectu\u00e9s. Observons l'arbre d'appels de fibo(6) : Le calcul de fibo(2) se retrouve ainsi 5 fois dans l'arbre. Pour r\u00e9soudre notre probl\u00e8me, nous l'avons divis\u00e9 en probl\u00e8mes plus petits, mais malheureusement pas ind\u00e9pendants : on dit que les probl\u00e8mes se recouvrent , ce qui nous am\u00e8ne \u00e0 refaire des choses d\u00e9j\u00e0 faites. Dans l'algorithme de dichotomie, ou du tri-fusion, les probl\u00e8mes \u00e9taient ind\u00e9pendants et ne se recouvraient pas : on ne refaisait jamais deux fois la m\u00eame chose. Ce n'est pas le cas ici.", "title": "1.1 Simple et inefficace"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#12-se-souvenir-des-belles-choses-des-calculs-la-memoisation", "text": "Comment \u00e9viter de recalculer (par exemple) 5 fois fibo(2) ? L'id\u00e9e g\u00e9n\u00e9rale est de stocker le r\u00e9sultat de chaque calcul, par exemple dans un dictionnaire. Ainsi, \u00e0 chaque demande de calcul : Soit le calcul a d\u00e9j\u00e0 \u00e9t\u00e9 effectu\u00e9 : on a donc juste \u00e0 le lire dans le dictionnaire. Soit le calcul n'a jamais \u00e9t\u00e9 effectu\u00e9 : on l'effectue, et on stocke le r\u00e9sultat dans le dictionnaire . Exercice 2 Compl\u00e9ter le code suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 dict_fibo = { 0 : 0 , 1 : 1 } def fibo ( n ): if n in dict_fibo : return ... dict_fibo [ n ] = ... + ... return ... Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 dict_fibo = { 0 : 0 , 1 : 1 } def fibo ( n ): if n in dict_fibo : return dict_fibo [ n ] dict_fibo [ n ] = fibo ( n - 1 ) + fibo ( n - 2 ) return dict_fibo [ n ] Exercice 3 Mesurer le temps de calcul de fibo(40) et comparer avec la mesure de l'exercice 1.", "title": "1.2 Se souvenir des belles choses des calculs : la m\u00e9mo\u00efsation"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#13-quelques-remarques", "text": "", "title": "1.3 Quelques remarques"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#14-de-bas-en-haut", "text": "La structure r\u00e9cursive naturelle de la suite de Fibonacci nous a conduit vers un programme qui calcule (ou plut\u00f4t appelle ) les valeurs de haut en bas . (m\u00e9thode top-down ) Et si on commen\u00e7ait par le bas ? Si nous devions calculer mentalement le 6\u00e8me terme de la suite de Fibonacci, on commencerait par calculer le 3\u00e8me, puis le 4\u00e8me, puis le 5\u00e8me et enfin le 6\u00e8me. Exercice 4 Compl\u00e9ter le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibo ( n ): dict_fibo = {} dict_fibo [ 0 ] = ... dict_fibo [ 1 ] = ... for k in range ( ... , ... ): dict_fibo [ k ] = dict_fibo [ ... ] + dict_fibo [ ... ] return dict_fibo [ ... ] Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibo ( n ): dict_fibo = {} dict_fibo [ 0 ] = 0 dict_fibo [ 1 ] = 1 for k in range ( 2 , n + 1 ): dict_fibo [ k ] = dict_fibo [ k - 1 ] + dict_fibo [ k - 2 ] return dict_fibo [ n ] Cette m\u00e9thode it\u00e9rative part du bas pour aller vers le haut. On parle de m\u00e9thode bottom-up . De mani\u00e8re plus g\u00e9n\u00e9rale, cette m\u00e9thode est bas\u00e9e sur le fait de r\u00e9soudre des probl\u00e8mes de petite taille, puis de plus en plus gros, jusqu'au probl\u00e8me final.", "title": "1.4 De bas en haut"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#15-bilan-des-methodes-employees", "text": "Principes de programmation dynamique Lors d'un calcul effectu\u00e9 de mani\u00e8re r\u00e9cursive, il peut arriver que de multiples appels r\u00e9cursifs soient identiques. Pour \u00e9viter de recalculer plusieurs fois la m\u00eame chose, on peut stocker les r\u00e9sultats interm\u00e9diaires. On appelle cette technique la m\u00e9mo\u00efsation . Cette technique minimise le nombre d'op\u00e9rations et acc\u00e9l\u00e8re grandement l'ex\u00e9cution du programme. Le prix \u00e0 payer est l'utilisation d'une structure de stockage des valeurs interm\u00e9diaires, et donc une augmentation de la m\u00e9moire utilis\u00e9e par le programme. Lors d'un calcul effectu\u00e9 de mani\u00e8re it\u00e9rative, il est parfois plus simple de commencer par une \u00abpetite\u00bb version du probl\u00e8me pour progressivement remonter vers la solution du probl\u00e8me global.", "title": "1.5 Bilan des m\u00e9thodes employ\u00e9es"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#2-programmation-dynamique-et-optimisation", "text": "", "title": "2. Programmation dynamique et optimisation"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#21-optimisation-dune-somme-dans-une-pyramide", "text": "Probl\u00e8me Consid\u00e9rons la pyramide ci-dessous : En partant du sommet et en descendant soit \u00e0 gauche soit \u00e0 droite, quel chemin donne la somme maximale en arrivant en bas ? La suite : TP Pyramides", "title": "2.1 Optimisation d'une somme dans une pyramide"}, {"location": "T3_Algorithmique/3.2_Programmation_dynamique/cours/#22-optimisation-du-rendu-de-monnaie", "text": "Probl\u00e8me \u00c9tant donn\u00e9s une liste de pi\u00e8ces pieces et une somme \u00e0 rendre somme , peut-on calculer le nombre minimal de pi\u00e8ces pour r\u00e9aliser cette somme ? La suite : TP Rendu de monnaie", "title": "2.2 Optimisation du rendu de monnaie"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/", "text": "Recherche textuelle \u2693\ufe0e 1. Recherche na\u00efve \u2693\ufe0e Illustration de l'algorithme Vous pouvez contr\u00f4ler le d\u00e9roulement de l'animation en la survolant avec la souris. 1.1 Premier algorithme \u2693\ufe0e Algorithme de recherche na\u00efve \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_naive ( texte , motif ): ''' renvoie la liste des indices (\u00e9ventuellement vide) des occurrences de de la cha\u00eene motif dans la cha\u00eene texte. ''' indices = [] i = 0 while i <= len ( texte ) - len ( motif ): k = 0 while k < len ( motif ) and texte [ i + k ] == motif [ k ]: k += 1 if k == len ( motif ): indices . append ( i ) i += 1 return indices Exemple d'utilisation : \ud83d\udc0d Script Python >>> recherche_naive ( \"une magnifique maison bleue\" , \"maison\" ) [ 15 ] >>> recherche_naive ( \"une magnifique maison bleue\" , \"nsi\" ) [] >>> recherche_naive ( \"une magnifique maison bleue\" , \"ma\" ) [ 4 , 15 ] 1.2 Modification de l'algorithme \u2693\ufe0e Exercice 1 \u00c9nonc\u00e9 Correction Re-\u00e9crire l'algorithme pr\u00e9c\u00e9dent en s'arr\u00eatant d\u00e8s qu'une occurrence de motif est trouv\u00e9e dans texte . La fonction renverra uniquement un bool\u00e9en. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_naive_bool ( texte , motif ): ''' renvoie un bool\u00e9en indiquant la pr\u00e9sence ou non de la cha\u00eene motif dans la cha\u00eene texte. ''' trouve = False i = 0 while i <= len ( texte ) - len ( motif ) and not trouve : k = 0 while k < len ( motif ) and texte [ i + k ] == motif [ k ]: k += 1 if k == len ( motif ): trouve = True i += 1 return trouve 1.3 Application \u00e0 la recherche d'un motif dans un roman \u2693\ufe0e Le Projet Gutenberg permet de t\u00e9l\u00e9charger l\u00e9galement des ouvrages libres de droits dans diff\u00e9rents formats. Nous allons travailler avec le Tome 1 du roman Les Mis\u00e9rables de Victor Hugo, \u00e0 t\u00e9l\u00e9charger ici au format txt . 1.3.1 R\u00e9cup\u00e9ration du texte dans une seule cha\u00eene de caract\u00e8res \u2693\ufe0e \ud83d\udc0d Script Python 1 2 with open ( \"Les_Miserables.txt\" ) as f : roman = f . read () . replace ( ' \\n ' , ' ' ) 1.3.2 V\u00e9rification et mesure du temps de recherche \u2693\ufe0e Exercice 2 \u00c9nonc\u00e9 Correction \u00c0 l'aide du module time , mesurer le temps de recherche dans Les Mis\u00e9rables d'un mot court, d'une longue phrase (pr\u00e9sente dans le texte), d'un mot qui n'existe pas. Que remarquez-vous ? \ud83d\udc0d Script Python t0 = time . time () motif = \"maison\" print ( recherche_naive ( roman , motif )) print ( time . time () - t0 ) t0 = time . time () motif = \"La chandelle \u00e9tait sur la chemin\u00e9e et ne donnait que peu de clart\u00e9.\" print ( recherche_naive ( roman , motif )) print ( time . time () - t0 ) t0 = time . time () motif = \"parcoursup\" print ( recherche_naive ( roman , motif )) print ( time . time () - t0 ) retour console : \ud83d\udc0d Script Python [ 7264 , 9090 , 9547 , 9745 , 10936 , 17820 , 23978 , 38192 , 41639 , 41651 , 41840 , 42493 , 48028 , 48393 , 51448 , 53353 , 70867 , 72692 , 72768 , 75608 , 77855 , 108489 , 115739 , 130629 , 132983 , 138870 , 143681 , 144600 , 153114 , 155973 , 158709 , 160700 , 163649 , 169164 , 169181 , 171761 , 171967 , 182642 , 186413 , 190534 , 219378 , 220314 , 224518 , 225098 , 227579 , 296302 , 345108 , 345893 , 346740 , 349677 , 359727 , 362025 , 389945 , 395690 , 434118 , 438068 , 457795 , 457886 , 464696 , 469403 , 501768 , 514980 , 520667 , 520878 , 520926 , 520968 , 522707 , 529329 , 598128 , 601390 , 645915 ] 0.21963715553283691 [ 651731 ] 0.21761441230773926 [] 0.22150230407714844 On remarque que le temps de recherche est semblable, quel que soit le motif cherch\u00e9. 2. Vers l'algorithme de Boyer-Moore : et si on partait \u00e0 l'envers ? \u2693\ufe0e Exercice 3 \u00c9nonc\u00e9 Correction Re-\u00e9crire l'algorithme de recherche na\u00efve mais en d\u00e9marrant de la fin du motif et non du d\u00e9but. Certes, c'est pour l'instant tr\u00e8s artificiel, mais : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def presqueBMH ( texte , motif ): indices = [] i = len ( motif ) - 1 while i < len ( texte ): k = 0 while k < len ( motif ) and motif [ len ( motif ) - 1 - k ] == texte [ i - k ]: k += 1 if k == len ( motif ): indices . append ( i - len ( motif ) + 1 ) i += 1 return indices 3. Algorithme de Boyer-Moore-Horspool \u2693\ufe0e 2.1 Principe \u2693\ufe0e L'id\u00e9e est d'am\u00e9liorer le code pr\u00e9c\u00e9dent (celui on parcourt le motif \u00e0 l'envers) en sautant directement au prochain endroit potentiellement valide. Pour cela on regarde le caract\u00e8re X du texte sur lequel on s'est arr\u00eat\u00e9 (car X n'\u00e9tait pas \u00e9gal au caract\u00e8re de rang \u00e9quivalent dans le motif): si X n'est pas dans le motif, il est inutile de se d\u00e9placer \"de 1\" : on retomberait tout de suite sur X , c'est du temps perdu. On se d\u00e9cale donc juste assez pour d\u00e9passer X , donc de la longueur du motif cherch\u00e9. si X est dans le motif (sauf \u00e0 la derni\u00e8re place du motif !), on va regarder la place de la derni\u00e8re occurence de X dans le motif et de d\u00e9placer de ce nombre, afin de faire co\u00efncider le X du motif et le X du texte. Illustration de l'algorithme Vous pouvez contr\u00f4ler le d\u00e9roulement de l'animation en la survolant avec la souris. 2.2 Impl\u00e9mentation \u2693\ufe0e On va d'abord coder une fonction dico_lettres qui renvoie un dictionnaire associant \u00e0 chaque lettre de mot (param\u00e8tre d'entr\u00e9e) son dernier rang dans le mot . On exclut la derni\u00e8re lettre, qui poserait un probl\u00e8me lors du d\u00e9calage (on d\u00e9calerait de 0...) Algorithme de Boyer-Moore-Horspool \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def dico_lettres ( mot ): d = {} for i in range ( len ( mot ) - 1 ): d [ mot [ i ]] = i return d def BMH ( texte , motif ): dico = dico_lettres ( motif ) indices = [] i = len ( motif ) - 1 while i < len ( texte ): k = 0 while k < len ( motif ) and motif [ len ( motif ) - 1 - k ] == texte [ i - k ]: #(1) k += 1 if k == len ( motif ): #(2) indices . append ( i - len ( motif ) + 1 ) i += 1 #(3) else : if texte [ i - k ] in dico : ( #4) i = max ( i - k + len ( motif ) - dico [ texte [ i - k ]] - 1 , i + 1 ) #(5) else : i = i - k + len ( motif ) #(6) return indices On remonte le motif \u00e0 l'envers, tant qu'il y a correspondance et qu'on n'est pas arriv\u00e9s au d\u00e9but du motif Si on est arriv\u00e9s au d\u00e9but du motif, c'est qu'on a trouv\u00e9 le mot. On a trouv\u00e9 le motif, mais attention, il ne faut pas trop se d\u00e9caler sinon on pourrait rater d'autres occurences du motif (pensez \u00e0 la recherche du motif \u00abmama\u00bb dans le mot \u00abmamamamama\u00bb). On se d\u00e9cale donc de 1. On s'est arr\u00eat\u00e9 avant la fin, sur une lettre pr\u00e9sente dans le mot : il va falloir faire un d\u00e9calage intelligent. On d\u00e9cale juste de ce qu'il faut pour mettre en correspondance les lettres, en \u00e9vitant le retour en arri\u00e8re (d'o\u00f9 le max pour se d\u00e9caler au moins de 1) La lettre n'est pas dans le motif : on se positionne juste apr\u00e8s elle. Exemple d'utilisation : \ud83d\udc0d Script Python >>> BMH ( \"une magnifique maison bleue\" , \"maison\" ) [ 15 ] >>> BMH ( \"une magnifique maison bleue\" , \"nsi\" ) [] >>> BMH ( \"une magnifique maison bleue\" , \"ma\" ) [ 4 , 15 ] Exercice 4 \u00c9nonc\u00e9 Correction Reprendre les mesures effectu\u00e9es sur Les Mis\u00e9rables, mais cette fois avec l'algorithme BMH. Que remarquez-vous ? \ud83d\udc0d Script Python t0 = time . time () motif = \"maison\" print ( BMH ( roman , motif )) print ( time . time () - t0 ) t0 = time . time () motif = \"La chandelle \u00e9tait sur la chemin\u00e9e et ne donnait que peu de clart\u00e9.\" print ( BMH ( roman , motif )) print ( time . time () - t0 ) t0 = time . time () motif = \"parcoursup\" print ( BMH ( roman , motif )) print ( time . time () - t0 ) retour console : \ud83d\udc0d Script Python [ 7264 , 9090 , 9547 , 9745 , 10936 , 17820 , 23978 , 38192 , 41639 , 41651 , 41840 , 42493 , 48028 , 48393 , 51448 , 53353 , 70867 , 72692 , 72768 , 75608 , 77855 , 108489 , 115739 , 130629 , 132983 , 138870 , 143681 , 144600 , 153114 , 155973 , 158709 , 160700 , 163649 , 169164 , 169181 , 171761 , 171967 , 182642 , 186413 , 190534 , 219378 , 220314 , 224518 , 225098 , 227579 , 296302 , 345108 , 345893 , 346740 , 349677 , 359727 , 362025 , 389945 , 395690 , 434118 , 438068 , 457795 , 457886 , 464696 , 469403 , 501768 , 514980 , 520667 , 520878 , 520926 , 520968 , 522707 , 529329 , 598128 , 601390 , 645915 ] 0.06359553337097168 [ 651731 ] 0.01853322982788086 [] 0.037064313888549805 On constate quelque chose de remarquable (et qui peut \u00eatre \u00e0 premi\u00e8re vue contre-intuitif) : Plus le motif recherch\u00e9 est long, plus la recherche est rapide .", "title": "Recherche textuelle"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#recherche-textuelle", "text": "", "title": "Recherche textuelle"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#1-recherche-naive", "text": "Illustration de l'algorithme Vous pouvez contr\u00f4ler le d\u00e9roulement de l'animation en la survolant avec la souris.", "title": "1. Recherche na\u00efve"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#11-premier-algorithme", "text": "Algorithme de recherche na\u00efve \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_naive ( texte , motif ): ''' renvoie la liste des indices (\u00e9ventuellement vide) des occurrences de de la cha\u00eene motif dans la cha\u00eene texte. ''' indices = [] i = 0 while i <= len ( texte ) - len ( motif ): k = 0 while k < len ( motif ) and texte [ i + k ] == motif [ k ]: k += 1 if k == len ( motif ): indices . append ( i ) i += 1 return indices Exemple d'utilisation : \ud83d\udc0d Script Python >>> recherche_naive ( \"une magnifique maison bleue\" , \"maison\" ) [ 15 ] >>> recherche_naive ( \"une magnifique maison bleue\" , \"nsi\" ) [] >>> recherche_naive ( \"une magnifique maison bleue\" , \"ma\" ) [ 4 , 15 ]", "title": "1.1 Premier algorithme"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#12-modification-de-lalgorithme", "text": "Exercice 1 \u00c9nonc\u00e9 Correction Re-\u00e9crire l'algorithme pr\u00e9c\u00e9dent en s'arr\u00eatant d\u00e8s qu'une occurrence de motif est trouv\u00e9e dans texte . La fonction renverra uniquement un bool\u00e9en. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_naive_bool ( texte , motif ): ''' renvoie un bool\u00e9en indiquant la pr\u00e9sence ou non de la cha\u00eene motif dans la cha\u00eene texte. ''' trouve = False i = 0 while i <= len ( texte ) - len ( motif ) and not trouve : k = 0 while k < len ( motif ) and texte [ i + k ] == motif [ k ]: k += 1 if k == len ( motif ): trouve = True i += 1 return trouve", "title": "1.2 Modification de l'algorithme"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#13-application-a-la-recherche-dun-motif-dans-un-roman", "text": "Le Projet Gutenberg permet de t\u00e9l\u00e9charger l\u00e9galement des ouvrages libres de droits dans diff\u00e9rents formats. Nous allons travailler avec le Tome 1 du roman Les Mis\u00e9rables de Victor Hugo, \u00e0 t\u00e9l\u00e9charger ici au format txt .", "title": "1.3 Application \u00e0 la recherche d'un motif dans un roman"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#2-vers-lalgorithme-de-boyer-moore-et-si-on-partait-a-lenvers", "text": "Exercice 3 \u00c9nonc\u00e9 Correction Re-\u00e9crire l'algorithme de recherche na\u00efve mais en d\u00e9marrant de la fin du motif et non du d\u00e9but. Certes, c'est pour l'instant tr\u00e8s artificiel, mais : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def presqueBMH ( texte , motif ): indices = [] i = len ( motif ) - 1 while i < len ( texte ): k = 0 while k < len ( motif ) and motif [ len ( motif ) - 1 - k ] == texte [ i - k ]: k += 1 if k == len ( motif ): indices . append ( i - len ( motif ) + 1 ) i += 1 return indices", "title": "2. Vers l'algorithme de Boyer-Moore : et si on partait \u00e0 l'envers ?"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#3-algorithme-de-boyer-moore-horspool", "text": "", "title": "3. Algorithme de Boyer-Moore-Horspool"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#21-principe", "text": "L'id\u00e9e est d'am\u00e9liorer le code pr\u00e9c\u00e9dent (celui on parcourt le motif \u00e0 l'envers) en sautant directement au prochain endroit potentiellement valide. Pour cela on regarde le caract\u00e8re X du texte sur lequel on s'est arr\u00eat\u00e9 (car X n'\u00e9tait pas \u00e9gal au caract\u00e8re de rang \u00e9quivalent dans le motif): si X n'est pas dans le motif, il est inutile de se d\u00e9placer \"de 1\" : on retomberait tout de suite sur X , c'est du temps perdu. On se d\u00e9cale donc juste assez pour d\u00e9passer X , donc de la longueur du motif cherch\u00e9. si X est dans le motif (sauf \u00e0 la derni\u00e8re place du motif !), on va regarder la place de la derni\u00e8re occurence de X dans le motif et de d\u00e9placer de ce nombre, afin de faire co\u00efncider le X du motif et le X du texte. Illustration de l'algorithme Vous pouvez contr\u00f4ler le d\u00e9roulement de l'animation en la survolant avec la souris.", "title": "2.1 Principe"}, {"location": "T3_Algorithmique/3.3_Recherche_textuelle/cours/#22-implementation", "text": "On va d'abord coder une fonction dico_lettres qui renvoie un dictionnaire associant \u00e0 chaque lettre de mot (param\u00e8tre d'entr\u00e9e) son dernier rang dans le mot . On exclut la derni\u00e8re lettre, qui poserait un probl\u00e8me lors du d\u00e9calage (on d\u00e9calerait de 0...) Algorithme de Boyer-Moore-Horspool \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def dico_lettres ( mot ): d = {} for i in range ( len ( mot ) - 1 ): d [ mot [ i ]] = i return d def BMH ( texte , motif ): dico = dico_lettres ( motif ) indices = [] i = len ( motif ) - 1 while i < len ( texte ): k = 0 while k < len ( motif ) and motif [ len ( motif ) - 1 - k ] == texte [ i - k ]: #(1) k += 1 if k == len ( motif ): #(2) indices . append ( i - len ( motif ) + 1 ) i += 1 #(3) else : if texte [ i - k ] in dico : ( #4) i = max ( i - k + len ( motif ) - dico [ texte [ i - k ]] - 1 , i + 1 ) #(5) else : i = i - k + len ( motif ) #(6) return indices On remonte le motif \u00e0 l'envers, tant qu'il y a correspondance et qu'on n'est pas arriv\u00e9s au d\u00e9but du motif Si on est arriv\u00e9s au d\u00e9but du motif, c'est qu'on a trouv\u00e9 le mot. On a trouv\u00e9 le motif, mais attention, il ne faut pas trop se d\u00e9caler sinon on pourrait rater d'autres occurences du motif (pensez \u00e0 la recherche du motif \u00abmama\u00bb dans le mot \u00abmamamamama\u00bb). On se d\u00e9cale donc de 1. On s'est arr\u00eat\u00e9 avant la fin, sur une lettre pr\u00e9sente dans le mot : il va falloir faire un d\u00e9calage intelligent. On d\u00e9cale juste de ce qu'il faut pour mettre en correspondance les lettres, en \u00e9vitant le retour en arri\u00e8re (d'o\u00f9 le max pour se d\u00e9caler au moins de 1) La lettre n'est pas dans le motif : on se positionne juste apr\u00e8s elle. Exemple d'utilisation : \ud83d\udc0d Script Python >>> BMH ( \"une magnifique maison bleue\" , \"maison\" ) [ 15 ] >>> BMH ( \"une magnifique maison bleue\" , \"nsi\" ) [] >>> BMH ( \"une magnifique maison bleue\" , \"ma\" ) [ 4 , 15 ] Exercice 4 \u00c9nonc\u00e9 Correction Reprendre les mesures effectu\u00e9es sur Les Mis\u00e9rables, mais cette fois avec l'algorithme BMH. Que remarquez-vous ? \ud83d\udc0d Script Python t0 = time . time () motif = \"maison\" print ( BMH ( roman , motif )) print ( time . time () - t0 ) t0 = time . time () motif = \"La chandelle \u00e9tait sur la chemin\u00e9e et ne donnait que peu de clart\u00e9.\" print ( BMH ( roman , motif )) print ( time . time () - t0 ) t0 = time . time () motif = \"parcoursup\" print ( BMH ( roman , motif )) print ( time . time () - t0 ) retour console : \ud83d\udc0d Script Python [ 7264 , 9090 , 9547 , 9745 , 10936 , 17820 , 23978 , 38192 , 41639 , 41651 , 41840 , 42493 , 48028 , 48393 , 51448 , 53353 , 70867 , 72692 , 72768 , 75608 , 77855 , 108489 , 115739 , 130629 , 132983 , 138870 , 143681 , 144600 , 153114 , 155973 , 158709 , 160700 , 163649 , 169164 , 169181 , 171761 , 171967 , 182642 , 186413 , 190534 , 219378 , 220314 , 224518 , 225098 , 227579 , 296302 , 345108 , 345893 , 346740 , 349677 , 359727 , 362025 , 389945 , 395690 , 434118 , 438068 , 457795 , 457886 , 464696 , 469403 , 501768 , 514980 , 520667 , 520878 , 520926 , 520968 , 522707 , 529329 , 598128 , 601390 , 645915 ] 0.06359553337097168 [ 651731 ] 0.01853322982788086 [] 0.037064313888549805 On constate quelque chose de remarquable (et qui peut \u00eatre \u00e0 premi\u00e8re vue contre-intuitif) : Plus le motif recherch\u00e9 est long, plus la recherche est rapide .", "title": "2.2 Impl\u00e9mentation"}, {"location": "T4_Bases_de_donnees/sommaire/", "text": "Mod\u00e8le relationnel Langage SQL SQLite on line", "title": "Sommaire"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/", "text": "Le mod\u00e8le relationnel \u2693\ufe0e 0. De la n\u00e9cessit\u00e9 d'organiser le stockage de ses donn\u00e9es \u2693\ufe0e Lorsqu'une grande quantit\u00e9 de donn\u00e9es doit \u00eatre g\u00e9r\u00e9e, il faut savoir distinguer deux choses : la structure qui va sous-tendre l'ensemble de ces donn\u00e9es, notamment les liens entre elles, les hi\u00e9rarchies \u00e9ventuelles,... le type de logiciel qui va aider \u00e0 g\u00e9rer ces donn\u00e9es. Par exemple, si je souhaite stocker toutes les temp\u00e9ratures relev\u00e9es dans mon jardin tous les matins \u00e0 07h00, je sais que mes donn\u00e9es seront des couples (date, temperature) . \u00c9ventuellement ces dates seront regroup\u00e9es par mois, ou par saison... mais la structure des donn\u00e9es sera quand m\u00eame simple et lin\u00e9aire. Pour g\u00e9rer ces donn\u00e9es, je peux : les \u00e9crire \u00e0 la main dans mon agenda, cr\u00e9er un feuille de tableur avec Excel ou LibreOffice, utiliser une liste dans un IDE Python,... Chaque m\u00e9thode aura ses avantages et ses inconv\u00e9nients. Si le nombre de donn\u00e9es \u00e0 stocker devient tr\u00e8s grand, est-ce que ma solution choisie pourra les g\u00e9rer ? (on peut par exemple m\u00e9diter sur le cas du Royaume-Uni dont le comptage des patients positifs au Covid est devenu faux car il a d\u00e9pass\u00e9 les limites de leur feuille Excel ) Est-ce que d'autres personnes que moi sont susceptibles de consulter ou modifier ces donn\u00e9es, \u00e9ventuellement en m\u00eame temps que moi ? Si une donn\u00e9e se retrouve \u00e0 plusieurs endroits dans mes donn\u00e9es, devrais-je aller modifier cette donn\u00e9e partout o\u00f9 elle se trouve ou bien une seule fois ? L'\u00e9tude des Bases de Donn\u00e9es tente d'apporter des r\u00e9ponses \u00e0 toutes ces questions. 1. Le mod\u00e8le relationnel \u2693\ufe0e Le programme de Terminale NSI pr\u00e9voit uniquement l'\u00e9tude du mod\u00e8le relationnel . Th\u00e9oris\u00e9 en 1970 par le Britannique Edgard J. Codd, le mod\u00e8le relationnel est \u00e0 ce jour le mod\u00e8le de base de donn\u00e9es le plus utilis\u00e9, m\u00eame si l'\u00e8re actuelle du Big Data tend \u00e0 mettre en avant d'autres mod\u00e8les non relationnels (nous en reparlerons). Les principes de base du mod\u00e8le relationnel Les donn\u00e9es sont regroup\u00e9es dans diff\u00e9rentes tables (qu'on appellera plut\u00f4t relations et qui donnent son nom au mod\u00e8le). Chaque relation contient des \u00e9l\u00e9ments directement en lien avec le sujet g\u00e9n\u00e9ral de la table. Autant que possible, des donn\u00e9es identiques ne doivent pas se trouver dans des tables diff\u00e9rentes : on \u00e9vite la redondance des donn\u00e9es. Les donn\u00e9es ne doivent pas contenir elles-m\u00eames d'autres donn\u00e9es : on parle d' atomicit\u00e9 des donn\u00e9es. Un mod\u00e8le relationnel est donc bas\u00e9 sur des... relations . 2. Premi\u00e8re relation \u2693\ufe0e Prenons l'exemple d'une biblioth\u00e8que dont la base de donn\u00e9es poss\u00e8de une relation \u00ablivres\u00bb : Vocabulaire relation , ou table : c'est l'endroit o\u00f9 sont rang\u00e9es les donn\u00e9es. L'ordre des lignes (que l'on appelera des enregistrements) n'a pas d'importance. enregistrement , ou tuple , ou n-uplet , ou t-uplet , ou vecteur : cela correspond \u00e0 une ligne du tableau, et donc un ensemble de valeurs li\u00e9es entre elles : l'auteur \u00abEric VUILLARD\u00bb a bien \u00e9crit le livre \u00abL'Ordre du jour\u00bb. Il est interdit que deux enregistrements soient totalement identiques. Le nombre d'enregistrements d'une relation s'appelle son cardinal . attribut : c'est l'\u00e9quivalent d'une colonne. Il y a dans notre relation un attribut \u00abcode\u00bb, un attribut \u00abTitre\u00bb, etc. domaine : le domaine d\u00e9signe \u00able type\u00bb (au sens type Int , Float , String ). L'attribut \u00ab\u00c9diteur\u00bb est une cha\u00eene de caract\u00e8res, son domaine est donc String . Par contre l'attribut \u00abISBN\u00bb est un nombre de 13 chiffres, commen\u00e7ant manifestement par 978. Son domaine est donc Int . sch\u00e9ma : le sch\u00e9ma d'une relation est le regroupement de tous les attributs et de leur domaine respectif. Ici notre sch\u00e9ma serait : ((Code, Entier), (Titre, Cha\u00eene de caract\u00e8res), (Auteur, Cha\u00eene de caract\u00e8res), (\u00c9diteur, Cha\u00eene de caract\u00e8res), (ISBN, Entier)) 3. Cl\u00e9 Primaire \u2693\ufe0e Cl\u00e9 primaire Une cl\u00e9 primaire est un attribut (ou une r\u00e9union d'attributs) dont la connaissance suffit \u00e0 identifier avec certitude un unique enregistrement . Par exemple, la cl\u00e9 primaire de la relation des personnes n\u00e9es en France pourrait \u00eatre leur num\u00e9ro de S\u00e9curit\u00e9 Sociale . Observons, dans notre relation pr\u00e9c\u00e9dente, ce qui peut \u00eatre une cl\u00e9 primaire et ce qui ne peut pas l'\u00eatre. Titre : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame titre. Auteur : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame auteur. \u00c9diteur : cet attribut ne peut pas jouer le r\u00f4le de cl\u00e9 primaire. En effet, la donn\u00e9e de l'attribut \u00abActes Sud\u00bb renvoie vers 4 livres diff\u00e9rents. ISBN : (International Standard Book Number) cet attribut est un num\u00e9ro unique sp\u00e9cifique \u00e0 chaque livre : il peut jouer le r\u00f4le de cl\u00e9 primaire. Code : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame code. Alors, quelle cl\u00e9 primaire choisir ? Il faut pour cela r\u00e9fl\u00e9chir \u00e0 ce que deviendrait notre relation si elle contenait 1000 livres au lieu de 10. Il est fort probable que deux livres aient alors le m\u00eame auteur : l'attribut \u00abAuteur\u00bb ne serait donc plus une cl\u00e9 primaire. Il peut arriver aussi que deux livres aient le m\u00eame titre : l'attribut \u00abTitre\u00bb n'est donc pas une bonne cl\u00e9 primaire. Par d\u00e9finition, l'attribut \u00abISBN\u00bb pourrait jouer le r\u00f4le de cl\u00e9 primaire. Quant \u00e0 l'attribut \u00abCode\u00bb, il s'agit sans doute d'une nomenclature \u00abmaison\u00bb correspondant \u00e0 une \u00e9tiquette coll\u00e9e sur la tranche des livres : c'est donc une cl\u00e9 primaire qu'on qualifiera d'\u00abartificielle\u00bb. Attention Il ne peut pas y avoir deux cl\u00e9s primaires dans une table. La cl\u00e9 primaire choisie ici serait sans aucun doute l'attribut \u00abCode\u00bb. 4. D'autres relations \u2693\ufe0e Ajoutons maintenant les relations ci-dessous : Relation \u00abEmprunts\u00bb id_emprunteur date Nom Pr\u00e9nom titre auteur code 845 12/10/2020 DURAND Michel Au revoir l\u00e0-haut Pierre LEMAITRE 942 125 13/10/2020 MARTIN Jean Pas pleurer Lydie SALVAYRE 1023 125 13/10/2020 MARTIN Jean Boussole Mathias ENARD 486 Relation \u00abEmprunteurs\u00bb id_emprunteur Nom Pr\u00e9nom 129 DULAC Marcel 845 DURAND Michel 125 MARTIN Jean L'attribut \u00abid_emprunteur\u00bb est une cl\u00e9 primaire de la relation \u00abEmprunteurs\u00bb. Notion de cl\u00e9 \u00e9trang\u00e8re Y-a-t-il une cl\u00e9 primaire dans la relation \u00abEmprunts\u00bb ? \u00abid_emprunteur\u00bb est bien une cl\u00e9 primaire (d'\u00abEmprunteurs\u00bb) mais ne peut pas \u00eatre une cl\u00e9 primaire d'\u00abEmprunts\u00bb, car une personne peut prendre plusieurs livres \u00e0 la fois : on dit que c'est une cl\u00e9 \u00e9trang\u00e8re . Cl\u00e9 \u00e9trang\u00e8re Une cl\u00e9 \u00e9trang\u00e8re est une cl\u00e9 primaire d'une autre relation. \u00abcode\u00bb est aussi une cl\u00e9 \u00e9trang\u00e8re : c'est une cl\u00e9 primaire (de la relation \u00ablivres\u00bb) mais elle ne peut pas jouer le r\u00f4le de cl\u00e9 primaire pour la relation emprunt, car un m\u00eame livre pourra \u00eatre pris \u00e0 diff\u00e9rentes dates. Une cl\u00e9 primaire pourrait alors \u00eatre la combinaison (\u00abdate\u00bb, \u00abcode\u00bb). En effet, aucun livre ne pouvant \u00eatre emprunt\u00e9 deux fois le m\u00eame jour, la connaissance de \u00abdate\u00bb et \u00abcode\u00bb suffit \u00e0 identifier n'importe quel enregistrement. 5. Redondance des donn\u00e9es \u2693\ufe0e La relation \u00abEmprunts\u00bb contient des informations qui sont d\u00e9j\u00e0 disponibles dans d'autres relations : on dit qu'elle est redondante , et c'est quelque chose qu'il faut \u00e9viter. \u00c0 la fois pour des raisons d'espace de stockage mais aussi de coh\u00e9rence : si une modification doit \u00eatre faite (un emprunteur change de pr\u00e9nom), cette modification ne doit \u00eatre faite qu'\u00e0 un seul endroit de notre base de donn\u00e9es. Une version non-redondante de la relation \u00abEmprunteurs\u00bb serait donc celle-ci : Relation \u00abEmprunts\u00bb id_emprunteur date code 845 12/10/2020 942 125 13/10/2020 1023 125 13/10/2020 486 6. Les 3 contraintes d'int\u00e9grit\u00e9 \u2693\ufe0e Contrainte de domaine Tout attribut d'un enregistrement doit respecter le domaine indiqu\u00e9 dans le sch\u00e9ma relationnel. Attention, certains domaines sont subtils. Par exemple, si une relation poss\u00e8de un attribut \"Code Postal\", le domaine de cet attribut devra \u00eatre String plut\u00f4t que Entier . Dans le cas contraire, un enregistrement poss\u00e9dant le code postal 03150 serait converti en 3150 (car pour les entiers, 03150 = 3150). Or le code postal 3150 n'existe pas. Contrainte de relation Tout enregistrement est unique. Cette contrainte est assur\u00e9e par l'existence obligatoire d'une cl\u00e9 primaire. Cette cl\u00e9 primaire est souvent cr\u00e9\u00e9e de mani\u00e8re artificielle (voir id_emprunteurs dans la table ci-dessus par exemple). Contrainte de r\u00e9f\u00e9rence La coh\u00e9rence entre les diff\u00e9rentes tables d'une base de donn\u00e9es est assur\u00e9e par les cl\u00e9s \u00e9trang\u00e8res : dans une table, la valeur d'un attribut qui est cl\u00e9 \u00e9trang\u00e8re doit obligatoirement pouvoir \u00eatre retrouv\u00e9e dans la table dont cet attribut est cl\u00e9 primaire. Par exemple, la relation \u00abEmprunts_v2\u00bb ci-dessous n'est pas valable : Relation \u00abEmprunts_v2\u00bb id_emprunteur date code 845 12/10/2020 942 125 13/10/2020 1023 125 13/10/2020 511 En effet, le code 511 (cl\u00e9 \u00e9trang\u00e8re de ma table \u00abEmprunts_v2\u00bb) ne correspond \u00e0 aucun enregistrement dans la table dont il est cl\u00e9 primaire (la table \u00abLivres\u00bb) : Il n'y a pas de code 511, donc ma relation \u00abEmprunts_v2\u00bb ne respecte pas la contrainte de r\u00e9f\u00e9rence, et provoquerait une erreur du SGBD. 7. Repr\u00e9sentation usuelles des bases de donn\u00e9es en mod\u00e8le relationnel \u2693\ufe0e Consid\u00e9rons la base de donn\u00e9es Tour de France 2020, contenant les relations suivantes : (d'apr\u00e8s une id\u00e9e de Didier Boulle ) relation \u00c9quipes codeEquipe nomEquipe ALM AG2R La Mondiale AST Astana Pro Team TBM Bahrain - McLaren BOH BORA - hansgrohe CCC CCC Team COF Cofidis, Solutions Cr\u00e9dits DQT Deceuninck - Quick Step EF1 EF Pro Cycling GFC Groupama - FDJ LTS Lotto Soudal ... ... \u00c9criture classique d'un sch\u00e9ma relationnel Le sch\u00e9ma relationnel de cette table sera fr\u00e9quemment donn\u00e9 sous cette forme : Equipes ( codeEquipe String , nomEquipe String ) Notez le soulignement sous le mot \u00abcodeEquipe\u00bb, qui signifie que cet attribut est une cl\u00e9 primaire. Les cl\u00e9s \u00e9trang\u00e8res, lorsqu'elles existent, peuvent \u00eatre signal\u00e9es par une ast\u00e9risque * ou un di\u00e8se #. relation Coureurs dossard nomCoureur pr\u00e9nomCoureur codeEquipe 141 L\u00d3PEZ Miguel \u00c1ngel AST 142 FRAILE Omar AST 143 HOULE Hugo AST 11 ROGLI\u010c Primo\u017e TJV 12 BENNETT George TJV 41 ALAPHILIPPE Julian DQT 44 CAVAGNA R\u00e9mi DQT 45 DECLERCQ Tim DQT 121 MARTIN Guillaume COF 122 CONSONNI Simone COF 123 EDET Nicolas COF \u2026 \u2026 \u2026 \u2026 Sch\u00e9ma : Coureurs ( dossard Int , nomCoureur String , pr\u00e9nomCoureur String , codeEquipe* String ) relation \u00c9tapes num\u00e9roEtape villeD\u00e9part villeArriv\u00e9e km 1 Nice Nice 156 2 Nice Nice 185 3 Nice Sisteron 198 4 Sisteron Orci\u00e8res-Merlette 160 5 Gap Privas 198 ... ... ... ... Sch\u00e9ma : \u00c9tapes ( num\u00e9roEtape Int , villeD\u00e9part String , villeArriv\u00e9e String , km Int ) relation Temps dossard num\u00e9roEtape tempsR\u00e9alis\u00e9 41 2 04:55:27 121 4 04:07:47 11 5 04:21:22 122 5 04:21:22 41 4 04:08:24 ... ... ... Sch\u00e9ma : Temps ( dossard * Int , num\u00e9roEtape * Int , tempsR\u00e9alis\u00e9 String ) Remarquez que la cl\u00e9 primaire de cette relation est le couple dossard-num\u00e9roEtape. Diagramme relationnel Fr\u00e9quemment, on pr\u00e9sentera l'ensemble des renseignements d'un mod\u00e8le relationnel sous forme d'un diagramme qui synth\u00e9tise la composition des diff\u00e9rentes tables et les relations entre elles. Bibliographie \u2693\ufe0e Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. Cours d'Olivier L\u00e9cluse, https://lecluseo.frama.io/leclusemaths/nsi/NSI_T/bdd/modrel/ https://www.procyclingstats.com/", "title": "Cours"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#le-modele-relationnel", "text": "", "title": "Le mod\u00e8le relationnel"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#0-de-la-necessite-dorganiser-le-stockage-de-ses-donnees", "text": "Lorsqu'une grande quantit\u00e9 de donn\u00e9es doit \u00eatre g\u00e9r\u00e9e, il faut savoir distinguer deux choses : la structure qui va sous-tendre l'ensemble de ces donn\u00e9es, notamment les liens entre elles, les hi\u00e9rarchies \u00e9ventuelles,... le type de logiciel qui va aider \u00e0 g\u00e9rer ces donn\u00e9es. Par exemple, si je souhaite stocker toutes les temp\u00e9ratures relev\u00e9es dans mon jardin tous les matins \u00e0 07h00, je sais que mes donn\u00e9es seront des couples (date, temperature) . \u00c9ventuellement ces dates seront regroup\u00e9es par mois, ou par saison... mais la structure des donn\u00e9es sera quand m\u00eame simple et lin\u00e9aire. Pour g\u00e9rer ces donn\u00e9es, je peux : les \u00e9crire \u00e0 la main dans mon agenda, cr\u00e9er un feuille de tableur avec Excel ou LibreOffice, utiliser une liste dans un IDE Python,... Chaque m\u00e9thode aura ses avantages et ses inconv\u00e9nients. Si le nombre de donn\u00e9es \u00e0 stocker devient tr\u00e8s grand, est-ce que ma solution choisie pourra les g\u00e9rer ? (on peut par exemple m\u00e9diter sur le cas du Royaume-Uni dont le comptage des patients positifs au Covid est devenu faux car il a d\u00e9pass\u00e9 les limites de leur feuille Excel ) Est-ce que d'autres personnes que moi sont susceptibles de consulter ou modifier ces donn\u00e9es, \u00e9ventuellement en m\u00eame temps que moi ? Si une donn\u00e9e se retrouve \u00e0 plusieurs endroits dans mes donn\u00e9es, devrais-je aller modifier cette donn\u00e9e partout o\u00f9 elle se trouve ou bien une seule fois ? L'\u00e9tude des Bases de Donn\u00e9es tente d'apporter des r\u00e9ponses \u00e0 toutes ces questions.", "title": "0. De la n\u00e9cessit\u00e9 d'organiser le stockage de ses donn\u00e9es"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#1-le-modele-relationnel", "text": "Le programme de Terminale NSI pr\u00e9voit uniquement l'\u00e9tude du mod\u00e8le relationnel . Th\u00e9oris\u00e9 en 1970 par le Britannique Edgard J. Codd, le mod\u00e8le relationnel est \u00e0 ce jour le mod\u00e8le de base de donn\u00e9es le plus utilis\u00e9, m\u00eame si l'\u00e8re actuelle du Big Data tend \u00e0 mettre en avant d'autres mod\u00e8les non relationnels (nous en reparlerons). Les principes de base du mod\u00e8le relationnel Les donn\u00e9es sont regroup\u00e9es dans diff\u00e9rentes tables (qu'on appellera plut\u00f4t relations et qui donnent son nom au mod\u00e8le). Chaque relation contient des \u00e9l\u00e9ments directement en lien avec le sujet g\u00e9n\u00e9ral de la table. Autant que possible, des donn\u00e9es identiques ne doivent pas se trouver dans des tables diff\u00e9rentes : on \u00e9vite la redondance des donn\u00e9es. Les donn\u00e9es ne doivent pas contenir elles-m\u00eames d'autres donn\u00e9es : on parle d' atomicit\u00e9 des donn\u00e9es. Un mod\u00e8le relationnel est donc bas\u00e9 sur des... relations .", "title": "1. Le mod\u00e8le relationnel"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#2-premiere-relation", "text": "Prenons l'exemple d'une biblioth\u00e8que dont la base de donn\u00e9es poss\u00e8de une relation \u00ablivres\u00bb : Vocabulaire relation , ou table : c'est l'endroit o\u00f9 sont rang\u00e9es les donn\u00e9es. L'ordre des lignes (que l'on appelera des enregistrements) n'a pas d'importance. enregistrement , ou tuple , ou n-uplet , ou t-uplet , ou vecteur : cela correspond \u00e0 une ligne du tableau, et donc un ensemble de valeurs li\u00e9es entre elles : l'auteur \u00abEric VUILLARD\u00bb a bien \u00e9crit le livre \u00abL'Ordre du jour\u00bb. Il est interdit que deux enregistrements soient totalement identiques. Le nombre d'enregistrements d'une relation s'appelle son cardinal . attribut : c'est l'\u00e9quivalent d'une colonne. Il y a dans notre relation un attribut \u00abcode\u00bb, un attribut \u00abTitre\u00bb, etc. domaine : le domaine d\u00e9signe \u00able type\u00bb (au sens type Int , Float , String ). L'attribut \u00ab\u00c9diteur\u00bb est une cha\u00eene de caract\u00e8res, son domaine est donc String . Par contre l'attribut \u00abISBN\u00bb est un nombre de 13 chiffres, commen\u00e7ant manifestement par 978. Son domaine est donc Int . sch\u00e9ma : le sch\u00e9ma d'une relation est le regroupement de tous les attributs et de leur domaine respectif. Ici notre sch\u00e9ma serait : ((Code, Entier), (Titre, Cha\u00eene de caract\u00e8res), (Auteur, Cha\u00eene de caract\u00e8res), (\u00c9diteur, Cha\u00eene de caract\u00e8res), (ISBN, Entier))", "title": "2. Premi\u00e8re relation"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#3-cle-primaire", "text": "Cl\u00e9 primaire Une cl\u00e9 primaire est un attribut (ou une r\u00e9union d'attributs) dont la connaissance suffit \u00e0 identifier avec certitude un unique enregistrement . Par exemple, la cl\u00e9 primaire de la relation des personnes n\u00e9es en France pourrait \u00eatre leur num\u00e9ro de S\u00e9curit\u00e9 Sociale . Observons, dans notre relation pr\u00e9c\u00e9dente, ce qui peut \u00eatre une cl\u00e9 primaire et ce qui ne peut pas l'\u00eatre. Titre : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame titre. Auteur : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame auteur. \u00c9diteur : cet attribut ne peut pas jouer le r\u00f4le de cl\u00e9 primaire. En effet, la donn\u00e9e de l'attribut \u00abActes Sud\u00bb renvoie vers 4 livres diff\u00e9rents. ISBN : (International Standard Book Number) cet attribut est un num\u00e9ro unique sp\u00e9cifique \u00e0 chaque livre : il peut jouer le r\u00f4le de cl\u00e9 primaire. Code : cet attribut pourrait jouer le r\u00f4le de cl\u00e9 primaire. En effet, notre table ne contient pas deux livres ayant le m\u00eame code. Alors, quelle cl\u00e9 primaire choisir ? Il faut pour cela r\u00e9fl\u00e9chir \u00e0 ce que deviendrait notre relation si elle contenait 1000 livres au lieu de 10. Il est fort probable que deux livres aient alors le m\u00eame auteur : l'attribut \u00abAuteur\u00bb ne serait donc plus une cl\u00e9 primaire. Il peut arriver aussi que deux livres aient le m\u00eame titre : l'attribut \u00abTitre\u00bb n'est donc pas une bonne cl\u00e9 primaire. Par d\u00e9finition, l'attribut \u00abISBN\u00bb pourrait jouer le r\u00f4le de cl\u00e9 primaire. Quant \u00e0 l'attribut \u00abCode\u00bb, il s'agit sans doute d'une nomenclature \u00abmaison\u00bb correspondant \u00e0 une \u00e9tiquette coll\u00e9e sur la tranche des livres : c'est donc une cl\u00e9 primaire qu'on qualifiera d'\u00abartificielle\u00bb. Attention Il ne peut pas y avoir deux cl\u00e9s primaires dans une table. La cl\u00e9 primaire choisie ici serait sans aucun doute l'attribut \u00abCode\u00bb.", "title": "3. Cl\u00e9 Primaire"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#4-dautres-relations", "text": "Ajoutons maintenant les relations ci-dessous : Relation \u00abEmprunts\u00bb id_emprunteur date Nom Pr\u00e9nom titre auteur code 845 12/10/2020 DURAND Michel Au revoir l\u00e0-haut Pierre LEMAITRE 942 125 13/10/2020 MARTIN Jean Pas pleurer Lydie SALVAYRE 1023 125 13/10/2020 MARTIN Jean Boussole Mathias ENARD 486 Relation \u00abEmprunteurs\u00bb id_emprunteur Nom Pr\u00e9nom 129 DULAC Marcel 845 DURAND Michel 125 MARTIN Jean L'attribut \u00abid_emprunteur\u00bb est une cl\u00e9 primaire de la relation \u00abEmprunteurs\u00bb. Notion de cl\u00e9 \u00e9trang\u00e8re Y-a-t-il une cl\u00e9 primaire dans la relation \u00abEmprunts\u00bb ? \u00abid_emprunteur\u00bb est bien une cl\u00e9 primaire (d'\u00abEmprunteurs\u00bb) mais ne peut pas \u00eatre une cl\u00e9 primaire d'\u00abEmprunts\u00bb, car une personne peut prendre plusieurs livres \u00e0 la fois : on dit que c'est une cl\u00e9 \u00e9trang\u00e8re . Cl\u00e9 \u00e9trang\u00e8re Une cl\u00e9 \u00e9trang\u00e8re est une cl\u00e9 primaire d'une autre relation. \u00abcode\u00bb est aussi une cl\u00e9 \u00e9trang\u00e8re : c'est une cl\u00e9 primaire (de la relation \u00ablivres\u00bb) mais elle ne peut pas jouer le r\u00f4le de cl\u00e9 primaire pour la relation emprunt, car un m\u00eame livre pourra \u00eatre pris \u00e0 diff\u00e9rentes dates. Une cl\u00e9 primaire pourrait alors \u00eatre la combinaison (\u00abdate\u00bb, \u00abcode\u00bb). En effet, aucun livre ne pouvant \u00eatre emprunt\u00e9 deux fois le m\u00eame jour, la connaissance de \u00abdate\u00bb et \u00abcode\u00bb suffit \u00e0 identifier n'importe quel enregistrement.", "title": "4. D'autres relations"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#5-redondance-des-donnees", "text": "La relation \u00abEmprunts\u00bb contient des informations qui sont d\u00e9j\u00e0 disponibles dans d'autres relations : on dit qu'elle est redondante , et c'est quelque chose qu'il faut \u00e9viter. \u00c0 la fois pour des raisons d'espace de stockage mais aussi de coh\u00e9rence : si une modification doit \u00eatre faite (un emprunteur change de pr\u00e9nom), cette modification ne doit \u00eatre faite qu'\u00e0 un seul endroit de notre base de donn\u00e9es. Une version non-redondante de la relation \u00abEmprunteurs\u00bb serait donc celle-ci : Relation \u00abEmprunts\u00bb id_emprunteur date code 845 12/10/2020 942 125 13/10/2020 1023 125 13/10/2020 486", "title": "5. Redondance des donn\u00e9es"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#6-les-3-contraintes-dintegrite", "text": "Contrainte de domaine Tout attribut d'un enregistrement doit respecter le domaine indiqu\u00e9 dans le sch\u00e9ma relationnel. Attention, certains domaines sont subtils. Par exemple, si une relation poss\u00e8de un attribut \"Code Postal\", le domaine de cet attribut devra \u00eatre String plut\u00f4t que Entier . Dans le cas contraire, un enregistrement poss\u00e9dant le code postal 03150 serait converti en 3150 (car pour les entiers, 03150 = 3150). Or le code postal 3150 n'existe pas. Contrainte de relation Tout enregistrement est unique. Cette contrainte est assur\u00e9e par l'existence obligatoire d'une cl\u00e9 primaire. Cette cl\u00e9 primaire est souvent cr\u00e9\u00e9e de mani\u00e8re artificielle (voir id_emprunteurs dans la table ci-dessus par exemple). Contrainte de r\u00e9f\u00e9rence La coh\u00e9rence entre les diff\u00e9rentes tables d'une base de donn\u00e9es est assur\u00e9e par les cl\u00e9s \u00e9trang\u00e8res : dans une table, la valeur d'un attribut qui est cl\u00e9 \u00e9trang\u00e8re doit obligatoirement pouvoir \u00eatre retrouv\u00e9e dans la table dont cet attribut est cl\u00e9 primaire. Par exemple, la relation \u00abEmprunts_v2\u00bb ci-dessous n'est pas valable : Relation \u00abEmprunts_v2\u00bb id_emprunteur date code 845 12/10/2020 942 125 13/10/2020 1023 125 13/10/2020 511 En effet, le code 511 (cl\u00e9 \u00e9trang\u00e8re de ma table \u00abEmprunts_v2\u00bb) ne correspond \u00e0 aucun enregistrement dans la table dont il est cl\u00e9 primaire (la table \u00abLivres\u00bb) : Il n'y a pas de code 511, donc ma relation \u00abEmprunts_v2\u00bb ne respecte pas la contrainte de r\u00e9f\u00e9rence, et provoquerait une erreur du SGBD.", "title": "6. Les 3 contraintes d'int\u00e9grit\u00e9"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#7-representation-usuelles-des-bases-de-donnees-en-modele-relationnel", "text": "Consid\u00e9rons la base de donn\u00e9es Tour de France 2020, contenant les relations suivantes : (d'apr\u00e8s une id\u00e9e de Didier Boulle ) relation \u00c9quipes codeEquipe nomEquipe ALM AG2R La Mondiale AST Astana Pro Team TBM Bahrain - McLaren BOH BORA - hansgrohe CCC CCC Team COF Cofidis, Solutions Cr\u00e9dits DQT Deceuninck - Quick Step EF1 EF Pro Cycling GFC Groupama - FDJ LTS Lotto Soudal ... ... \u00c9criture classique d'un sch\u00e9ma relationnel Le sch\u00e9ma relationnel de cette table sera fr\u00e9quemment donn\u00e9 sous cette forme : Equipes ( codeEquipe String , nomEquipe String ) Notez le soulignement sous le mot \u00abcodeEquipe\u00bb, qui signifie que cet attribut est une cl\u00e9 primaire. Les cl\u00e9s \u00e9trang\u00e8res, lorsqu'elles existent, peuvent \u00eatre signal\u00e9es par une ast\u00e9risque * ou un di\u00e8se #. relation Coureurs dossard nomCoureur pr\u00e9nomCoureur codeEquipe 141 L\u00d3PEZ Miguel \u00c1ngel AST 142 FRAILE Omar AST 143 HOULE Hugo AST 11 ROGLI\u010c Primo\u017e TJV 12 BENNETT George TJV 41 ALAPHILIPPE Julian DQT 44 CAVAGNA R\u00e9mi DQT 45 DECLERCQ Tim DQT 121 MARTIN Guillaume COF 122 CONSONNI Simone COF 123 EDET Nicolas COF \u2026 \u2026 \u2026 \u2026 Sch\u00e9ma : Coureurs ( dossard Int , nomCoureur String , pr\u00e9nomCoureur String , codeEquipe* String ) relation \u00c9tapes num\u00e9roEtape villeD\u00e9part villeArriv\u00e9e km 1 Nice Nice 156 2 Nice Nice 185 3 Nice Sisteron 198 4 Sisteron Orci\u00e8res-Merlette 160 5 Gap Privas 198 ... ... ... ... Sch\u00e9ma : \u00c9tapes ( num\u00e9roEtape Int , villeD\u00e9part String , villeArriv\u00e9e String , km Int ) relation Temps dossard num\u00e9roEtape tempsR\u00e9alis\u00e9 41 2 04:55:27 121 4 04:07:47 11 5 04:21:22 122 5 04:21:22 41 4 04:08:24 ... ... ... Sch\u00e9ma : Temps ( dossard * Int , num\u00e9roEtape * Int , tempsR\u00e9alis\u00e9 String ) Remarquez que la cl\u00e9 primaire de cette relation est le couple dossard-num\u00e9roEtape. Diagramme relationnel Fr\u00e9quemment, on pr\u00e9sentera l'ensemble des renseignements d'un mod\u00e8le relationnel sous forme d'un diagramme qui synth\u00e9tise la composition des diff\u00e9rentes tables et les relations entre elles.", "title": "7. Repr\u00e9sentation usuelles des bases de donn\u00e9es en mod\u00e8le relationnel"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/cours/#bibliographie", "text": "Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. Cours d'Olivier L\u00e9cluse, https://lecluseo.frama.io/leclusemaths/nsi/NSI_T/bdd/modrel/ https://www.procyclingstats.com/", "title": "Bibliographie"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/exercices/", "text": "Exercices sur le mod\u00e8le relationnel \u2693\ufe0e Exercice 1 \u2693\ufe0e (d'apr\u00e8s Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.) Deux relations mod\u00e9lisent la flotte de voitures d'un r\u00e9seau de location de voitures. Agences id_agence ville d\u00e9partement 1 Paris 75 2 Lyon 69 3 Marseille 13 4 Aubagne 13 Voitures id_voiture marque mod\u00e8le kilom\u00e9trage couleur id_agence 1 Renault Clio 12000 Rouge 2 2 Peugeot 205 22000 Noir 3 3 Toyota Yaris 33000 Noir 3 Questions \u00c9nonc\u00e9 Correction Combien la relation Voitures comporte-t-elle d'attributs ? Que vaut son cardinal ? Quel est le domaine de l'attribut ig_agence dans la relation Voitures ? Quel est le sch\u00e9ma relationnel de la relation Agences ? Quelle est la cl\u00e9 primaire de la relation Agences ? Quelle est la cl\u00e9 primaire de la relation Voitures ? Quelle est la cl\u00e9 \u00e9trang\u00e8re de la relation Voitures ? Exercice 2 \u2693\ufe0e Reprenons la base Tour de France 2020 vue en cours : relation \u00c9quipes codeEquipe nomEquipe ALM AG2R La Mondiale AST Astana Pro Team TBM Bahrain - McLaren BOH BORA - hansgrohe CCC CCC Team COF Cofidis, Solutions Cr\u00e9dits DQT Deceuninck - Quick Step EF1 EF Pro Cycling GFC Groupama - FDJ LTS Lotto Soudal ... ... relation Coureurs dossard nomCoureur pr\u00e9nomCoureur codeEquipe 141 L\u00d3PEZ Miguel \u00c1ngel AST 142 FRAILE Omar AST 143 HOULE Hugo AST 11 ROGLI\u010c Primo\u017e TJV 12 BENNETT George TJV 41 ALAPHILIPPE Julian DQT 44 CAVAGNA R\u00e9mi DQT 45 DECLERCQ Tim DQT 121 MARTIN Guillaume COF 122 CONSONNI Simone COF 123 EDET Nicolas COF \u2026 \u2026 \u2026 \u2026 relation \u00c9tapes num\u00e9roEtape villeD\u00e9part villeArriv\u00e9e km 1 Nice Nice 156 2 Nice Nice 185 3 Nice Sisteron 198 4 Sisteron Orci\u00e8res-Merlette 160 5 Gap Privas 198 ... ... ... ... relation Temps dossard num\u00e9roEtape tempsR\u00e9alis\u00e9 41 2 04:55:27 121 4 04:07:47 11 5 04:21:22 122 5 04:21:22 ... ... ... Questions \u00c9nonc\u00e9 Correction Quel temps a r\u00e9alis\u00e9 Guillaume MARTIN sur l'\u00e9tape Sisteron / Orci\u00e8res-Merlette ? \u00c0 l'arriv\u00e9e \u00e0 Privas, qui est arriv\u00e9 en premier entre Primo\u017e ROGLI\u010c et Simone CONSONNI ?", "title": "Exercices"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/exercices/#exercices-sur-le-modele-relationnel", "text": "", "title": "Exercices sur le mod\u00e8le relationnel"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/exercices/#exercice-1", "text": "(d'apr\u00e8s Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.) Deux relations mod\u00e9lisent la flotte de voitures d'un r\u00e9seau de location de voitures. Agences id_agence ville d\u00e9partement 1 Paris 75 2 Lyon 69 3 Marseille 13 4 Aubagne 13 Voitures id_voiture marque mod\u00e8le kilom\u00e9trage couleur id_agence 1 Renault Clio 12000 Rouge 2 2 Peugeot 205 22000 Noir 3 3 Toyota Yaris 33000 Noir 3 Questions \u00c9nonc\u00e9 Correction Combien la relation Voitures comporte-t-elle d'attributs ? Que vaut son cardinal ? Quel est le domaine de l'attribut ig_agence dans la relation Voitures ? Quel est le sch\u00e9ma relationnel de la relation Agences ? Quelle est la cl\u00e9 primaire de la relation Agences ? Quelle est la cl\u00e9 primaire de la relation Voitures ? Quelle est la cl\u00e9 \u00e9trang\u00e8re de la relation Voitures ?", "title": "Exercice 1"}, {"location": "T4_Bases_de_donnees/4.1_Modele_relationnel/exercices/#exercice-2", "text": "Reprenons la base Tour de France 2020 vue en cours : relation \u00c9quipes codeEquipe nomEquipe ALM AG2R La Mondiale AST Astana Pro Team TBM Bahrain - McLaren BOH BORA - hansgrohe CCC CCC Team COF Cofidis, Solutions Cr\u00e9dits DQT Deceuninck - Quick Step EF1 EF Pro Cycling GFC Groupama - FDJ LTS Lotto Soudal ... ... relation Coureurs dossard nomCoureur pr\u00e9nomCoureur codeEquipe 141 L\u00d3PEZ Miguel \u00c1ngel AST 142 FRAILE Omar AST 143 HOULE Hugo AST 11 ROGLI\u010c Primo\u017e TJV 12 BENNETT George TJV 41 ALAPHILIPPE Julian DQT 44 CAVAGNA R\u00e9mi DQT 45 DECLERCQ Tim DQT 121 MARTIN Guillaume COF 122 CONSONNI Simone COF 123 EDET Nicolas COF \u2026 \u2026 \u2026 \u2026 relation \u00c9tapes num\u00e9roEtape villeD\u00e9part villeArriv\u00e9e km 1 Nice Nice 156 2 Nice Nice 185 3 Nice Sisteron 198 4 Sisteron Orci\u00e8res-Merlette 160 5 Gap Privas 198 ... ... ... ... relation Temps dossard num\u00e9roEtape tempsR\u00e9alis\u00e9 41 2 04:55:27 121 4 04:07:47 11 5 04:21:22 122 5 04:21:22 ... ... ... Questions \u00c9nonc\u00e9 Correction Quel temps a r\u00e9alis\u00e9 Guillaume MARTIN sur l'\u00e9tape Sisteron / Orci\u00e8res-Merlette ? \u00c0 l'arriv\u00e9e \u00e0 Privas, qui est arriv\u00e9 en premier entre Primo\u017e ROGLI\u010c et Simone CONSONNI ?", "title": "Exercice 2"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices_ecrit/", "text": "Exercices SQL d\u00e9branch\u00e9s \u2693\ufe0e Exercice 1 (d'apr\u00e8s Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.) On veut cr\u00e9er une base de donn\u00e9es baseHopital.db qui contiendra les trois tables suivantes : Patients id Int nom Text prenom Text genre Text annee_naissance Int Ordonnances code Int id_patient Int matricule_medecin Int date_ord Text medicaments Text Medecins matricule Int nom_prenom Text specialite Text telephone Text On suppose que les dates sont donn\u00e9es sous la forme jj-mm-aaaa . On donne le diagramme relationnel de cette base : Q0. \u00c9crire le sch\u00e9ma relationnel de la table Ordonnances. On soulignera les cl\u00e9s primaires et marquera d'un # les cl\u00e9s \u00e9trang\u00e8res. Correction Ordonnaces (( code , Int), (id_patient#, Int), (matricule_medecin#, Int), (date_ord, Text), (medicaments, Text)) Q1. (HP) Donner les commandes SQL permettant de cr\u00e9er ces tables. Correction SQL CREATE TABLE Patients ( id INTEGER PRIMARY KEY , nom TEXT , prenom TEXT , genre TEXT , annee_naissance INTEGER ); CREATE TABLE Ordonnances ( code INTEGER PRIMARY KEY , id_patient INTEGER , matricule_medecin INTEGER , date_ord TEXT , medicaments TEXT , FOREIGN KEY ( id_patient ) REFERENCES Patients ( Id ), FOREIGN KEY ( matricule_medecin ) REFERENCES Medecins ( matricule ) ); CREATE TABLE Medecins ( matricule INTEGER PRIMARY KEY , nom_prenom TEXT , specialite TEXT , telephone TEXT ); Q2. Mme Anne Wizeunid, n\u00e9e en 2000 et demeurant 3 rue des Pignons Verts 12345 Avonelit doit \u00eatre enregistr\u00e9e comme patiente num\u00e9ro 1. Donner la commande SQLite correspondante. Correction SQL INSERT INTO Patients VALUES ( 1 , \"Wizeunit\" , \"Anne\" , \"F\" , 2000 ); Q3. Le patient num\u00e9ro 100 a chang\u00e9 de pr\u00e9nom et s'appelle maintenant \"Alice\". Donner la commande SQLite modifiant en cons\u00e9quence ses donn\u00e9es. Correction SQL UPDATE Patients SET prenom = 'Alice' WHERE id = 100 ; Q4. Par souci d'\u00e9conomie, la direction d\u00e9cide de se passer des m\u00e9decins sp\u00e9cialis\u00e9s en \u00e9pid\u00e9miologie. Donner la commande permettant de supprimer leurs fiches. Correction SQL DELETE FROM Medecins WHERE specialite = \"\u00e9pid\u00e9miologie\" ; Q5. Donner la liste des patient(e)s ayant \u00e9t\u00e9 examin\u00e9(e)s par un(e) psychiatre en avril 2020. Correction SQL SELECT p . nom , p . prenom FROM Patients AS p JOIN Ordonnances AS o ON p . id = o . id_patient JOIN Medecins AS m ON o . matricule_medecin = m . matricule WHERE m . specialite = \"psychiatrie\" AND o . date_ord LIKE \"%04-2020%\" Exercice 2 bas\u00e9 sur le travail de G.Viateau (Bayonne) On consid\u00e8re ci-dessous le sch\u00e9ma de la base de donn\u00e9es du stock d'un supermarch\u00e9 : Q1 . Quelle requ\u00eate SQL donne le prix d'achat du produit dont le nom_court est \u00abLiq_Vaiss_1L\u00bb ? Correction SQL SELECT prix_achat FROM Produits WHERE nom_court = 'Liq_Vaiss_1L' Q2 . Quelle requ\u00eate donne l'adresse, le code postal et la ville du fournisseur dont le nom est \u00abAvenir_confiseur\u00bb ? Correction SQL SELECT adresse , cp , ville FROM Fournisseurs WHERE nom = 'Avenir_confiseur' ; Q3 . Quelle requ\u00eate donne les produits \u00e9tant en rupture de stock ? Correction SQL SELECT Produits . nom FROM Produits JOIN Stocks ON Produits . id = Stocks . produit WHERE Stocks . quantite = 0 ; Q4 . Quelle requ\u00eate donne la liste de toutes les ampoules vendues en magasin ? On pourra faire l'hypoth\u00e8se que le nom du produit contient le mot \u00abampoule\u00bb Correction SQL SELECT nom FROM Produits WHERE nom LIKE \"%ampoule%\" ; Q5 . Quelle requ\u00eate permet d'avoir le prix moyen de ces ampoules ? Correction SQL SELECT AVG ( prix_vente ) FROM Produits WHERE nom LIKE \"%ampoule%\" ; Q6 . Quelle requ\u00eate permet d'identifier le produit le plus cher du magasin ? Correction SQL SELECT nom_court FROM Produits ORDER BY prix_vente DESC LIMIT 1 ; ou SQL SELECT nom FROM Produits WHERE prix_vente = ( SELECT MAX ( prix_vente ) FROM Produits ); Q7 . Quelle requ\u00eate renvoie les noms des produits dont la date de p\u00e9remption est d\u00e9pass\u00e9e ? (on pourra utiliser la fonction SQL NOW() qui renvoie la date actuelle ) Correction SQL SELECT p . nom FROM Produits AS p JOIN Stocks AS s ON s . produits = p . id WHERE s . date_peremption < NOW (); Exercice 3 Exercice 1 du sujet Am\u00e9rique du Sud J1 2022 Correction Correction Q1.a. La relation Sport a pour cl\u00e9 primaire le couple NomSport et nomStation, et pour cl\u00e9 \u00e9trang\u00e8re l'attribut nomStation, cl\u00e9 primaire de la relation Station. Correction Q1.b. Contrainte d'int\u00e9grit\u00e9 de domaine : l'attribut Prix doit \u00eatre un nombre entier. Contrainte d'int\u00e9grit\u00e9 de relation : le couple (nomSport, nomStation) ne peut pas se retrouver deux fois dans la table (car il forme une cl\u00e9 primaire) Contrainte d'int\u00e9grit\u00e9 de r\u00e9f\u00e9rence : l'attribut nomStation ne peut pas \u00eatre un nom n'apparaissant pas dans la relation Station. Correction Q2.a. La commande INSERT ne sert que pour ins\u00e9rer de nouveaux enregistrements, or le couple (\"planche \u00e0 voile\" , \"La tramontane catalane\") existe d\u00e9j\u00e0 dans la relation (et c'est une cl\u00e9 primaire donc on ne peut pas la retrouver deux fois). Il faut donc utiliser : SQL UPDATE Sports SET prix = 1350 WHERE nomSport = \"planche \u00e0 voile\" AND nomStation = \"La tramontane catalane\" Correction Q2.b. SQL INSERT INTO Station VALUES ( \"Soleil Rouge\" , \"Bastia\" , \"Corse\" ) INSERT INTO Sport VALUES ( \"plong\u00e9e\" , \"Soleil Rouge\" , 900 ) Correction Q3.a. SQL SELECT mail FROM Client Correction Q3.b. SQL SELECT nomStation FROM Sport WHERE nomSport = \"plongee\" Correction Q4.a. SQL SELECT Station . ville , Station . nomStation FROM Station JOIN Sport ON Sport . nomStation = Station . nomStation WHERE Sport . nomSport = \"plongee\" Correction Q4.b. SQL SELECT COUNT ( * ) FROM Sejour JOIN Station ON Station . nomStation = Sejour . nomStation WHERE Sejour . annee = 2020 AND Station . region = \"Corse\" Exercice 4 Exercice 4 du sujet Centres \u00c9trangers J1 2022 Correction Correction Q1.a. L'attribut id_mesure semble une cl\u00e9 primaire acceptable car elle semble sp\u00e9cifique \u00e0 chaque enregistrement. Correction Q1.b. L'attribut id_centres semble \u00eatre une cl\u00e9 primaire de la relation Centres . On le retrouve aussi (sous le m\u00eame nom) dans la relation Mesures . C'est donc un attribut qui permettra de faire une jointure entre les deux relations. Correction Q2.a. Cette requ\u00eate va afficher tous les renseignements disponibles sur les centres dont l'altitude est strictement sup\u00e9rieure \u00e0 500m. Correction Q2.b. SQL SELECT nom_ville FROM Centres WHERE altitude >= 700 AND altitude <= 1200 ; Correction Q2.c. SQL SELECT longitude , nom_ville FROM Centres WHERE longitude > 5 ORDER BY nom_ville ; Correction Q3.a. Cette requ\u00eate va afficher tous les renseignements sur les mesures dat\u00e9es du 30 octobre 2021. Correction Q3.b. SQL INSERT INTO Mesures VALUES ( 3650 , 138 , 2021 - 11 - 08 , 11 , 1013 , 0 ); Correction Q4.a. Cette requ\u00eate va renvoyer tous les renseignements sur les centres dont la latitude est la latitude minimum de tous les centres. Correction Q4.b. SQL SELECT DISTINCT Centres . nom_ville FROM Centres JOIN Mesures ON Mesures . id_centre = Centres . id_centre WHERE Mesures . temperature < 10 AND Mesures . date <= 2021 - 10 - 31 AND Mesures . date >= 2021 - 10 - 01 ; Exercice 5 Exercice 4 du sujet M\u00e9tropole J2 2022 Correction Correction Q1.a. \ud83d\udccb Texte Hey Jude I Want To Hold Your Hand Correction Q1.b. SQL SELECT nom FROM interpretes WHERE pays = 'Angleterre' ; Correction Q1.c. \ud83d\udccb Texte I Want To Hold Your Hand, 1963 Like a Rolling Stone, 1965 Respect, 1967 Hey Jude, 1968 Imagine, 1970 Smells Like Teen Spirit, 1991 Correction Q1.d. SQL SELECT COUNT ( * ) FROM morceaux ; Correction Q1.e. SQL SELECT titre FROM morceaux ORDER BY titre ; Correction Q2.a. La cl\u00e9 \u00e9trang\u00e8re de la table morceaux est l'attribut id_interprete qui fait r\u00e9f\u00e9rence \u00e0 la cl\u00e9 primaire id_interprete de la table interpretes . Correction Q2.b. morceaux : (( id_morceau , Int), (titre, Text), (annee, Int), (id_interprete#, Int)) interpretes : (( id_interprete , Int), (nom, Text), (pays, Text)) Correction Q2.c. La requ\u00eate va renvoyer une erreur car la cl\u00e9 primaire 1 est d\u00e9j\u00e0 pr\u00e9sente dans la table : il s'agit d'une violation de la contrainte de relation. Correction Q3.a. SQL UPDATE morceaux SET annee = 1971 WHERE titre = 'Imagine' Correction Q3.b. SQL INSERT INTO interpretes VALUES ( 6 , \"The Who\" , \"Angleterre\" ) Correction Q3.c. SQL INSERT INTO morceaux VALUES ( 7 , \"My Generation\" , 1965 , 6 ) Correction Q4. SQL SELECT morceaux . titre FROM morceaux JOIN interpretes ON interpretes . id_interprete = morceaux . id_interprete WHERE interpretes . pays = \"\u00c9tats-Unis\" Exercice 6 Exercice 2 du sujet La R\u00e9union J2 2022 Correction Correction Q1. Le couple (NumClient, NumChambre) ne pouvait pas \u00eatre une cl\u00e9 primaire car un m\u00eame client peut revenir dans l'h\u00f4tel et avoir la m\u00eame chambre qu'\u00e0 un pr\u00e9c\u00e9dent s\u00e9jour. Le couple (NumClient, NumChambre) ne serait donc pas unique et ne peut donc pas servir de cl\u00e9 primaire pour la relation Reservations . Correction Q2.a. SQL SELECT Nom , Prenom FROM Clients Correction Q2.b. SQL SELECT Telephone FROM Clients WHERE Prenom = \"Grace\" AND Nom = \"Hopper\" Correction Q3. SQL SELECT NumChambre FROM Reservations WHERE date ( DateArr ) <= date ( '2024-12-28' ) AND date ( DateDep ) > date ( '2024-12-28' ) Correction Q4.a. SQL UPDATE Chambres SET prix = 75 WHERE NumChambre = 404 Correction Q4.b SQL SELECT Reservations . NumChambre FROM Reservations JOIN Clients ON Clients . NumClient = Reservations . NumClient WHERE Clients . Nom = 'Codd' AND Clients . Prenom = 'Edgar'", "title": "Exercices SQL d\u00e9branch\u00e9s"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices_ecrit/#exercices-sql-debranches", "text": "Exercice 1 (d'apr\u00e8s Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER.) On veut cr\u00e9er une base de donn\u00e9es baseHopital.db qui contiendra les trois tables suivantes : Patients id Int nom Text prenom Text genre Text annee_naissance Int Ordonnances code Int id_patient Int matricule_medecin Int date_ord Text medicaments Text Medecins matricule Int nom_prenom Text specialite Text telephone Text On suppose que les dates sont donn\u00e9es sous la forme jj-mm-aaaa . On donne le diagramme relationnel de cette base : Q0. \u00c9crire le sch\u00e9ma relationnel de la table Ordonnances. On soulignera les cl\u00e9s primaires et marquera d'un # les cl\u00e9s \u00e9trang\u00e8res. Correction Ordonnaces (( code , Int), (id_patient#, Int), (matricule_medecin#, Int), (date_ord, Text), (medicaments, Text)) Q1. (HP) Donner les commandes SQL permettant de cr\u00e9er ces tables. Correction SQL CREATE TABLE Patients ( id INTEGER PRIMARY KEY , nom TEXT , prenom TEXT , genre TEXT , annee_naissance INTEGER ); CREATE TABLE Ordonnances ( code INTEGER PRIMARY KEY , id_patient INTEGER , matricule_medecin INTEGER , date_ord TEXT , medicaments TEXT , FOREIGN KEY ( id_patient ) REFERENCES Patients ( Id ), FOREIGN KEY ( matricule_medecin ) REFERENCES Medecins ( matricule ) ); CREATE TABLE Medecins ( matricule INTEGER PRIMARY KEY , nom_prenom TEXT , specialite TEXT , telephone TEXT ); Q2. Mme Anne Wizeunid, n\u00e9e en 2000 et demeurant 3 rue des Pignons Verts 12345 Avonelit doit \u00eatre enregistr\u00e9e comme patiente num\u00e9ro 1. Donner la commande SQLite correspondante. Correction SQL INSERT INTO Patients VALUES ( 1 , \"Wizeunit\" , \"Anne\" , \"F\" , 2000 ); Q3. Le patient num\u00e9ro 100 a chang\u00e9 de pr\u00e9nom et s'appelle maintenant \"Alice\". Donner la commande SQLite modifiant en cons\u00e9quence ses donn\u00e9es. Correction SQL UPDATE Patients SET prenom = 'Alice' WHERE id = 100 ; Q4. Par souci d'\u00e9conomie, la direction d\u00e9cide de se passer des m\u00e9decins sp\u00e9cialis\u00e9s en \u00e9pid\u00e9miologie. Donner la commande permettant de supprimer leurs fiches. Correction SQL DELETE FROM Medecins WHERE specialite = \"\u00e9pid\u00e9miologie\" ; Q5. Donner la liste des patient(e)s ayant \u00e9t\u00e9 examin\u00e9(e)s par un(e) psychiatre en avril 2020. Correction SQL SELECT p . nom , p . prenom FROM Patients AS p JOIN Ordonnances AS o ON p . id = o . id_patient JOIN Medecins AS m ON o . matricule_medecin = m . matricule WHERE m . specialite = \"psychiatrie\" AND o . date_ord LIKE \"%04-2020%\" Exercice 2 bas\u00e9 sur le travail de G.Viateau (Bayonne) On consid\u00e8re ci-dessous le sch\u00e9ma de la base de donn\u00e9es du stock d'un supermarch\u00e9 : Q1 . Quelle requ\u00eate SQL donne le prix d'achat du produit dont le nom_court est \u00abLiq_Vaiss_1L\u00bb ? Correction SQL SELECT prix_achat FROM Produits WHERE nom_court = 'Liq_Vaiss_1L' Q2 . Quelle requ\u00eate donne l'adresse, le code postal et la ville du fournisseur dont le nom est \u00abAvenir_confiseur\u00bb ? Correction SQL SELECT adresse , cp , ville FROM Fournisseurs WHERE nom = 'Avenir_confiseur' ; Q3 . Quelle requ\u00eate donne les produits \u00e9tant en rupture de stock ? Correction SQL SELECT Produits . nom FROM Produits JOIN Stocks ON Produits . id = Stocks . produit WHERE Stocks . quantite = 0 ; Q4 . Quelle requ\u00eate donne la liste de toutes les ampoules vendues en magasin ? On pourra faire l'hypoth\u00e8se que le nom du produit contient le mot \u00abampoule\u00bb Correction SQL SELECT nom FROM Produits WHERE nom LIKE \"%ampoule%\" ; Q5 . Quelle requ\u00eate permet d'avoir le prix moyen de ces ampoules ? Correction SQL SELECT AVG ( prix_vente ) FROM Produits WHERE nom LIKE \"%ampoule%\" ; Q6 . Quelle requ\u00eate permet d'identifier le produit le plus cher du magasin ? Correction SQL SELECT nom_court FROM Produits ORDER BY prix_vente DESC LIMIT 1 ; ou SQL SELECT nom FROM Produits WHERE prix_vente = ( SELECT MAX ( prix_vente ) FROM Produits ); Q7 . Quelle requ\u00eate renvoie les noms des produits dont la date de p\u00e9remption est d\u00e9pass\u00e9e ? (on pourra utiliser la fonction SQL NOW() qui renvoie la date actuelle ) Correction SQL SELECT p . nom FROM Produits AS p JOIN Stocks AS s ON s . produits = p . id WHERE s . date_peremption < NOW (); Exercice 3 Exercice 1 du sujet Am\u00e9rique du Sud J1 2022 Correction Correction Q1.a. La relation Sport a pour cl\u00e9 primaire le couple NomSport et nomStation, et pour cl\u00e9 \u00e9trang\u00e8re l'attribut nomStation, cl\u00e9 primaire de la relation Station. Correction Q1.b. Contrainte d'int\u00e9grit\u00e9 de domaine : l'attribut Prix doit \u00eatre un nombre entier. Contrainte d'int\u00e9grit\u00e9 de relation : le couple (nomSport, nomStation) ne peut pas se retrouver deux fois dans la table (car il forme une cl\u00e9 primaire) Contrainte d'int\u00e9grit\u00e9 de r\u00e9f\u00e9rence : l'attribut nomStation ne peut pas \u00eatre un nom n'apparaissant pas dans la relation Station. Correction Q2.a. La commande INSERT ne sert que pour ins\u00e9rer de nouveaux enregistrements, or le couple (\"planche \u00e0 voile\" , \"La tramontane catalane\") existe d\u00e9j\u00e0 dans la relation (et c'est une cl\u00e9 primaire donc on ne peut pas la retrouver deux fois). Il faut donc utiliser : SQL UPDATE Sports SET prix = 1350 WHERE nomSport = \"planche \u00e0 voile\" AND nomStation = \"La tramontane catalane\" Correction Q2.b. SQL INSERT INTO Station VALUES ( \"Soleil Rouge\" , \"Bastia\" , \"Corse\" ) INSERT INTO Sport VALUES ( \"plong\u00e9e\" , \"Soleil Rouge\" , 900 ) Correction Q3.a. SQL SELECT mail FROM Client Correction Q3.b. SQL SELECT nomStation FROM Sport WHERE nomSport = \"plongee\" Correction Q4.a. SQL SELECT Station . ville , Station . nomStation FROM Station JOIN Sport ON Sport . nomStation = Station . nomStation WHERE Sport . nomSport = \"plongee\" Correction Q4.b. SQL SELECT COUNT ( * ) FROM Sejour JOIN Station ON Station . nomStation = Sejour . nomStation WHERE Sejour . annee = 2020 AND Station . region = \"Corse\" Exercice 4 Exercice 4 du sujet Centres \u00c9trangers J1 2022 Correction Correction Q1.a. L'attribut id_mesure semble une cl\u00e9 primaire acceptable car elle semble sp\u00e9cifique \u00e0 chaque enregistrement. Correction Q1.b. L'attribut id_centres semble \u00eatre une cl\u00e9 primaire de la relation Centres . On le retrouve aussi (sous le m\u00eame nom) dans la relation Mesures . C'est donc un attribut qui permettra de faire une jointure entre les deux relations. Correction Q2.a. Cette requ\u00eate va afficher tous les renseignements disponibles sur les centres dont l'altitude est strictement sup\u00e9rieure \u00e0 500m. Correction Q2.b. SQL SELECT nom_ville FROM Centres WHERE altitude >= 700 AND altitude <= 1200 ; Correction Q2.c. SQL SELECT longitude , nom_ville FROM Centres WHERE longitude > 5 ORDER BY nom_ville ; Correction Q3.a. Cette requ\u00eate va afficher tous les renseignements sur les mesures dat\u00e9es du 30 octobre 2021. Correction Q3.b. SQL INSERT INTO Mesures VALUES ( 3650 , 138 , 2021 - 11 - 08 , 11 , 1013 , 0 ); Correction Q4.a. Cette requ\u00eate va renvoyer tous les renseignements sur les centres dont la latitude est la latitude minimum de tous les centres. Correction Q4.b. SQL SELECT DISTINCT Centres . nom_ville FROM Centres JOIN Mesures ON Mesures . id_centre = Centres . id_centre WHERE Mesures . temperature < 10 AND Mesures . date <= 2021 - 10 - 31 AND Mesures . date >= 2021 - 10 - 01 ; Exercice 5 Exercice 4 du sujet M\u00e9tropole J2 2022 Correction Correction Q1.a. \ud83d\udccb Texte Hey Jude I Want To Hold Your Hand Correction Q1.b. SQL SELECT nom FROM interpretes WHERE pays = 'Angleterre' ; Correction Q1.c. \ud83d\udccb Texte I Want To Hold Your Hand, 1963 Like a Rolling Stone, 1965 Respect, 1967 Hey Jude, 1968 Imagine, 1970 Smells Like Teen Spirit, 1991 Correction Q1.d. SQL SELECT COUNT ( * ) FROM morceaux ; Correction Q1.e. SQL SELECT titre FROM morceaux ORDER BY titre ; Correction Q2.a. La cl\u00e9 \u00e9trang\u00e8re de la table morceaux est l'attribut id_interprete qui fait r\u00e9f\u00e9rence \u00e0 la cl\u00e9 primaire id_interprete de la table interpretes . Correction Q2.b. morceaux : (( id_morceau , Int), (titre, Text), (annee, Int), (id_interprete#, Int)) interpretes : (( id_interprete , Int), (nom, Text), (pays, Text)) Correction Q2.c. La requ\u00eate va renvoyer une erreur car la cl\u00e9 primaire 1 est d\u00e9j\u00e0 pr\u00e9sente dans la table : il s'agit d'une violation de la contrainte de relation. Correction Q3.a. SQL UPDATE morceaux SET annee = 1971 WHERE titre = 'Imagine' Correction Q3.b. SQL INSERT INTO interpretes VALUES ( 6 , \"The Who\" , \"Angleterre\" ) Correction Q3.c. SQL INSERT INTO morceaux VALUES ( 7 , \"My Generation\" , 1965 , 6 ) Correction Q4. SQL SELECT morceaux . titre FROM morceaux JOIN interpretes ON interpretes . id_interprete = morceaux . id_interprete WHERE interpretes . pays = \"\u00c9tats-Unis\" Exercice 6 Exercice 2 du sujet La R\u00e9union J2 2022 Correction Correction Q1. Le couple (NumClient, NumChambre) ne pouvait pas \u00eatre une cl\u00e9 primaire car un m\u00eame client peut revenir dans l'h\u00f4tel et avoir la m\u00eame chambre qu'\u00e0 un pr\u00e9c\u00e9dent s\u00e9jour. Le couple (NumClient, NumChambre) ne serait donc pas unique et ne peut donc pas servir de cl\u00e9 primaire pour la relation Reservations . Correction Q2.a. SQL SELECT Nom , Prenom FROM Clients Correction Q2.b. SQL SELECT Telephone FROM Clients WHERE Prenom = \"Grace\" AND Nom = \"Hopper\" Correction Q3. SQL SELECT NumChambre FROM Reservations WHERE date ( DateArr ) <= date ( '2024-12-28' ) AND date ( DateDep ) > date ( '2024-12-28' ) Correction Q4.a. SQL UPDATE Chambres SET prix = 75 WHERE NumChambre = 404 Correction Q4.b SQL SELECT Reservations . NumChambre FROM Reservations JOIN Clients ON Clients . NumClient = Reservations . NumClient WHERE Clients . Nom = 'Codd' AND Clients . Prenom = 'Edgar'", "title": "Exercices SQL d\u00e9branch\u00e9s"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices_inter/", "text": "Exercices SQL interactifs \u2693\ufe0e Exercice 1 Questions interactives \u00e0 r\u00e9aliser sur le site sqlzoo.net. Q1. Travail sur SELECT, (base de donn\u00e9es Nobel) ici . Correction Corrections extraites du d\u00e9p\u00f4t https://github.com/jisaw/sqlzoo-solutions . SQL /* Third section of sqlzoo, SELECT from Nobel */ --#1 /* Change the query shown so that it displays Nobel prizes for 1950. */ SELECT yr , subject , winner FROM nobel WHERE yr = 1950 --#2 /* Show who won the 1962 prize for Literature. */ SELECT winner FROM nobel WHERE yr = 1962 AND subject = 'Literature' --#3 /* Show the year and subject that won 'Albert Einstein' his prize. */ SELECT yr , subject FROM nobel WHERE winner = 'Albert Einstein' --#4 /* Give the name of the 'Peace' winners since the year 2000, including 2000. */ SELECT winner FROM nobel WHERE subject = 'Peace' AND yr >= 2000 --#5 /* Show all details (yr, subject, winner) of the Literature prize winners for 1980 to 1989 inclusive */ SELECT yr , subject , winner FROM nobel WHERE ( yr >= 1980 AND yr <= 1989 ) AND subject = 'Literature' --#6 /* Show all details of the presidential winners: Theodore Roosevelt Woodrow Wilson Jimmy Carter */ SELECT * FROM nobel WHERE winner IN ( 'Theodore Roosevelt' , 'Woodrow Wilson' , 'Jimmy Carter' ) --#7 /* Show the winners with first name John */ SELECT winner FROM nobel WHERE winner LIKE 'john%' --#8 /* Show the Physics winners for 1980 together with the Chemistry winners for 1984. */ SELECT * FROM nobel WHERE ( subject = \"Physics\" AND yr = '1980' ) OR ( subject = 'Chemistry' AND yr = 1984 ) --#9 /* Show the winners for 1980 excluding the Chemistry and Medicine */ SELECT * FROM nobel WHERE yr = 1980 AND subject NOT IN ( 'Chemistry' , 'Medicine' ) --#10 /* Show who won a 'Medicine' prize in an early year (before 1910, not including 1910) together with winners of a 'Literature' prize in a later year (after 2004, including 2004) */ SELECT * FROM nobel WHERE ( subject = 'Medicine' AND yr < 1910 ) OR ( subject = 'Literature' AND yr >= 2004 ) --#11 /* Find all details of the prize won by PETER GR\u00dcNBERG */ SELECT * FROM nobel WHERE winner LIKE 'peter gr%nberg' --#12 /* Find all details of the prize won by EUGENE O'NEILL */ SELECT * FROM nobel WHERE winner = 'Eugene O''Neill' --#13 /* Knights in order List the winners, year and subject where the winner starts with Sir. Show the the most recent first, then by name order. */ SELECT winner , yr , subject FROM nobel WHERE winner LIKE 'sir%' ORDER BY yr DESC , winner --#14 /* The expression subject IN ('Chemistry','Physics') can be used as a value - it will be 0 or 1. Show the 1984 winners ordered by subject and winner name; but list Chemistry and Physics last. */ SELECT winner , subject , subject IN ( 'Physics' , 'Chemistry' ) FROM nobel WHERE yr = 1984 ORDER BY subject IN ( 'Physics' , 'Chemistry' ), subject , winner Q2. Travail sur SUM et COUNT, (base de donn\u00e9es World) ici . (jusqu'\u00e0 la question 5.) Correction Corrections extraites du d\u00e9p\u00f4t https://github.com/jisaw/sqlzoo-solutions . SQL /* Fifth section of sqlzoo, SUM and COUNT */ --#1 /* Show the total population of the world. */ SELECT SUM ( population ) FROM world --#2 /* List all the continents - just once each. */ SELECT DISTINCT ( continent ) FROM world --#3 /* Give the total GDP of Africa */ SELECT SUM ( gdp ) FROM world WHERE continent = 'Africa' --#4 /* How many countries have an area of at least 1000000 */ SELECT COUNT ( name ) FROM world WHERE area >= 1000000 --#5 /* What is the total population of ('France','Germany','Spain') */ SELECT SUM ( population ) FROM world WHERE name IN ( 'France' , 'Germany' , 'Spain' ) --#6 /* For each continent show the continent and number of countries. */ SELECT continent , COUNT ( name ) FROM world GROUP BY continent --#7 /* For each continent show the continent and number of countries with populations of at least 10 million. */ SELECT continent , COUNT ( name ) FROM world WHERE population >= 10000000 GROUP BY continent --#8 /* List the continents that have a total population of at least 100 million. */ SELECT continent FROM world GROUP BY continent HAVING SUM ( population ) > 100000000 Q3. Travail sur JOIN, (base de donn\u00e9es Euro2012) ici . correction SQL /* Sixth section of sqlzoo, Join */ --#1 /* The first example shows the goal scored by 'Bender'. Show matchid and player name for all goals scored by Germany. */ SELECT matchid , player FROM goal WHERE teamid = 'GER' --#2 /* From the previous query you can see that Lars Bender's goal was scored in game 1012. Notice that the column matchid in the goal table corresponds to the id column in the game table. Show id, stadium, team1, team2 for game 1012 */ SELECT id , stadium , team1 , team2 FROM game WHERE id = 1012 --#3 /* You can combine the two steps into a single query with a JOIN. You will get all the game details and all the goal details if you use SELECT * FROM game JOIN goal ON (id=matchid) Show the player, teamid and mdate and for every German goal. teamid='GER' */ SELECT player , teamid , mdate FROM game JOIN goal ON ( id = matchid AND teamid = 'GER' ) --#4 /* Use the same JOIN as in the previous question. Show the team1, team2 and player for every goal scored by a player called Mario player LIKE 'Mario%' */ SELECT team1 , team2 , player FROM game JOIN goal ON ( id = matchid AND player LIKE 'Mario%' ) --#5 /* The table eteam gives details of every national team including the coach. You can JOIN goal to eteam using the phrase goal JOIN eteam on teamid=id Show player, teamid, coach, gtime for all goals scored in the first 10 minutes gtime<=10 */ SELECT player , teamid , coach , gtime FROM goal JOIN eteam ON ( teamid = id AND gtime <= 10 ) --#6 /* To JOIN game with eteam you could use either game JOIN eteam ON (team1=eteam.id) or game JOIN eteam ON (team2=eteam.id) Notice that because id is a column name in both game and eteam you must specify eteam.id instead of just id List the the dates of the matches and the name of the team in which 'Fernando Santos' was the team1 coach. */ SELECT mdate , teamname FROM game JOIN eteam ON ( team1 = eteam . id AND coach LIKE '%Santos' ) --#7 /* List the player for every goal scored in a game where the stadium was 'National Stadium, Warsaw' */ SELECT player FROM goal JOIN game ON ( id = matchid AND stadium = 'National Stadium, Warsaw' ) --#8 /* The example query shows all goals scored in the Germany-Greece quarterfinal. Instead show the name of all players who scored a goal against Germany. */ SELECT DISTINCT ( player ) FROM game JOIN goal ON matchid = id WHERE (( team1 = 'GER' OR team2 = 'GER' ) AND teamid != 'GER' ) --#9 /* Show teamname and the total number of goals scored. */ SELECT teamname , COUNT ( player ) FROM eteam JOIN goal ON id = teamid GROUP BY teamname --#10 /* Show the stadium and the number of goals scored in each stadium. */ SELECT stadium , COUNT ( player ) AS goals FROM game JOIN goal ON ( id = matchid ) GROUP BY stadium --#11 /* For every match involving 'POL', show the matchid, date and the number of goals scored. */ SELECT matchid , mdate , COUNT ( player ) AS goals FROM game JOIN goal ON ( matchid = id AND ( team1 = 'POL' OR team2 = 'POL' )) GROUP BY matchid , mdate --#12 /* For every match where 'GER' scored, show matchid, match date and the number of goals scored by 'GER' */ SELECT id , mdate , COUNT ( player ) FROM game JOIN goal ON ( id = matchid AND ( team1 = 'GER' OR team2 = 'GER' ) AND teamid = 'GER' ) GROUP BY id , mdate --#13 /* List every match with the goals scored by each team as shown. This will use \"CASE WHEN\" which has not been explained in any previous exercises. mdate team1 score1 team2 score2 1 July 2012 ESP 4 ITA 0 10 June 2012 ESP 1 ITA 1 10 June 2012 IRL 1 CRO 3 ... Notice in the query given every goal is listed. If it was a team1 goal then a 1 appears in score1, otherwise there is a 0. You could SUM this column to get a count of the goals scored by team1. Sort your result by mdate, matchid, team1 and team2. */ SELECT mdate , team1 , SUM ( CASE WHEN teamid = team1 THEN 1 ELSE 0 END ) AS score1 , team2 , SUM ( CASE WHEN teamid = team2 THEN 1 ELSE 0 END ) AS score2 FROM game LEFT JOIN goal ON ( id = matchid ) GROUP BY mdate , team1 , team2 ORDER BY mdate , matchid , team1 , team2 Exercice 2 Gestion d'un r\u00e9seau d'agences de location de voitures. D'apr\u00e8s le travail de J. Le Coupanec (Acad\u00e9mie de Rennes) La base de donn\u00e9es locations.db contient les tables Agences , Locations , Vehicules . Requ\u00eate : Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/raoulhatterer.github.io/tnsi/T4_Bases_de_donnees/4.2_Langage_SQL/data/locations.db', '', '', ); }).catch(() => {}); Questions sur la relation Agences Q1 . Visualisez toute la relation Agences Correction SQL SELECT * FROM Agences Q2 . Listez uniquement les noms des agences et de leur ville. Correction SQL SELECT nom , ville FROM Agences Q3 . Listez les noms des agences de la ville de Lorient Correction SQL SELECT nom FROM Agences WHERE ville = 'Lorient' Q4 . Listez les noms des agences du d\u00e9partement du Morbihan (code postal 56***) ainsi que les codes postaux en utilisant par exemple un WHERE LIKE . Correction SQL SELECT nom , code FROM Agences WHERE code LIKE '56%' Questions sur la relation Vehicules Q5 . D\u00e9terminez le nombre de voitures que vous poss\u00e9dez. Correction SQL SELECT COUNT ( * ) FROM Vehicules Q6 . D\u00e9terminez l'\u00e2ge minimum et maximum de vos v\u00e9hicules. Correction SQL SELECT MAX ( age ), MIN ( age ) FROM Vehicules Q7 . Quels sont la marque et le mod\u00e8le de votre derni\u00e8re acquisition qui date de trois mois ? Correction SQL SELECT nom FROM Vehicules WHERE age = 3 Q8 . Quel est le kilom\u00e9trage maximum des v\u00e9hicules ? Correction SQL SELECT MAX ( kilometrage ) FROM Vehicules Q9 . Quel est le kilom\u00e9trage moyen des v\u00e9hicules ? Correction SQL SELECT AVG ( kilometrage ) FROM Vehicules Q10 . Afficher toute la flotte de v\u00e9hicules par ordre d\u00e9croissant de kilom\u00e9trage. Correction SQL SELECT * FROM Vehicules ORDER BY kilometrage DESC Questions sur la relation Locations Q11 . Visualisez toute la relation Locations. Correction SQL SELECT * FROM Locations Q12 . D\u00e9terminez le nombre de locations effectu\u00e9es avec changement d'agence Correction SQL SELECT COUNT ( * ) FROM Locations WHERE depart != retour Q13 . D\u00e9terminez le nombre total de kilom\u00e8tres effectu\u00e9s durant les locations Correction SQL SELECT SUM ( kilometrage ) FROM Locations Q14 . Listez toutes les locations en y associant les caract\u00e9ristiques du v\u00e9hicule Correction SQL SELECT * FROM Locations JOIN Vehicules ON Locations . vehicule = Vehicules . immatriculation Q15 . Affichez le nom et l'immatriculation du v\u00e9hicule ainsi que la date de la location et le kilom\u00e9trage r\u00e9alis\u00e9 pour chacune des locations Correction SQL SELECT Vehicules . nom , Vehicules . immatriculation , Locations . date , Locations . kilometrage FROM Locations JOIN Vehicules ON Locations . vehicule = Vehicules . immatriculation Q16 . Affichez une seule fois le nom et l'immatriculation des v\u00e9hicules ayant d\u00e9j\u00e0 \u00e9t\u00e9 lou\u00e9s. Correction SQL SELECT DISTINCT nom , immatriculation FROM Locations JOIN Vehicules ON Locations . vehicule = Vehicules . immatriculation Q17 . Affichez les locations du v\u00e9hicule immatricul\u00e9 AB-224-BA en pr\u00e9cisant le nom de l'agence de d\u00e9part ainsi que la ville de d\u00e9part dans l'ordre chronologique des locations. Correction SQL SELECT Agences . nom , Agences . ville , Locations . * FROM Locations JOIN Agences ON Locations . depart = Agences . id WHERE vehicule = 'AB-224-BA' ORDER BY Locations . date Exercice 3 Championnat de France de Football 2015-2016 D'apr\u00e8s le travail de J. Le Coupanec (Acad\u00e9mie de Rennes) La base de donn\u00e9es soccer.db contient les tables Team , Match , Event , Player . Requ\u00eate : Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, 'https:/raoulhatterer.github.io/tnsi/T4_Bases_de_donnees/4.2_Langage_SQL/data/soccer.db', '', '', ); }).catch(() => {}); Q1 . Combien d'\u00e9quipes ont particip\u00e9 \u00e0 ce championnat ? Correction SQL SELECT COUNT ( * ) FROM Team ou mieux SQL SELECT COUNT ( DISTINCT team ) from EVENT ; Q2 . Listez les noms des clubs ainsi que leur date de cr\u00e9ation dans l'ordre chronologique de leur cr\u00e9ation. Correction SQL SELECT name , birthday FROM Team ORDER BY birthday ; Q3 . Combien de p\u00e9naltys ont \u00e9t\u00e9 marqu\u00e9s ? Correction SQL SELECT COUNT ( * ) FROM Event WHERE type = 'penalty' ; Q4 . Combien de p\u00e9naltys ont \u00e9t\u00e9 siffl\u00e9s ? Correction SQL SELECT COUNT ( * ) FROM Event WHERE type IN ( 'penalty' , 'miss' ) Q5 . Combien de cartons ont \u00e9t\u00e9 distribu\u00e9s ? Correction SQL SELECT COUNT ( * ) FROM Event WHERE type IN ( 'red' , 'yellow2' , 'yellow' ) Q6 . Combien de buts ont \u00e9t\u00e9 marqu\u00e9s ? Correction SQL SELECT COUNT ( * ) FROM Event WHERE type IN ( 'goal' , 'own' , 'penalty' ) Q7 . Affichez tous les renseignements sur les 10 cartons rouges obtenus le plus rapidement pendant un match. Correction SQL SELECT * FROM Event WHERE type = 'red' ORDER BY time LIMIT 10 Q8 . Donnez le nom du joueur qui a obtenu le carton rouge le plus rapidement. Correction SQL SELECT name FROM event JOIN player ON player . id = event . player WHERE type = 'red' ORDER BY time LIMIT 1 ; Exercice 4 \u00c9nonc\u00e9 Zone d'enqu\u00eate Correction Cet exercice en ligne est propos\u00e9 le Knight Lab de l'universit\u00e9 am\u00e9ricaine Northwerstern University. Le point de d\u00e9part de l'histoire : un meurtre a \u00e9t\u00e9 commis dans la ville de SQL City le 15 janvier 2018. \u00c0 partir de ce point de d\u00e9part et d'une base de donn\u00e9es dont le diagramme est donn\u00e9 ci-dessous, il s'agit de trouver le meurtrier. Zone d'enqu\u00eate (\u00e0 coups de requ\u00eates) Il est conseill\u00e9 de travailler avec un Bloc-Notes ouvert \u00e0 c\u00f4t\u00e9 afin d'y coller les renseignements obtenus. Tapez votre requ\u00eate ci-dessous Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, 'https:/raoulhatterer.github.io/tnsi/T4_Bases_de_donnees/4.2_Langage_SQL/data/sql-murder-mystery.db', '', '', ); }).catch(() => {}); Vous pensez avoir trouv\u00e9 le meurtrier ? Copiez la requ\u00eate SQL INSERT INTO solution VALUES ( 1 , 'nom du meurtrier' ); SELECT value FROM solution ; dans le champ ci-dessous : Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, 'https:/raoulhatterer.github.io/tnsi/T4_Bases_de_donnees/4.2_Langage_SQL/data/sql-murder-mystery.db', '', '', ); }).catch(() => {}); Sur la page officielle , vous pouvez \u00eatre guid\u00e9s \u00e9tape par \u00e9tape jusqu'\u00e0 la recherche du meurtrier (qui n'est pas la fin de l'\u00e9nigme !) Vous pouvez si vous le souhaitez t\u00e9l\u00e9charger la base sql-murder-mystery.db .", "title": "Exercices SQL interactifs"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/02_exercices_inter/#exercices-sql-interactifs", "text": "Exercice 1 Questions interactives \u00e0 r\u00e9aliser sur le site sqlzoo.net. Q1. Travail sur SELECT, (base de donn\u00e9es Nobel) ici . Correction Corrections extraites du d\u00e9p\u00f4t https://github.com/jisaw/sqlzoo-solutions . SQL /* Third section of sqlzoo, SELECT from Nobel */ --#1 /* Change the query shown so that it displays Nobel prizes for 1950. */ SELECT yr , subject , winner FROM nobel WHERE yr = 1950 --#2 /* Show who won the 1962 prize for Literature. */ SELECT winner FROM nobel WHERE yr = 1962 AND subject = 'Literature' --#3 /* Show the year and subject that won 'Albert Einstein' his prize. */ SELECT yr , subject FROM nobel WHERE winner = 'Albert Einstein' --#4 /* Give the name of the 'Peace' winners since the year 2000, including 2000. */ SELECT winner FROM nobel WHERE subject = 'Peace' AND yr >= 2000 --#5 /* Show all details (yr, subject, winner) of the Literature prize winners for 1980 to 1989 inclusive */ SELECT yr , subject , winner FROM nobel WHERE ( yr >= 1980 AND yr <= 1989 ) AND subject = 'Literature' --#6 /* Show all details of the presidential winners: Theodore Roosevelt Woodrow Wilson Jimmy Carter */ SELECT * FROM nobel WHERE winner IN ( 'Theodore Roosevelt' , 'Woodrow Wilson' , 'Jimmy Carter' ) --#7 /* Show the winners with first name John */ SELECT winner FROM nobel WHERE winner LIKE 'john%' --#8 /* Show the Physics winners for 1980 together with the Chemistry winners for 1984. */ SELECT * FROM nobel WHERE ( subject = \"Physics\" AND yr = '1980' ) OR ( subject = 'Chemistry' AND yr = 1984 ) --#9 /* Show the winners for 1980 excluding the Chemistry and Medicine */ SELECT * FROM nobel WHERE yr = 1980 AND subject NOT IN ( 'Chemistry' , 'Medicine' ) --#10 /* Show who won a 'Medicine' prize in an early year (before 1910, not including 1910) together with winners of a 'Literature' prize in a later year (after 2004, including 2004) */ SELECT * FROM nobel WHERE ( subject = 'Medicine' AND yr < 1910 ) OR ( subject = 'Literature' AND yr >= 2004 ) --#11 /* Find all details of the prize won by PETER GR\u00dcNBERG */ SELECT * FROM nobel WHERE winner LIKE 'peter gr%nberg' --#12 /* Find all details of the prize won by EUGENE O'NEILL */ SELECT * FROM nobel WHERE winner = 'Eugene O''Neill' --#13 /* Knights in order List the winners, year and subject where the winner starts with Sir. Show the the most recent first, then by name order. */ SELECT winner , yr , subject FROM nobel WHERE winner LIKE 'sir%' ORDER BY yr DESC , winner --#14 /* The expression subject IN ('Chemistry','Physics') can be used as a value - it will be 0 or 1. Show the 1984 winners ordered by subject and winner name; but list Chemistry and Physics last. */ SELECT winner , subject , subject IN ( 'Physics' , 'Chemistry' ) FROM nobel WHERE yr = 1984 ORDER BY subject IN ( 'Physics' , 'Chemistry' ), subject , winner Q2. Travail sur SUM et COUNT, (base de donn\u00e9es World) ici . (jusqu'\u00e0 la question 5.) Correction Corrections extraites du d\u00e9p\u00f4t https://github.com/jisaw/sqlzoo-solutions . SQL /* Fifth section of sqlzoo, SUM and COUNT */ --#1 /* Show the total population of the world. */ SELECT SUM ( population ) FROM world --#2 /* List all the continents - just once each. */ SELECT DISTINCT ( continent ) FROM world --#3 /* Give the total GDP of Africa */ SELECT SUM ( gdp ) FROM world WHERE continent = 'Africa' --#4 /* How many countries have an area of at least 1000000 */ SELECT COUNT ( name ) FROM world WHERE area >= 1000000 --#5 /* What is the total population of ('France','Germany','Spain') */ SELECT SUM ( population ) FROM world WHERE name IN ( 'France' , 'Germany' , 'Spain' ) --#6 /* For each continent show the continent and number of countries. */ SELECT continent , COUNT ( name ) FROM world GROUP BY continent --#7 /* For each continent show the continent and number of countries with populations of at least 10 million. */ SELECT continent , COUNT ( name ) FROM world WHERE population >= 10000000 GROUP BY continent --#8 /* List the continents that have a total population of at least 100 million. */ SELECT continent FROM world GROUP BY continent HAVING SUM ( population ) > 100000000 Q3. Travail sur JOIN, (base de donn\u00e9es Euro2012) ici . correction SQL /* Sixth section of sqlzoo, Join */ --#1 /* The first example shows the goal scored by 'Bender'. Show matchid and player name for all goals scored by Germany. */ SELECT matchid , player FROM goal WHERE teamid = 'GER' --#2 /* From the previous query you can see that Lars Bender's goal was scored in game 1012. Notice that the column matchid in the goal table corresponds to the id column in the game table. Show id, stadium, team1, team2 for game 1012 */ SELECT id , stadium , team1 , team2 FROM game WHERE id = 1012 --#3 /* You can combine the two steps into a single query with a JOIN. You will get all the game details and all the goal details if you use SELECT * FROM game JOIN goal ON (id=matchid) Show the player, teamid and mdate and for every German goal. teamid='GER' */ SELECT player , teamid , mdate FROM game JOIN goal ON ( id = matchid AND teamid = 'GER' ) --#4 /* Use the same JOIN as in the previous question. Show the team1, team2 and player for every goal scored by a player called Mario player LIKE 'Mario%' */ SELECT team1 , team2 , player FROM game JOIN goal ON ( id = matchid AND player LIKE 'Mario%' ) --#5 /* The table eteam gives details of every national team including the coach. You can JOIN goal to eteam using the phrase goal JOIN eteam on teamid=id Show player, teamid, coach, gtime for all goals scored in the first 10 minutes gtime<=10 */ SELECT player , teamid , coach , gtime FROM goal JOIN eteam ON ( teamid = id AND gtime <= 10 ) --#6 /* To JOIN game with eteam you could use either game JOIN eteam ON (team1=eteam.id) or game JOIN eteam ON (team2=eteam.id) Notice that because id is a column name in both game and eteam you must specify eteam.id instead of just id List the the dates of the matches and the name of the team in which 'Fernando Santos' was the team1 coach. */ SELECT mdate , teamname FROM game JOIN eteam ON ( team1 = eteam . id AND coach LIKE '%Santos' ) --#7 /* List the player for every goal scored in a game where the stadium was 'National Stadium, Warsaw' */ SELECT player FROM goal JOIN game ON ( id = matchid AND stadium = 'National Stadium, Warsaw' ) --#8 /* The example query shows all goals scored in the Germany-Greece quarterfinal. Instead show the name of all players who scored a goal against Germany. */ SELECT DISTINCT ( player ) FROM game JOIN goal ON matchid = id WHERE (( team1 = 'GER' OR team2 = 'GER' ) AND teamid != 'GER' ) --#9 /* Show teamname and the total number of goals scored. */ SELECT teamname , COUNT ( player ) FROM eteam JOIN goal ON id = teamid GROUP BY teamname --#10 /* Show the stadium and the number of goals scored in each stadium. */ SELECT stadium , COUNT ( player ) AS goals FROM game JOIN goal ON ( id = matchid ) GROUP BY stadium --#11 /* For every match involving 'POL', show the matchid, date and the number of goals scored. */ SELECT matchid , mdate , COUNT ( player ) AS goals FROM game JOIN goal ON ( matchid = id AND ( team1 = 'POL' OR team2 = 'POL' )) GROUP BY matchid , mdate --#12 /* For every match where 'GER' scored, show matchid, match date and the number of goals scored by 'GER' */ SELECT id , mdate , COUNT ( player ) FROM game JOIN goal ON ( id = matchid AND ( team1 = 'GER' OR team2 = 'GER' ) AND teamid = 'GER' ) GROUP BY id , mdate --#13 /* List every match with the goals scored by each team as shown. This will use \"CASE WHEN\" which has not been explained in any previous exercises. mdate team1 score1 team2 score2 1 July 2012 ESP 4 ITA 0 10 June 2012 ESP 1 ITA 1 10 June 2012 IRL 1 CRO 3 ... Notice in the query given every goal is listed. If it was a team1 goal then a 1 appears in score1, otherwise there is a 0. You could SUM this column to get a count of the goals scored by team1. Sort your result by mdate, matchid, team1 and team2. */ SELECT mdate , team1 , SUM ( CASE WHEN teamid = team1 THEN 1 ELSE 0 END ) AS score1 , team2 , SUM ( CASE WHEN teamid = team2 THEN 1 ELSE 0 END ) AS score2 FROM game LEFT JOIN goal ON ( id = matchid ) GROUP BY mdate , team1 , team2 ORDER BY mdate , matchid , team1 , team2 Exercice 2 Gestion d'un r\u00e9seau d'agences de location de voitures. D'apr\u00e8s le travail de J. Le Coupanec (Acad\u00e9mie de Rennes) La base de donn\u00e9es locations.db contient les tables Agences , Locations , Vehicules . Requ\u00eate : Ex\u00e9cuter onElementLoaded(\"div#ide1\").then(() => { const ide = document.querySelector(\"div#ide1\"); load(ide, 'https:/raoulhatterer.github.io/tnsi/T4_Bases_de_donnees/4.2_Langage_SQL/data/locations.db', '', '', ); }).catch(() => {}); Questions sur la relation Agences Q1 . Visualisez toute la relation Agences Correction SQL SELECT * FROM Agences Q2 . Listez uniquement les noms des agences et de leur ville. Correction SQL SELECT nom , ville FROM Agences Q3 . Listez les noms des agences de la ville de Lorient Correction SQL SELECT nom FROM Agences WHERE ville = 'Lorient' Q4 . Listez les noms des agences du d\u00e9partement du Morbihan (code postal 56***) ainsi que les codes postaux en utilisant par exemple un WHERE LIKE . Correction SQL SELECT nom , code FROM Agences WHERE code LIKE '56%' Questions sur la relation Vehicules Q5 . D\u00e9terminez le nombre de voitures que vous poss\u00e9dez. Correction SQL SELECT COUNT ( * ) FROM Vehicules Q6 . D\u00e9terminez l'\u00e2ge minimum et maximum de vos v\u00e9hicules. Correction SQL SELECT MAX ( age ), MIN ( age ) FROM Vehicules Q7 . Quels sont la marque et le mod\u00e8le de votre derni\u00e8re acquisition qui date de trois mois ? Correction SQL SELECT nom FROM Vehicules WHERE age = 3 Q8 . Quel est le kilom\u00e9trage maximum des v\u00e9hicules ? Correction SQL SELECT MAX ( kilometrage ) FROM Vehicules Q9 . Quel est le kilom\u00e9trage moyen des v\u00e9hicules ? Correction SQL SELECT AVG ( kilometrage ) FROM Vehicules Q10 . Afficher toute la flotte de v\u00e9hicules par ordre d\u00e9croissant de kilom\u00e9trage. Correction SQL SELECT * FROM Vehicules ORDER BY kilometrage DESC Questions sur la relation Locations Q11 . Visualisez toute la relation Locations. Correction SQL SELECT * FROM Locations Q12 . D\u00e9terminez le nombre de locations effectu\u00e9es avec changement d'agence Correction SQL SELECT COUNT ( * ) FROM Locations WHERE depart != retour Q13 . D\u00e9terminez le nombre total de kilom\u00e8tres effectu\u00e9s durant les locations Correction SQL SELECT SUM ( kilometrage ) FROM Locations Q14 . Listez toutes les locations en y associant les caract\u00e9ristiques du v\u00e9hicule Correction SQL SELECT * FROM Locations JOIN Vehicules ON Locations . vehicule = Vehicules . immatriculation Q15 . Affichez le nom et l'immatriculation du v\u00e9hicule ainsi que la date de la location et le kilom\u00e9trage r\u00e9alis\u00e9 pour chacune des locations Correction SQL SELECT Vehicules . nom , Vehicules . immatriculation , Locations . date , Locations . kilometrage FROM Locations JOIN Vehicules ON Locations . vehicule = Vehicules . immatriculation Q16 . Affichez une seule fois le nom et l'immatriculation des v\u00e9hicules ayant d\u00e9j\u00e0 \u00e9t\u00e9 lou\u00e9s. Correction SQL SELECT DISTINCT nom , immatriculation FROM Locations JOIN Vehicules ON Locations . vehicule = Vehicules . immatriculation Q17 . Affichez les locations du v\u00e9hicule immatricul\u00e9 AB-224-BA en pr\u00e9cisant le nom de l'agence de d\u00e9part ainsi que la ville de d\u00e9part dans l'ordre chronologique des locations. Correction SQL SELECT Agences . nom , Agences . ville , Locations . * FROM Locations JOIN Agences ON Locations . depart = Agences . id WHERE vehicule = 'AB-224-BA' ORDER BY Locations . date Exercice 3 Championnat de France de Football 2015-2016 D'apr\u00e8s le travail de J. Le Coupanec (Acad\u00e9mie de Rennes) La base de donn\u00e9es soccer.db contient les tables Team , Match , Event , Player . Requ\u00eate : Ex\u00e9cuter onElementLoaded(\"div#ide2\").then(() => { const ide = document.querySelector(\"div#ide2\"); load(ide, 'https:/raoulhatterer.github.io/tnsi/T4_Bases_de_donnees/4.2_Langage_SQL/data/soccer.db', '', '', ); }).catch(() => {}); Q1 . Combien d'\u00e9quipes ont particip\u00e9 \u00e0 ce championnat ? Correction SQL SELECT COUNT ( * ) FROM Team ou mieux SQL SELECT COUNT ( DISTINCT team ) from EVENT ; Q2 . Listez les noms des clubs ainsi que leur date de cr\u00e9ation dans l'ordre chronologique de leur cr\u00e9ation. Correction SQL SELECT name , birthday FROM Team ORDER BY birthday ; Q3 . Combien de p\u00e9naltys ont \u00e9t\u00e9 marqu\u00e9s ? Correction SQL SELECT COUNT ( * ) FROM Event WHERE type = 'penalty' ; Q4 . Combien de p\u00e9naltys ont \u00e9t\u00e9 siffl\u00e9s ? Correction SQL SELECT COUNT ( * ) FROM Event WHERE type IN ( 'penalty' , 'miss' ) Q5 . Combien de cartons ont \u00e9t\u00e9 distribu\u00e9s ? Correction SQL SELECT COUNT ( * ) FROM Event WHERE type IN ( 'red' , 'yellow2' , 'yellow' ) Q6 . Combien de buts ont \u00e9t\u00e9 marqu\u00e9s ? Correction SQL SELECT COUNT ( * ) FROM Event WHERE type IN ( 'goal' , 'own' , 'penalty' ) Q7 . Affichez tous les renseignements sur les 10 cartons rouges obtenus le plus rapidement pendant un match. Correction SQL SELECT * FROM Event WHERE type = 'red' ORDER BY time LIMIT 10 Q8 . Donnez le nom du joueur qui a obtenu le carton rouge le plus rapidement. Correction SQL SELECT name FROM event JOIN player ON player . id = event . player WHERE type = 'red' ORDER BY time LIMIT 1 ; Exercice 4 \u00c9nonc\u00e9 Zone d'enqu\u00eate Correction Cet exercice en ligne est propos\u00e9 le Knight Lab de l'universit\u00e9 am\u00e9ricaine Northwerstern University. Le point de d\u00e9part de l'histoire : un meurtre a \u00e9t\u00e9 commis dans la ville de SQL City le 15 janvier 2018. \u00c0 partir de ce point de d\u00e9part et d'une base de donn\u00e9es dont le diagramme est donn\u00e9 ci-dessous, il s'agit de trouver le meurtrier. Zone d'enqu\u00eate (\u00e0 coups de requ\u00eates) Il est conseill\u00e9 de travailler avec un Bloc-Notes ouvert \u00e0 c\u00f4t\u00e9 afin d'y coller les renseignements obtenus. Tapez votre requ\u00eate ci-dessous Ex\u00e9cuter onElementLoaded(\"div#ide3\").then(() => { const ide = document.querySelector(\"div#ide3\"); load(ide, 'https:/raoulhatterer.github.io/tnsi/T4_Bases_de_donnees/4.2_Langage_SQL/data/sql-murder-mystery.db', '', '', ); }).catch(() => {}); Vous pensez avoir trouv\u00e9 le meurtrier ? Copiez la requ\u00eate SQL INSERT INTO solution VALUES ( 1 , 'nom du meurtrier' ); SELECT value FROM solution ; dans le champ ci-dessous : Ex\u00e9cuter onElementLoaded(\"div#ide4\").then(() => { const ide = document.querySelector(\"div#ide4\"); load(ide, 'https:/raoulhatterer.github.io/tnsi/T4_Bases_de_donnees/4.2_Langage_SQL/data/sql-murder-mystery.db', '', '', ); }).catch(() => {}); Sur la page officielle , vous pouvez \u00eatre guid\u00e9s \u00e9tape par \u00e9tape jusqu'\u00e0 la recherche du meurtrier (qui n'est pas la fin de l'\u00e9nigme !) Vous pouvez si vous le souhaitez t\u00e9l\u00e9charger la base sql-murder-mystery.db .", "title": "Exercices SQL interactifs"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/03_python_et_SQL/", "text": "Python et SQL / mini-projets \u2693\ufe0e Nous allons cr\u00e9er et interroger une base de donn\u00e9es sqlite avec le module sqlite3 de Python. 1. Permiers exemples \u2693\ufe0e 1.1 Cr\u00e9ation d'une table \u2693\ufe0e \ud83d\udc0d Script Python import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mynewbase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () # ---- d\u00e9but des instructions SQL #Cr\u00e9ation de la table c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS bulletin( Nom TEXT, Pr\u00e9nom TEXT, Note INT); \"\"\" ) # ---- fin des instructions SQL #Validation connexion . commit () #D\u00e9connexion connexion . close () Le fichier mynewbase.db sera cr\u00e9\u00e9 dans le m\u00eame r\u00e9pertoire que le fichier source Python. Si fichier existe d\u00e9j\u00e0, il est ouvert et peut \u00eatre modifi\u00e9. IF NOT EXISTS assure de ne pas \u00e9craser une table existante qui porterait le m\u00eame nom. Si une telle table existe, elle n'est alors pas modifi\u00e9e. La nouvelle table peut \u00eatre ouverte avec DB Browser pour v\u00e9rifier sa structure et ses donn\u00e9es. 1.2 Insertion d'enregistrements dans la table \u2693\ufe0e Les morceaux de code ci-dessous sont \u00e0 positionner entre les balises # ---- d\u00e9but des instructions SQL et # ---- fin des instructions SQL . 1.2.1 Insertion d'un enregistrement unique \u2693\ufe0e \ud83d\udc0d Script Python c . execute ( '''INSERT INTO bulletin VALUES ('Simpson', 'Bart', 17)''' ) Pensez \u00e0 v\u00e9rifier avec DB Browser si les modifications sont effectives. 1.2.2 Insertion d'un enregistrement unique avec variable \u2693\ufe0e \ud83d\udc0d Script Python data = ( 'Simpson' , 'Maggie' , 2 ) c . execute ( '''INSERT INTO bulletin VALUES (?,?,?)''' , data ) 1.2.3 Insertion de multiples enregistrements \u2693\ufe0e \ud83d\udc0d Script Python lst_notes = [ ( 'Simpson' , 'Lisa' , 19 ), ( 'Muntz' , 'Nelson' , 4 ), ( 'Van Houten' , 'Milhouse' , 12 ) ] c . executemany ( '''INSERT INTO bulletin VALUES (?, ?, ?)''' , lst_notes ) Les diff\u00e9rentes valeurs sont stock\u00e9es au pr\u00e9alable dans une liste de tuples. 1.3 Mini-projet 1 \u2693\ufe0e Cr\u00e9er un programme qui demande \u00e0 l'utilisateur un nom et une note, en boucle. Les r\u00e9sultats sont stock\u00e9s au fur et \u00e0 mesure dans une base de donn\u00e9es. Si le nom est \u00e9gal \u00e0 \u00abQ\u00bb ou \u00abq\u00bb, le programme s'arr\u00eate. 1.4 \u2620 Exemple d'injection SQL \u2693\ufe0e L'injection SQL est une technique consistant \u00e0 \u00e9crire du code SQL \u00e0 un endroit qui n'est pas cens\u00e9 en recevoir. https://xkcd.com/327/ Cr\u00e9ez un fichier contenant le code suivant : \ud83d\udc0d Script Python import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mabasecobaye.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () c . execute ( \"\"\" CREATE TABLE IF NOT EXISTS notes( Nom TEXT, Note INT); \"\"\" ) while True : nom = input ( 'Nom ? ' ) if nom in [ 'Q' , 'q' ] : break note = input ( 'Note ? ' ) data = ( nom , note ) p = \"INSERT INTO notes VALUES ('\" + nom + \"','\" + note + \"')\" c . executescript ( p ) #Validation connexion . commit () #D\u00e9connexion connexion . close () Ex\u00e9cutez ce fichier, rentrez quelques valeurs, quittez, et ouvrez dans DB Browser la table notes pour bien v\u00e9rifier que vos valeurs ont bien \u00e9t\u00e9 stock\u00e9es. Lancez \u00e0 nouveau le fichier, en donnant ensuite comme nom la cha\u00eene de caract\u00e8res suivante : g','3'); DROP TABLE notes;-- Donnez une note quelconque (par exemple 12), quittez le programme... et allez observer l'\u00e9tat de la base de donn\u00e9es. La table notes n'existe plus ! Explication : La requ\u00eate qui a \u00e9t\u00e9 formul\u00e9e est INSERT INTO notes VALUES ('g','3'); DROP TABLE notes;--','12') Dans un premier temps, le couple ('g','3') a \u00e9t\u00e9 ins\u00e9r\u00e9. Puis l'ordre a \u00e9t\u00e9 donn\u00e9 de d\u00e9truire la table notes . Le reste du code (qui n'est pas correct) est ignor\u00e9 car -- est le symbole du commentaire en SQL (l'\u00e9quivalent du # de Python). Remarques : \u00c9videmment, ce code a \u00e9t\u00e9 fait sp\u00e9cifiquement pour \u00eatre vuln\u00e9rable \u00e0 l'injection SQL. Il suffit d'ailleurs de remplacer le c.executescript(p) par c.execute(p) pour que le code reste fonctionnel mais refuse l'injection SQL. Ceci dit, de nombreux serveurs sont encore attaqu\u00e9s par cette technique, au prix de manipulations bien s\u00fbr plus complexes que celles que nous venons de voir (vous pouvez par exemple regarder ici ). Rappelons enfin que ce genre de pratiques est interdit sur un serveur qui ne vous appartient pas. 2. Lecture des enregistrements \u2693\ufe0e \ud83d\udc0d Script Python import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mynewbase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () data = ( 'Simpson' , ) c . execute ( \"SELECT Pr\u00e9nom FROM Bulletin WHERE Nom = ?\" , data ) print ( c . fetchall ()) #D\u00e9connexion connexion . close () Ce code renvoie [('Homer',), ('Lisa',), ('Maggie',)] , ou une liste vide s'il n'y a pas de r\u00e9sultat \u00e0 la requ\u00eate. 2.1 Mini-projet 2 \u2693\ufe0e Reprendre le mini-projet pr\u00e9c\u00e9dent, en rendant possible \u00e0 l'utilisateur de rentrer des notes ou bien de les consulter. Exemple : 2.3 Mini-projet 3 \u2693\ufe0e \u00c9nonc\u00e9 Aide Correction Cr\u00e9er un syst\u00e8me d'authenfication par login / mot de passe, dans le but de conserver une phrase secr\u00e8te. Id\u00e9alement le mot de passe ne sera pas conserv\u00e9 en clair mais hach\u00e9 (\u00e0 l'aide du module hashlib ). Exemple : La m\u00e9thode fetchall() est simple \u00e0 utiliser mais peut poser un probl\u00e8me de performance. En effet, cette m\u00e9thode retourne une liste, cela signifie que tous les r\u00e9sultats sont r\u00e9cup\u00e9r\u00e9s de la base de donn\u00e9es pour \u00eatre convertis en n-uplets. S\u2019il y a un nombre important de lignes dans le r\u00e9sultat de la requ\u00eate, cela signifie que la liste peut \u00eatre tr\u00e8s grande et avoir une empreinte m\u00e9moire importante. Parfois, on d\u00e9sire traiter directement la donn\u00e9e retourn\u00e9e et il n\u2019est pas n\u00e9cessaire de la stocker dans une liste. Nous pouvons am\u00e9liorer notre code en optant pour l\u2019appel \u00e0 la m\u00e9thode fetchone() . Cette m\u00e9thode retourne un seul r\u00e9sultat sous la forme d\u2019un n-uplet. Lorsqu\u2019il n\u2019y a plus de r\u00e9sultat \u00e0 lire, la m\u00e9thode retourne None. Le r\u00e9sultat du programme sera le m\u00eame sauf que les r\u00e9sultats sont extraits un \u00e0 un et qu\u2019aucune liste n\u2019est cr\u00e9\u00e9e. Warning Si vous fermez un curseur avant d\u2019avoir extrait tous les r\u00e9sultats, vous obtiendrez une exception. N\u2019utilisez pas la m\u00e9thode fetchone() pour ne retourner que le premier r\u00e9sultat, elle n\u2019a pas \u00e9t\u00e9 con\u00e7ue pour cela. Son r\u00f4le est de permettre de retourner tous les r\u00e9sultats d\u2019une requ\u00eate mais un \u00e0 un. Si vous voulez limiter le nombre de r\u00e9sultats retourn\u00e9s par une requ\u00eate, utilisez l\u2019instruction SQL LIMIT", "title": "Exercices Python-SQL"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/03_python_et_SQL/#python-et-sql-mini-projets", "text": "Nous allons cr\u00e9er et interroger une base de donn\u00e9es sqlite avec le module sqlite3 de Python.", "title": "Python et SQL / mini-projets"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/03_python_et_SQL/#1-permiers-exemples", "text": "", "title": "1. Permiers exemples"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/03_python_et_SQL/#2-lecture-des-enregistrements", "text": "\ud83d\udc0d Script Python import sqlite3 #Connexion connexion = sqlite3 . connect ( 'mynewbase.db' ) #R\u00e9cup\u00e9ration d'un curseur c = connexion . cursor () data = ( 'Simpson' , ) c . execute ( \"SELECT Pr\u00e9nom FROM Bulletin WHERE Nom = ?\" , data ) print ( c . fetchall ()) #D\u00e9connexion connexion . close () Ce code renvoie [('Homer',), ('Lisa',), ('Maggie',)] , ou une liste vide s'il n'y a pas de r\u00e9sultat \u00e0 la requ\u00eate.", "title": "2. Lecture des enregistrements"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/", "text": "Langage SQL \u2693\ufe0e 0. Du mod\u00e8le relationnel au SGBD \u2693\ufe0e Les consid\u00e9rations sur le mod\u00e8le relationnel du cours pr\u00e9c\u00e9dent traitaient plut\u00f4t de la structure math\u00e9matique des donn\u00e9es. Il s'agissait de d\u00e9terminer la meilleure structure pour repr\u00e9senter les donn\u00e9es et les relations qui les lient. Il convient maintenant d'aborder la partie logicielle : les SGBD (Syst\u00e8mes de Gestion de Bases de Donn\u00e9es). Les SGBD jouent le r\u00f4le d'interface entre l'\u00eatre humain et la base de donn\u00e9es. Par l'interm\u00e9diaire de requ\u00eates , l'utilisateur va consulter ou modifier la base de donn\u00e9es. Le SGBD est garant de l'int\u00e9grit\u00e9 de cette base, et pr\u00e9vient notamment que les modifications (souvent appel\u00e9es transactions ) ne soient pas pr\u00e9judiciables \u00e0 la base de donn\u00e9es. Le langage utilis\u00e9 pour communiquer avec le SGBD est le langage SQL , pour Structured Query Langage (pour langage de requ\u00eates structur\u00e9es ). Les SGBD les plus utilis\u00e9s sont bas\u00e9s sur le mod\u00e8le relationnel. Parmi eux, citons Oracle, MySQL, Microsoft SQL Server, PostgreSQL, Microsoft Access, SQLite, MariaDB... Mais de plus en plus de SGBD non-relationnels sont utilis\u00e9s, sp\u00e9cialement adapt\u00e9s \u00e0 des donn\u00e9es plus diverses et moins structur\u00e9es. On les retrouve sous l'appelation NoSQL (pour Not only SQL ). Citons parmi eux MongoDB, Cassandra (Facebook), BigTable (Google)... La quasi-totalit\u00e9 de ces SGBD fonctionnent avec un mod\u00e8le client-serveur. Nous allons travailler principalement avec le langage SQLite peut lui s'utiliser directement sans d\u00e9marrer un serveur : la base de donn\u00e9es est enti\u00e8rement repr\u00e9sent\u00e9e dans le logiciel utilisant SQLite (dans notre cas, DB Browser for SQLite). Sa simplicit\u00e9 d'utilisation en fera notre choix pour illustrer cette pr\u00e9sentation du langage SQL. 1. Introduction au langage SQL \u2693\ufe0e Dans toute la suite, nous allons travailler avec la base de donn\u00e9es livres.db qui provient de l'ouvrage paru chez Ellipses, cit\u00e9 en bibliographie. 1.0 Mise en \u0153uvre \u2693\ufe0e Pr\u00e9-requis : T\u00e9l\u00e9charger la base de donn\u00e9es livres.db . Disposer d'un moyen agir sur la base de donn\u00e9es \u00e0 partir de requ\u00eates SQL, soit en ligne soit en utilisant un logiciel externe. 1. En ligne avec sqliteonline.com 2. Avec un logiciel externe : DB Browser for SQLite Rendez vous sur https://sqliteonline.com/ Par File / OpenDB, ouvrez le fichier livres.db pr\u00e9c\u00e9demment t\u00e9l\u00e9charg\u00e9. \u00c9crivez votre requ\u00eate plus cliquez sur Run. Installez DB Browser for SQLite , t\u00e9l\u00e9chargeable \u00e0 l'adresse https://sqlitebrowser.org/ Ouvrez le fichier livres.db . Dans toute la suite, les manipulations sont \u00e0 faire en interrogeant la base de donn\u00e9es livres.db , avec l'une des m\u00e9thodes indiqu\u00e9es ci-dessus. Voici le diagramme relationnel de cette base : les cl\u00e9s primaires sont en bleu (suivi d'une icone de cl\u00e9) les cl\u00e9s \u00e9trang\u00e8res sont en noir et reli\u00e9es \u00e0 leur cl\u00e9 primaire. 1.1. S\u00e9lections \u2693\ufe0e Exemple 1 : \u00e9crire une requ\u00eate basique avec SELECT et FROM Commande : SQL SELECT titre FROM livre ; Traduction : On veut tous les titres de la table \u00ablivre\u00bb. R\u00e9sultat : Remarques Les mots-cl\u00e9s SQL sont traditionnellement \u00e9crits en MAJUSCULES. Le ; signale la fin de l'instruction. Il peut donc \u00eatre omis s'il n'y a pas d'instructions encha\u00een\u00e9es (ce qui sera toujours notre cas). L'indentation n'est pas syntaxique (pas comme en Python). On peut faire des retours \u00e0 la ligne et des indentations pour rendre le code plus lisible. Exemple 2 : \u00e9crire une requ\u00eate filtr\u00e9e avec SELECT , FROM et WHERE Commande : SQL SELECT titre FROM livre WHERE annee >= 1990 ; Traduction : On veut les titres de la table \u00ablivre\u00bb qui sont parus apr\u00e8s (ou en ) 1990; R\u00e9sultat : Le mot-cl\u00e9 WHERE doit \u00eatre suivi d'un bool\u00e9en. Les op\u00e9rateurs classiques = , != , > , >= , < , <= peuvent \u00eatre utilis\u00e9s, mais aussi le mot-cl\u00e9 IN : Exemple 3 : \u00e9crire une requ\u00eate avec plusieurs possibilit\u00e9s avec WHERE ... IN ... Commande : SQL SELECT titre FROM livre WHERE annee IN ( 1990 , 1991 , 1992 ); Traduction : On veut les titres de la table \u00ablivre\u00bb qui sont parus en 1990, 1991 ou 1992. R\u00e9sultat : Exemple 4: \u00e9crire une requ\u00eate avec bool\u00e9ens AND - OR Commande : SQL SELECT titre FROM livre WHERE annee >= 1970 AND annee <= 1980 AND editeur = 'Dargaud' ; Traduction : On veut les titres de la table \u00ablivre\u00bb qui sont parus entre 1970 et 1980 chez l'\u00e9diteur Dargaud; R\u00e9sultat : Exemple 5 : \u00e9crire une requ\u00eate approch\u00e9e avec LIKE Commande : SQL SELECT titre FROM livre WHERE titre LIKE '%Ast\u00e9rix%' ; Traduction : On veut les titres de la table \u00ablivre\u00bb dont le titre contient la cha\u00eene de caract\u00e8res \"Ast\u00e9rix\". Le symbole % est un joker qui peut symboliser n'importe quelle cha\u00eene de caract\u00e8res. R\u00e9sultat : Exemple 6 : s\u00e9lectionner plusieurs colonnes Commande : SQL SELECT titre , isbn FROM livre WHERE annee >= 1990 ; Traduction : On veut les titres et les ISBN de la table \u00ablivre\u00bb qui sont parus apr\u00e8s 1990. R\u00e9sultat : Exemple 7 : s\u00e9lectionner toutes les colonnes avec * Commande : SQL SELECT * FROM livre WHERE annee >= 1990 ; Traduction : On veut toutes les colonnes disponibles de la table \u00ablivre\u00bb pour les livres qui sont parus apr\u00e8s 1990. L'ast\u00e9risque * est un joker ( wildcard en anglais). R\u00e9sultat : Exemple 8 : renommer les colonnes avec AS Commande : SQL SELECT titre AS titre_du_livre FROM livre WHERE annee >= 1990 ; Traduction : Lors de l'affichage du r\u00e9sulats et dans la suite de la requ\u00eate (important), la colonne \"titre\" est renomm\u00e9e \"titre_du_livre\". R\u00e9sultat : Remarque L'alias AS sera souvent utilis\u00e9 pour raccourcir un nom, notamment lors des jointures de plusieurs tables (voir plus loin). 1.2. Agr\u00e9gations \u2693\ufe0e Les requ\u00eates effectu\u00e9es jusqu'ici ont juste s\u00e9lectionn\u00e9 des donn\u00e9es gr\u00e2ce \u00e0 diff\u00e9rents filtres : aucune action n'a \u00e9t\u00e9 effectu\u00e9e \u00e0 partir de ces donn\u00e9es. Nous allons maintenant effectuer des op\u00e9rations \u00e0 partir des donn\u00e9es s\u00e9lectionn\u00e9es. On appelle ces op\u00e9rations des op\u00e9rations d'agr\u00e9gation . Exemple 9 : compter avec COUNT Commande : SQL SELECT COUNT ( * ) AS total FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut compter le nombre d'enregistrements de la tables livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00abtotal\u00bb. R\u00e9sultat : Exemple 10 : additionner avec SUM Commande : SQL SELECT SUM ( annee ) AS somme FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut additionner les ann\u00e9es des livres de la tables livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00absomme\u00bb. Attention : dans notre cas pr\u00e9cis, ce calcul n'a aucun sens... R\u00e9sultat : Exemple 11 : faire une moyenne avec AVG Commande : SQL SELECT AVG ( annee ) AS moyenne FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut calculer la moyenne des ann\u00e9es de parution des livres de la table livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00abmoyenne\u00bb. Attention : l\u00e0 encore, ce calcul n'a aucun sens... R\u00e9sultat : Exemple 12 : trouver les extremums avec MIN , MAX Commande : SQL SELECT MIN ( annee ) AS minimum FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut trouver la plus petite valeur de la colonne \u00abannee\u00bb parmi les livres de la tables livre comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e minimum. Le fonctionnement est identique avec MAX pour la recherche du maximum. R\u00e9sultat : Exemple 13 : ordonner des valeurs avec ORDER BY , ASC , DESC , LIMIT Commande : SQL SELECT titre , annee FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ORDER BY annee DESC ; Traduction : On veut afficher tous les albums d'Ast\u00e9rix, et leur ann\u00e9e de parution, class\u00e9s par ann\u00e9e d\u00e9croissante. R\u00e9sultat : Comportement par d\u00e9faut : Si le param\u00e8tre ASC ou DESC est omis, le classement se fait par ordre croissant ( ASC est le param\u00e8tre par d\u00e9faut). Utilisation de LIMIT : Le mot-cl\u00e9 LIMIT (suivi d'un nombre) permet de limiter le nombre de r\u00e9sultats affich\u00e9s. Ainsi la requ\u00eate SQL SELECT titre , annee FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ORDER BY annee DESC LIMIT 1 ; permet d'obtenir les renseignements sur l'Ast\u00e9rix le plus r\u00e9cent. Exemple 14 : \u00e9viter les doublons avec DISTINCT Commande : SQL SELECT DISTINCT editeur FROM livre ; Traduction : On veut la liste de tous les \u00e9diteurs. Sans le mot-cl\u00e9 DISTINCT , beaucoup de doublons appara\u00eetraient. R\u00e9sultat : 1.3 Jointures \u2693\ufe0e Observons le contenu de la table \u00abemprunt\u00bb : SQL SELECT * FROM emprunt ; Le contenu est peu lisible : qui a emprunt\u00e9 quel livre ? Souvenons-nous du diagramme de la base de donn\u00e9es. Pour que la table \u00abemprunt\u00bb soit lisible, il faudrait (dans un premier temps) que l'on affiche \u00e0 la place de l'ISBN le titre de l'ouvrage. Or ce titre est disponible dans la table \u00ablivres\u00bb. On va donc proc\u00e9der \u00e0 une jointure de ces deux tables. Exemple 15 : jointure de 2 tables avec JOIN ... ON Commande : SQL SELECT livre . titre , emprunt . code_barre , emprunt . retour FROM emprunt JOIN livre ON emprunt . isbn = livre . isbn ; Traduction : Comme plusieurs tables sont appel\u00e9es, nous pr\u00e9fixons chaque colonne avec le nom de la table. Nous demandons ici l'affichage de la table \u00abemprunt\u00bb, mais o\u00f9 on aura remplac\u00e9 l'ISBN (peu lisible) par le titre du livre. L'expression SQL JOIN livre ON emprunt . isbn = livre . isbn doit se comprendre comme ceci : on \u00abinvite\u00bb la table \u00ablivres\u00bb (dont on va afficher la colonne \u00abtitre\u00bb). La correspondance entre la table \u00ablivres\u00bb et la table \u00abemprunt\u00bb doit se faire sur l'attribut ISBN, qui est la cl\u00e9 primaire de \u00ablivres\u00bb et une cl\u00e9 \u00e9trang\u00e8re d'\u00abemprunts\u00bb. Il est donc tr\u00e8s important de sp\u00e9cifier ce sur quoi les deux tables vont se retrouver (ici, l'ISBN) R\u00e9sultat : Le r\u00e9sultat pr\u00e9c\u00e9dent a permis d'am\u00e9liorer la visibilit\u00e9 de la table \u00abemprunt\u00bb, mais il reste la colonne \u00abcode_barre\u00bb qui est peu lisible. Nous pouvons la remplacer par le titre du livre, en faisant une nouvelle jointure, en invitant maintenant les deux tables \u00ablivre\u00bb et \u00abusager\u00bb. Exemple 16 : jointure de 3 tables Commande : SQL SELECT u . nom , u . prenom , l . titre , e . retour FROM emprunt AS e JOIN livre AS l ON e . isbn = l . isbn JOIN usager AS u ON e . code_barre = u . code_barre ; Traduction : Il faut bien comprendre que la table principale qui nous int\u00e9resse ici est \u00abemprunts\u00bb, mais qu'on modifie les valeurs affich\u00e9es en allant chercher des correspondances dans deux autres tables. Notez ici que des alias sont donn\u00e9s aux tables (par AS ) afin de faciliter l'\u00e9criture. R\u00e9sultat : 2. Cr\u00e9ation et modification d'une base de donn\u00e9es \u2693\ufe0e 2.1 Cr\u00e9ation \u2693\ufe0e L'objectif est de cr\u00e9er la table suivante : id Nom Maths Anglais NSI 1 Alice 16 11 17 2 Bob 12 15 10 3 Charles 9 11 18 La cr\u00e9ation d'une table n'est pas explicitement au programme de NSI. Personne ne sait vraiment pourquoi Exemple 17 : cr\u00e9ation d'une table avec CREATE TABLE Commande : SQL CREATE TABLE Table_notes ( Id INTEGER PRIMARY KEY , Nom TEXT , Maths INTEGER , Anglais INTEGER , NSI INTEGER ); Remarque : C'est l'utilisateur qui sp\u00e9cifie, \u00e9ventuellement, quel attribut sera une cl\u00e9 primaire. R\u00e9sultat : Dans DB Browser, il faut avoir au pr\u00e9alable cr\u00e9\u00e9 une nouvelle base de donn\u00e9es. 2.2 Modification \u2693\ufe0e Par contre, la modification d'une base de donn\u00e9es est au programme. rappel : Exemple 18 : insertion de valeurs avec INSERT INTO ... VALUES Commande : SQL INSERT INTO Table_notes VALUES ( 1 , 'Alice' , 16 , 11 , 17 ), ( 2 , 'Bob' , 12 , 15 , 10 ), ( 3 , 'Charles' , 9 , 11 , 18 ); R\u00e9sultat : Int\u00e9r\u00eat de la cl\u00e9 primaire \u2693\ufe0e Essayons d'ins\u00e9rer un 4\u00e8me enregistrement ayant le m\u00eame id qu'un autre \u00e9l\u00e8ve. Commande : SQL INSERT INTO Table_notes VALUES ( 3 , 'Denis' , 18 , 10 , 12 ); R\u00e9sultat : La contrainte de relation est viol\u00e9e : le SGBD \u00abprot\u00e8ge\u00bb la base de donn\u00e9es en n'acceptant pas la proposition d'insertion. La base de donn\u00e9es n'est pas modifi\u00e9e. Remarque : Il est possible de \u00abd\u00e9l\u00e9guer\u00bb la gestion des valeurs de la cl\u00e9 primaire avec l'instruction AUTOINCREMENT . La d\u00e9claration de la table et l'insertion des valeurs serait : SQL CREATE TABLE Table_notes ( Id INTEGER PRIMARY KEY AUTOINCREMENT , Nom TEXT , Maths INTEGER , Anglais INTEGER , NSI INTEGER ); INSERT INTO Table_notes ( Nom , Maths , Anglais , NSI ) VALUES ( 'Alice' , 16 , 11 , 17 ), ( 'Bob' , 12 , 15 , 10 ), ( 'Charles' , 9 , 11 , 18 ); et le r\u00e9sultat serait : L'attribut id est donc g\u00e9r\u00e9 automatiquement par le SGBD. Exemple 19 : modifier une valeur avec UPDATE , SET Pour modifier la note de Maths d'Alice : Commande : SQL UPDATE Table_notes SET Maths = 18 WHERE Nom = 'Alice' ; 2.3 Suppressions \u2693\ufe0e Exemple 20 : supprimer un enregistrement avec DELETE Pour supprimer totalement la ligne concernant Charles : Commande : SQL DELETE FROM Table_notes WHERE Nom = 'Charles' ; Contrainte de r\u00e9f\u00e9rence : si une autre table contient par exemple l'attribut id comme cl\u00e9 \u00e9trang\u00e8re, et si l' id de Charles fait partie de cette table, le SGBD refusera de supprimer cette ligne, afin de ne pas violer la contrainte de r\u00e9f\u00e9rence. Exemple 21 : suppression totale d'une table avec DROP TABLE Pour supprimer totalement et d\u00e9fitivement la table : Commande : SQL DROP TABLE Table_notes ; Contrainte de r\u00e9f\u00e9rence : l\u00e0 encore, si une autre table est reli\u00e9e \u00e0 Table_notes par une cl\u00e9 \u00e9trang\u00e8re, la suppression sera bloqu\u00e9e par le SGBD.", "title": "Cours"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#langage-sql", "text": "", "title": "Langage SQL"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#0-du-modele-relationnel-au-sgbd", "text": "Les consid\u00e9rations sur le mod\u00e8le relationnel du cours pr\u00e9c\u00e9dent traitaient plut\u00f4t de la structure math\u00e9matique des donn\u00e9es. Il s'agissait de d\u00e9terminer la meilleure structure pour repr\u00e9senter les donn\u00e9es et les relations qui les lient. Il convient maintenant d'aborder la partie logicielle : les SGBD (Syst\u00e8mes de Gestion de Bases de Donn\u00e9es). Les SGBD jouent le r\u00f4le d'interface entre l'\u00eatre humain et la base de donn\u00e9es. Par l'interm\u00e9diaire de requ\u00eates , l'utilisateur va consulter ou modifier la base de donn\u00e9es. Le SGBD est garant de l'int\u00e9grit\u00e9 de cette base, et pr\u00e9vient notamment que les modifications (souvent appel\u00e9es transactions ) ne soient pas pr\u00e9judiciables \u00e0 la base de donn\u00e9es. Le langage utilis\u00e9 pour communiquer avec le SGBD est le langage SQL , pour Structured Query Langage (pour langage de requ\u00eates structur\u00e9es ). Les SGBD les plus utilis\u00e9s sont bas\u00e9s sur le mod\u00e8le relationnel. Parmi eux, citons Oracle, MySQL, Microsoft SQL Server, PostgreSQL, Microsoft Access, SQLite, MariaDB... Mais de plus en plus de SGBD non-relationnels sont utilis\u00e9s, sp\u00e9cialement adapt\u00e9s \u00e0 des donn\u00e9es plus diverses et moins structur\u00e9es. On les retrouve sous l'appelation NoSQL (pour Not only SQL ). Citons parmi eux MongoDB, Cassandra (Facebook), BigTable (Google)... La quasi-totalit\u00e9 de ces SGBD fonctionnent avec un mod\u00e8le client-serveur. Nous allons travailler principalement avec le langage SQLite peut lui s'utiliser directement sans d\u00e9marrer un serveur : la base de donn\u00e9es est enti\u00e8rement repr\u00e9sent\u00e9e dans le logiciel utilisant SQLite (dans notre cas, DB Browser for SQLite). Sa simplicit\u00e9 d'utilisation en fera notre choix pour illustrer cette pr\u00e9sentation du langage SQL.", "title": "0. Du mod\u00e8le relationnel au SGBD"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#1-introduction-au-langage-sql", "text": "Dans toute la suite, nous allons travailler avec la base de donn\u00e9es livres.db qui provient de l'ouvrage paru chez Ellipses, cit\u00e9 en bibliographie.", "title": "1. Introduction au langage SQL"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#10-mise-en-uvre", "text": "Pr\u00e9-requis : T\u00e9l\u00e9charger la base de donn\u00e9es livres.db . Disposer d'un moyen agir sur la base de donn\u00e9es \u00e0 partir de requ\u00eates SQL, soit en ligne soit en utilisant un logiciel externe. 1. En ligne avec sqliteonline.com 2. Avec un logiciel externe : DB Browser for SQLite Rendez vous sur https://sqliteonline.com/ Par File / OpenDB, ouvrez le fichier livres.db pr\u00e9c\u00e9demment t\u00e9l\u00e9charg\u00e9. \u00c9crivez votre requ\u00eate plus cliquez sur Run. Installez DB Browser for SQLite , t\u00e9l\u00e9chargeable \u00e0 l'adresse https://sqlitebrowser.org/ Ouvrez le fichier livres.db . Dans toute la suite, les manipulations sont \u00e0 faire en interrogeant la base de donn\u00e9es livres.db , avec l'une des m\u00e9thodes indiqu\u00e9es ci-dessus. Voici le diagramme relationnel de cette base : les cl\u00e9s primaires sont en bleu (suivi d'une icone de cl\u00e9) les cl\u00e9s \u00e9trang\u00e8res sont en noir et reli\u00e9es \u00e0 leur cl\u00e9 primaire.", "title": "1.0 Mise en \u0153uvre"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#11-selections", "text": "Exemple 1 : \u00e9crire une requ\u00eate basique avec SELECT et FROM Commande : SQL SELECT titre FROM livre ; Traduction : On veut tous les titres de la table \u00ablivre\u00bb. R\u00e9sultat : Remarques Les mots-cl\u00e9s SQL sont traditionnellement \u00e9crits en MAJUSCULES. Le ; signale la fin de l'instruction. Il peut donc \u00eatre omis s'il n'y a pas d'instructions encha\u00een\u00e9es (ce qui sera toujours notre cas). L'indentation n'est pas syntaxique (pas comme en Python). On peut faire des retours \u00e0 la ligne et des indentations pour rendre le code plus lisible. Exemple 2 : \u00e9crire une requ\u00eate filtr\u00e9e avec SELECT , FROM et WHERE Commande : SQL SELECT titre FROM livre WHERE annee >= 1990 ; Traduction : On veut les titres de la table \u00ablivre\u00bb qui sont parus apr\u00e8s (ou en ) 1990; R\u00e9sultat : Le mot-cl\u00e9 WHERE doit \u00eatre suivi d'un bool\u00e9en. Les op\u00e9rateurs classiques = , != , > , >= , < , <= peuvent \u00eatre utilis\u00e9s, mais aussi le mot-cl\u00e9 IN : Exemple 3 : \u00e9crire une requ\u00eate avec plusieurs possibilit\u00e9s avec WHERE ... IN ... Commande : SQL SELECT titre FROM livre WHERE annee IN ( 1990 , 1991 , 1992 ); Traduction : On veut les titres de la table \u00ablivre\u00bb qui sont parus en 1990, 1991 ou 1992. R\u00e9sultat : Exemple 4: \u00e9crire une requ\u00eate avec bool\u00e9ens AND - OR Commande : SQL SELECT titre FROM livre WHERE annee >= 1970 AND annee <= 1980 AND editeur = 'Dargaud' ; Traduction : On veut les titres de la table \u00ablivre\u00bb qui sont parus entre 1970 et 1980 chez l'\u00e9diteur Dargaud; R\u00e9sultat : Exemple 5 : \u00e9crire une requ\u00eate approch\u00e9e avec LIKE Commande : SQL SELECT titre FROM livre WHERE titre LIKE '%Ast\u00e9rix%' ; Traduction : On veut les titres de la table \u00ablivre\u00bb dont le titre contient la cha\u00eene de caract\u00e8res \"Ast\u00e9rix\". Le symbole % est un joker qui peut symboliser n'importe quelle cha\u00eene de caract\u00e8res. R\u00e9sultat : Exemple 6 : s\u00e9lectionner plusieurs colonnes Commande : SQL SELECT titre , isbn FROM livre WHERE annee >= 1990 ; Traduction : On veut les titres et les ISBN de la table \u00ablivre\u00bb qui sont parus apr\u00e8s 1990. R\u00e9sultat : Exemple 7 : s\u00e9lectionner toutes les colonnes avec * Commande : SQL SELECT * FROM livre WHERE annee >= 1990 ; Traduction : On veut toutes les colonnes disponibles de la table \u00ablivre\u00bb pour les livres qui sont parus apr\u00e8s 1990. L'ast\u00e9risque * est un joker ( wildcard en anglais). R\u00e9sultat : Exemple 8 : renommer les colonnes avec AS Commande : SQL SELECT titre AS titre_du_livre FROM livre WHERE annee >= 1990 ; Traduction : Lors de l'affichage du r\u00e9sulats et dans la suite de la requ\u00eate (important), la colonne \"titre\" est renomm\u00e9e \"titre_du_livre\". R\u00e9sultat : Remarque L'alias AS sera souvent utilis\u00e9 pour raccourcir un nom, notamment lors des jointures de plusieurs tables (voir plus loin).", "title": "1.1. S\u00e9lections"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#12-agregations", "text": "Les requ\u00eates effectu\u00e9es jusqu'ici ont juste s\u00e9lectionn\u00e9 des donn\u00e9es gr\u00e2ce \u00e0 diff\u00e9rents filtres : aucune action n'a \u00e9t\u00e9 effectu\u00e9e \u00e0 partir de ces donn\u00e9es. Nous allons maintenant effectuer des op\u00e9rations \u00e0 partir des donn\u00e9es s\u00e9lectionn\u00e9es. On appelle ces op\u00e9rations des op\u00e9rations d'agr\u00e9gation . Exemple 9 : compter avec COUNT Commande : SQL SELECT COUNT ( * ) AS total FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut compter le nombre d'enregistrements de la tables livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00abtotal\u00bb. R\u00e9sultat : Exemple 10 : additionner avec SUM Commande : SQL SELECT SUM ( annee ) AS somme FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut additionner les ann\u00e9es des livres de la tables livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00absomme\u00bb. Attention : dans notre cas pr\u00e9cis, ce calcul n'a aucun sens... R\u00e9sultat : Exemple 11 : faire une moyenne avec AVG Commande : SQL SELECT AVG ( annee ) AS moyenne FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut calculer la moyenne des ann\u00e9es de parution des livres de la table livres comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e \u00abmoyenne\u00bb. Attention : l\u00e0 encore, ce calcul n'a aucun sens... R\u00e9sultat : Exemple 12 : trouver les extremums avec MIN , MAX Commande : SQL SELECT MIN ( annee ) AS minimum FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ; Traduction : On veut trouver la plus petite valeur de la colonne \u00abannee\u00bb parmi les livres de la tables livre comportant le mot \"Ast\u00e9rix\". Le r\u00e9sultat sera le seul \u00e9l\u00e9ment d'une colonne nomm\u00e9e minimum. Le fonctionnement est identique avec MAX pour la recherche du maximum. R\u00e9sultat : Exemple 13 : ordonner des valeurs avec ORDER BY , ASC , DESC , LIMIT Commande : SQL SELECT titre , annee FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ORDER BY annee DESC ; Traduction : On veut afficher tous les albums d'Ast\u00e9rix, et leur ann\u00e9e de parution, class\u00e9s par ann\u00e9e d\u00e9croissante. R\u00e9sultat : Comportement par d\u00e9faut : Si le param\u00e8tre ASC ou DESC est omis, le classement se fait par ordre croissant ( ASC est le param\u00e8tre par d\u00e9faut). Utilisation de LIMIT : Le mot-cl\u00e9 LIMIT (suivi d'un nombre) permet de limiter le nombre de r\u00e9sultats affich\u00e9s. Ainsi la requ\u00eate SQL SELECT titre , annee FROM livre WHERE titre LIKE \"%Ast\u00e9rix%\" ORDER BY annee DESC LIMIT 1 ; permet d'obtenir les renseignements sur l'Ast\u00e9rix le plus r\u00e9cent. Exemple 14 : \u00e9viter les doublons avec DISTINCT Commande : SQL SELECT DISTINCT editeur FROM livre ; Traduction : On veut la liste de tous les \u00e9diteurs. Sans le mot-cl\u00e9 DISTINCT , beaucoup de doublons appara\u00eetraient. R\u00e9sultat :", "title": "1.2. Agr\u00e9gations"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#13-jointures", "text": "Observons le contenu de la table \u00abemprunt\u00bb : SQL SELECT * FROM emprunt ; Le contenu est peu lisible : qui a emprunt\u00e9 quel livre ? Souvenons-nous du diagramme de la base de donn\u00e9es. Pour que la table \u00abemprunt\u00bb soit lisible, il faudrait (dans un premier temps) que l'on affiche \u00e0 la place de l'ISBN le titre de l'ouvrage. Or ce titre est disponible dans la table \u00ablivres\u00bb. On va donc proc\u00e9der \u00e0 une jointure de ces deux tables. Exemple 15 : jointure de 2 tables avec JOIN ... ON Commande : SQL SELECT livre . titre , emprunt . code_barre , emprunt . retour FROM emprunt JOIN livre ON emprunt . isbn = livre . isbn ; Traduction : Comme plusieurs tables sont appel\u00e9es, nous pr\u00e9fixons chaque colonne avec le nom de la table. Nous demandons ici l'affichage de la table \u00abemprunt\u00bb, mais o\u00f9 on aura remplac\u00e9 l'ISBN (peu lisible) par le titre du livre. L'expression SQL JOIN livre ON emprunt . isbn = livre . isbn doit se comprendre comme ceci : on \u00abinvite\u00bb la table \u00ablivres\u00bb (dont on va afficher la colonne \u00abtitre\u00bb). La correspondance entre la table \u00ablivres\u00bb et la table \u00abemprunt\u00bb doit se faire sur l'attribut ISBN, qui est la cl\u00e9 primaire de \u00ablivres\u00bb et une cl\u00e9 \u00e9trang\u00e8re d'\u00abemprunts\u00bb. Il est donc tr\u00e8s important de sp\u00e9cifier ce sur quoi les deux tables vont se retrouver (ici, l'ISBN) R\u00e9sultat : Le r\u00e9sultat pr\u00e9c\u00e9dent a permis d'am\u00e9liorer la visibilit\u00e9 de la table \u00abemprunt\u00bb, mais il reste la colonne \u00abcode_barre\u00bb qui est peu lisible. Nous pouvons la remplacer par le titre du livre, en faisant une nouvelle jointure, en invitant maintenant les deux tables \u00ablivre\u00bb et \u00abusager\u00bb. Exemple 16 : jointure de 3 tables Commande : SQL SELECT u . nom , u . prenom , l . titre , e . retour FROM emprunt AS e JOIN livre AS l ON e . isbn = l . isbn JOIN usager AS u ON e . code_barre = u . code_barre ; Traduction : Il faut bien comprendre que la table principale qui nous int\u00e9resse ici est \u00abemprunts\u00bb, mais qu'on modifie les valeurs affich\u00e9es en allant chercher des correspondances dans deux autres tables. Notez ici que des alias sont donn\u00e9s aux tables (par AS ) afin de faciliter l'\u00e9criture. R\u00e9sultat :", "title": "1.3 Jointures"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#2-creation-et-modification-dune-base-de-donnees", "text": "", "title": "2. Cr\u00e9ation et modification d'une base de donn\u00e9es"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#21-creation", "text": "L'objectif est de cr\u00e9er la table suivante : id Nom Maths Anglais NSI 1 Alice 16 11 17 2 Bob 12 15 10 3 Charles 9 11 18 La cr\u00e9ation d'une table n'est pas explicitement au programme de NSI. Personne ne sait vraiment pourquoi Exemple 17 : cr\u00e9ation d'une table avec CREATE TABLE Commande : SQL CREATE TABLE Table_notes ( Id INTEGER PRIMARY KEY , Nom TEXT , Maths INTEGER , Anglais INTEGER , NSI INTEGER ); Remarque : C'est l'utilisateur qui sp\u00e9cifie, \u00e9ventuellement, quel attribut sera une cl\u00e9 primaire. R\u00e9sultat : Dans DB Browser, il faut avoir au pr\u00e9alable cr\u00e9\u00e9 une nouvelle base de donn\u00e9es.", "title": "2.1 Cr\u00e9ation"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#22-modification", "text": "Par contre, la modification d'une base de donn\u00e9es est au programme. rappel : Exemple 18 : insertion de valeurs avec INSERT INTO ... VALUES Commande : SQL INSERT INTO Table_notes VALUES ( 1 , 'Alice' , 16 , 11 , 17 ), ( 2 , 'Bob' , 12 , 15 , 10 ), ( 3 , 'Charles' , 9 , 11 , 18 ); R\u00e9sultat :", "title": "2.2 Modification"}, {"location": "T4_Bases_de_donnees/4.2_Langage_SQL/cours/#23-suppressions", "text": "Exemple 20 : supprimer un enregistrement avec DELETE Pour supprimer totalement la ligne concernant Charles : Commande : SQL DELETE FROM Table_notes WHERE Nom = 'Charles' ; Contrainte de r\u00e9f\u00e9rence : si une autre table contient par exemple l'attribut id comme cl\u00e9 \u00e9trang\u00e8re, et si l' id de Charles fait partie de cette table, le SGBD refusera de supprimer cette ligne, afin de ne pas violer la contrainte de r\u00e9f\u00e9rence. Exemple 21 : suppression totale d'une table avec DROP TABLE Pour supprimer totalement et d\u00e9fitivement la table : Commande : SQL DROP TABLE Table_notes ; Contrainte de r\u00e9f\u00e9rence : l\u00e0 encore, si une autre table est reli\u00e9e \u00e0 Table_notes par une cl\u00e9 \u00e9trang\u00e8re, la suppression sera bloqu\u00e9e par le SGBD.", "title": "2.3 Suppressions"}, {"location": "T5_Architecture_materielle/sommaire/", "text": "Autour de GNU/Linux Syst\u00e8mes sur puce Gestion des processus Protocoles de routage Cryptographie", "title": "Sommaire"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/", "text": "OS & GNU/Linux \u2693\ufe0e 1. Syste\u0300mes d'exploitations : \u2693\ufe0e 1.1. De\u0301finition et historique \u2693\ufe0e D'apre\u0300s la de\u0301finition de Wikipedia \u00ab En informatique, un syste\u0300me d'exploitation (souvent appele\u0301 OS \u2014 de l'anglais O perating S ystem) est un ensemble de programmes qui dirige l'utilisation des ressources d'un ordinateur par des logiciels applicatifs. Il rec\u0327oit des demandes d'utilisation des ressources de l'ordinateur \u2014 ressources de stockage des me\u0301moires (par exemple des acce\u0300s a\u0300 la me\u0301moire vive, aux disques durs), ressources de calcul du processeur central, ressources de communication vers des pe\u0301riphe\u0301riques [...] ou via le re\u0301seau \u2014 de la part des logiciels applicatifs. Le syste\u0300me d'exploitation ge\u0300re les demandes ainsi que les ressources ne\u0301cessaires e\u0301vitant les interfe\u0301rences entre les logiciels. \u00bb Historique Les anne\u0301es 1960 ont constitue\u0301 un tournant pour les syste\u0300me d'exploitation. Au MIT (Massachusset Institute of Technology), le syste\u0300me d'exploitation CTTS (Compatible Time Sharing System) est publie\u0301 en 1961. C'est l'un des tout premiers syste\u0300me d'exploitation a\u0300 temps partage\u0301 , permettant a\u0300 plusieurs utilisateurs d'utiliser un ordinateur en me\u0302me temps . Cette apparente simultane\u0301ite\u0301 dans l'exe\u0301cution des programmes a permis de se diriger vers l'informatique moderne. Le MIT s'associa aux laboratoires BELL et a\u0300 General Electric pour cre\u0301er Multics qui e\u0301tait un syste\u0300me innovant, he\u0301ritant de CTTS . C'e\u0301tait l'un des premier syste\u0300me d'exploitation avec syste\u0300me de fichier hie\u0301rarchique, temps partage\u0301, multita\u0302che pre\u0301emptif (c'est- a\u0300-dire la capacite\u0301 d'arre\u0302ter ou d'exe\u0301cuter une ta\u0302che planifie\u0301e en cours), multiutilisateur, avec une prise en compte de la se\u0301curite\u0301. La premie\u0300re version sortit en 1965. En 1969, les laboratoires BELL sortirent du projet et deux de leurs plus brillants informaticiens, Ken THOMPSON et Dennis RITCHIE qui avaient travaille\u0301 sur le projet Multics en conc\u0327urent une version simplifie\u0301e (ils conside\u0301raient Multics inutilement complexe) qu'ils nomme\u0300rent initialement UNICS (UNiplexed Information and Computing Service) puis UNIX . L'informatique moderne e\u0301tait ne\u0301e ! Au fil des anne\u0301es, des surcouches de plus en plus complexes sont ajoute\u0301es aux syste\u0300mes d'exploitations afin de ge\u0301rer par exemple les entre\u0301es claviers, puis souris, et une interface graphique est ajoute\u0301e, simplifiant la ta\u0302che pour l'utilisateur. Chaque ordinateur doit donc disposer d'un OS afin de pouvoir faire fonctionner les diffe\u0301rents logiciels en paralle\u0300le. Historiquement, chaque fabriquant d'ordinateur a de\u0301veloppe\u0301 en partie son OS. On pourra, de manie\u0300re non-exhaustive, citer : OS/360 par IBM , en 1968 ; DOS par Microsoft en 1981 ; Mac OS par Apple en 1984 ; Windows 3.X par Microsoft en 1990 ; GNU/Linux par la communaute\u0301 en 1991 ; Android par Google en 2007 ; iOS par Apple en 2007. 1.2 GNU/Linux \u2693\ufe0e En 1985, Richard Stallman quitte le MIT pour e\u0301crire un syste\u0300me d'exploitation compatible Unix : GNU ( G nu is N ot U nix). Oppose\u0301 au principe du logiciel \u00ab proprie\u0301taire \u00bb, il publie le manifeste GNU, ou\u0300 il expose ses ide\u0301es de logiciel libre , permettant a\u0300 chacun de s'approprier, de modifier et de diffuser le code source d'un logiciel. Exercice 1 Se rendre sur Wikip\u00e9dia et expliquer pourquoi il ne faut pas confondre les termes suivants: logiciel libre (free software, libre software ou libreware) ; gratuiciels (freewares) ; open source. En 1991, Linus Torvalds , e\u0301tudiant norve\u0301gien de 21 ans, indispos\u00e9 par la faible disponibilit\u00e9 de serveur UNIX de l'universit\u00e9 d'Helsinki de\u0301cide d'e\u0301crire un mini OS de\u0301rive\u0301 d'Unix pour son PC. Il \u00e9crit un noyau auquel il adapte de nombreux composants disponibles du projet GNU . Re\u0301pute\u0301 pour sa stabilite\u0301 (mais aussi pour sa complexite\u0301 d'installation), GNU/Linux appel\u00e9 commun\u00e9ment Linux est adopte\u0301 par une grande communaute\u0301 de bidouilleurs ( hacker ) sur l'internet, qui e\u0301tendent re\u0301gulie\u0300rement ses possibilite\u0301s. Sans publicite\u0301, soutenu par la communaute\u0301 du libre et de l' open-source , Linux se re\u0301pand doucement et devient rapidement une alternative cre\u0301dible a\u0300 Windows , a\u0300 tel point que 90 % des serveurs du cloud sont des serveurs Linux . Linus Torvalds continue a\u0300 diriger le de\u0301veloppement de Linux , et est conside\u0301re\u0301 comme le \u00ab dictateur bienveillant a\u0300 vie \u00bb (Benevolent Dictator for Life) de celui-ci. Si, \u00e0 l'origine, Linux a \u00e9t\u00e9 d\u00e9velopp\u00e9 pour les ordinateurs compatibles PC, il n'a jamais \u00e9quip\u00e9 qu'une tr\u00e8s faible part des ordinateurs personnels. Mais le noyau Linux , accompagn\u00e9 ou non des logiciels GNU , est \u00e9galement utilis\u00e9 par d'autres types de syst\u00e8mes informatiques, notamment les serveurs, t\u00e9l\u00e9phones portables, syst\u00e8mes embarqu\u00e9s ou encore superordinateurs. Le syst\u00e8me d'exploitation pour t\u00e9l\u00e9phones portables Android qui utilise le noyau Linux (mais pas GNU ) \u00e9quipe aujourd'hui 85 % des tablettes tactiles et smartphones. 2. O\u00f9 pratiquer ? \u2693\ufe0e Si vous utilisez d\u00e9j\u00e0 Linux ou un mac vous n'avez rien \u00e0 installer. Sinon, pour faire vos premiers pas, selon les modalite\u0301s \u00e0 votre disposition, vous avez les solutions suivantes: En ligne Avec WSL Sur Raspberry Pi Le site https://www.pythonanywhere.com permet de cr\u00e9er un compte gratuit pour programmer en python ou pour disposer d'un terminal sous Linux . Windows Subsystem for Linux (WSL) est une couche de compatibilite\u0301 permettant d'exe\u0301cuter des exe\u0301cutables binaires Linux de manie\u0300re native sur les dernie\u0300res versions de Windows (a\u0300 partir de windows 10). La version WSL 2,sortie en mai 2019, introduit la pre\u0301sence d'un ve\u0301ritable noyau Linux . Installation sur WSL Pour installer la distribution Ubuntu, lancer l'invite de commande windows, puis : wsl -install -d Ubuntu Utilisation de WSL Une fois installe\u0301, vous avez acce\u0300s a\u0300 la distribution depuis l'invite de commande windows par l'interme\u0301diaire de la commande wsl . Vous acce\u0301dez alors a\u0300 un terminal Linux tout ce qui est des plus classique Le prompt est de la forme nom_utilisateur@nom_machine : chemin_dossier_courant $ . Normalement, votre re\u0301pertoire courant est symbolise\u0301 par ~ , ce qui est un raccourci pour symboliser le re\u0301pertoire personnel de l'utilisateur. Installation sur Raspberry Pi 4 Il existe des distributions Linux spe\u0301cifiques pour Rasberry 4, mais nous utiliserons Raspberry Pi OS (anciennement connu sous le nom de Raspbian ), qui est une distribution base\u0301e sur Linux Debian spe\u0301cialement optimise\u0301 pour Rasberry Pi. Une image est te\u0301le\u0301chargeable ici Une fois l'image installe\u0301e sur une carte micro-SD, le mini-ordinateur devrait-e\u0302tre imme\u0301diatement fonctionnel. Exercice Suivez toutes les e\u0301tapes d'installation de l'OS Raspebbry Pi OS , en cre\u0301ant un utilisateur administrateur avec votre nom de famille + premie\u0300re lettre de votre pre\u0301nom, et un mot de passe simple . Le terminal Pour obtenir la ligne de commande dans Raspbian, il faut lancer le programme Terminal . Le prompt est de la forme nom_utilisateur@nom_machine : chemin_dossier_courant $ . Normalement, votre re\u0301pertoire courant est symbolise\u0301 par ~ , ce qui est un raccourci pour symboliser le re\u0301pertoire personnel de l'utilisateur. 3. Le Shell Linux \u2693\ufe0e 3.1. Bash \u2693\ufe0e Bash (acronyme de Bourne-Again shell) est un interpre\u0301teur en ligne de commande de type script. C\u2019est le shell Unix(l'interpre\u0301teur de commande) du projet GNU. Le terminal fonctionne avec le principe REPL : Read Eval Print Loop. Read : L\u2019utilisateur tape une commande qui est lue par l\u2019interpr\u00e9teur, Eval : Cette commande est ex\u00e9cut\u00e9e et retourne une cha\u00eene de caract\u00e8res, Print : La cha\u00eene de caract\u00e8res est affich\u00e9e \u00e0 l\u2019\u00e9cran, Loop : On recommence. Comme tous les interpre\u0301teurs en ligne de commande de type script, Bash exe\u0301cute quatre ope\u0301rations fondamentales: Il fournit une liste de commandes permettant d\u2019ope\u0301rer sur l\u2019ordinateur (lancement de programmes, copie de fichiers, etc.) et il permet de regrouper ces commandes dans un fichier unique appele\u0301 script ; Il ve\u0301rifie la ligne de commande lors de son exe\u0301cution ou lors d\u2019une e\u0301ventuelle proce\u0301dure de ve\u0301rification et renvoie un message d\u2019erreur en cas d\u2019erreur de syntaxe ; En cas de validation, chaque ligne de commande est interpre\u0301te\u0301e, c\u2019est-a\u0300-dire traduite dans un langage compre\u0301hensible par le syste\u0300me d\u2019exploitation qui l\u2019exe\u0301cute alors. Les scripts sont de courts programmes ge\u0301ne\u0301ralement faciles a\u0300 construire. Bash offre un service de gestion de flux, c\u2019est-a\u0300-dire qu\u2019il permet que le re\u0301sultat d\u2019un script (la sortie) soit transmis a\u0300 un autre script (l\u2019entre\u0301e). De cette fac\u0327on, les scripts peuvent e\u0302tre \u00ab chai\u0302ne\u0301s \u00bb, chacun effectuant une seule ta\u0302che bien de\u0301limite\u0301e. Les scripts peuvent e\u0302tre exe\u0301cute\u0301s manuellement par l\u2019utilisateur ou automatiquement par le syste\u0300me. Par exemple, dans la distribution GNU/Linux Ubuntu , le re\u0301pertoire resume.d contient un certain nombre de scripts qui s\u2019exe\u0301cutent automatiquement lors du rede\u0301marrage du syste\u0300me, c\u2019est-a\u0300-dire apre\u0300s la fin de la mise en veille de celui-ci. Ces scripts servent a\u0300 relancer les diffe\u0301rents programmes interrompus par la mise en veille. 3.2. Le syste\u0300me de fichiers \u2693\ufe0e Sur un syste\u0300me Linux , tout est un fichier , y compris un dossier. Mais pour rester compatible avec l'arborescence classique de windows, nous parlerons donc de : fichier lorsqu'il s'agit d'une feuille de l'arborescence ; dossier lorsqu'on parle d'un n\u0153ud ayant des enfants. Pour naviguer dans l'arborescence, il est ne\u0301cessaire de connai\u0302tre deux commandes: la commande ls pour List , qui permet de lister tous les enfants du re\u0301pertoire courant dans l'arborescence et peut utiliser les options suivantes : ls -a affiche les fichiers cache\u0301s; ls -R afiche tous les fichiers dans les sous-re\u0301pertoires(de manie\u0300re re\u0301cursive ); ls -l affichera les de\u0301tails des fichiers (autorisations, taille, proprie\u0301taires, etc...). la commande cd pour Change Directory , qui peut s'utiliser selon les manie\u0300res suivantes : cd ~ , rame\u0300ne au re\u0301pertoire de l'utilisateur courant; cd nom_du_repertoire_enfant , qui de\u0301place le prompt dans le re\u0301pertoire enfant se\u0301lectionne\u0301 (adressage relatif); cd /chemin/absolu/vers/un re\u0301pertoire , qui de\u0301place vers le re\u0301pertoire cible (adressage absolu); cd .. qui permet de remonter au re\u0301pertoire parent. Exercice 2 Se repe\u0301rer dans l'arborescence: Remonter l'arborescence jusqu'a\u0300 la racine. Donner le chemin absolu de votre re\u0301pertoire personnel \u00e0 partir de la racine. Se d\u00e9placer jusqu'au re\u0301pertoire /usr/bin et lister les fichiers pre\u0301sents. Retourner dans le dossier personnel, puis lister les fichiers pre\u0301sents, en affichant les de\u0301tails. Quelles sont les informations donne\u0301es ? Quels sont les utilisateurs recense\u0301s du syste\u0300me ? Les dossiers syste\u0300mes Linux Dans un syste\u0300me de type UNIX , on dispose d'une arborescence de fichiers dont la racine est / , puis d'un certain nombres de re\u0301pertoires dont voici les principaux e\u0301le\u0301ments : / \u251c\u2500\u2500 bin \u2190 Commandes de base du syste\u0300me \u251c\u2500\u2500 dev \u2190 Fichiers repre\u0301sentant les dispositifs mate\u0301riels (devices) du syste\u0300me \u251c\u2500\u2500 etc \u2190 Fichiers de configuration du syste\u0300me \u251c\u2500\u2500 home \u2190 Re\u0301pertoire d'accueil (HOME) des utilisateurs \u251c\u2500\u2500 lib \u2190 Librairies \u251c\u2500\u2500 mnt \u2190 Points de montage (cle\u0301s usb etc.) \u251c\u2500\u2500 proc \u2190 E\u0301tat du syste\u0300me et de ses processus \u251c\u2500\u2500 root \u2190 Re\u0301pertoire de l'administrateur syste\u0300me \u251c\u2500\u2500 run \u2190 Variables d'e\u0301tat du syste\u0300me depuis le boot \u251c\u2500\u2500 sys \u2190 Informations sur le noyau et les pe\u0301riphe\u0301riques \u251c\u2500\u2500 usr \u2190 Logiciels installe\u0301s avec le syste\u0300me, base de donne\u0301es etc. \u2514\u2500\u2500 var \u2190 Donne\u0301es fre\u0301quemment utilise\u0301es et modifie\u0301es 3.3. Les utilisateurs et les droits \u2693\ufe0e En Linux , tout fichier, et par extension dossier, appartient a\u0300 un proprie\u0301taire ainsi qu'a\u0300 un groupe et un utilisateur quelconque ne pourra pas force\u0301ment avoir tous les droits sur un fichier qui ne lui appartient pas. Par exemple, e\u0301tudions la sortie suivante donne\u0301e par la commande ls -l : Bash -rw-r--r-- 1 raoul staff 21359 2024 -06-07 02 :16 cours.md drwx------@ 887 raoul staff 28384 6 jui 22 :22 Downloads - indique que l'\u00e9l\u00e9ment trouv\u00e9 est un fichier alors que d indique qu'il s'agit d'un dossier; les 3\u00d73=9 lettres suivantes indiquent les droits dont disposent les diff\u00e9rents utilisateurs sur ce fichier; @ est pour nous sans int\u00e9r\u00eat (il indique que l'existence d' attributs \u00e9tendus ) le nombre suivant est pour nous sans inte\u0301re\u0302t (il s'agit d'un compteur de liaison) ; le groupe de lettre suivant est le nom de l' utilisateur proprie\u0301taire du fichier ou dossier ; le groupe de lettre suivant est le nom du groupe proprie\u0301taire du fichier ou dossier ; 21359 et 28384 repre\u0301sentent respectivement la taille en octet du fichier et celle du dossier ; on trouve ensuite la date et l'heure de la dernie\u0300re modification ; enfin le nom du fichier ou du dossier. Les utilisateurs Pour un fichier, on distinguera trois types d'utilisateurs : u pour user , c'est-a\u0300-dire le proprie\u0301taire du fichier ; g pour group , le groupe auquel appartient le fichier ; o pour other , tous les autres utilisateurs. Super-Utilisateur Par de\u0301faut, il existe un super-utilisateur nomme\u0301 root qui posse\u0300de tous les droits sur un os Linux . Pour modifier des attributs au niveau syste\u0300me, il faut prendre les droits de super-utilisateur, gra\u0302ce a\u0300 la commande sudo (super-user do). Cette commande demande syste\u0301matiquement a\u0300 l'utilisateur faisant partie du groupe des super-utilisateurs ( sudoers ) de confirmer avec son mot de passe (celui choisi a\u0300 l'installation du syste\u0300me) toute action de modification effectue\u0301e au niveau du syst\u00e8me. Par exemple pour une mise a\u0300 jour sous Ubuntu, on tapera les commandes suivantes : Mise a\u0300 jour de la base de donne\u0301e des paquets syste\u0300mes : Bash sudo apt update mise a\u0300 jour des paquets : Bash sudo apt upgrade Attention ! Avec de grands pouvoirs viennent de grandes responsabilite\u0301s ! Les droits Pour un fichier donne\u0301, on distinguera 4 permissions : r : read , droit de lire le fichier ; w : write , droit de modifier le fichier ; x : execute , droit d'ex\u00e9cution du fichier ; - : aucun droit sur le fichier. Exercice 3 Quels sont les droits des utilisateurs sur le dossier Te\u0301le\u0301chargements de mon PC ? Attribution des permissions Pour donner ou supprimer des permissions sur un fichier mon_texte.txt , on utilise la commande chmod de la manie\u0300re suivante : Pour donner les droits en lecture et e\u0301criture a\u0300 l'utilisateur: Bash chmod u+rw mon_texte.txt Pour supprimer les droits en modification au groupe : Bash chmod g-w mon_texte.txt Pour supprimer tous les droits aux autres utilisateurs : Bash chmod o-rwx mon_texte.txt Il est aussi possible d'utiliser la notation octale pour ge\u0301rer ces droits. Par exemple, avec la commande suivante : Bash chmod 640 mon_texte.txt en sachant que r = 4 , w = 2 , x = 1 , et que le premier chiffre correspond a\u0300 l'utilisateur, le second au groupe, et le troisie\u0300me aux autres. Ainsi ici : l'utilisateur a\u0300 les droits de lecture et d'e\u0301criture (4+2 = 6) ; le groupe a\u0300 le droit de lecture (4) ; les autres n'ont aucun droit (0). Une commande telle que chmod 777 mon_texte.txt done tous les droits de lecture, e\u0301criture et exe\u0301cution a\u0300 tous les utilisateurs du syste\u0300me. Exercice 4 Copiez un fichier quelconque depuis votre session Windows vers votre session WSL par l'interme\u0301diaire de l'explorateur de fichier de windows. Quels sont les droits sur ce fichier ? Modifiez-les de manie\u0300re a\u0300 ce que seul l'utilisateur principal (vous) ait des droits de lecture, e\u0301criture et exe\u0301cution sur ce fichier, et que les autres n'aient qu'un droit de lecture. 3.4. Les principales commandes Shell sous Linux \u2693\ufe0e Voici, de manie\u0300re non-exhaustive, quelques-unes des commandes les plus utiles sous Linux : Les principales commandes pwd man cat cp mv mkdir rmdir rm touch find locate grep head tail diff ( p rint w orking d irectory) Donne le chemin absolu du re\u0301pertoire courant. ( man ual) Donne le manuel de la commande passe\u0301e en argument. Exemple: man pwd affiche le manuel de la commande pwd (con cat enate) Son utilisation simple est d'afficher le contenu d'un fichier directement dans le terminal. Cependant cette commande permet bien d'autres choses : cat > nv_fichier.txt : cre\u0301e un nouveau fichier dans le re\u0301pertoire courant, et le remplit avec les saisies de l'utilisateur ( Ctrl + C pour quitter) ; cat fichier1 fichier2 > fichier3 : concate\u0300ne les contenus des fichiers 1 et 2 dans un nouveau fichier. Remarque: Pour cr\u00e9er un fichier vide on utilise plut\u00f4t la commande touch . ( c o p y) Copie un fichier dans un dossier. Exemple: cp bidule.jpg /home/bob/photo copie le fichier bidule.jpg vers le re\u0301pertoire /home/bob/photo , si les permissions sont correctement attribue\u0301es. ( m o v e) De\u0301place un fichier vers un re\u0301pertoire cible, et par extension permet de renommer un fichier . Exemples: mv bidule.jpg /home/bob/photo de\u0301place le fichier bidule.jpg vers /home/bob/photo ; mv bidule.jpg truc.jpg renomme le fichier bidule.jpg en truc.jpg . ( m a k e dir ectory) Cre\u0301e un nouveau re\u0301pertoire dont le nom est passe\u0301 en argument. Exemple: mkdir nv_dossier ( r e m ove dir ectory) Supprime un re\u0301pertoire vide dont le nom est passe\u0301 en argument. Exemple: rmdir nom_dossier ( r e m ove) Supprime le ou les fichiers passe\u0301s en arguments. Attention a\u0300 cette commande qui peut tout casser Exemples: rm mon_fichier : supprime mon_fichier rm * : supprime tous les fichiers du re\u0301pertoire courant ! rm -R : supprime de manie\u0300re re\u0301cursive tous les fichiers et sous-dossiers du re\u0301pertoire courant !!! Permet de cre\u0301er un nouveau fichier vide en lui passant le nom en argument. Ce n'est pas la peine d'utiliser la commande cat pour cr\u00e9er un fichier vide. Exemple: touch nv_fichier Permet de chercher des fichiers et/ou des dossiers dans un dossier donne\u0301. Exemple: find /home/ -name mon_texte.txt : cherche le fichier mon_texte.txt dans le re\u0301pertoire home et tous ses sous-dossiers. Permet de donner la localisation d'un fichier dans le syste\u0300me de fichier. Remarques: Le r\u00e9sultat de la commande locate est tre\u0300s rapide \u00e0 obtenir, car elle utilise une base de donne\u0301e mise a\u0300 jour re\u0301gulie\u0300rement qui recense tous les fichiers du syste\u0300me. Cependant, la mise a\u0300 jour de cette base de donne\u0301e n'est pas imme\u0301diate, donc les modifications re\u0301centes ne sont pas prises en compte. Si l'on a les droits super-utilisateur on peut mettre \u00e0 jour la base de donn\u00e9es avec la commande sudo updatedb . ( G lobal R egular E xpression P rint) Permet de chercher une chai\u0302ne de caracte\u0300re dans un fichier. Ce qui est d\u00e9j\u00e0 utile mais cette commande permet aussi aux utilisateurs de sp\u00e9cifier des mod\u00e8les \u00e0 l'aide d'expressions r\u00e9guli\u00e8res, puis de rechercher des lignes qui leur correspondent. Ce qui en fait un outil tr\u00e8s puissant. Syntaxe: grep [options] mod\u00e8le [fichier...] Exemples: grep \"toto\" bob.txt utilisation basique qui renverra toutes les lignes du fichier bob.txt contenant la chai\u0302ne toto . grep \"linux\" /path/to/directory/* renverra toutes les lignes contenant la cha\u00eene linux dans les diff\u00e9rents fichiers du r\u00e9pertoire indiqu\u00e9. grep -i \"important\" /path/to/directory/* o\u00f9 l'option -i permet de rendre la recherche insensible \u00e0 la casse . grep -c \"pattern\" /path/to/directory/* o\u00f9 l'option -c permet de compter le nombre d'occurences. grep -r \"pattern\" /path/to/directory/ o\u00f9 l'option -r permet de chercher de fa\u00e7on r\u00e9cursive dans les sous-dossiers. Remarque: grep est tre\u0300s efficace sur les fichiers comptenant du texte, mais ne fonctionne pas correctement sur les fichiers pdf, odt ... Renvoie les 10 premie\u0300res lignes d'un fichier. On peut parame\u0301trer le nombre de lignes obtenues avec l'option -n Exemple: head -n 5 bob.txt envoie les 5 premie\u0300res lignes du fichier bob.txt . Fonctionne de la me\u0302me manie\u0300re que head , mais en renvoyant les 10 dernie\u0300res lignes. Compare deux fichiers ligne par ligne et renvoie toutes celles pre\u0301sentant une diffe\u0301rence. Pratique! Exercice 5 Te\u0301le\u0301charger le fichier Arborescence.tar.gz Cre\u0301er un dossier TP dans le dossier personnel Copier le fichier pre\u0301ce\u0301dent dans ce dossier, puis le de\u0301compresser avec la commande Bash tar -xzf Arborescence.tar.gz Attention, la d\u00e9compression peut durer plusieurs minutes. Vous aurez besoin de la commande locate qui n'est pas installe\u0301e. Exe\u0301cutez la commande suivante pour installer le paquet ne\u0301cessaire a\u0300 son utilisation : Bash sudo apt install plocate Pour de\u0301buter, chercher le fichier commencement.txt dans l'arborescence, et le lire ! Bon courage, vous aurez probablement a\u0300 chercher en paralle\u0300le sur des commandes spe\u0301cifiques avec les options qui vont bien pour parvenir a\u0300 la fin de ce TP ! (Petit point de de\u0301tail, si une commande vous semble trop longue, vous pouvez l'interrompre avec le raccourci clavier Ctrl + C ).", "title": "5.0 OS & GNU/Linux"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#os-gnulinux", "text": "", "title": "OS &amp; GNU/Linux"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#1-systemes-dexploitations", "text": "", "title": "1. Syste\u0300mes d'exploitations :"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#11-definition-et-historique", "text": "D'apre\u0300s la de\u0301finition de Wikipedia \u00ab En informatique, un syste\u0300me d'exploitation (souvent appele\u0301 OS \u2014 de l'anglais O perating S ystem) est un ensemble de programmes qui dirige l'utilisation des ressources d'un ordinateur par des logiciels applicatifs. Il rec\u0327oit des demandes d'utilisation des ressources de l'ordinateur \u2014 ressources de stockage des me\u0301moires (par exemple des acce\u0300s a\u0300 la me\u0301moire vive, aux disques durs), ressources de calcul du processeur central, ressources de communication vers des pe\u0301riphe\u0301riques [...] ou via le re\u0301seau \u2014 de la part des logiciels applicatifs. Le syste\u0300me d'exploitation ge\u0300re les demandes ainsi que les ressources ne\u0301cessaires e\u0301vitant les interfe\u0301rences entre les logiciels. \u00bb Historique Les anne\u0301es 1960 ont constitue\u0301 un tournant pour les syste\u0300me d'exploitation. Au MIT (Massachusset Institute of Technology), le syste\u0300me d'exploitation CTTS (Compatible Time Sharing System) est publie\u0301 en 1961. C'est l'un des tout premiers syste\u0300me d'exploitation a\u0300 temps partage\u0301 , permettant a\u0300 plusieurs utilisateurs d'utiliser un ordinateur en me\u0302me temps . Cette apparente simultane\u0301ite\u0301 dans l'exe\u0301cution des programmes a permis de se diriger vers l'informatique moderne. Le MIT s'associa aux laboratoires BELL et a\u0300 General Electric pour cre\u0301er Multics qui e\u0301tait un syste\u0300me innovant, he\u0301ritant de CTTS . C'e\u0301tait l'un des premier syste\u0300me d'exploitation avec syste\u0300me de fichier hie\u0301rarchique, temps partage\u0301, multita\u0302che pre\u0301emptif (c'est- a\u0300-dire la capacite\u0301 d'arre\u0302ter ou d'exe\u0301cuter une ta\u0302che planifie\u0301e en cours), multiutilisateur, avec une prise en compte de la se\u0301curite\u0301. La premie\u0300re version sortit en 1965. En 1969, les laboratoires BELL sortirent du projet et deux de leurs plus brillants informaticiens, Ken THOMPSON et Dennis RITCHIE qui avaient travaille\u0301 sur le projet Multics en conc\u0327urent une version simplifie\u0301e (ils conside\u0301raient Multics inutilement complexe) qu'ils nomme\u0300rent initialement UNICS (UNiplexed Information and Computing Service) puis UNIX . L'informatique moderne e\u0301tait ne\u0301e ! Au fil des anne\u0301es, des surcouches de plus en plus complexes sont ajoute\u0301es aux syste\u0300mes d'exploitations afin de ge\u0301rer par exemple les entre\u0301es claviers, puis souris, et une interface graphique est ajoute\u0301e, simplifiant la ta\u0302che pour l'utilisateur. Chaque ordinateur doit donc disposer d'un OS afin de pouvoir faire fonctionner les diffe\u0301rents logiciels en paralle\u0300le. Historiquement, chaque fabriquant d'ordinateur a de\u0301veloppe\u0301 en partie son OS. On pourra, de manie\u0300re non-exhaustive, citer : OS/360 par IBM , en 1968 ; DOS par Microsoft en 1981 ; Mac OS par Apple en 1984 ; Windows 3.X par Microsoft en 1990 ; GNU/Linux par la communaute\u0301 en 1991 ; Android par Google en 2007 ; iOS par Apple en 2007.", "title": "1.1. De\u0301finition et historique"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#12-gnulinux", "text": "En 1985, Richard Stallman quitte le MIT pour e\u0301crire un syste\u0300me d'exploitation compatible Unix : GNU ( G nu is N ot U nix). Oppose\u0301 au principe du logiciel \u00ab proprie\u0301taire \u00bb, il publie le manifeste GNU, ou\u0300 il expose ses ide\u0301es de logiciel libre , permettant a\u0300 chacun de s'approprier, de modifier et de diffuser le code source d'un logiciel. Exercice 1 Se rendre sur Wikip\u00e9dia et expliquer pourquoi il ne faut pas confondre les termes suivants: logiciel libre (free software, libre software ou libreware) ; gratuiciels (freewares) ; open source. En 1991, Linus Torvalds , e\u0301tudiant norve\u0301gien de 21 ans, indispos\u00e9 par la faible disponibilit\u00e9 de serveur UNIX de l'universit\u00e9 d'Helsinki de\u0301cide d'e\u0301crire un mini OS de\u0301rive\u0301 d'Unix pour son PC. Il \u00e9crit un noyau auquel il adapte de nombreux composants disponibles du projet GNU . Re\u0301pute\u0301 pour sa stabilite\u0301 (mais aussi pour sa complexite\u0301 d'installation), GNU/Linux appel\u00e9 commun\u00e9ment Linux est adopte\u0301 par une grande communaute\u0301 de bidouilleurs ( hacker ) sur l'internet, qui e\u0301tendent re\u0301gulie\u0300rement ses possibilite\u0301s. Sans publicite\u0301, soutenu par la communaute\u0301 du libre et de l' open-source , Linux se re\u0301pand doucement et devient rapidement une alternative cre\u0301dible a\u0300 Windows , a\u0300 tel point que 90 % des serveurs du cloud sont des serveurs Linux . Linus Torvalds continue a\u0300 diriger le de\u0301veloppement de Linux , et est conside\u0301re\u0301 comme le \u00ab dictateur bienveillant a\u0300 vie \u00bb (Benevolent Dictator for Life) de celui-ci. Si, \u00e0 l'origine, Linux a \u00e9t\u00e9 d\u00e9velopp\u00e9 pour les ordinateurs compatibles PC, il n'a jamais \u00e9quip\u00e9 qu'une tr\u00e8s faible part des ordinateurs personnels. Mais le noyau Linux , accompagn\u00e9 ou non des logiciels GNU , est \u00e9galement utilis\u00e9 par d'autres types de syst\u00e8mes informatiques, notamment les serveurs, t\u00e9l\u00e9phones portables, syst\u00e8mes embarqu\u00e9s ou encore superordinateurs. Le syst\u00e8me d'exploitation pour t\u00e9l\u00e9phones portables Android qui utilise le noyau Linux (mais pas GNU ) \u00e9quipe aujourd'hui 85 % des tablettes tactiles et smartphones.", "title": "1.2 GNU/Linux"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#2-ou-pratiquer", "text": "Si vous utilisez d\u00e9j\u00e0 Linux ou un mac vous n'avez rien \u00e0 installer. Sinon, pour faire vos premiers pas, selon les modalite\u0301s \u00e0 votre disposition, vous avez les solutions suivantes: En ligne Avec WSL Sur Raspberry Pi Le site https://www.pythonanywhere.com permet de cr\u00e9er un compte gratuit pour programmer en python ou pour disposer d'un terminal sous Linux . Windows Subsystem for Linux (WSL) est une couche de compatibilite\u0301 permettant d'exe\u0301cuter des exe\u0301cutables binaires Linux de manie\u0300re native sur les dernie\u0300res versions de Windows (a\u0300 partir de windows 10). La version WSL 2,sortie en mai 2019, introduit la pre\u0301sence d'un ve\u0301ritable noyau Linux . Installation sur WSL Pour installer la distribution Ubuntu, lancer l'invite de commande windows, puis : wsl -install -d Ubuntu Utilisation de WSL Une fois installe\u0301, vous avez acce\u0300s a\u0300 la distribution depuis l'invite de commande windows par l'interme\u0301diaire de la commande wsl . Vous acce\u0301dez alors a\u0300 un terminal Linux tout ce qui est des plus classique Le prompt est de la forme nom_utilisateur@nom_machine : chemin_dossier_courant $ . Normalement, votre re\u0301pertoire courant est symbolise\u0301 par ~ , ce qui est un raccourci pour symboliser le re\u0301pertoire personnel de l'utilisateur. Installation sur Raspberry Pi 4 Il existe des distributions Linux spe\u0301cifiques pour Rasberry 4, mais nous utiliserons Raspberry Pi OS (anciennement connu sous le nom de Raspbian ), qui est une distribution base\u0301e sur Linux Debian spe\u0301cialement optimise\u0301 pour Rasberry Pi. Une image est te\u0301le\u0301chargeable ici Une fois l'image installe\u0301e sur une carte micro-SD, le mini-ordinateur devrait-e\u0302tre imme\u0301diatement fonctionnel. Exercice Suivez toutes les e\u0301tapes d'installation de l'OS Raspebbry Pi OS , en cre\u0301ant un utilisateur administrateur avec votre nom de famille + premie\u0300re lettre de votre pre\u0301nom, et un mot de passe simple . Le terminal Pour obtenir la ligne de commande dans Raspbian, il faut lancer le programme Terminal . Le prompt est de la forme nom_utilisateur@nom_machine : chemin_dossier_courant $ . Normalement, votre re\u0301pertoire courant est symbolise\u0301 par ~ , ce qui est un raccourci pour symboliser le re\u0301pertoire personnel de l'utilisateur.", "title": "2. O\u00f9 pratiquer ?"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#3-le-shell-linux", "text": "", "title": "3. Le Shell Linux"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#31-bash", "text": "Bash (acronyme de Bourne-Again shell) est un interpre\u0301teur en ligne de commande de type script. C\u2019est le shell Unix(l'interpre\u0301teur de commande) du projet GNU. Le terminal fonctionne avec le principe REPL : Read Eval Print Loop. Read : L\u2019utilisateur tape une commande qui est lue par l\u2019interpr\u00e9teur, Eval : Cette commande est ex\u00e9cut\u00e9e et retourne une cha\u00eene de caract\u00e8res, Print : La cha\u00eene de caract\u00e8res est affich\u00e9e \u00e0 l\u2019\u00e9cran, Loop : On recommence. Comme tous les interpre\u0301teurs en ligne de commande de type script, Bash exe\u0301cute quatre ope\u0301rations fondamentales: Il fournit une liste de commandes permettant d\u2019ope\u0301rer sur l\u2019ordinateur (lancement de programmes, copie de fichiers, etc.) et il permet de regrouper ces commandes dans un fichier unique appele\u0301 script ; Il ve\u0301rifie la ligne de commande lors de son exe\u0301cution ou lors d\u2019une e\u0301ventuelle proce\u0301dure de ve\u0301rification et renvoie un message d\u2019erreur en cas d\u2019erreur de syntaxe ; En cas de validation, chaque ligne de commande est interpre\u0301te\u0301e, c\u2019est-a\u0300-dire traduite dans un langage compre\u0301hensible par le syste\u0300me d\u2019exploitation qui l\u2019exe\u0301cute alors. Les scripts sont de courts programmes ge\u0301ne\u0301ralement faciles a\u0300 construire. Bash offre un service de gestion de flux, c\u2019est-a\u0300-dire qu\u2019il permet que le re\u0301sultat d\u2019un script (la sortie) soit transmis a\u0300 un autre script (l\u2019entre\u0301e). De cette fac\u0327on, les scripts peuvent e\u0302tre \u00ab chai\u0302ne\u0301s \u00bb, chacun effectuant une seule ta\u0302che bien de\u0301limite\u0301e. Les scripts peuvent e\u0302tre exe\u0301cute\u0301s manuellement par l\u2019utilisateur ou automatiquement par le syste\u0300me. Par exemple, dans la distribution GNU/Linux Ubuntu , le re\u0301pertoire resume.d contient un certain nombre de scripts qui s\u2019exe\u0301cutent automatiquement lors du rede\u0301marrage du syste\u0300me, c\u2019est-a\u0300-dire apre\u0300s la fin de la mise en veille de celui-ci. Ces scripts servent a\u0300 relancer les diffe\u0301rents programmes interrompus par la mise en veille.", "title": "3.1. Bash"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#32-le-systeme-de-fichiers", "text": "Sur un syste\u0300me Linux , tout est un fichier , y compris un dossier. Mais pour rester compatible avec l'arborescence classique de windows, nous parlerons donc de : fichier lorsqu'il s'agit d'une feuille de l'arborescence ; dossier lorsqu'on parle d'un n\u0153ud ayant des enfants. Pour naviguer dans l'arborescence, il est ne\u0301cessaire de connai\u0302tre deux commandes: la commande ls pour List , qui permet de lister tous les enfants du re\u0301pertoire courant dans l'arborescence et peut utiliser les options suivantes : ls -a affiche les fichiers cache\u0301s; ls -R afiche tous les fichiers dans les sous-re\u0301pertoires(de manie\u0300re re\u0301cursive ); ls -l affichera les de\u0301tails des fichiers (autorisations, taille, proprie\u0301taires, etc...). la commande cd pour Change Directory , qui peut s'utiliser selon les manie\u0300res suivantes : cd ~ , rame\u0300ne au re\u0301pertoire de l'utilisateur courant; cd nom_du_repertoire_enfant , qui de\u0301place le prompt dans le re\u0301pertoire enfant se\u0301lectionne\u0301 (adressage relatif); cd /chemin/absolu/vers/un re\u0301pertoire , qui de\u0301place vers le re\u0301pertoire cible (adressage absolu); cd .. qui permet de remonter au re\u0301pertoire parent. Exercice 2 Se repe\u0301rer dans l'arborescence: Remonter l'arborescence jusqu'a\u0300 la racine. Donner le chemin absolu de votre re\u0301pertoire personnel \u00e0 partir de la racine. Se d\u00e9placer jusqu'au re\u0301pertoire /usr/bin et lister les fichiers pre\u0301sents. Retourner dans le dossier personnel, puis lister les fichiers pre\u0301sents, en affichant les de\u0301tails. Quelles sont les informations donne\u0301es ? Quels sont les utilisateurs recense\u0301s du syste\u0300me ? Les dossiers syste\u0300mes Linux Dans un syste\u0300me de type UNIX , on dispose d'une arborescence de fichiers dont la racine est / , puis d'un certain nombres de re\u0301pertoires dont voici les principaux e\u0301le\u0301ments : / \u251c\u2500\u2500 bin \u2190 Commandes de base du syste\u0300me \u251c\u2500\u2500 dev \u2190 Fichiers repre\u0301sentant les dispositifs mate\u0301riels (devices) du syste\u0300me \u251c\u2500\u2500 etc \u2190 Fichiers de configuration du syste\u0300me \u251c\u2500\u2500 home \u2190 Re\u0301pertoire d'accueil (HOME) des utilisateurs \u251c\u2500\u2500 lib \u2190 Librairies \u251c\u2500\u2500 mnt \u2190 Points de montage (cle\u0301s usb etc.) \u251c\u2500\u2500 proc \u2190 E\u0301tat du syste\u0300me et de ses processus \u251c\u2500\u2500 root \u2190 Re\u0301pertoire de l'administrateur syste\u0300me \u251c\u2500\u2500 run \u2190 Variables d'e\u0301tat du syste\u0300me depuis le boot \u251c\u2500\u2500 sys \u2190 Informations sur le noyau et les pe\u0301riphe\u0301riques \u251c\u2500\u2500 usr \u2190 Logiciels installe\u0301s avec le syste\u0300me, base de donne\u0301es etc. \u2514\u2500\u2500 var \u2190 Donne\u0301es fre\u0301quemment utilise\u0301es et modifie\u0301es", "title": "3.2. Le syste\u0300me de fichiers"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#33-les-utilisateurs-et-les-droits", "text": "En Linux , tout fichier, et par extension dossier, appartient a\u0300 un proprie\u0301taire ainsi qu'a\u0300 un groupe et un utilisateur quelconque ne pourra pas force\u0301ment avoir tous les droits sur un fichier qui ne lui appartient pas. Par exemple, e\u0301tudions la sortie suivante donne\u0301e par la commande ls -l : Bash -rw-r--r-- 1 raoul staff 21359 2024 -06-07 02 :16 cours.md drwx------@ 887 raoul staff 28384 6 jui 22 :22 Downloads - indique que l'\u00e9l\u00e9ment trouv\u00e9 est un fichier alors que d indique qu'il s'agit d'un dossier; les 3\u00d73=9 lettres suivantes indiquent les droits dont disposent les diff\u00e9rents utilisateurs sur ce fichier; @ est pour nous sans int\u00e9r\u00eat (il indique que l'existence d' attributs \u00e9tendus ) le nombre suivant est pour nous sans inte\u0301re\u0302t (il s'agit d'un compteur de liaison) ; le groupe de lettre suivant est le nom de l' utilisateur proprie\u0301taire du fichier ou dossier ; le groupe de lettre suivant est le nom du groupe proprie\u0301taire du fichier ou dossier ; 21359 et 28384 repre\u0301sentent respectivement la taille en octet du fichier et celle du dossier ; on trouve ensuite la date et l'heure de la dernie\u0300re modification ; enfin le nom du fichier ou du dossier. Les utilisateurs Pour un fichier, on distinguera trois types d'utilisateurs : u pour user , c'est-a\u0300-dire le proprie\u0301taire du fichier ; g pour group , le groupe auquel appartient le fichier ; o pour other , tous les autres utilisateurs. Super-Utilisateur Par de\u0301faut, il existe un super-utilisateur nomme\u0301 root qui posse\u0300de tous les droits sur un os Linux . Pour modifier des attributs au niveau syste\u0300me, il faut prendre les droits de super-utilisateur, gra\u0302ce a\u0300 la commande sudo (super-user do). Cette commande demande syste\u0301matiquement a\u0300 l'utilisateur faisant partie du groupe des super-utilisateurs ( sudoers ) de confirmer avec son mot de passe (celui choisi a\u0300 l'installation du syste\u0300me) toute action de modification effectue\u0301e au niveau du syst\u00e8me. Par exemple pour une mise a\u0300 jour sous Ubuntu, on tapera les commandes suivantes : Mise a\u0300 jour de la base de donne\u0301e des paquets syste\u0300mes : Bash sudo apt update mise a\u0300 jour des paquets : Bash sudo apt upgrade Attention ! Avec de grands pouvoirs viennent de grandes responsabilite\u0301s ! Les droits Pour un fichier donne\u0301, on distinguera 4 permissions : r : read , droit de lire le fichier ; w : write , droit de modifier le fichier ; x : execute , droit d'ex\u00e9cution du fichier ; - : aucun droit sur le fichier. Exercice 3 Quels sont les droits des utilisateurs sur le dossier Te\u0301le\u0301chargements de mon PC ? Attribution des permissions Pour donner ou supprimer des permissions sur un fichier mon_texte.txt , on utilise la commande chmod de la manie\u0300re suivante : Pour donner les droits en lecture et e\u0301criture a\u0300 l'utilisateur: Bash chmod u+rw mon_texte.txt Pour supprimer les droits en modification au groupe : Bash chmod g-w mon_texte.txt Pour supprimer tous les droits aux autres utilisateurs : Bash chmod o-rwx mon_texte.txt Il est aussi possible d'utiliser la notation octale pour ge\u0301rer ces droits. Par exemple, avec la commande suivante : Bash chmod 640 mon_texte.txt en sachant que r = 4 , w = 2 , x = 1 , et que le premier chiffre correspond a\u0300 l'utilisateur, le second au groupe, et le troisie\u0300me aux autres. Ainsi ici : l'utilisateur a\u0300 les droits de lecture et d'e\u0301criture (4+2 = 6) ; le groupe a\u0300 le droit de lecture (4) ; les autres n'ont aucun droit (0). Une commande telle que chmod 777 mon_texte.txt done tous les droits de lecture, e\u0301criture et exe\u0301cution a\u0300 tous les utilisateurs du syste\u0300me. Exercice 4 Copiez un fichier quelconque depuis votre session Windows vers votre session WSL par l'interme\u0301diaire de l'explorateur de fichier de windows. Quels sont les droits sur ce fichier ? Modifiez-les de manie\u0300re a\u0300 ce que seul l'utilisateur principal (vous) ait des droits de lecture, e\u0301criture et exe\u0301cution sur ce fichier, et que les autres n'aient qu'un droit de lecture.", "title": "3.3. Les utilisateurs et les droits"}, {"location": "T5_Architecture_materielle/5.0_Autour_de_GNU_Linux/cours/#34-les-principales-commandes-shell-sous-linux", "text": "Voici, de manie\u0300re non-exhaustive, quelques-unes des commandes les plus utiles sous Linux : Les principales commandes pwd man cat cp mv mkdir rmdir rm touch find locate grep head tail diff ( p rint w orking d irectory) Donne le chemin absolu du re\u0301pertoire courant. ( man ual) Donne le manuel de la commande passe\u0301e en argument. Exemple: man pwd affiche le manuel de la commande pwd (con cat enate) Son utilisation simple est d'afficher le contenu d'un fichier directement dans le terminal. Cependant cette commande permet bien d'autres choses : cat > nv_fichier.txt : cre\u0301e un nouveau fichier dans le re\u0301pertoire courant, et le remplit avec les saisies de l'utilisateur ( Ctrl + C pour quitter) ; cat fichier1 fichier2 > fichier3 : concate\u0300ne les contenus des fichiers 1 et 2 dans un nouveau fichier. Remarque: Pour cr\u00e9er un fichier vide on utilise plut\u00f4t la commande touch . ( c o p y) Copie un fichier dans un dossier. Exemple: cp bidule.jpg /home/bob/photo copie le fichier bidule.jpg vers le re\u0301pertoire /home/bob/photo , si les permissions sont correctement attribue\u0301es. ( m o v e) De\u0301place un fichier vers un re\u0301pertoire cible, et par extension permet de renommer un fichier . Exemples: mv bidule.jpg /home/bob/photo de\u0301place le fichier bidule.jpg vers /home/bob/photo ; mv bidule.jpg truc.jpg renomme le fichier bidule.jpg en truc.jpg . ( m a k e dir ectory) Cre\u0301e un nouveau re\u0301pertoire dont le nom est passe\u0301 en argument. Exemple: mkdir nv_dossier ( r e m ove dir ectory) Supprime un re\u0301pertoire vide dont le nom est passe\u0301 en argument. Exemple: rmdir nom_dossier ( r e m ove) Supprime le ou les fichiers passe\u0301s en arguments. Attention a\u0300 cette commande qui peut tout casser Exemples: rm mon_fichier : supprime mon_fichier rm * : supprime tous les fichiers du re\u0301pertoire courant ! rm -R : supprime de manie\u0300re re\u0301cursive tous les fichiers et sous-dossiers du re\u0301pertoire courant !!! Permet de cre\u0301er un nouveau fichier vide en lui passant le nom en argument. Ce n'est pas la peine d'utiliser la commande cat pour cr\u00e9er un fichier vide. Exemple: touch nv_fichier Permet de chercher des fichiers et/ou des dossiers dans un dossier donne\u0301. Exemple: find /home/ -name mon_texte.txt : cherche le fichier mon_texte.txt dans le re\u0301pertoire home et tous ses sous-dossiers. Permet de donner la localisation d'un fichier dans le syste\u0300me de fichier. Remarques: Le r\u00e9sultat de la commande locate est tre\u0300s rapide \u00e0 obtenir, car elle utilise une base de donne\u0301e mise a\u0300 jour re\u0301gulie\u0300rement qui recense tous les fichiers du syste\u0300me. Cependant, la mise a\u0300 jour de cette base de donne\u0301e n'est pas imme\u0301diate, donc les modifications re\u0301centes ne sont pas prises en compte. Si l'on a les droits super-utilisateur on peut mettre \u00e0 jour la base de donn\u00e9es avec la commande sudo updatedb . ( G lobal R egular E xpression P rint) Permet de chercher une chai\u0302ne de caracte\u0300re dans un fichier. Ce qui est d\u00e9j\u00e0 utile mais cette commande permet aussi aux utilisateurs de sp\u00e9cifier des mod\u00e8les \u00e0 l'aide d'expressions r\u00e9guli\u00e8res, puis de rechercher des lignes qui leur correspondent. Ce qui en fait un outil tr\u00e8s puissant. Syntaxe: grep [options] mod\u00e8le [fichier...] Exemples: grep \"toto\" bob.txt utilisation basique qui renverra toutes les lignes du fichier bob.txt contenant la chai\u0302ne toto . grep \"linux\" /path/to/directory/* renverra toutes les lignes contenant la cha\u00eene linux dans les diff\u00e9rents fichiers du r\u00e9pertoire indiqu\u00e9. grep -i \"important\" /path/to/directory/* o\u00f9 l'option -i permet de rendre la recherche insensible \u00e0 la casse . grep -c \"pattern\" /path/to/directory/* o\u00f9 l'option -c permet de compter le nombre d'occurences. grep -r \"pattern\" /path/to/directory/ o\u00f9 l'option -r permet de chercher de fa\u00e7on r\u00e9cursive dans les sous-dossiers. Remarque: grep est tre\u0300s efficace sur les fichiers comptenant du texte, mais ne fonctionne pas correctement sur les fichiers pdf, odt ... Renvoie les 10 premie\u0300res lignes d'un fichier. On peut parame\u0301trer le nombre de lignes obtenues avec l'option -n Exemple: head -n 5 bob.txt envoie les 5 premie\u0300res lignes du fichier bob.txt . Fonctionne de la me\u0302me manie\u0300re que head , mais en renvoyant les 10 dernie\u0300res lignes. Compare deux fichiers ligne par ligne et renvoie toutes celles pre\u0301sentant une diffe\u0301rence. Pratique! Exercice 5 Te\u0301le\u0301charger le fichier Arborescence.tar.gz Cre\u0301er un dossier TP dans le dossier personnel Copier le fichier pre\u0301ce\u0301dent dans ce dossier, puis le de\u0301compresser avec la commande Bash tar -xzf Arborescence.tar.gz Attention, la d\u00e9compression peut durer plusieurs minutes. Vous aurez besoin de la commande locate qui n'est pas installe\u0301e. Exe\u0301cutez la commande suivante pour installer le paquet ne\u0301cessaire a\u0300 son utilisation : Bash sudo apt install plocate Pour de\u0301buter, chercher le fichier commencement.txt dans l'arborescence, et le lire ! Bon courage, vous aurez probablement a\u0300 chercher en paralle\u0300le sur des commandes spe\u0301cifiques avec les options qui vont bien pour parvenir a\u0300 la fin de ce TP ! (Petit point de de\u0301tail, si une commande vous semble trop longue, vous pouvez l'interrompre avec le raccourci clavier Ctrl + C ).", "title": "3.4. Les principales commandes Shell sous Linux"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/", "text": "Syst\u00e8mes sur puce \u2693\ufe0e pr\u00e9ambule : cours de Premi\u00e8re sur l'architecture Von Neumann 1. Loi de Moore et miniaturisation progressive \u2693\ufe0e 1.1 La Loi de Moore \u2693\ufe0e En 1965, Gordon Moore postule que le nombre de transistors pr\u00e9sents sur une puce de microprocesseur doublera tous les deux ans. Cette pr\u00e9diction s'est r\u00e9v\u00e9l\u00e9e \u00e9tonnamment juste (\u00e0 quelques approximations pr\u00e8s) et les \u00e9quipements \u00e9lectroniques n'ont depuis jamais cess\u00e9 de devenir toujours plus performants / miniatures / \u00e9conomes en \u00e9nergie. 1.2 \u00c9volution de la taille des ordinateurs \u2693\ufe0e 1.2.1 IBM 650, le premier ordinateur fabriqu\u00e9 en s\u00e9rie (1955) \u2693\ufe0e Cet ordinateur n'a pas encore de transistors mais des tubes \u00e0 vide. 1.2.2 IBM 7090, le premier ordinateur \u00e0 transistors (1959) \u2693\ufe0e Le transistor Le transistor est un composant \u00e9lectronique essentiel : il permet de laisser (ou non) passer un courant \u00e9lectrique. 1.2.3 Le r\u00f4le crucial de la taille des transistors \u2693\ufe0e Ainsi que l'avait pr\u00e9dit Moore, c'est la progression du nombre de transistors gravables sur le processeur qui guidera pendant des ann\u00e9es l'\u00e9volution de l'informatique : 2. Composition d'un pc actuel \u2693\ufe0e Chaque composant a un r\u00f4le sp\u00e9cifique. Ils communiquent entre eux par des bus de diff\u00e9rentes vitesses. Chaque composant est rempla\u00e7able, et il est possible d'ajouter de nouveaux composants sur la carte m\u00e8re qui poss\u00e8de des slots d'extension. 3. Tout un pc sur une seule puce : les SoC \u2693\ufe0e 3.1 L'int\u00e9gration de composants diff\u00e9rents au sein d'une m\u00eame puce \u2693\ufe0e Le principe d'un syst\u00e8me sur puce ou System On a Chip (SoC) est d'int\u00e9grer au sein d'une puce unique un ensemble de composants habituellement physiquement dissoci\u00e9s dans un ordinateur classique (ordinateur de bureau ou ordinateur portable). On peut retrouver ainsi au sein d'une m\u00eame puce : le microprocesseur (CPU) la carte graphique (GPU) la m\u00e9moire RAM + \u00e9ventuellement des composants de communication (WiFi, Bluetooth...) Avantages et inconv\u00e9nients d'un SoC Avantages moindre consommation \u00e9lectrique moindre encombrement pas besoin de refroidissement meilleure s\u00e9curit\u00e9 (vue globale sur la s\u00e9curit\u00e9 qui n'est plus d\u00e9pendante d'une multitude de composants) moindre co\u00fbt (forte automisation du processus, gros volumes de production) Inconv\u00e9nients Impossibilit\u00e9 de choisir ind\u00e9pendamment ses composants Pas de mise \u00e0 jour possible / remplacement / ajout d'un composant La panne d'un seul composant entra\u00eene la panne totale du SoC 3.2 Exemple : A15 Bionic \u2693\ufe0e Observons par exemple la puce Apple A15 Bionic, qui \u00e9quipe les iPhone 13. Cette puce est fabriqu\u00e9e par TSMC . Cette puce contient : 15 milliards de transistors (grav\u00e9s \u00e0 5 nm) un processeur central \u00e0 6 c\u0153urs (2 c\u0153urs hautes performances + 4 c\u0153urs plus \u00e9conomes en \u00e9nergie) un GPU (processeur d\u00e9di\u00e9 uniquement au calcul du rendu graphique) de 5 c\u0153urs. une puce d\u00e9di\u00e9e au Machine Learning ( Neural Engine ) 4. Des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches sp\u00e9cifiques \u2693\ufe0e L'int\u00e9gration dans un SoC n'est pas totale : il reste des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches tr\u00e8s sp\u00e9cifiques qui ne sont pas forc\u00e9ment int\u00e9gr\u00e9es dans le SoC. 4.1 Au sein d'un t\u00e9l\u00e9phone \u2693\ufe0e Ainsi, d'apr\u00e8s le site iFixit , on peut retrouver ceci dans l'iPhone Pro 13, au c\u00f4t\u00e9 de la puce A15 \u00e9voqu\u00e9e plus haut : On voit que (par exemple) qu'il existe une puce sp\u00e9cifique pour g\u00e9rer l'audio, une puce sp\u00e9cifique pour le module WiFi, une puce sp\u00e9cifique pour le module Modem 5G... 4.2 En \u00e9lectronique \u00abgrand public\u00bb \u2693\ufe0e Ce composant (pouvant \u00eatre utilis\u00e9 dans un montage personnel, sur un Arduino par exemple) ne sert qu'\u00e0 faire des calculs cryptographiques. 4.3 Un principe g\u00e9n\u00e9ral \u2693\ufe0e Il est important de comprendre que certains processeurs sont optimis\u00e9s pour un certains types de calcul. C'est le cas par exemple d'une carte graphique, qui excelle dans le calcul de rendus de polygones. On s'est aper\u00e7u que cette aptitude \u00e0 faire des calculs \u00abb\u00eates et r\u00e9p\u00e9titifs\u00bb \u00e9tait parfaite pour faire les calculs math\u00e9matiques (inutiles) n\u00e9cessaires au minage des cryptomonnaies. Les cartes graphiques ont donc \u00e9t\u00e9 d\u00e9tourn\u00e9es de leur usage originel, \u00e0 cause de la sp\u00e9cificit\u00e9 de l'impl\u00e9mentation de leur puce. De m\u00eame, les calculs sur les r\u00e9seaux de neurones (essentiels en IA) n\u00e9cessitent une grande rapidit\u00e9 dans les multiplications de matrices. Pour cette raison, Apple a int\u00e9gr\u00e9 directement dans son SoC A15 une puce sp\u00e9calis\u00e9e dans ces calculs (voir plus haut). 4.4 Conclusion \u2693\ufe0e L'orientation actuelle de l'\u00e9lectronique est donc \u00e0 la fois : une int\u00e9gration toujours plus grande dans des SoC multi-t\u00e2ches. des puces toujours plus sp\u00e9cifiques qui excellent dans un domaine particulier. 5. Exercice \u2693\ufe0e Exercice (Polyn\u00e9sie 2021) \u00c9nonc\u00e9 Correction Un constructeur automobile int\u00e8gre \u00e0 ses v\u00e9hicules des syst\u00e8mes embarqu\u00e9s, comme par exemple un syst\u00e8me de guidage par satellites (GPS), un syst\u00e8me de freinage antiblocage (ABS)... Ces dispositifs utilisent des syst\u00e8mes sur puces (SoC : System on a Chip). Citer deux avantages \u00e0 utiliser ces syst\u00e8mes sur puces plut\u00f4t qu'une architecture classique d'ordinateur. Bibliographie / Sitographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. https://fr.wikipedia.org/wiki/Loi_de_Moore https://blog.iakaa.com/lordinateur-fete-ses-60-ans/ https://www.thewindowsclub.com/history-of-computers https://perso-etis.ensea.fr//lorandel/M2_SoC/s1.pdf https://www.hawkpointtechnologies.com/about/blog/computer-components https://www.tremplin-numerique.org/apple-a15-vs-a14-quoi-de-neuf-dans-la-puce-de-liphone-13 https://www.distrelec.be/fr/cryptoprocesseur-breakout-atecc608a-sparkfun-electronics-dev-18077/p/30241877", "title": "5.1 Syst\u00e8mes sur puce"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#systemes-sur-puce", "text": "pr\u00e9ambule : cours de Premi\u00e8re sur l'architecture Von Neumann", "title": "Syst\u00e8mes sur puce"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#1-loi-de-moore-et-miniaturisation-progressive", "text": "", "title": "1. Loi de Moore et miniaturisation progressive"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#11-la-loi-de-moore", "text": "En 1965, Gordon Moore postule que le nombre de transistors pr\u00e9sents sur une puce de microprocesseur doublera tous les deux ans. Cette pr\u00e9diction s'est r\u00e9v\u00e9l\u00e9e \u00e9tonnamment juste (\u00e0 quelques approximations pr\u00e8s) et les \u00e9quipements \u00e9lectroniques n'ont depuis jamais cess\u00e9 de devenir toujours plus performants / miniatures / \u00e9conomes en \u00e9nergie.", "title": "1.1 La Loi de Moore"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#12-evolution-de-la-taille-des-ordinateurs", "text": "", "title": "1.2  \u00c9volution de la taille des ordinateurs"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#2-composition-dun-pc-actuel", "text": "Chaque composant a un r\u00f4le sp\u00e9cifique. Ils communiquent entre eux par des bus de diff\u00e9rentes vitesses. Chaque composant est rempla\u00e7able, et il est possible d'ajouter de nouveaux composants sur la carte m\u00e8re qui poss\u00e8de des slots d'extension.", "title": "2. Composition d'un pc actuel"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#3-tout-un-pc-sur-une-seule-puce-les-soc", "text": "", "title": "3. Tout un pc sur une seule puce : les SoC"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#31-lintegration-de-composants-differents-au-sein-dune-meme-puce", "text": "Le principe d'un syst\u00e8me sur puce ou System On a Chip (SoC) est d'int\u00e9grer au sein d'une puce unique un ensemble de composants habituellement physiquement dissoci\u00e9s dans un ordinateur classique (ordinateur de bureau ou ordinateur portable). On peut retrouver ainsi au sein d'une m\u00eame puce : le microprocesseur (CPU) la carte graphique (GPU) la m\u00e9moire RAM + \u00e9ventuellement des composants de communication (WiFi, Bluetooth...) Avantages et inconv\u00e9nients d'un SoC Avantages moindre consommation \u00e9lectrique moindre encombrement pas besoin de refroidissement meilleure s\u00e9curit\u00e9 (vue globale sur la s\u00e9curit\u00e9 qui n'est plus d\u00e9pendante d'une multitude de composants) moindre co\u00fbt (forte automisation du processus, gros volumes de production) Inconv\u00e9nients Impossibilit\u00e9 de choisir ind\u00e9pendamment ses composants Pas de mise \u00e0 jour possible / remplacement / ajout d'un composant La panne d'un seul composant entra\u00eene la panne totale du SoC", "title": "3.1 L'int\u00e9gration de composants diff\u00e9rents au sein d'une m\u00eame puce"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#32-exemple-a15-bionic", "text": "Observons par exemple la puce Apple A15 Bionic, qui \u00e9quipe les iPhone 13. Cette puce est fabriqu\u00e9e par TSMC . Cette puce contient : 15 milliards de transistors (grav\u00e9s \u00e0 5 nm) un processeur central \u00e0 6 c\u0153urs (2 c\u0153urs hautes performances + 4 c\u0153urs plus \u00e9conomes en \u00e9nergie) un GPU (processeur d\u00e9di\u00e9 uniquement au calcul du rendu graphique) de 5 c\u0153urs. une puce d\u00e9di\u00e9e au Machine Learning ( Neural Engine )", "title": "3.2 Exemple : A15 Bionic"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#4-des-puces-dediees-a-des-taches-specifiques", "text": "L'int\u00e9gration dans un SoC n'est pas totale : il reste des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches tr\u00e8s sp\u00e9cifiques qui ne sont pas forc\u00e9ment int\u00e9gr\u00e9es dans le SoC.", "title": "4. Des puces d\u00e9di\u00e9es \u00e0 des t\u00e2ches sp\u00e9cifiques"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#41-au-sein-dun-telephone", "text": "Ainsi, d'apr\u00e8s le site iFixit , on peut retrouver ceci dans l'iPhone Pro 13, au c\u00f4t\u00e9 de la puce A15 \u00e9voqu\u00e9e plus haut : On voit que (par exemple) qu'il existe une puce sp\u00e9cifique pour g\u00e9rer l'audio, une puce sp\u00e9cifique pour le module WiFi, une puce sp\u00e9cifique pour le module Modem 5G...", "title": "4.1 Au sein d'un t\u00e9l\u00e9phone"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#42-en-electronique-grand-public", "text": "Ce composant (pouvant \u00eatre utilis\u00e9 dans un montage personnel, sur un Arduino par exemple) ne sert qu'\u00e0 faire des calculs cryptographiques.", "title": "4.2 En \u00e9lectronique \u00abgrand public\u00bb"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#43-un-principe-general", "text": "Il est important de comprendre que certains processeurs sont optimis\u00e9s pour un certains types de calcul. C'est le cas par exemple d'une carte graphique, qui excelle dans le calcul de rendus de polygones. On s'est aper\u00e7u que cette aptitude \u00e0 faire des calculs \u00abb\u00eates et r\u00e9p\u00e9titifs\u00bb \u00e9tait parfaite pour faire les calculs math\u00e9matiques (inutiles) n\u00e9cessaires au minage des cryptomonnaies. Les cartes graphiques ont donc \u00e9t\u00e9 d\u00e9tourn\u00e9es de leur usage originel, \u00e0 cause de la sp\u00e9cificit\u00e9 de l'impl\u00e9mentation de leur puce. De m\u00eame, les calculs sur les r\u00e9seaux de neurones (essentiels en IA) n\u00e9cessitent une grande rapidit\u00e9 dans les multiplications de matrices. Pour cette raison, Apple a int\u00e9gr\u00e9 directement dans son SoC A15 une puce sp\u00e9calis\u00e9e dans ces calculs (voir plus haut).", "title": "4.3 Un principe g\u00e9n\u00e9ral"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#44-conclusion", "text": "L'orientation actuelle de l'\u00e9lectronique est donc \u00e0 la fois : une int\u00e9gration toujours plus grande dans des SoC multi-t\u00e2ches. des puces toujours plus sp\u00e9cifiques qui excellent dans un domaine particulier.", "title": "4.4 Conclusion"}, {"location": "T5_Architecture_materielle/5.1_Systemes_sur_puce/cours/#5-exercice", "text": "Exercice (Polyn\u00e9sie 2021) \u00c9nonc\u00e9 Correction Un constructeur automobile int\u00e8gre \u00e0 ses v\u00e9hicules des syst\u00e8mes embarqu\u00e9s, comme par exemple un syst\u00e8me de guidage par satellites (GPS), un syst\u00e8me de freinage antiblocage (ABS)... Ces dispositifs utilisent des syst\u00e8mes sur puces (SoC : System on a Chip). Citer deux avantages \u00e0 utiliser ces syst\u00e8mes sur puces plut\u00f4t qu'une architecture classique d'ordinateur. Bibliographie / Sitographie Num\u00e9rique et Sciences Informatiques, Terminale, T. BALABONSKI, S. CONCHON, J.-C. FILLIATRE, K. NGUYEN, \u00e9ditions ELLIPSES. Pr\u00e9pabac NSI, Terminale, G.CONNAN, V.PETROV, G.ROZSAVOLGYI, L.SIGNAC, \u00e9ditions HATIER. https://fr.wikipedia.org/wiki/Loi_de_Moore https://blog.iakaa.com/lordinateur-fete-ses-60-ans/ https://www.thewindowsclub.com/history-of-computers https://perso-etis.ensea.fr//lorandel/M2_SoC/s1.pdf https://www.hawkpointtechnologies.com/about/blog/computer-components https://www.tremplin-numerique.org/apple-a15-vs-a14-quoi-de-neuf-dans-la-puce-de-liphone-13 https://www.distrelec.be/fr/cryptoprocesseur-breakout-atecc608a-sparkfun-electronics-dev-18077/p/30241877", "title": "5. Exercice"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/Exercices/", "text": "Exercice 1 Partie A Cette partie est un questionnaire \u00e0 choix multiples (QCM). Pour chacune des questions, une seule des quatre r\u00e9ponses est exacte. Parmi les commandes ci-dessous, laquelle permet d\u2019afficher les processus en cours d\u2019ex\u00e9cution ? a. dir b. ps c. man d. ls Quelle abr\u00e9viation d\u00e9signe l\u2019identifiant d\u2019un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? a. PIX b. SIG c. PID d. SID Comment s'appelle la gestion du partage de processeur entre les diff\u00e9rents processus ? a. L'interblocage b. L'ordonnancement c. La planification d. La priorisation Quelle commande permet d\u2019interrompre un processus dans un syst\u00e8me d\u2019exploitation de type UNIX ? a. stop b. interrupt c. end d. kill Correction b c b d Partie B Q1. Un processeur choisit \u00e0 chaque cycle d\u2019ex\u00e9cution le processus qui doit \u00eatre ex\u00e9cut\u00e9. Le tableau ci-dessous donne pour trois processus P1, P2, P3 : la dur\u00e9e d\u2019ex\u00e9cution (en nombre de cycles), l\u2019instant d\u2019arriv\u00e9e sur le processeur (exprim\u00e9 en nombre de cycles \u00e0 partir de 0), le num\u00e9ro de priorit\u00e9. Le num\u00e9ro de priorit\u00e9 est d\u2019autant plus petit que la priorit\u00e9 est grande. On suppose qu\u2019\u00e0 chaque instant, c\u2019est le processus qui a le plus petit num\u00e9ro de priorit\u00e9 qui est ex\u00e9cut\u00e9, ce qui peut provoquer la suspension d\u2019un autre processus, lequel reprendra lorsqu\u2019il sera le plus prioritaire. Reproduire le tableau ci-dessous sur la copie et indiquer dans chacune des cases le processus ex\u00e9cut\u00e9 \u00e0 chaque cycle. Correction Q2. On suppose maintenant que les trois processus pr\u00e9c\u00e9dents s\u2019ex\u00e9cutent et utilisent une ou plusieurs ressources parmi R1, R2 et R3. Parmi les sc\u00e9narios suivants, lequel provoque un interblocage ? Justifier. Correction Seul le scenario 2 pr\u00e9sente un cycle d'interd\u00e9pendance : seul le sc\u00e9nario 2 va donc provoquer un interblocage. Exercice 2 2021, M\u00e9tropole Candidats Libres sujet 2 Q1. Les \u00e9tats possibles d\u2019un processus sont : pr\u00eat , \u00e9lu , termin\u00e9 et bloqu\u00e9 . Q1.a. Expliquer \u00e0 quoi correspond l\u2019\u00e9tat \u00e9lu . Q1.b. Proposer un sch\u00e9ma illustrant les passages entre les diff\u00e9rents \u00e9tats. Correction Q1a. \u00c9lu signifie que le processus est actuellement en cours d'ex\u00e9cution par le processeur. Q1b. Q2. On suppose que quatre processus C\u2081, C\u2082, C\u2083 et C\u2084 sont cr\u00e9\u00e9s sur un ordinateur, et qu\u2019aucun autre processus n\u2019est lanc\u00e9 sur celui-ci, ni pr\u00e9alablement ni pendant l\u2019ex\u00e9cution des quatre processus. L\u2019ordonnanceur, pour ex\u00e9cuter les diff\u00e9rents processus pr\u00eats, les place dans une structure de donn\u00e9es de type file. Un processus pr\u00eat est enfil\u00e9 et un processus \u00e9lu est d\u00e9fil\u00e9. Q2.a. Parmi les propositions suivantes, recopier celle qui d\u00e9crit le fonctionnement des entr\u00e9es/sorties dans une file : i.Premier entr\u00e9, dernier sorti ii. Premier entr\u00e9, premier sorti iii. Dernier entr\u00e9, premier sorti Correction Q2a. ii. Premier entr\u00e9, premier sorti Q2.b. On suppose que les quatre processus arrivent dans la file et y sont plac\u00e9s dans l\u2019ordre C\u2081, C\u2082, C\u2083 et C\u2084. Les temps d\u2019ex\u00e9cution totaux de C\u2081, C\u2082, C\u2083 et C\u2084 sont respectivement 100 ms, 150 ms, 80 ms et 60 ms. Apr\u00e8s 40 ms d\u2019ex\u00e9cution, le processus C\u2081 demande une op\u00e9ration d\u2019\u00e9criture disque, op\u00e9ration qui dure 200 ms. Pendant cette op\u00e9ration d\u2019\u00e9criture, le processus C\u2081 passe \u00e0 l\u2019\u00e9tat bloqu\u00e9. Apr\u00e8s 20 ms d\u2019ex\u00e9cution, le processus C\u2083 demande une op\u00e9ration d\u2019\u00e9criture disque, op\u00e9ration qui dure 10 ms. Pendant cette op\u00e9ration d\u2019\u00e9criture, le processus C\u2083 passe \u00e0 l\u2019\u00e9tat bloqu\u00e9. Sur la frise chronologique ci-dessous, les \u00e9tats du processus C\u2082 sont donn\u00e9s. Compl\u00e9ter la frise avec les \u00e9tats des processus C\u2081, C\u2083 et C\u2084. Correction Exercice 3 2021, sujet Am\u00e9rique du Nord Un constructeur automobile utilise des ordinateurs pour la conception de ses v\u00e9hicules. Ceux-ci sont munis d'un syst\u00e8me d'exploitation ainsi que de nombreuses applications parmi lesquelles on peut citer : un logiciel de traitement de texte ; un tableur ; un logiciel de Conception Assist\u00e9e par Ordinateur (CAO) ; un syst\u00e8me de gestion de base de donn\u00e9es (SGBD) Chaque ordinateur est \u00e9quip\u00e9 des p\u00e9riph\u00e9riques classiques : clavier, souris, \u00e9cran et est reli\u00e9 \u00e0 une imprimante r\u00e9seau. (question System On Chip) Un ing\u00e9nieur travaille sur son ordinateur et utilise les quatre applications cit\u00e9es au d\u00e9but de l'\u00e9nonc\u00e9. Pendant l'ex\u00e9cution de ces applications, des processus mobilisent des donn\u00e9es et sont en attente d'autres donn\u00e9es mobilis\u00e9es par d'autres processus. On donne ci-dessous un tableau indiquant \u00e0 un instant pr\u00e9cis l'\u00e9tat des processus en cours d'ex\u00e9cution et dans lequel D1, D2, D3, D4 et D5 sont des donn\u00e9es. La lettre M signifie que la donn\u00e9e est mobilis\u00e9e par l'application ; la lettre A signifie que l'application est en attente de cette donn\u00e9e. Lecture du tableau : le logiciel de traitement de texte mobilise (M) la donn\u00e9e D1 et est en attente (A) de la donn\u00e9e D2. D1 D2 D3 D4 D5 Traitement de texte M A - - - Tableur A - - - M SGBD - M A A - CAO - - A M A Montrer que les applications s'attendent mutuellement. Comment s'appelle cette situation ? Correction Le cycle en pointill\u00e9s montre que les applications s'attendent mutuellement : cette situation s'appelle un interblocage. Exercice 4 2021, M\u00e9tropole sujet 2 Partie A Dans un bureau d\u2019architectes, on dispose de certaines ressources qui ne peuvent \u00eatre utilis\u00e9es simultan\u00e9ment par plus d\u2019un processus, comme l\u2019imprimante, la table tra\u00e7ante, le modem. Chaque programme, lorsqu\u2019il s\u2019ex\u00e9cute, demande l\u2019allocation des ressources qui lui sont n\u00e9cessaires. Lorsqu\u2019il a fini de s\u2019ex\u00e9cuter, il lib\u00e8re ses ressources. On appelle p1, p2 et p3 les processus associ\u00e9s respectivement aux programmes 1, 2 et 3 Q1. Les processus s'ex\u00e9cutent de mani\u00e8re concurrente. Justifier qu'une situation d'interblocage peut se produire. Q2 . Modifier l'ordre des instructions du programme 3 pour qu'une telle situation ne puisse pas se produire. Aucune justification n'est attendue. Supposons que le processus p1 demande la table tra\u00e7ante alors qu'elle est en cours d'utilisation par le processus p3. Parmi les \u00e9tats suivants, quel sera l'\u00e9tat du processus p1 tant que la table tra\u00e7ante n'est pas disponible : a. \u00e9lu b. bloqu\u00e9 c. pr\u00eat d. termin\u00e9 Partie B Avec une ligne de commande dans un terminal sous Linux, on obtient l'affichage suivant : La documentation Linux donne la signification des diff\u00e9rents champs : UID : identifiant utilisateur effectif ; PID : identifiant de processus ; PPID : PID du processus parent ; C : partie enti\u00e8re du pourcentage d'utilisation du processeur par rapport au temps de vie des processus ; STIME : l'heure de lancement du processus ; TTY : terminal de contr\u00f4le TIME : temps d'ex\u00e9cution CMD : nom de la commande du processus Q1. Parmi les quatre commandes suivantes, laquelle a permis cet affichage ? a. ls -l b. ps -ef c. cd .. d. chmod 741 processus.txt Q2. Quel est l'identifiant du processus parent \u00e0 l'origine de tous les processus concernant le navigateur Web (chromium-browser) ? Q3. Quel est l'identifiant du processus dont le temps d'ex\u00e9cution est le plus long ? Exercice 5 Exercice 2 du sujet Am\u00e9rique du Nord J2 2022 Exercice 6 Exercice 2 du sujet Polyn\u00e9sie J1", "title": "Exercices"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/", "text": "Gestion des processus \u2693\ufe0e 1. Notion de processus \u2693\ufe0e 1.1 D\u00e9finition d'un processus \u2693\ufe0e Lorsqu'un programme est ex\u00e9cut\u00e9 sur un ordinateur, celui-ci va cr\u00e9er un (ou plusieurs) processus . On dit que ce processus est une instance d'ex\u00e9cution de ce programme. Un processus est caract\u00e9ris\u00e9 par : l'ensemble des instructions qu'il va devoir accomplir (\u00e9crites dans le fichier ex\u00e9cutable obtenu par la compilation du code-source du programme) les ressources que le programme va mobiliser (fichier en ouverture, carte son...) l'\u00e9tat des registres du processeur (voir le cours de Premi\u00e8re sur l' architecture Von Neumann ) 1.2 Observation des processus sous Linux \u2693\ufe0e 1.2.1 La commande ps \u2693\ufe0e Dans un terminal, la commande ps va permettre d'afficher la liste des processus actifs. Plus pr\u00e9cis\u00e9ment, nous allons utiliser la commande ps -lu nom_user . L'option l permet d'afficher un grand nombre de renseignements et l'option u permet de sp\u00e9cifier l'utilisateur propri\u00e9taire des processus. On retrouve notamment dans ce tableau les colonnes : CMD (Command) : le nom de la commande qui a cr\u00e9\u00e9 le processus. Vous pouvez y retrouver par ordre chronologique le nom de tous les programmes actifs. Certains sont ceux que vous avez ouverts volontairement (navigateur...) mais on y trouve surtout tous les programmes n\u00e9cessaires au bon fonctionnement du syst\u00e8me d'exploitation. Le dernier processus en bas de la liste est forc\u00e9ment ps , puisque vous venez de l'appeler. PID (Process Identifier) : le num\u00e9ro unique d'identification, affect\u00e9 chronologiquement par le syst\u00e8me d'exploitation. Le processus de PID \u00e9gal \u00e0 1 est systemd , qui est le tout premier programme lanc\u00e9 par le noyau Linux au d\u00e9marrage. PPID (Parent PID) : certains processus vont eux-m\u00eames lancer plusieurs processus-fils, qui porteront le m\u00eame nom. C'est ainsi qu'on peut retrouver de multiples processus s'appelant chrome : Ici, l'instance \u00abprincipale\u00bb de Chrome ( PID 1453) a g\u00e9n\u00e9r\u00e9 6 autres instances de PID diff\u00e9rents, dont le PPID vaut 1453. Dans Chrome/Chromium, vous pouvez comprendre le r\u00f4le de chaque processus en le retrouvant dans le gestionnaire des t\u00e2ches (clic-droit sur une zone vide de la barre d'onglets) 1.2.2 La commande pstree \u2693\ufe0e \u00c0 noter que la commande pstree permet d'afficher les processus sous forme d'arborescence : 1.2.3 La commande top \u2693\ufe0e La commande top permet de conna\u00eetre en temps r\u00e9el la liste des processus, class\u00e9s par ordre d\u00e9croissant de consommation de CPU. On ferme top par la combinaison de touches Ctrl-C . Pourcentage d'utilisation du CPU En face de chaque processus est affich\u00e9e sa consommation de CPU. Elle est calcul\u00e9e en prenant, sur un intervalle de temps donn\u00e9, le temps qu'a pass\u00e9 le CPU \u00e0 traiter le processus en question, et en divisant ce temps par le temps total de la mesure. \\[\\text{Pourcentage d'utilisation CPU} = \\frac{\\text{Temps d'utilisation CPU}}{\\text{Temps total \u00e9coul\u00e9}} \\times 100\\] Si on rep\u00e8re alors un processus qui consomme beaucoup trop de ressources, on peut utiliser... 1.2.4 La commande kill \u2693\ufe0e La commande kill permet de fermer un processus, en donnant son PID en argument. Exemple : kill 1453 tuera Chrome (voir la capture du 1.2.1) 2. Ordonnancement \u2693\ufe0e 2.1 Exp\u00e9rience : les processus fonctionnent simultan\u00e9ment \u00e0 tour de r\u00f4le. \u2693\ufe0e Un ordinateur donne l'illusion de r\u00e9aliser plusieurs t\u00e2ches simultan\u00e9ment. Hormis pour les processeurs fonctionnant avec plusieurs c\u0153urs, il n'en est rien. Comme nous l'avons vu, ces processus sont lanc\u00e9s s\u00e9quentiellement par le syst\u00e8me d'exploitation, et sont ensuite en apparence tous \u00abactifs en m\u00eame temps\u00bb (les guillemets sont importants) : on parle de programmation concurrente . Revenons sur l'expression \u00abactifs en m\u00eame temps\u00bb, car elle v\u00e9hicule une fausse id\u00e9e : ces processus sont bien vivants dans un m\u00eame laps de temps, mais ils s'ex\u00e9cutent LES UNS APR\u00c8S LES AUTRES , le processeur ne pouvant en traiter qu' un seul \u00e0 la fois . Un cadencement extr\u00eamement rapide et efficace donne l' apparence d'une (fausse) simultan\u00e9it\u00e9. Nous allons la mettre en \u00e9vidence : Consid\u00e9rons les fichiers progA.py et progB.py ci-dessous : progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) progB.py import time time . sleep ( 0.01 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) Le programme progB.py est l\u00e9g\u00e8rement retard\u00e9 au d\u00e9marrage par le time.sleep(0.01) . Il devrait donc en r\u00e9sulter un entrelacement entre les phrases programme A en cours et programme B en cours . L'ex\u00e9cution \u00abd'apparence simultan\u00e9e\u00bb de ces deux programmes peut se faire dans un Terminal via la commande python3 progA.py & python3 progB.py . Il en r\u00e9sulte ceci : Nous retrouvons bien l'alternance pr\u00e9vue \u00e0 la lecture du code. Tout se passe donc comme si les deux processus avaient \u00e9t\u00e9 lanc\u00e9s et trait\u00e9s simultan\u00e9ment. R\u00e9duisons maintenant les temporisations (en passant du centi\u00e8me de seconde \u00e0 la milliseconde): progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) progB.py import time time . sleep ( 0.001 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) Il en r\u00e9sulte maintenant ceci : L'alternance pr\u00e9vue n'est plus respect\u00e9e (et les r\u00e9sultats deviennent non-reproductibles). Si la gestion des processus \u00e9tait r\u00e9ellement simultan\u00e9e, m\u00eame en consid\u00e9rant des ralentissements du processeur par des sollicitations ext\u00e9rieures, chaque processus serait ralenti de la m\u00eame mani\u00e8re : l'entrelacement des phrases serait toujours le m\u00eame. En r\u00e9alit\u00e9, le processeur passe son temps \u00e0 alterner entre les divers processus qu'il a \u00e0 g\u00e9rer, et les met en attente quand il ne peut pas s'occuper d'eux. Il ob\u00e9it pour cela aux instructions de son ordonnanceur . 2.2 L'ordonnancement des processus \u2693\ufe0e 2.2.1 Diff\u00e9rents types d'ordonnancement \u2693\ufe0e Si on vous donne 4 t\u00e2ches A, B, C et D \u00e0 accomplir, vous pouvez d\u00e9cider : de faire la t\u00e2che prioritaire d'abord ; de faire la t\u00e2che la plus rapide d'abord ; de faire la t\u00e2che la plus longue d'abord ; de les faire dans l'ordre o\u00f9 elles vous ont \u00e9t\u00e9 donn\u00e9es ; de faire \u00e0 tour de r\u00f4le chaque t\u00e2che pendant un temps fixe jusqu'\u00e0 ce qu'elles soient toutes termin\u00e9es; ... Un processeur est confront\u00e9 aux m\u00eames choix : comment d\u00e9terminer quel processus doit \u00eatre trait\u00e9 \u00e0 quel moment ? Le sch\u00e9ma ci-dessous (issu de ce site ) pr\u00e9sente quelques politiques d'ordonnancement : Sous Linux, l'ordonnancement est effectu\u00e9 par un syst\u00e8me hybride o\u00f9 les processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le (on parle de tourniquet ou de Round Robin ) suivant un ordre de priorit\u00e9 dynamique. Dans le cas (tr\u00e8s fr\u00e9quent maintenant) d'un processeur multi-c\u0153urs , le probl\u00e8me reste identique. Certes, sur 4 c\u0153urs, 4 processus pourront \u00eatre trait\u00e9s simultan\u00e9ment (une r\u00e9elle simultan\u00e9it\u00e9) mais il reste toujours beaucoup plus de processus \u00e0 traiter que de c\u0153urs dans le processeur... et un ordonnancement est donc toujours n\u00e9cessaire. 2.2.2 Les diff\u00e9rents \u00e9tats d'un processus \u2693\ufe0e Selon que l'ordonnanceur aura d\u00e9cid\u00e9 de le confier ou non au processeur pour son ex\u00e9cution, un processus peut donc se trouver dans 3 \u00e9tats : Pr\u00eat : il attend qu'arrive le moment de son ex\u00e9cution. \u00c9lu : il est en cours d'ex\u00e9cution par le processeur. Bloqu\u00e9 : pendant son ex\u00e9cution (\u00e9tat \u00c9lu ), le processus r\u00e9clame une ressource qui n'est pas imm\u00e9diatement disponible. Son ex\u00e9cution s'interrompt. Lorsque la ressource sera disponible, le processus repassera par l'\u00e9tat Pr\u00eat et attendra \u00e0 nouveau son tour. Voici les transitions possibles entre ces \u00e9tats (diagramme issu de https://info.blaisepascal.fr/nsi-processus-et-ressources ) : Ou de mani\u00e8re simplifi\u00e9e : On peut utiliser la m\u00e9taphore suivante : Sur le bureau d'un professeur, il y a 3 paquets de copies, correspondant aux classes A, B, et C. Ces paquets sont Pr\u00eats \u00e0 \u00eatre corrig\u00e9s. Si le professeur ram\u00e8ne devant lui le paquet A, celui-ci devient \u00c9lu , et le professeur peut commencer \u00e0 le corriger. Pour se changer les id\u00e9es, il peut interrompre la correction du paquet A (qui repassera \u00e0 l'\u00e9tat Pr\u00eat en attendant son tour) et ramener vers lui le paquet C. Il pourra ensuite prendre le paquet B, puis \u00e0 nouveau le C, puis le A, ainsi de suite jusqu'\u00e0 ce que tous les paquets soient totalement corrig\u00e9s. Ces paquets seront alors Termin\u00e9s . Si, pendant la correction du paquet, le professeur donne celui-ci \u00e0 sa fille pour qu'elle classe les copies par ordre alphab\u00e9tique, ce paquet sera Bloqu\u00e9 . Il ne reviendra \u00e0 l'\u00e9tat Pr\u00eat que quand la fille du professeur aura rendu le paquet. Au cours de cette proc\u00e9dure, le professeur n'a toujours eu devant lui qu' un seul paquet de copies (soit A, soit B, soit C). Pourquoi l'acc\u00e8s \u00e0 une ressource peut bloquer un processus ? Pendant son ex\u00e9cution, un processus peut avoir besoin d'acc\u00e9der \u00e0 une ressource d\u00e9j\u00e0 occup\u00e9e (un fichier d\u00e9j\u00e0 ouvert, par exemple) ou \u00eatre en attente d'une entr\u00e9e-utilisateur (un input() dans un code Python par exemple). Dans ce cas-l\u00e0, le processeur va passer ce processus \u00e0 l'\u00e9tat Bloqu\u00e9 , pour pouvoir ainsi se consacrer \u00e0 un autre processus. Une fois d\u00e9bloqu\u00e9, le processus va repasser \u00e0 l'\u00e9tat Pr\u00eat et rejoindre (par exemple) la file d'attente des processus avant d'\u00eatre \u00e0 nouveau \u00c9lu et donc ex\u00e9cut\u00e9. 3. Interblocage \u2693\ufe0e 3.1 D\u00e9finition et exemple \u2693\ufe0e Comme nous venons de le voir, un processus peut \u00eatre dans l'\u00e9tat bloqu\u00e9 dans l'attente de la lib\u00e9ration d'une ressource. Ces ressources (l'acc\u00e8s en \u00e9criture \u00e0 un fichier, \u00e0 un registre de la m\u00e9moire...) ne peuvent \u00eatre donn\u00e9es \u00e0 deux processus \u00e0 la fois. Des processus souhaitant acc\u00e9der \u00e0 cette ressource sont donc en concurrence sur cette ressource. Un processus peut donc devoir attendre qu'une ressource se lib\u00e8re avant de pouvoir y acc\u00e9der (et ainsi passer de l'\u00e9tat Bloqu\u00e9 \u00e0 l'\u00e9tat Pr\u00eat). Probl\u00e8me : Et si deux processus se bloquent mutuellement la ressource dont ils ont besoin ? Exemple : Consid\u00e9rons 2 processus A et B, et deux ressources R et S. L'action des processus A et B est d\u00e9crite ci-dessous : D\u00e9roulement des processus A et B : A et B sont cr\u00e9\u00e9s et passent \u00e0 l'\u00e9tat Pr\u00eat . L'ordonnanceur d\u00e9clare \u00c9lu le processus A (ou bien B, cela ne change rien). L'\u00e9tape A1 de A est r\u00e9alis\u00e9e : la ressource R est donc affect\u00e9e \u00e0 A. L'ordonnanceur d\u00e9clare maintenant \u00c9lu le processus B. A est donc pass\u00e9 \u00e0 Pr\u00eat en attendant que son tour revienne. L'\u00e9tape B1 de B est r\u00e9alis\u00e9e : la ressource S est donc affect\u00e9e \u00e0 B. L'ordonnanceur d\u00e9clare \u00e0 nouveau \u00c9lu le processus A. B est donc pass\u00e9 \u00e0 Pr\u00eat en attendant que son tour revienne. L'\u00e9tape A2 de A est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource S, qui n'est pas disponible. L'ordonnanceur va donc passer A \u00e0 Bloqu\u00e9 et va revenir au processus B qui redevient \u00c9lu . L'\u00e9tape B2 de B est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource R, qui n'est pas disponible. L'ordonnanceur va donc passer B \u00e0 Bloqu\u00e9 . Les deux processus A et B sont donc dans l'\u00e9tat Bloqu\u00e9 , chacun en attente de la lib\u00e9ration d'une ressource bloqu\u00e9e par l'autre : ils se bloquent mutuellement. Cette situation (critique) est appel\u00e9e interblocage ou deadlock . 3.3 Repr\u00e9sentation sch\u00e9matique \u2693\ufe0e les processus seront repr\u00e9sent\u00e9s par des cercles , les ressources par des carr\u00e9s . Si \u00e0 l'\u00e9tape A1 le processus A a demand\u00e9 et re\u00e7u la ressource R, la repr\u00e9sentation sera : Si \u00e0 l'\u00e9tape A2 le processus A est en attente de la ressource S, la repr\u00e9sentation sera : Avec ces conventions, la situation pr\u00e9c\u00e9dente peut donc se sch\u00e9matiser par : Ce type de sch\u00e9ma fait appara\u00eetre un cycle d'interd\u00e9pendance , qui caract\u00e9rise ici la situation de deadlock. 3.4 Comment s'en pr\u00e9munir ? (HP) \u2693\ufe0e Il existe trois strat\u00e9gies pour \u00e9viter les interblocages : la pr\u00e9vention : on oblige le processus \u00e0 d\u00e9clarer \u00e0 l'avance la liste de toutes les ressources auxquelles il va acc\u00e9der. l'\u00e9vitement : on fait en sorte qu'\u00e0 chaque \u00e9tape il reste une possibilit\u00e9 d'attribution de ressources qui \u00e9vite le deadlock. la d\u00e9tection/r\u00e9solution : on laisse la situation arriver jusqu'au deadlock, puis un algorithme de r\u00e9solution d\u00e9termine quelle ressource lib\u00e9rer pour mettre fin \u00e0 l'interblocage. 3.5 Le deadlock dans la vie courante \u2693\ufe0e 3.5.1 L'emballage diabolique \u2693\ufe0e 3.5.2 Le carrefour maudit \u2693\ufe0e 3.5.3 Le ch\u00f4mage \u00e9ternel \u2693\ufe0e", "title": "Cours"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#gestion-des-processus", "text": "", "title": "Gestion des processus"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#1-notion-de-processus", "text": "", "title": "1. Notion de processus"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#11-definition-dun-processus", "text": "Lorsqu'un programme est ex\u00e9cut\u00e9 sur un ordinateur, celui-ci va cr\u00e9er un (ou plusieurs) processus . On dit que ce processus est une instance d'ex\u00e9cution de ce programme. Un processus est caract\u00e9ris\u00e9 par : l'ensemble des instructions qu'il va devoir accomplir (\u00e9crites dans le fichier ex\u00e9cutable obtenu par la compilation du code-source du programme) les ressources que le programme va mobiliser (fichier en ouverture, carte son...) l'\u00e9tat des registres du processeur (voir le cours de Premi\u00e8re sur l' architecture Von Neumann )", "title": "1.1 D\u00e9finition d'un processus"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#12-observation-des-processus-sous-linux", "text": "", "title": "1.2 Observation des processus sous Linux"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#121-la-commande-ps", "text": "Dans un terminal, la commande ps va permettre d'afficher la liste des processus actifs. Plus pr\u00e9cis\u00e9ment, nous allons utiliser la commande ps -lu nom_user . L'option l permet d'afficher un grand nombre de renseignements et l'option u permet de sp\u00e9cifier l'utilisateur propri\u00e9taire des processus. On retrouve notamment dans ce tableau les colonnes : CMD (Command) : le nom de la commande qui a cr\u00e9\u00e9 le processus. Vous pouvez y retrouver par ordre chronologique le nom de tous les programmes actifs. Certains sont ceux que vous avez ouverts volontairement (navigateur...) mais on y trouve surtout tous les programmes n\u00e9cessaires au bon fonctionnement du syst\u00e8me d'exploitation. Le dernier processus en bas de la liste est forc\u00e9ment ps , puisque vous venez de l'appeler. PID (Process Identifier) : le num\u00e9ro unique d'identification, affect\u00e9 chronologiquement par le syst\u00e8me d'exploitation. Le processus de PID \u00e9gal \u00e0 1 est systemd , qui est le tout premier programme lanc\u00e9 par le noyau Linux au d\u00e9marrage. PPID (Parent PID) : certains processus vont eux-m\u00eames lancer plusieurs processus-fils, qui porteront le m\u00eame nom. C'est ainsi qu'on peut retrouver de multiples processus s'appelant chrome : Ici, l'instance \u00abprincipale\u00bb de Chrome ( PID 1453) a g\u00e9n\u00e9r\u00e9 6 autres instances de PID diff\u00e9rents, dont le PPID vaut 1453. Dans Chrome/Chromium, vous pouvez comprendre le r\u00f4le de chaque processus en le retrouvant dans le gestionnaire des t\u00e2ches (clic-droit sur une zone vide de la barre d'onglets)", "title": "1.2.1 La commande ps"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#122-la-commande-pstree", "text": "\u00c0 noter que la commande pstree permet d'afficher les processus sous forme d'arborescence :", "title": "1.2.2 La commande pstree"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#123-la-commande-top", "text": "La commande top permet de conna\u00eetre en temps r\u00e9el la liste des processus, class\u00e9s par ordre d\u00e9croissant de consommation de CPU. On ferme top par la combinaison de touches Ctrl-C . Pourcentage d'utilisation du CPU En face de chaque processus est affich\u00e9e sa consommation de CPU. Elle est calcul\u00e9e en prenant, sur un intervalle de temps donn\u00e9, le temps qu'a pass\u00e9 le CPU \u00e0 traiter le processus en question, et en divisant ce temps par le temps total de la mesure. \\[\\text{Pourcentage d'utilisation CPU} = \\frac{\\text{Temps d'utilisation CPU}}{\\text{Temps total \u00e9coul\u00e9}} \\times 100\\] Si on rep\u00e8re alors un processus qui consomme beaucoup trop de ressources, on peut utiliser...", "title": "1.2.3 La commande top"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#124-la-commande-kill", "text": "La commande kill permet de fermer un processus, en donnant son PID en argument. Exemple : kill 1453 tuera Chrome (voir la capture du 1.2.1)", "title": "1.2.4 La commande kill"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#2-ordonnancement", "text": "", "title": "2. Ordonnancement"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#21-experience-les-processus-fonctionnent-simultanement-a-tour-de-role", "text": "Un ordinateur donne l'illusion de r\u00e9aliser plusieurs t\u00e2ches simultan\u00e9ment. Hormis pour les processeurs fonctionnant avec plusieurs c\u0153urs, il n'en est rien. Comme nous l'avons vu, ces processus sont lanc\u00e9s s\u00e9quentiellement par le syst\u00e8me d'exploitation, et sont ensuite en apparence tous \u00abactifs en m\u00eame temps\u00bb (les guillemets sont importants) : on parle de programmation concurrente . Revenons sur l'expression \u00abactifs en m\u00eame temps\u00bb, car elle v\u00e9hicule une fausse id\u00e9e : ces processus sont bien vivants dans un m\u00eame laps de temps, mais ils s'ex\u00e9cutent LES UNS APR\u00c8S LES AUTRES , le processeur ne pouvant en traiter qu' un seul \u00e0 la fois . Un cadencement extr\u00eamement rapide et efficace donne l' apparence d'une (fausse) simultan\u00e9it\u00e9. Nous allons la mettre en \u00e9vidence : Consid\u00e9rons les fichiers progA.py et progB.py ci-dessous : progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) progB.py import time time . sleep ( 0.01 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.02 ) Le programme progB.py est l\u00e9g\u00e8rement retard\u00e9 au d\u00e9marrage par le time.sleep(0.01) . Il devrait donc en r\u00e9sulter un entrelacement entre les phrases programme A en cours et programme B en cours . L'ex\u00e9cution \u00abd'apparence simultan\u00e9e\u00bb de ces deux programmes peut se faire dans un Terminal via la commande python3 progA.py & python3 progB.py . Il en r\u00e9sulte ceci : Nous retrouvons bien l'alternance pr\u00e9vue \u00e0 la lecture du code. Tout se passe donc comme si les deux processus avaient \u00e9t\u00e9 lanc\u00e9s et trait\u00e9s simultan\u00e9ment. R\u00e9duisons maintenant les temporisations (en passant du centi\u00e8me de seconde \u00e0 la milliseconde): progA.py import time for i in range ( 10 ): print ( \"programme A en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) progB.py import time time . sleep ( 0.001 ) for i in range ( 10 ): print ( \"programme B en cours, it\u00e9ration\" , i ) time . sleep ( 0.002 ) Il en r\u00e9sulte maintenant ceci : L'alternance pr\u00e9vue n'est plus respect\u00e9e (et les r\u00e9sultats deviennent non-reproductibles). Si la gestion des processus \u00e9tait r\u00e9ellement simultan\u00e9e, m\u00eame en consid\u00e9rant des ralentissements du processeur par des sollicitations ext\u00e9rieures, chaque processus serait ralenti de la m\u00eame mani\u00e8re : l'entrelacement des phrases serait toujours le m\u00eame. En r\u00e9alit\u00e9, le processeur passe son temps \u00e0 alterner entre les divers processus qu'il a \u00e0 g\u00e9rer, et les met en attente quand il ne peut pas s'occuper d'eux. Il ob\u00e9it pour cela aux instructions de son ordonnanceur .", "title": "2.1 Exp\u00e9rience : les processus fonctionnent simultan\u00e9ment \u00e0 tour de r\u00f4le."}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#22-lordonnancement-des-processus", "text": "", "title": "2.2 L'ordonnancement des processus"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#221-differents-types-dordonnancement", "text": "Si on vous donne 4 t\u00e2ches A, B, C et D \u00e0 accomplir, vous pouvez d\u00e9cider : de faire la t\u00e2che prioritaire d'abord ; de faire la t\u00e2che la plus rapide d'abord ; de faire la t\u00e2che la plus longue d'abord ; de les faire dans l'ordre o\u00f9 elles vous ont \u00e9t\u00e9 donn\u00e9es ; de faire \u00e0 tour de r\u00f4le chaque t\u00e2che pendant un temps fixe jusqu'\u00e0 ce qu'elles soient toutes termin\u00e9es; ... Un processeur est confront\u00e9 aux m\u00eames choix : comment d\u00e9terminer quel processus doit \u00eatre trait\u00e9 \u00e0 quel moment ? Le sch\u00e9ma ci-dessous (issu de ce site ) pr\u00e9sente quelques politiques d'ordonnancement : Sous Linux, l'ordonnancement est effectu\u00e9 par un syst\u00e8me hybride o\u00f9 les processus sont ex\u00e9cut\u00e9s \u00e0 tour de r\u00f4le (on parle de tourniquet ou de Round Robin ) suivant un ordre de priorit\u00e9 dynamique. Dans le cas (tr\u00e8s fr\u00e9quent maintenant) d'un processeur multi-c\u0153urs , le probl\u00e8me reste identique. Certes, sur 4 c\u0153urs, 4 processus pourront \u00eatre trait\u00e9s simultan\u00e9ment (une r\u00e9elle simultan\u00e9it\u00e9) mais il reste toujours beaucoup plus de processus \u00e0 traiter que de c\u0153urs dans le processeur... et un ordonnancement est donc toujours n\u00e9cessaire.", "title": "2.2.1 Diff\u00e9rents types d'ordonnancement"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#222-les-differents-etats-dun-processus", "text": "Selon que l'ordonnanceur aura d\u00e9cid\u00e9 de le confier ou non au processeur pour son ex\u00e9cution, un processus peut donc se trouver dans 3 \u00e9tats : Pr\u00eat : il attend qu'arrive le moment de son ex\u00e9cution. \u00c9lu : il est en cours d'ex\u00e9cution par le processeur. Bloqu\u00e9 : pendant son ex\u00e9cution (\u00e9tat \u00c9lu ), le processus r\u00e9clame une ressource qui n'est pas imm\u00e9diatement disponible. Son ex\u00e9cution s'interrompt. Lorsque la ressource sera disponible, le processus repassera par l'\u00e9tat Pr\u00eat et attendra \u00e0 nouveau son tour. Voici les transitions possibles entre ces \u00e9tats (diagramme issu de https://info.blaisepascal.fr/nsi-processus-et-ressources ) : Ou de mani\u00e8re simplifi\u00e9e : On peut utiliser la m\u00e9taphore suivante : Sur le bureau d'un professeur, il y a 3 paquets de copies, correspondant aux classes A, B, et C. Ces paquets sont Pr\u00eats \u00e0 \u00eatre corrig\u00e9s. Si le professeur ram\u00e8ne devant lui le paquet A, celui-ci devient \u00c9lu , et le professeur peut commencer \u00e0 le corriger. Pour se changer les id\u00e9es, il peut interrompre la correction du paquet A (qui repassera \u00e0 l'\u00e9tat Pr\u00eat en attendant son tour) et ramener vers lui le paquet C. Il pourra ensuite prendre le paquet B, puis \u00e0 nouveau le C, puis le A, ainsi de suite jusqu'\u00e0 ce que tous les paquets soient totalement corrig\u00e9s. Ces paquets seront alors Termin\u00e9s . Si, pendant la correction du paquet, le professeur donne celui-ci \u00e0 sa fille pour qu'elle classe les copies par ordre alphab\u00e9tique, ce paquet sera Bloqu\u00e9 . Il ne reviendra \u00e0 l'\u00e9tat Pr\u00eat que quand la fille du professeur aura rendu le paquet. Au cours de cette proc\u00e9dure, le professeur n'a toujours eu devant lui qu' un seul paquet de copies (soit A, soit B, soit C). Pourquoi l'acc\u00e8s \u00e0 une ressource peut bloquer un processus ? Pendant son ex\u00e9cution, un processus peut avoir besoin d'acc\u00e9der \u00e0 une ressource d\u00e9j\u00e0 occup\u00e9e (un fichier d\u00e9j\u00e0 ouvert, par exemple) ou \u00eatre en attente d'une entr\u00e9e-utilisateur (un input() dans un code Python par exemple). Dans ce cas-l\u00e0, le processeur va passer ce processus \u00e0 l'\u00e9tat Bloqu\u00e9 , pour pouvoir ainsi se consacrer \u00e0 un autre processus. Une fois d\u00e9bloqu\u00e9, le processus va repasser \u00e0 l'\u00e9tat Pr\u00eat et rejoindre (par exemple) la file d'attente des processus avant d'\u00eatre \u00e0 nouveau \u00c9lu et donc ex\u00e9cut\u00e9.", "title": "2.2.2 Les diff\u00e9rents \u00e9tats d'un processus"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#3-interblocage", "text": "", "title": "3. Interblocage"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#31-definition-et-exemple", "text": "Comme nous venons de le voir, un processus peut \u00eatre dans l'\u00e9tat bloqu\u00e9 dans l'attente de la lib\u00e9ration d'une ressource. Ces ressources (l'acc\u00e8s en \u00e9criture \u00e0 un fichier, \u00e0 un registre de la m\u00e9moire...) ne peuvent \u00eatre donn\u00e9es \u00e0 deux processus \u00e0 la fois. Des processus souhaitant acc\u00e9der \u00e0 cette ressource sont donc en concurrence sur cette ressource. Un processus peut donc devoir attendre qu'une ressource se lib\u00e8re avant de pouvoir y acc\u00e9der (et ainsi passer de l'\u00e9tat Bloqu\u00e9 \u00e0 l'\u00e9tat Pr\u00eat). Probl\u00e8me : Et si deux processus se bloquent mutuellement la ressource dont ils ont besoin ? Exemple : Consid\u00e9rons 2 processus A et B, et deux ressources R et S. L'action des processus A et B est d\u00e9crite ci-dessous : D\u00e9roulement des processus A et B : A et B sont cr\u00e9\u00e9s et passent \u00e0 l'\u00e9tat Pr\u00eat . L'ordonnanceur d\u00e9clare \u00c9lu le processus A (ou bien B, cela ne change rien). L'\u00e9tape A1 de A est r\u00e9alis\u00e9e : la ressource R est donc affect\u00e9e \u00e0 A. L'ordonnanceur d\u00e9clare maintenant \u00c9lu le processus B. A est donc pass\u00e9 \u00e0 Pr\u00eat en attendant que son tour revienne. L'\u00e9tape B1 de B est r\u00e9alis\u00e9e : la ressource S est donc affect\u00e9e \u00e0 B. L'ordonnanceur d\u00e9clare \u00e0 nouveau \u00c9lu le processus A. B est donc pass\u00e9 \u00e0 Pr\u00eat en attendant que son tour revienne. L'\u00e9tape A2 de A est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource S, qui n'est pas disponible. L'ordonnanceur va donc passer A \u00e0 Bloqu\u00e9 et va revenir au processus B qui redevient \u00c9lu . L'\u00e9tape B2 de B est donc enclench\u00e9e : probl\u00e8me, il faut pour cela pouvoir acc\u00e8der \u00e0 la ressource R, qui n'est pas disponible. L'ordonnanceur va donc passer B \u00e0 Bloqu\u00e9 . Les deux processus A et B sont donc dans l'\u00e9tat Bloqu\u00e9 , chacun en attente de la lib\u00e9ration d'une ressource bloqu\u00e9e par l'autre : ils se bloquent mutuellement. Cette situation (critique) est appel\u00e9e interblocage ou deadlock .", "title": "3.1 D\u00e9finition et exemple"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#33-representation-schematique", "text": "les processus seront repr\u00e9sent\u00e9s par des cercles , les ressources par des carr\u00e9s . Si \u00e0 l'\u00e9tape A1 le processus A a demand\u00e9 et re\u00e7u la ressource R, la repr\u00e9sentation sera : Si \u00e0 l'\u00e9tape A2 le processus A est en attente de la ressource S, la repr\u00e9sentation sera : Avec ces conventions, la situation pr\u00e9c\u00e9dente peut donc se sch\u00e9matiser par : Ce type de sch\u00e9ma fait appara\u00eetre un cycle d'interd\u00e9pendance , qui caract\u00e9rise ici la situation de deadlock.", "title": "3.3 Repr\u00e9sentation sch\u00e9matique"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#34-comment-sen-premunir-hp", "text": "Il existe trois strat\u00e9gies pour \u00e9viter les interblocages : la pr\u00e9vention : on oblige le processus \u00e0 d\u00e9clarer \u00e0 l'avance la liste de toutes les ressources auxquelles il va acc\u00e9der. l'\u00e9vitement : on fait en sorte qu'\u00e0 chaque \u00e9tape il reste une possibilit\u00e9 d'attribution de ressources qui \u00e9vite le deadlock. la d\u00e9tection/r\u00e9solution : on laisse la situation arriver jusqu'au deadlock, puis un algorithme de r\u00e9solution d\u00e9termine quelle ressource lib\u00e9rer pour mettre fin \u00e0 l'interblocage.", "title": "3.4 Comment s'en pr\u00e9munir ? (HP)"}, {"location": "T5_Architecture_materielle/5.2_Gestion_des_processus/cours/#35-le-deadlock-dans-la-vie-courante", "text": "", "title": "3.5 Le deadlock dans la vie courante"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/Exercices/", "text": "Exercice 1 Exercice 5 du sujet La R\u00e9union J1 2022 Correction Q1.a. Une adresse IPv4 se code \u00e0 l'aide de 4 octets. Correction Q1.b. Le PC3 a pour adresse 172.150.4.30 / 24 . Cela signfie que son masque, en notation CIDR, est 24. Ses 24 premiers bits sont donc \u00e0 1. Cela correspond au masque 255.255.255.0 en notation d\u00e9cimale. Correction Q2. Correction Q3.a. Pour \u00eatre dans le r\u00e9seau 1, il faut que le & logique entre l'IP de la machine et l'adresse du masque donne l'adresse r\u00e9seau ( 172.150.4.0 ). Le r\u00e9seau \u00e9tant en /24 (\u00e9quivalent au masque 255.255.255.0 ), cela signifie que l'adresse IP de la machine soit de la forme 172.150.4.??? . Attention, il faut en plus s'assurer que l'adresse ne soit pas d\u00e9j\u00e0 utilis\u00e9e, et qu'elle ne soit pas l'adresse du r\u00e9seau ( 172.150.4.0 ) ou de broadcast ( 172.150.4.255 ). Il reste alors les adresses 4) et 6). ( 172.150.4.11 et 172.150.4.200 ) Correction Q3.b. La commande permettant de conna\u00eetre son adresse IP est ifconfig ou ip addr sous Linux / MacOS. Ou bien ipconfig sous Windows. Correction Q4. La solution de relier les switchs entre eux n'est pas satisfaisante. Les deux r\u00e9seaux ne pourront pas communiquer entre eux, \u00e0 moins d'\u00e9largir (beaucoup) leur masque de sous-r\u00e9seau. La meilleure solution est d'installer un routeur entre les deux switchs, de lui attribuer une adresse IP dans chaque sous-r\u00e9seau, et de renseigner cette adresse IP comme adresse de passerelle sur chacun des PCs des deux sous-r\u00e9seaux. Correction Q5. \ud83d\udc0d Script Python 1 2 3 4 5 6 def adresse ( IP , liste_IP ): if IP in liste_IP : print ( \"trouv\u00e9e\" ) else : liste_IP . append ( IP ) print ( \"pas trouv\u00e9e, ajout\u00e9e\" ) Exercice 2 \u00c9nonc\u00e9 Correction Cr\u00e9er une fonction meme_sous_reseau(ip_a, ip_b, masque) qui renvoie un bool\u00e9en indiquant si A et B sont partie du m\u00eame sous-r\u00e9seau. Exercice (difficile) \u00e0 r\u00e9aliser en Test Driven Developpement \u00e0 partir du squelette de code ci-dessous, en testant chaque fonction apr\u00e8s sa r\u00e9alisation, jusqu'\u00e0 la fonction finale. \ud83d\udc0d Script Python def convert_ip_to_list ( ip ): \"\"\" entr\u00e9e : ip (string) sortie : liste d'entiers \"\"\" # \u00e0 vous def test_convert_ip_to_list (): assert convert_ip_to_list ( '192.168.0.1' ) == [ 192 , 168 , 0 , 1 ] def nb_to_binary_word ( masque ): \"\"\" entr\u00e9e : masque (int) sortie : string \"\"\" # \u00e0 vous def test_nb_convert_to_binary_word (): assert nb_to_binary_word ( 24 ) == '11111111111111111111111100000000' def binary_word_to_list ( word ): \"\"\" entr\u00e9e : word (string de 32 caract\u00e8res) sortie : liste de 4 entiers \"\"\" # \u00e0 vous def test_binary_word_to_list (): assert binary_word_to_list ( '11111111111111111111111100000000' ) == [ 255 , 255 , 255 , 0 ] def meme_sous_reseau ( ip_a , ip_b , masque ): \"\"\" ip_a: string contenant une IP (ex \"192.168.0.1\") ip_b : string contenant une IP masque : entier du masque en notation CIDR (ex : 24) renvoie un bool\u00e9en indiquant si ip_a et ip_b sont dans le m\u00eame sous-r\u00e9seau \"\"\" # \u00e0 vous def test_meme_sous_reseau (): assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 24 ) == False assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 20 ) == True assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.0.3\" , 30 ) == True Exercice difficile, il n'est pas \u00e0 savoir faire mais c'est bien de le comprendre ! \ud83d\udc0d Script Python def convert_ip_to_list ( ip ): \"\"\" entr\u00e9e : ip (string) sortie : liste d'entiers \"\"\" return [ int ( k ) for k in ip . split ( \".\" )] def test_convert_ip_to_list (): assert convert_ip_to_list ( '192.168.0.1' ) == [ 192 , 168 , 0 , 1 ] def nb_to_binary_word ( masque ): \"\"\" entr\u00e9e : masque (int) sortie : string \"\"\" return '1' * masque + '0' * ( 32 - masque ) def test_nb_convert_to_binary_word (): assert nb_to_binary_word ( 24 ) == '11111111111111111111111100000000' def binary_word_to_list ( word ): \"\"\" entr\u00e9e : word (string de 32 caract\u00e8res) sortie : liste de 4 entiers \"\"\" decoupe = [ word [ 8 * i : 8 * ( i + 1 )] for i in range ( 4 )] return [ int ( k , 2 ) for k in decoupe ] def test_binary_word_to_list (): assert binary_word_to_list ( '11111111111111111111111100000000' ) == [ 255 , 255 , 255 , 0 ] def meme_sous_reseau ( ip_a , ip_b , masque ): lstA = convert_ip_to_list ( ip_a ) lstB = convert_ip_to_list ( ip_b ) mask = binary_word_to_list ( nb_to_binary_word ( masque )) resA = [ lstA [ i ] & mask [ i ] for i in range ( 4 )] resB = [ lstB [ i ] & mask [ i ] for i in range ( 4 )] return resA == resB def test_meme_sous_reseau (): assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 24 ) == False assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.1.3\" , 20 ) == True assert meme_sous_reseau ( \"192.168.0.1\" , \"192.168.0.3\" , 30 ) == True Exercice 3 \u00c9nonc\u00e9 Correction 2020, sujet 0 On consid\u00e8re un r\u00e9seau compos\u00e9 de plusieurs routeurs reli\u00e9s de la fa\u00e7on suivante : Le protocole RIP permet de construire les tables de routage des diff\u00e9rents routeurs, en indiquant pour chaque routeur la distance, en nombre de sauts, qui le s\u00e9pare d\u2019un autre routeur. Pour le r\u00e9seau ci-dessus, on dispose des tables de routage suivantes : Question 1 Le routeur A doit transmettre un message au routeur G, en effectuant un nombre minimal de sauts. D\u00e9terminer le trajet parcouru. D\u00e9terminer une table de routage possible pour le routeur G obtenue \u00e0 l\u2019aide du protocole RIP. Question 2 Le routeur C tombe en panne. Reconstruire la table de routage du routeur A en suivant le protocole RIP. Q1.1. Le trajet parcouru de A \u00e0 G est A-C-F-G Q1.2. Table de routage de G : Destination Routeur suivant Distance A F 3 B E 3 C E 2 D E 2 E E 1 F F 1 Q2 Nouvelle table de routage de A : Destination Routeur suivant Distance B B 1 D D 1 E D 2 G D 3 F D 4 Exercice 4 \u00c9nonc\u00e9 Correction 2021, sujet M\u00e9tropole 1 On repr\u00e9sente ci-dessous un r\u00e9seau dans lequel R1, R2, R3, R4, R5 et R6 sont des routeurs. Le r\u00e9seau local L1 est reli\u00e9 au routeur R1 et le r\u00e9seau local L2 au routeur R6. Dans cet exercice, les adresses IP sont compos\u00e9es de 4 octets, soit 32 bits. Elles sont not\u00e9es X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets, convertis en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants repr\u00e9sentent la partie \u00ab h\u00f4te \u00bb. Toutes les adresses des h\u00f4tes connect\u00e9s \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau et peuvent donc communiquer directement. L\u2019adresse IP dont tous les bits de la partie \u00ab h\u00f4te \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. On donne \u00e9galement des extraits de la table de routage des routeurs R1 \u00e0 R5 dans le tableau suivant : 1/ Un paquet part du r\u00e9seau local L1 \u00e0 destination du r\u00e9seau local L2. 1.a. En utilisant l\u2019extrait de la table de routage de R1, vers quel routeur R1 envoie-t-il ce paquet : R2 ou R3 ? Justifier. 1.b. A l\u2019aide des extraits de tables de routage ci-dessus, nommer les routeurs travers\u00e9s par ce paquet, lorsqu\u2019il va du r\u00e9seau L1 au r\u00e9seau L2. 2/ La liaison entre R1 et R2 est rompue. 2.a. Sachant que ce r\u00e9seau utilise le protocole RIP (distance en nombre de sauts), donner l\u2019un des deux chemins possibles que pourra suivre un paquet allant de L1 vers L2. 2.b. Dans les extraits de tables de routage ci-dessus, pour le chemin de la question 2.a, quelle(s) ligne(s) sera (seront) modifi\u00e9e(s) ? 3/ On a r\u00e9tabli la liaison entre R1 et R2. Par ailleurs, pour tenir compte du d\u00e9bit des liaisons, on d\u00e9cide d\u2019utiliser le protocole OSPF (distance li\u00e9e au co\u00fbt minimal des liaisons) pour effectuer le routage. Le co\u00fbt des liaisons entre les routeurs est donn\u00e9 par le tableau suivant : a. Le co\u00fbt C d\u2019une liaison est donn\u00e9 ici par la formule \\(C = \\frac{10^9}{BP}\\) o\u00f9 \\(BP\\) est la bande passante de la connexion en bps (bits par seconde). Sachant que la bande passante de la liaison R2-R3 est de 10 Mbps, calculer le co\u00fbt correspondant. b. D\u00e9terminer le chemin parcouru par un paquet partant du r\u00e9seau L1 et arrivant au r\u00e9seau L2, en utilisant le protocole OSPF. c. Indiquer pour quel(s) routeur(s) l\u2019extrait de la table de routage sera modifi\u00e9 pour un paquet \u00e0 destination de L2, avec la m\u00e9trique OSPF. 1.a. D'apr\u00e8s la table, R1 doit passer par la passerelle 86.154.10.1 qui correspond au routeur R2. 1.b. Le paquet va traverser R1, R2, R6 avant d'arriver \u00e0 L2. 2.a. RIP doit minimiser le nombre de sauts, donc les deux chemins minimaux possibles sont R1-R3-R4-R6 et R1-R3-R2-R6. 2.b. La ligne R1 sera modifi\u00e9e, il faudra partir vers R3 (et son r\u00e9seau 112.44.65.0/24). Les autres lignes n'ont pas \u00e0 \u00eatre modifi\u00e9es puisque R3 am\u00e8ne en R4 qui am\u00e8ne en R6. 3.a \\(\\dfrac{10^9}{10 \\times 10^6}=100\\) donc le co\u00fbt R2-R3 est 100. 3.b. Avec OSPF, le chemin qui minimise le co\u00fbt est le chemin R1-R2-R4-R5-R6 (co\u00fbt 103) : 3.c. Dans la table de routage initiale, il faut modifier R2 pour qu'elle envoie sur R4 (et non sur R6), mais aussi R4 pour qu'elle envoie sur R5 (et non sur R6). Exercice 5 \u00c9nonc\u00e9 Correction 2021, sujet M\u00e9tropole 2 (sujet modifi\u00e9, correction d'erreurs sur les adresses passerelles) Figure 1 La figure 1 ci-dessus repr\u00e9sente le sch\u00e9ma d\u2019un r\u00e9seau d\u2019entreprise. Il y figure deux r\u00e9seaux locaux L1 et L2. Ces deux r\u00e9seaux locaux sont interconnect\u00e9s par les routeurs R2, R3, R4 et R5. Le r\u00e9seau local L1 est constitu\u00e9 des PC portables P1 et P2 connect\u00e9s \u00e0 la passerelle R1 par le switch Sw1. Les serveurs S1 et S2 sont connect\u00e9s \u00e0 la passerelle R6 par le switch Sw2. Le tableau 1 suivant indique les adresses IPv4 des machines constituants le r\u00e9seau de l\u2019entreprise. Tableau 1 : adresses IPv4 des machines Rappels et notations Rappelons qu\u2019une adresse IP est compos\u00e9e de 4 octets, soit 32 bits. Elle est not\u00e9e X1.X2.X3.X4, o\u00f9 X1, X2, X3 et X4 sont les valeurs des 4 octets. Dans le tableau 1, les valeurs des 4 octets ont \u00e9t\u00e9 converties en notation d\u00e9cimale. La notation X1.X2.X3.X4/n signifie que les n premiers bits de poids forts de l\u2019adresse IP repr\u00e9sentent la partie \u00ab r\u00e9seau \u00bb, les bits suivants de poids faibles repr\u00e9sentent la partie \u00ab machine \u00bb. Toutes les adresses des machines connect\u00e9es \u00e0 un r\u00e9seau local ont la m\u00eame partie r\u00e9seau. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 0 est appel\u00e9e \u00ab adresse du r\u00e9seau \u00bb. L\u2019adresse IP dont tous les bits de la partie \u00ab machine \u00bb sont \u00e0 1 est appel\u00e9e \u00ab adresse de diffusion \u00bb. 1/ 1.a. Quelles sont les adresses des r\u00e9seaux locaux L1 et L2 ? 1.b. Donner la plus petite et la plus grande adresse IP valides pouvant \u00eatre attribu\u00e9es \u00e0 un ordinateur portable ou un serveur sur chacun des r\u00e9seaux L1 et L2 sachant que l\u2019adresse du r\u00e9seau et l\u2019adresse de diffusion ne peuvent pas \u00eatre attribu\u00e9es \u00e0 une machine. 1.c. Combien de machines peut-on connecter au maximum \u00e0 chacun des r\u00e9seaux locaux L1 et L2 ? 2/ 2.a. Expliquer l\u2019utilit\u00e9 d\u2019avoir plusieurs chemins possibles reliant les r\u00e9seaux L1 et L2. 2.b. Quel est le chemin le plus court en nombre de sauts pour relier R1 et R6 ? Donner le nombre de sauts de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. 2.c. La bande passante d\u2019une liaison Ether (quantit\u00e9 d\u2019information qui peut \u00eatre transmise en bits/s) est de \\(10^7\\) bits/s et celle d\u2019une liaison FastEther est de \\(10^8\\) bits/s. Le co\u00fbt d\u2019une liaison est d\u00e9fini par \\(\\frac{10^8}{d}\\) , o\u00f9 \\(d\\) est sa bande passante en bits/s. Tableau 2 : type des liaisons entre les routeurs Quel est le chemin reliant R1 et R6 qui a le plus petit co\u00fbt ? Donner le co\u00fbt de ce chemin et pr\u00e9ciser les routeurs utilis\u00e9s. 3/ Dans l\u2019annexe A figurent les tables de routages des routeurs R1, R2, R5 et R6 au d\u00e9marrage du r\u00e9seau. Indiquer sur votre copie ce qui doit figurer dans les lignes laiss\u00e9es vides des tables de routage des routeurs R5 et R6 pour que les \u00e9changes entre les ordinateurs des r\u00e9seaux L1 et L2 se fassent en empruntant le chemin le plus court en nombre de sauts. 1.a L'adresse du r\u00e9seau L1 est 192.168.1.0/24. L'adresse de L2 est 175.6.0.0/16. 1.b Pour le r\u00e9seau L1 (192.168.1.0/24), l'adresse min est 192.168.1.1/24, l'adresse max est 192.168.1.254/24. Pour le r\u00e9seau L2 (175.6.0.0/16), l'adresse min est 175.6.0.1/16 et l'adresse max est 175.6.255.254/16 1.c. Pour le r\u00e9seau L1, il y a donc 254 adresses (256 moins les deux interdites) Pour le r\u00e9seau L2, il y en a \\(256^2-2\\) , soit 65534. 2.a Il est utile d'avoir plusieurs chemins en cas de panne d'un routeur. 2.b En nombres de sauts (protocole RIP), le chemin le plus court est R1-R2-R5-R6, qui contient 3 sauts. 2.c Les liaisons Ether ont un co\u00fbt de 10, les liaisons FastEther ont un co\u00fbt de 1. Ce qui donne : Le chemin le plus court est donc R1-R2-R3-R4-R5-R6, avec un co\u00fbt total de 23. On veut que le chemin soit le plus court en nombre de sauts, donc il faut que le chemin soit R1-R2-R5-R6. Dans la table R5, il manque les lignes IP destination Passerelle Interface 192.168.1.0/24 10.1.3.1 Interface 1 172.16.0.0/16 10.1.7.2 Interface 4 Dans la table R6, on peut compl\u00e9ter comme ceci (il faudrait des lignes suppl\u00e9mentaires pour y inscrire tous les r\u00e9seaux) IP destination Passerelle Interface 10.1.7.0/24 Interface 2 192.168.1.0/24 10.1.7.1 Interface 2 Exercice 6 \u00c9nonc\u00e9 Correction 2021, sujet Am\u00e9rique du Nord Un constructeur automobile poss\u00e8de six sites de production qui \u00e9changent des documents entre eux. Les sites de production sont reli\u00e9s entre eux par six routeurs A, B, C, D, E et F. On donne ci-dessous les tables de routage des routeurs A \u00e0 F obtenues avec le protocole RIP. D\u00e9terminer \u00e0 l'aide de ces tables le chemin emprunt\u00e9 par un paquet de donn\u00e9es envoy\u00e9 du routeur A vers le routeur F. On veut repr\u00e9senter sch\u00e9matiquement le r\u00e9seau de routeur \u00e0 partir des tables de routage. Recopier sur la copie le sch\u00e9ma ci-dessous : En s'appuyant sur les tables de routage, tracer les liaisons entre les routeurs. A-B-E-F 2. Exercice 7 Exercice 4 du sujet Nouvelle-Cal\u00e9donie J2 2022 . Correction Q1.a. 195.168.1.0/24 Correction Q1.b. 195.168.1.17/24 Correction Q1.c Le r\u00e9seau T2 a pour adresse 172.162.1.0/24 . Sur ce r\u00e9seau, 254 adresses sont initialement disponibles (de 172.162.1.1 \u00e0 172.162.1.254 , puisque l'adresse 172.162.1.255 est r\u00e9serv\u00e9e pour le broadcast sur le r\u00e9seau). Comme le routeur R2 et le portable 5 prennent chacun une adresse IP, il en reste donc 252 pour le portable 4. Correction Q2. c\u00f4t\u00e9 R4 : 200.158.4.1 c\u00f4t\u00e9 R2 : 198.164.3.2 (car la 198.164.3.1 est d\u00e9j\u00e0 prise par R2) c\u00f4t\u00e9 S3 : 199.160.1.1 Correction Q3.a. Parcours possibles : - S1-R1-R2-S2 - S1-R1-R4-R2-S2 - S1-R1-R4-R3-R2-S2 Correction Q3.b. Suivant le protocole RIP, le parcours le plus court est celui passant par R1 puis R2. Il comporte 2 sauts. Correction Q3.c Si la liaison R1-R2 est rompue, le protocole RIP sera emprunter le chemin R1-R4-R2, qui est le nouveau meilleur chemin, comportant 3 sauts. Correction Q4. Le c\u00e2ble utilis\u00e9 est le cable c) Ethernet. (le c\u00e2ble \u00abInternet\u00bb n'existe, les c\u00e2bles VGA et HDMI servent \u00e0 relier un ordinateur \u00e0 un \u00e9cran). Correction Q5.a. \\(10=\\dfrac{10^9}{d}\\) donc \\(d=\\dfrac{10^9}{10}=10^8\\) . Le d\u00e9bit de cette liaison est donc de \\(10^8\\) bits par seconde, soit 100 Mbps. Correction Q5.b. Le parcours de co\u00fbt minimal est le parcours R1-R4-R2, qui a un co\u00fbt total de 2. Co\u00fbt des autres parcours : - R1-R2 : 10 - R1-R4-R3-R2 : 151 Le parcours R1-R4-R2 est donc bien le parcours minimal. Exercice 8 Parties 2, 3 et 4 de l'exercice 2 du sujet Nouvelle-Cal\u00e9donie J1 2022 . Partie 2 Correction Q1. Le r\u00e9seau services a pour adresse IP 195.168.254.0 . Correction Q2. Le r\u00e9seau services a pour adresse 195.168.254.0 . Comme le masque de sous-r\u00e9seau utilis\u00e9 est 255.255.255.0 , 254 adresses sont initialement disponibles ( 195.168.254.1 \u00e0 195.168.254.254 , puisque l'adresse 195.168.254.255 est r\u00e9serv\u00e9e pour le broadcast sur le r\u00e9seau). Comme deux adresses sont d\u00e9j\u00e0 prises par le routeur 1 et le routeur 2, il en reste 252. Correction Q3. Le serveur web acc\u00e8de \u00e0 internet via le routeur 2, dont l'adresse sur le r\u00e9seau services est 192.168.254.2 . C'est donc cette adresse qui joue est l'adresse de passerelle pour le serveur web. Partie 3 Correction Q1. La ligne 2 montre que l'adresse MAC du serveur DNS est 8A:FD:54:49:D0:CC . Correction Q2. La couche Transport montre que le protocole utilis\u00e9 est le protocole UDP. Correction Q3. Le commentaire de la couche Application indique que l'adresse IP du serveur web est 192.168.254.201 . Partie 4 Correction Q1. Table de routage du routeur R4 : Destination Routeur suivant Distance R1 R2 2 R2 R2 1 R3 R2 2 R5 R6 2 R6 R6 1 Correction Q2. Pour minimiser le nombre de sauts (protocole RIP), le trajet sera R1-R2-R4-R6 .", "title": "Exercices"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/", "text": "Protocoles de routage \u2693\ufe0e 0. R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents \u2693\ufe0e cours de 1\u00e8re sur l'architecture d'un r\u00e9seau cours de 1\u00e8re sur les diff\u00e9rents protocoles de communication dans un r\u00e9seau. Notions essentielles Lorsqu'une machine A, d'adresse IP_A veut discuter avec une machine B, d'adresse IP_B : La machine A calcule (gr\u00e2ce au masque de sous-r\u00e9seau) si B est dans le m\u00eame sous-r\u00e9seau qu'elle, ou pas. Si oui, elle peut donc conna\u00eetre l'adresse MAC de la carte r\u00e9seau de la machine B (soit elle la poss\u00e8de d\u00e9j\u00e0 dans sa table ARP, soit elle la demande en envoyant un message de broadcast \u00e0 tout le sous-r\u00e9seau : \u00abqui poss\u00e8de cette adresse IP_B ?\u00bb). Elle envoie donc dans le sous-r\u00e9seau une trame ayant pour ent\u00eate l'adresse MAC de B : le switch lit cette trame, sait sur quel port est branch\u00e9 la machine B et lui envoie sp\u00e9cifiquement donc le message. Si B n'est pas dans le m\u00eame sous-r\u00e9seau que A, A mettra en ent\u00eate de sa trame l'adresse MAC de la carte r\u00e9seau du routeur, qui joue le r\u00f4le de passerelle. Le routeur va ouvrir la trame et va observer l'IP_B, \u00e0 qui il doit remettre ce message. C'est maintenant que vont intervenir les protocoles de routage : est-ce que B est dans le m\u00eame sous-r\u00e9seau que le routeur ? est-ce que B est dans un autre sous-r\u00e9seau connu du routeur ? est-ce que B est totalement inconnu du routeur ? Ces questions trouveront des r\u00e9ponses gr\u00e2ce \u00e0 table de routage du routeur. 1. Tables de routage \u2693\ufe0e Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). interface et passerelle Les tables de routage des routeurs font tr\u00e8s souvent appara\u00eetre deux colonnes, interface et passerelle , dont il ne faut pas confondre l'utilit\u00e9 : interface : c'est l'adresse IP de la carte r\u00e9seau du routeur par o\u00f9 va sortir le paquet \u00e0 envoyer. Il y a donc toujours une adresse d'interface \u00e0 renseigner (car un paquet sort bien de quelque part !). Parfois cette interface sera juste nomm\u00e9e interface1 ou interface2 . passerelle : c'est l'adresse IP de la carte r\u00e9seau du routeur \u00e0 qui on va confier le paquet , si on n'est pas capable de le d\u00e9livrer directement (donc si l'adresse IP de destination n'est pas dans notre propre sous-r\u00e9seau). Cette adresse de passerelle n'est donc pas syst\u00e9matiquement mentionn\u00e9e. Quand elle l'est, elle donne le renseignement sur le prochain routeur \u00e0 qui le paquet est confi\u00e9. Exemple: table de routage du routeur R1 Destination Interface Passerelle F 192.168.0.254 A 10.0.5.152 E 172.17.1.254 B 172.17.1.254 172.17.1.123 C 10.0.5.152 10.0.5.135 Les trois r\u00e9seaux F, A et E sont directement accessibles au routeur R1, puisqu'il en fait partie : il n'a donc pas besoin d'adresse passerelle pour communiquer avec ces r\u00e9seaux. Par contre, la communication avec le r\u00e9seau B n\u00e9cessite de confier le paquet au routeur R2 (c'est le choix de cette table de routage). Il faut donc mentionner l'adresse IP de ce routeur R2 (172.17.1.123), qu'on appelle adresse de passerelle. De la m\u00eame mani\u00e8re, la communication avec le r\u00e9seau C n\u00e9cessite de confier le paquet au routeur R3 (c'est le choix de cette table de routage). Il faut donc mentionner l'adresse IP de ce routeur R3 (10.0.5.135). Comment sont construites les tables de routage ? \u2693\ufe0e Soit \u00e0 la main par l'administrateur r\u00e9seau, quand le r\u00e9seau est petit : on parle alors de table statique . Soit de mani\u00e8re dynamique : les r\u00e9seaux s'envoient eux-m\u00eames des informations permettant de mettre \u00e0 jour leurs tables de routages respectives. Des algorithmes de d\u00e9termination de meilleur chemin sont alors utilis\u00e9s : nous allons en d\u00e9couvrir deux, le protocole RIP et le protocole OSPF . 2. Le protocole RIP \u2693\ufe0e Le protocole RIP ( R outing I nformation P rotocol) est un protocole de routage qui minimise le nombre de routeurs par lesquels les paquets transitent. principe fondamental du protocole RIP Le chemin le plus court. voir le TP d\u00e9branch\u00e9 : le jeu dont vous \u00eates le routeur (proc\u00e9dure: se connecter \u00e0 Overleaf pour pouvoir \u00e9diter le document) Les r\u00e8gles du protocole RIP Le Routing Information Protocol ( RIP ) est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur va recevoir p\u00e9riodiquement (toutes les 30 secondes) la table des r\u00e9seaux auquel il est connect\u00e9, et mettre \u00e0 jour sa propre table suivant les r\u00e8gles ci-dessous : s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et inconv\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF . 3. Le protocole OSPF \u2693\ufe0e Un inconv\u00e9nient majeur du protocole pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. Le protocole OSPF ( O pen S hortest P ath F irst) est un protocole de routage qui minimise le co\u00fbt du transit des paquets. principe fondamental du protocole OSPF Le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF , les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP ) et de la qualit\u00e9 technique de la liaison entre chaque routeur. 3.1 Les diff\u00e9rents types de liaison et leur co\u00fbt \u2693\ufe0e On peut, approximativement, classer les types de liaison suivant ce tableau de d\u00e9bits th\u00e9oriques : Technologie BP descendante BP montante Modem 56 kbit/s 48 kbit/s Bluetooth 3 Mbit/s 3 Mbit/s Ethernet 10 Mbit/s 10 Mbit/s Wi-Fi 10 Mbit/s ~ 10 Gbits/s 10 Mbit/s ~ 10 Gbits/s ADSL 13 Mbit/s 1 Mbit/s 4G 100 Mbit/s 50 Mbit/s Satellite 50 Mbit/s 1 Mbit/s Fast Ethernet 100 Mbit/s 100 Mbit/s FFTH (fibre) 10 Gbit/s 10 Gbit/s 5G 20 Gbit/s 10 Gbit/s L'id\u00e9e du protocole OSPF est de pond\u00e9rer chaque trajet entre routeurs (comptant simplement pour \u00ab1\u00bb dans le protocole RIP ) par une valeur de co\u00fbt inversement proportionnelle au d\u00e9bit de transfert. Par exemple, si le d\u00e9bit \\(d\\) est exprim\u00e9 en bits/s, on peut calculer le co\u00fbt de chaque liaison par la formule : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Cette formule de calcul peut \u00eatre diff\u00e9rente suivant les exercices, et sera syst\u00e9matiquement redonn\u00e9e. N\u00e9anmoins la valeur \\(d\\) sera toujours au d\u00e9nominateur, pour assurer la proportionnalit\u00e9 inverse du d\u00e9bit. Avec cette convention, un route entre deux routeurs reli\u00e9s en Fast Ethernet (100 Mbits/s) aura a un poids de 1, une liaison satellite de 20 Mbits/s aura un poids de 5, etc. 3.2 Exemple \u2693\ufe0e Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de \\(\\frac{100}{20}=5\\) . Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP . 3.3 Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9 \u2693\ufe0e L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exercice d'application de l'algorithme de Dijkstra (HP) Donner le plus court chemin pour aller de E \u00e0 F dans le graphe ci-dessous : correction E A B C D F Choix 0 -- -- -- -- -- E(0) . 30vE -- 40vE 10vE -- D(10) . 20vD -- 40vE . 80vD A(20) . . 60vA 30vA . 80vD C(30) . . 50vC . . 80vD B(50) . . . . . 70vB F(70) Le meilleur trajet est donc E-D-A-C-B-F. Attention ce trajet correspond \u00e0 la colonne choix (dans l'ordre) mais c'est un hasard. 3.4 Exercice \u2693\ufe0e (extrait du sujet 0) On consid\u00e8re le r\u00e9seau suivant : On rappelle que le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Question 1 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? Question 2 Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Correction Q1 1. \\(\\text{co\u00fbt} = \\dfrac{10^8}{10 \\times 10^9}= \\dfrac{10^8}{10^{10}}= 10^{-2}=0,01\\) 2. \\(5=\\dfrac{10^8}{d}\\) donc \\(d=\\dfrac{10^8}{5}=20 \\times 10^6\\) = 20 Mb/s Q2 Le graphe pond\u00e9r\u00e9 par les co\u00fbts est : On peut y deviner le chemin de co\u00fbt minimal entre A et G, qui est A-D-E-G (co\u00fbt 1,011). Pour le justifier, on peut (non obligatoire) faire un algorithme de Dijkstra :", "title": "Cours"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#protocoles-de-routage", "text": "", "title": "Protocoles de routage"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#0-resume-des-episodes-precedents", "text": "cours de 1\u00e8re sur l'architecture d'un r\u00e9seau cours de 1\u00e8re sur les diff\u00e9rents protocoles de communication dans un r\u00e9seau. Notions essentielles Lorsqu'une machine A, d'adresse IP_A veut discuter avec une machine B, d'adresse IP_B : La machine A calcule (gr\u00e2ce au masque de sous-r\u00e9seau) si B est dans le m\u00eame sous-r\u00e9seau qu'elle, ou pas. Si oui, elle peut donc conna\u00eetre l'adresse MAC de la carte r\u00e9seau de la machine B (soit elle la poss\u00e8de d\u00e9j\u00e0 dans sa table ARP, soit elle la demande en envoyant un message de broadcast \u00e0 tout le sous-r\u00e9seau : \u00abqui poss\u00e8de cette adresse IP_B ?\u00bb). Elle envoie donc dans le sous-r\u00e9seau une trame ayant pour ent\u00eate l'adresse MAC de B : le switch lit cette trame, sait sur quel port est branch\u00e9 la machine B et lui envoie sp\u00e9cifiquement donc le message. Si B n'est pas dans le m\u00eame sous-r\u00e9seau que A, A mettra en ent\u00eate de sa trame l'adresse MAC de la carte r\u00e9seau du routeur, qui joue le r\u00f4le de passerelle. Le routeur va ouvrir la trame et va observer l'IP_B, \u00e0 qui il doit remettre ce message. C'est maintenant que vont intervenir les protocoles de routage : est-ce que B est dans le m\u00eame sous-r\u00e9seau que le routeur ? est-ce que B est dans un autre sous-r\u00e9seau connu du routeur ? est-ce que B est totalement inconnu du routeur ? Ces questions trouveront des r\u00e9ponses gr\u00e2ce \u00e0 table de routage du routeur.", "title": "0. R\u00e9sum\u00e9 des \u00e9pisodes pr\u00e9c\u00e9dents"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#1-tables-de-routage", "text": "Les tables de routage sont des informations stock\u00e9es dans le routeur permettant d'aiguiller intelligemment les donn\u00e9es qui lui sont transmises. Dans le r\u00e9seau ci-dessus, si l'ordinateur d'adresse 192.168.0.5 veut interroger le serveur 10.7.3.8 : l'adresse 10.7.3.8 n'\u00e9tant pas dans le sous-r\u00e9seau F (d'adresse 192.168.0.0 / 24 ), la requ\u00eate est confi\u00e9e au routeur via son adresse passerelle dans le r\u00e9seau F (ici 192.168.0.254 ). le routeur observe si l'IP recherch\u00e9e appartient \u00e0 un autre des sous-r\u00e9seaux auquel il est connect\u00e9. Ici, l'IP recherch\u00e9e 10.7.3.8 n'appartient ni au sous-r\u00e9seau A ou E. le routeur va donc regarder dans sa table de routage l'adresse passerelle d'un autre routeur vers qui elle doit rediriger les donn\u00e9es. Si le sous-r\u00e9seau C fait partie de sa table de routage, le routeur R1 saura alors que le meilleur chemin est (par exemple) de confier les donn\u00e9es au routeur R3. si le sous-r\u00e9seau C ne fait pas partie de la table de routage, le routeur R1 va alors le rediriger vers une route \u00abpar d\u00e9faut\u00bb (que l'on peut assimiler au panneau \u00abtoutes directions\u00bb sur les panneaux de signalisation). interface et passerelle Les tables de routage des routeurs font tr\u00e8s souvent appara\u00eetre deux colonnes, interface et passerelle , dont il ne faut pas confondre l'utilit\u00e9 : interface : c'est l'adresse IP de la carte r\u00e9seau du routeur par o\u00f9 va sortir le paquet \u00e0 envoyer. Il y a donc toujours une adresse d'interface \u00e0 renseigner (car un paquet sort bien de quelque part !). Parfois cette interface sera juste nomm\u00e9e interface1 ou interface2 . passerelle : c'est l'adresse IP de la carte r\u00e9seau du routeur \u00e0 qui on va confier le paquet , si on n'est pas capable de le d\u00e9livrer directement (donc si l'adresse IP de destination n'est pas dans notre propre sous-r\u00e9seau). Cette adresse de passerelle n'est donc pas syst\u00e9matiquement mentionn\u00e9e. Quand elle l'est, elle donne le renseignement sur le prochain routeur \u00e0 qui le paquet est confi\u00e9. Exemple: table de routage du routeur R1 Destination Interface Passerelle F 192.168.0.254 A 10.0.5.152 E 172.17.1.254 B 172.17.1.254 172.17.1.123 C 10.0.5.152 10.0.5.135 Les trois r\u00e9seaux F, A et E sont directement accessibles au routeur R1, puisqu'il en fait partie : il n'a donc pas besoin d'adresse passerelle pour communiquer avec ces r\u00e9seaux. Par contre, la communication avec le r\u00e9seau B n\u00e9cessite de confier le paquet au routeur R2 (c'est le choix de cette table de routage). Il faut donc mentionner l'adresse IP de ce routeur R2 (172.17.1.123), qu'on appelle adresse de passerelle. De la m\u00eame mani\u00e8re, la communication avec le r\u00e9seau C n\u00e9cessite de confier le paquet au routeur R3 (c'est le choix de cette table de routage). Il faut donc mentionner l'adresse IP de ce routeur R3 (10.0.5.135).", "title": "1. Tables de routage"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#2-le-protocole-rip", "text": "Le protocole RIP ( R outing I nformation P rotocol) est un protocole de routage qui minimise le nombre de routeurs par lesquels les paquets transitent. principe fondamental du protocole RIP Le chemin le plus court. voir le TP d\u00e9branch\u00e9 : le jeu dont vous \u00eates le routeur (proc\u00e9dure: se connecter \u00e0 Overleaf pour pouvoir \u00e9diter le document) Les r\u00e8gles du protocole RIP Le Routing Information Protocol ( RIP ) est bas\u00e9 sur l'\u00e9change (toutes les 30 secondes) des tables de routage de chaque routeur. Au d\u00e9but, chaque routeur ne conna\u00eet que les r\u00e9seaux auquel il est directement connect\u00e9, associ\u00e9 \u00e0 la distance 1. Ensuite, chaque routeur va recevoir p\u00e9riodiquement (toutes les 30 secondes) la table des r\u00e9seaux auquel il est connect\u00e9, et mettre \u00e0 jour sa propre table suivant les r\u00e8gles ci-dessous : s'il d\u00e9couvre une route vers un nouveau r\u00e9seau inconnu, il l'ajoute \u00e0 sa table en augmentant de 1 la distance annonc\u00e9e par le routeur qui lui a transmis sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus courte (en rajoutant 1) que celle qu'il poss\u00e8de dans sa table, il actualise sa table. s'il d\u00e9couvre une route vers un r\u00e9seau connu mais plus longue que celle qu'il poss\u00e8de dans sa table, il ignore cette route. s'il re\u00e7oit une route vers un r\u00e9seau connu en provenance d'un routeur d\u00e9j\u00e0 existant dans sa table, il met \u00e0 jour sa table car la topologie du r\u00e9seau a \u00e9t\u00e9 modifi\u00e9e. si le r\u00e9seau n'\u00e9volue pas (panne ou ajout de nouveau mat\u00e9riel), les tables de routage convergent vers une valeur stable. Elles n'\u00e9voluent plus. si un routeur ne re\u00e7oit pas pendant 3 minutes d'information de la part d'un routeur qui lui avait auparavant communiqu\u00e9 sa table de routage, ce routeur est consid\u00e9r\u00e9 comme en panne, et toutes les routes passant par lui sont affect\u00e9es de la distance infinie : 16. Remarques et inconv\u00e9nients: Le protocole RIP n'admet qu'une distance maximale \u00e9gale \u00e0 15 (ceci explique que 16 soit consid\u00e9r\u00e9 comme la distance infinie), ce qui le limite aux r\u00e9seaux de petite taille. Chaque routeur n'a jamais connaissance de la topologie du r\u00e9seau tout entier : il ne le conna\u00eet que par ce que les autres routeurs lui ont racont\u00e9. On dit que ce protocole de routage est du routing by rumor . La m\u00e9trique utilis\u00e9e (le nombre de sauts) ne tient pas compte de la qualit\u00e9 de la liaison, contrairement au protocole OSPF .", "title": "2. Le protocole RIP"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#3-le-protocole-ospf", "text": "Un inconv\u00e9nient majeur du protocole pr\u00e9c\u00e9dent est la non-prise en compte de la bande passante reliant les routeurs. Le protocole OSPF ( O pen S hortest P ath F irst) est un protocole de routage qui minimise le co\u00fbt du transit des paquets. principe fondamental du protocole OSPF Le chemin le plus rapide n'est pas forc\u00e9ment le plus court. En gris, le chemin RIP. En bleu, l'OSPF. Dans le protocole OSPF , les tables de routage vont prendre en consid\u00e9ration la vitesse de communication entre les routeurs. Dans une premi\u00e8re phase d'initialisation, chaque routeur va acqu\u00e9rir (par succession de messages envoy\u00e9s et re\u00e7us) la connaissance totale du r\u00e9seau (diff\u00e9rence fondamentale avec RIP ) et de la qualit\u00e9 technique de la liaison entre chaque routeur.", "title": "3. Le protocole OSPF"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#32-exemple", "text": "Reprenons le r\u00e9seau suivant : et simplifions-le en ne gardant que les liens entre routeurs, en indiquant leur d\u00e9bit : Notre r\u00e9seau est devenu un graphe . Nous allons pond\u00e9rer ses ar\u00eates avec la fonction co\u00fbt introduite pr\u00e9c\u00e9demment. L'unit\u00e9 \u00e9tant le Mbit/s, l'ar\u00eate entre R1 et R3 aura un poids de \\(\\frac{100}{20}=5\\) . Le graphe pond\u00e9r\u00e9 est donc : Le chemin le plus rapide pour aller de l'ordinateur au serveur est donc R1-R2-R4, et non plus R1-R3 comme l'aurait indiqu\u00e9 le protocole RIP .", "title": "3.2 Exemple"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#33-trouver-le-plus-court-chemin-dans-un-graphe-pondere", "text": "L'exemple pr\u00e9c\u00e9dent \u00e9tait tr\u00e8s simple et de solution intuitive. Dans le cas d'un graphe pond\u00e9r\u00e9 complexe, existe-t-il un algorithme de d\u00e9termination du plus court chemin d'un point \u00e0 un autre ? La r\u00e9ponse est oui , depuis la d\u00e9couverte en 1959 par Edsger Dijkstra de l'algorithme qui porte son nom, l'algorithme de Dijkstra . Pour le comprendre, vous pouvez regarder la vid\u00e9o d'un c\u00e9l\u00e8bre YouTuber : Cet algorithme, ici ex\u00e9cut\u00e9 de mani\u00e8re manuelle, est bien s\u00fbr programmable. Et c'est donc gr\u00e2ce \u00e0 lui que chaque routeur calcule la route la plus rapide pour acheminer les donn\u00e9es qu'il re\u00e7oit. Exercice d'application de l'algorithme de Dijkstra (HP) Donner le plus court chemin pour aller de E \u00e0 F dans le graphe ci-dessous : correction E A B C D F Choix 0 -- -- -- -- -- E(0) . 30vE -- 40vE 10vE -- D(10) . 20vD -- 40vE . 80vD A(20) . . 60vA 30vA . 80vD C(30) . . 50vC . . 80vD B(50) . . . . . 70vB F(70) Le meilleur trajet est donc E-D-A-C-B-F. Attention ce trajet correspond \u00e0 la colonne choix (dans l'ordre) mais c'est un hasard.", "title": "3.3 Trouver le plus court chemin dans un graphe pond\u00e9r\u00e9"}, {"location": "T5_Architecture_materielle/5.3_Protocoles_de_routage/cours/#34-exercice", "text": "(extrait du sujet 0) On consid\u00e8re le r\u00e9seau suivant : On rappelle que le co\u00fbt d\u2019une liaison est donn\u00e9 par la formule suivante : \\[ \\text{co\u00fbt} = \\frac{10^8}{d} \\] Question 1 V\u00e9rifier que le co\u00fbt de la liaison entre les routeurs A et B est 0,01. La liaison entre le routeur B et D a un co\u00fbt de 5. Quel est le d\u00e9bit de cette liaison ? Question 2 Le routeur A doit transmettre un message au routeur G, en empruntant le chemin dont la somme des co\u00fbts sera la plus petite possible. D\u00e9terminer le chemin parcouru. On indiquera le raisonnement utilis\u00e9. Correction Q1 1. \\(\\text{co\u00fbt} = \\dfrac{10^8}{10 \\times 10^9}= \\dfrac{10^8}{10^{10}}= 10^{-2}=0,01\\) 2. \\(5=\\dfrac{10^8}{d}\\) donc \\(d=\\dfrac{10^8}{5}=20 \\times 10^6\\) = 20 Mb/s Q2 Le graphe pond\u00e9r\u00e9 par les co\u00fbts est : On peut y deviner le chemin de co\u00fbt minimal entre A et G, qui est A-D-E-G (co\u00fbt 1,011). Pour le justifier, on peut (non obligatoire) faire un algorithme de Dijkstra :", "title": "3.4 Exercice"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/Exercices/", "text": "Exercice 1 Utilisation des biblioth\u00e8ques cryptographiques du module sympy . Documentation : https://docs.sympy.org/latest/modules/crypto.html D\u00e9coder la phrase RYTVJKGCLJWRTZCVRMVTLEDFULCVHLZWRZKKFLKRMFKIVGCRTV , sachant qu'elle a \u00e9t\u00e9 chiffr\u00e9e par d\u00e9calage ( shift en anglais...) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 from sympy.crypto.crypto import decipher_shift msg = 'RYTVJKGCLJWRTZCVRMVTLEDFULCVHLZWRZKKFLKRMFKIVGCRTV' for cle in range ( 26 ): phrase = decipher_shift ( msg , cle ) print ( phrase ) Exercice 2 Chiffrage affine Principe du chiffrage affine : Chaque lettre est cod\u00e9e par son rang, en commen\u00e7ant \u00e0 0 (A\u21920, B\u21921, ..., Z\u219225) On applique \u00e0 chaque rang la transformation affine \\(f(x) = (ax+b)\\, \\%26\\) o\u00f9 \\(a\\) et \\(b\\) sont deux nombres entiers. Attention, a doit \u00eatre premier avec 26. Rappel sur les nombres premiers entre eux Deux nombres sont dits premiers entre eux si leur PGCD vaut 1. Exemples : 8 et 15 sont premiers entre eux (ils n'ont aucun diviseur commun autre que 1) 8 et 12 ne sont pas premiers entre eux (leur PGCD vaut 4). Q1. Codez votre fonction affine(msg, a, b) Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def rang ( lettre ): return ord ( lettre ) - 65 def affine ( msg , a , b ): sol = '' for lettre in msg : rg = rang ( lettre ) nv_rg = ( a * rg + b ) % 26 #chiffrement affine nv_lettre = chr ( nv_rg + 65 ) sol += nv_lettre return sol Q2. Comparez vos r\u00e9sultats avec ceux obtenus par la fonction encipher_affine() de sympy . Q3. D\u00e9codez la phrase UCGXLODCMOXPMFMSRJCFQOGTCRSUSXC , sachant qu'elle contient le mot TRAVAIL et que \\(a\\) et \\(b\\) sont inf\u00e9rieurs \u00e0 20. Aide L'instruction gcd du module math permet de calculer le PGCD de deux nombres. Correction \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 from sympy.crypto.crypto import decipher_affine from math import gcd for a in range ( 1 , 20 ): if gcd ( a , 26 ) == 1 : for b in range ( 1 , 20 ): p = decipher_affine ( 'UCGXLODCMOXPMFMSRJCFQOGTCRSUSXC' , ( a , b )) if 'TRAVAIL' in p : print ( p ) Exercice 3 Cryptographie RSA presque \u00e0 la main \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import Crypto import libnum from Crypto.Util.number import bytes_to_long , long_to_bytes from Crypto.Random import get_random_bytes bits = 256 msg = \"en NSI on fait de la crypto\" p = ... q = ... n = ... phi = ... e = 65537 d = ... # on calcule l'inverse de e modulo phi M = bytes_to_long ( msg . encode ( 'utf-8' )) # on convertit le message msg en un nombre chiffre = ... # message chiffr\u00e9 (sous forme de nombre) print ( long_to_bytes ( chiffre )) # message chiffr\u00e9 (sous forme de texte) clair = ... # message d\u00e9chiffr\u00e9 (sous forme de nombre) print ( long_to_bytes ( clair )) # message d\u00e9chiffr\u00e9 (sous forme de texte) Pour disposer du module Crypto installer pycryptodome avec pip Si vous ne disposez pas des droits d'installation, le travail peut \u00eatre fait en ligne sur https://www.pythonanywhere.com Pour g\u00e9n\u00e9rer un grand nombre premier, on utilise la fonction Crypto.Util.number.getPrime(bits, randfunc=get_random_bytes) . Pour inverser un nombre \\(x\\) modulo \\(n\\) , on utilise la fonction libnum.invmod(x, n) . Pour calculer a \u00e0 la puissance b modulo n , on utilise pow(a, b, n) . Exercice 4 En vous servant du code pr\u00e9c\u00e9dent, d\u00e9chiffrez le message 58152918114477529438769495136495430966050302170947748011925859233600631318929939319619808279389222131229963717435870597641010567365311762267359794338657867540621133550787677728203831932548041236152866441194127191404729294628415184239755221703677388875259927092794165578604353985011899152968982365630138088486380827379488939561996226754182 sachant que : \\(e\\) vaut 65537. \\(p\\) et \\(q\\) sont respectivement les 13\u00e8mes et 14\u00e8mes nombres de Mersenne. Exercice 5 module RSA dans les r\u00e8gles de l'art \ud83d\udc0d Script Python from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP import binascii keyPair = RSA . generate ( 1024 ) pubKey = keyPair . publickey () pubKeyPEM = pubKey . exportKey () privKeyPEM = keyPair . exportKey () msg = b 'vive la crypto en NSI !' encryptor = PKCS1_OAEP . new ( pubKey ) encrypted = encryptor . encrypt ( msg ) print ( \"Encrypted:\" , binascii . hexlify ( encrypted )) decryptor = PKCS1_OAEP . new ( keyPair ) decrypted = decryptor . decrypt ( encrypted ) print ( 'Decrypted:' , decrypted )", "title": "Exercices"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/", "text": "Cryptographie \u2693\ufe0e 1. Chiffrement sym\u00e9trique \u2693\ufe0e 1.1 Activit\u00e9 du masque jetable \u2693\ufe0e Exercice \u00c9nonc\u00e9 Aide Correction On consid\u00e8re la variable suivante : \ud83d\udc0d Script Python masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" Cr\u00e9er une fonction chiffre(message, masque) qui chiffre message en le XORant avec masque . Cette fonction doit pouvoir aussi servir \u00e0 d\u00e9chiffrer le message chiffr\u00e9. Le XOR (voir ici ) est une op\u00e9ration sym\u00e9trique : \ud83d\udc0d Script Python >>> 34 ^ 23 53 >>> 53 ^ 23 34 La fonction ord permet de renvoyer le code ASCII d'un caract\u00e8re. La fonction chr fait l'op\u00e9ration inverse. \ud83d\udc0d Script Python >>> ord ( 'A' ) 65 >>> chr ( 65 ) 'A' 1.2 Principe du chiffrement sym\u00e9trique \u2693\ufe0e Chiffrement sym\u00e9trique Dans un chiffrement sym\u00e9trique, c'est la m\u00eame cl\u00e9 qui va servir au chiffrement et au d\u00e9chiffrement. Illustration : Qu'appelle-t-on une cl\u00e9 ? \u2693\ufe0e La cl\u00e9 est un renseignement permettant de chiffrer ou d\u00e9chiffrer un message. Cela peut \u00eatre : un nombre (dans un simple d\u00e9calage des lettres de l'alphabet, comme le chiffre de C\u00e9sar ) une phrase (dans la m\u00e9thode du masque jetable ) une image (imaginez un chiffrement o\u00f9 on effectue un XOR par les pixels d'une image, comme dans cette \u00e9nigme ) Un chiffrement est dit sym\u00e9trique lorsque la connaissance de la cl\u00e9 ayant servi au chiffrement permet de d\u00e9chiffrer le message. Par exemple, Alice chiffre son message en d\u00e9calant les lettres de 3 rangs vers la droite dans l'alphabet, Bob saura qu'il doit les d\u00e9caler de 3 rangs vers la gauche pour retrouver le message initial. Quel est l'avantage d'un chiffrement sym\u00e9trique ? \u2693\ufe0e Les chiffrements sym\u00e9triques sont souvent rapides, consommant peu de ressources et donc adapt\u00e9s au chiffrement de flux important d'informations. Comme nous le verrons, la s\u00e9curisation des donn\u00e9es transitant par le protocole https est bas\u00e9e sur un chiffrement sym\u00e9trique. Quel est l'inconv\u00e9nient d'un chiffrement sym\u00e9trique ? \u2693\ufe0e La cl\u00e9 ! Si Alice et Bob ont besoin d'utiliser un chiffrement pour se parler, comment peuvent-ils \u00e9changer leurs cl\u00e9s puisque leur canal de transmission n'est pas s\u00fbr ? Le chiffrement sym\u00e9trique impose qu'Alice et Bob aient pu se rencontrer physiquement au pr\u00e9alable pour convenir d'une cl\u00e9 secr\u00e8te, ou bien qu'ils aient r\u00e9ussi \u00e0 \u00e9tablir une connexion s\u00e9curis\u00e9e pour s'\u00e9changer cette cl\u00e9. Un chiffrement sym\u00e9trique est-il un chiffrement de mauvaise qualit\u00e9 ? \u2693\ufe0e Pas du tout ! S'il est associ\u00e9 naturellement \u00e0 des chiffrements simples et faibles (comme le d\u00e9calage de C\u00e9sar), un chiffrement sym\u00e9trique peut \u00eatre tr\u00e8s robuste... voire inviolable. C'est le cas du masque jetable. Si le masque avec lequel on effectue le XOR sur le message est aussi long que le message, alors il est impossible de retrouver le message initial. Pourquoi ? Imaginons qu'Alice veuille transmettre le message clair \"LUNDI\". Elle le chiffre avec un masque jetable (que connait aussi Bob), et Bob re\u00e7oit donc \"KHZOK\". Si Marc a intercept\u00e9 le message \"KHZOK\", m\u00eame s'il sait que la m\u00e9thode de chiffrement utilis\u00e9e est celle du masque jetable ( principe de Kerckhoffs ), il n'a pas d'autre choix que de tester tous les masques de 5 lettres possibles. Principe de Kerckhoffs La s\u00e9curit\u00e9 d'un syst\u00e8me de chiffrement ne doit reposer que sur le secret de la cl\u00e9, et non pas sur la connaissance de l'algorithme de chiffrement. Cet algorithme peut m\u00eame \u00eatre public (ce qui est pratiquement toujours le cas). Ce qui lui donne \\(26^5\\) possibilit\u00e9s (plus de 11 millions) pour le masque, et par cons\u00e9quent (propri\u00e9t\u00e9 de bijectivit\u00e9 du XOR) \\(26^5\\) possibilit\u00e9s pour le message \u00abd\u00e9chiffr\u00e9\u00bb... Cela signifie que Marc verra appara\u00eetre, dans sa tentative de d\u00e9chiffrage, les mots \"MARDI\", \"JEUDI\", \"JOUDI\", \"STYLO\", \"FSDJK\", \"LUNDI\", \"LUNDA\"... Il n'a aucune possibilit\u00e9 de savoir o\u00f9 est le bon message original parmi toutes les propositions (on parle de s\u00e9curit\u00e9 s\u00e9mantique ). Quels sont les chiffrements sym\u00e9triques modernes ? \u2693\ufe0e L'algorithme de chiffrement sym\u00e9trique le plus utilis\u00e9 actuellement est le chiffrement AES , pour Advanced Encryption Standard. chiffrement par bloc de 128 bits, r\u00e9partis dans une matrice de 16 octets (matrice carr\u00e9e de taille 4). ces 128 bits sont transform\u00e9s par des rotations, multiplications, transpositions, [...] de la matrice initiale, en faisant intervenir dans ces transformations une cl\u00e9 de 128, 192 ou 256 bits. pour l'AES-256 (avec une cl\u00e9 de 256 bits), l'attaque par force brute n\u00e9cessiterait \\(2^{256}\\) op\u00e9rations, soit un nombre \u00e0 78 chiffres... il n'existe pas d'attaque connue efficace \u00e0 ce jour. Les seules attaques sont des attaques sur des faiblesses d'impl\u00e9mentation, ou par canal auxiliaire . 2. Chiffrement asym\u00e9trique \u2693\ufe0e Invent\u00e9 par Whitfield Diffie et Martin Hellman en 1976, le chiffrement asym\u00e9trique vient r\u00e9soudre l'inconv\u00e9nient essentiel du chiffrement sym\u00e9trique : le n\u00e9cessaire partage d'un secret (la cl\u00e9) avant l'\u00e9tablissement de la communication s\u00e9curis\u00e9e. 2.1 Principe du chiffrement asym\u00e9trique \u2693\ufe0e Le principe de base est l'existence d'une cl\u00e9 publique , appel\u00e9e \u00e0 \u00eatre distribu\u00e9e largement, et d'une cl\u00e9 priv\u00e9e , qui ne quitte jamais son propri\u00e9taire. 2.2 Le r\u00f4le interchangeable des cl\u00e9s publiques et priv\u00e9es \u2693\ufe0e L'illustration pr\u00e9c\u00e9dente associe : une image de cadenas \u00e0 la cl\u00e9 publique (car on s'en sert pour chiffrer les messages) une image de cl\u00e9 \u00e0 la cl\u00e9 priv\u00e9e (car on s'en sert pour d\u00e9chiffrer les messages) Concr\u00e8tement, (nous le verrons dans l'application par le chiffrement RSA), la cl\u00e9 priv\u00e9e et la cl\u00e9 publique sont deux nombres aux r\u00f4les identiques. Appelons-les A et B : il est impossible de trouver A en fonction de B. R\u00e9ciproquement, si on conna\u00eet A, il est impossible d'en d\u00e9duire B. si on chiffre un message avec A, on peut le d\u00e9chiffrer avec B. R\u00e9ciproquement, si on chiffre avec B, on peut d\u00e9chiffrer le message gr\u00e2ce \u00e0 A. on peut donc chiffrer avec une cl\u00e9 publique et d\u00e9chiffrer avec la cl\u00e9 priv\u00e9e associ\u00e9e (ce qui est fait dans l'exemple pr\u00e9c\u00e9dent). Mais on peut aussi chiffrer avec la cl\u00e9 priv\u00e9e, et d\u00e9chiffrer avec la cl\u00e9 publique associ\u00e9e. A et B ont donc des r\u00f4les interchangeables (chacun peut \u00eatre un cadenas, chacun peut \u00eatre une cl\u00e9), et ce n'est qu'en connaissant A et B qu'on peut d\u00e9chiffrer le message. Nous allons donc maintenant adopter une nouvelle convention infographique : Consid\u00e9rons ce message : Si ce message est chiffr\u00e9 avec la cl\u00e9 publique d'Alice, le message sera : Si on d\u00e9chiffre ce message avec la cl\u00e9 priv\u00e9e d'Alice, il deviendra et donc puisque l'application de la cl\u00e9 priv\u00e9e sur la cl\u00e9 publique, ou bien de la cl\u00e9 publique sur la cl\u00e9 priv\u00e9e, permet de retrouver le message en clair. De mani\u00e8re graphique, la connaissance des deux moiti\u00e9s du disque qui s'assemblent permet de les faire disparaitre, peu importe qu'on ait commenc\u00e9 par chiffrer avec la cl\u00e9 publique ou avec la cl\u00e9 priv\u00e9e. 2.3 Communication authentifi\u00e9e. \u2693\ufe0e Dans la situation du 2.1, Alice (qui a distribu\u00e9 largement sa cl\u00e9 publique) ne peut pas s'assurer que le message vient bien de Bob. Il peut avoir \u00e9t\u00e9 cr\u00e9\u00e9 par Marc, qui signe \u00abBob\u00bb et usurpe ainsi son identit\u00e9. Le protocole que nous allons d\u00e9crire ci-dessous permet : d'emp\u00eacher qu'un message intercept\u00e9 soit d\u00e9chiffr\u00e9 (ce qui \u00e9tait d\u00e9j\u00e0 le cas dans le 2.1) mais aussi de s'assurer que chaque personne est bien celle qu'elle pr\u00e9tend \u00eatre : on r\u00e9sout le probl\u00e8me d'authentification . En r\u00e9sum\u00e9 : Alice est s\u00fbre que seul Bob pourra d\u00e9chiffrer le message qu'elle envoie. Bob est s\u00fbr que le message qu'il re\u00e7oit vient bien d'Alice. 2.3 Un exemple de chiffrement asym\u00e9trique : le chiffrement RSA \u2693\ufe0e 2.3.1 Histoire \u2693\ufe0e Lorsqu'en 1976 Diffie et Hellman (chercheurs \u00e0 Stanford) pr\u00e9sentent le concept de chiffrement asym\u00e9trique (souvent appel\u00e9 cryptographie \u00e0 cl\u00e9s publiques ), ils en proposent uniquement un mod\u00e8le th\u00e9orique, n'ayant pas trouv\u00e9 une r\u00e9elle impl\u00e9mentation de leur protocole. Trois chercheurs du MIT (Boston), Ron Rivest, Adi Shamir et Len Adleman se penchent alors sur ce protocole, convaincus qu'il est en effet impossible d'en trouver une impl\u00e9mentation pratique. En 1977, au cours de leurs recherches, ils d\u00e9montrent en fait l'inverse de ce qu'ils cherchaient : ils cr\u00e9ent le premier protocole concret de chiffrement asym\u00e9trique : le chiffrement RSA . Au m\u00eame moment \u00e0 Londres, Clifford Cocks, (chercheur au tr\u00e8s secret GCHQ ) apprend que Rivest Shamir et Adleman viennent de d\u00e9couvrir ce que lui-m\u00eame a d\u00e9couvert 3 ans auparavant mais qui est rest\u00e9 class\u00e9 Secret D\u00e9fense. Il est le v\u00e9ritable inventeur du RSA... mais le reste du monde ne l'apprendra qu'en 1997 au moment de la d\u00e9classification de cette information. 2.3.1 Description \u2693\ufe0e Le chiffrement RSA est bas\u00e9 sur l'arithm\u00e9tique modulaire . Faire des calculs modulo un entier \\(n\\) , c'est ne garder que le reste de la division euclidienne par \\(n\\) . Le fait que 15 soit \u00e9gal \u00e0 1 modulo 7 (car \\(15=2 \\times 7+1\\) ) s'\u00e9crira \\(15 \\equiv 1 [7]\\) . De m\u00eame, \\(10 \\equiv 3 [7]\\) , \\(25 \\equiv 4 [7]\\) , \\(32 \\equiv 2 [10]\\) , etc. \u00c9tape 1 \u2693\ufe0e Alice choisit 2 grands nombres premiers \\(p\\) et \\(q\\) . Dans la r\u00e9alit\u00e9 ces nombres seront vraiment tr\u00e8s grands (plus de 100 chiffres). Dans notre exemple, nous prendrons \\(p = 3\\) et \\(q = 11\\) . \u00c9tape 2 \u2693\ufe0e Alice multiplie ces deux nombres \\(p\\) et \\(q\\) et obtient ainsi un nombre \\(n\\) . Il est tr\u00e8s facile pour Alice de calculer \\(n\\) en connaissant \\(p\\) et \\(q\\) , mais il extr\u00eamement difficile pour Marc de faire le travail inverse : trouver \\(p\\) et \\(q\\) en connaissant \\(n\\) prend un temps exponentiel avec la taille de \\(n\\) . C'est sur cette difficult\u00e9 (appel\u00e9e difficult\u00e9 de factorisation ) que repose la robustesse du syst\u00e8me RSA. \u00c9tape 3 \u2693\ufe0e Alice choisit un nombre \\(e\\) qui doit \u00eatre premier avec \\((p-1)(q-1)\\) . On note \\(\\phi(n)\\) le nombre \\((p-1)(q-1)\\) . Dans notre exemple, \\((p-1)(q-1) = 20\\) , Alice choisit donc \\(e = 3\\) . (mais elle aurait pu aussi choisir 7, 9, 13...). Le couple \\((e, n)\\) sera la cl\u00e9 publique d'Alice. Elle la diffuse \u00e0 qui veut lui \u00e9crire. Dans notre exemple, la cl\u00e9 publique d'Alice est \\((3, 33)\\) . \u00c9tape 4 \u2693\ufe0e Alice calcule maintenant sa cl\u00e9 priv\u00e9e : elle doit trouver un nombre d qui v\u00e9rifie l'\u00e9galit\u00e9 \\(e d \\equiv 1 [\\phi(n)]\\) . Dans notre exemple, comme \\(7 \\times 3 \\equiv 1 [20]\\) , ce nombre \\(d\\) est \u00e9gal \u00e0 7. En pratique, il existe un algorithme simple (algorithme d' Euclide \u00e9tendu ) pour trouver cette valeur \\(d\\) , appel\u00e9e inverse de e . Le couple \\((d, n)\\) sera la cl\u00e9 priv\u00e9e d'Alice. Elle ne la diffuse \u00e0 personne. Dans notre exemple, la cl\u00e9 priv\u00e9e d'Alice est \\((7, 33)\\) . \u00c9tape 5 \u2693\ufe0e Supposons que Bob veuille \u00e9crire \u00e0 Alice pour lui envoyer le nombre 4. Il poss\u00e8de la cl\u00e9 publique d'Alice, qui est \\((3, 33)\\) . Il calcule donc \\(4^3\\) modulo 33, qui vaut 31. C'est cette valeur 31 qu'il transmet \u00e0 Alice. \\[4^3 \\equiv 31 [33]\\] Si Marc intercepte cette valeur 31, m\u00eame en connaissant la cl\u00e9 publique d'Alice (3,33), il ne peut pas r\u00e9soudre l'\u00e9quation \\(x^3 \\equiv 31 [33]\\) de mani\u00e8re efficace. \u00c9tape 6 \u2693\ufe0e Alice re\u00e7oit la valeur 31. Il lui suffit alors d'\u00e9lever 31 \u00e0 la puissance 7 (sa cl\u00e9 priv\u00e9e), et de calculer le reste modulo 33 : \\(31^7 = 27512614111\\) \\(27512614111 \\equiv 4 [33]\\) Elle r\u00e9cup\u00e8re la valeur 4, qui est bien le message original de Bob. Comment \u00e7a marche ? Gr\u00e2ce au Petit Th\u00e9or\u00e8me de Fermat , on d\u00e9montre (voir ici ) assez facilement que \\(M^{ed} \\equiv M [n]\\) . Il faut remarquer que \\(M^{ed} = M^{de}\\) . On voit que les r\u00f4les de la cl\u00e9 publique et de la cl\u00e9 priv\u00e9e sont sym\u00e9triques : un message chiffr\u00e9 avec la cl\u00e9 publique se d\u00e9chiffrera en le chiffrant avec la cl\u00e9 priv\u00e9e, tout comme un message chiffr\u00e9 avec la cl\u00e9 priv\u00e9e se d\u00e9chiffrera en le chiffrant avec la cl\u00e9 publique. Animation interactive voir https://animations.interstices.info/interstices-rsa/rsa.html RSA, un syst\u00e8me inviolable ? \u2693\ufe0e Le chiffrement RSA a des d\u00e9fauts (notamment une grande consommation des ressources, due \u00e0 la manipulation de tr\u00e8s grands nombres). Mais le choix d'une cl\u00e9 publique de grande taille (actuellement 1024 ou 2048 bits) le rend pour l'instant inviolable. Actuellement, il n'existe pas d'algorithme efficace pour factoriser un nombre ayant plusieurs centaines de chiffres. Deux \u00e9v\u00e8nements pourraient faire s'\u00e9crouler la s\u00e9curit\u00e9 du RSA : la d\u00e9couverte d'un algorithme efficace de factorisation, capable de tourner sur les ordinateurs actuels. Cette annonce est r\u00e9guli\u00e8rement faite, et tout aussi r\u00e9guli\u00e8rement contredite par la communaut\u00e9 scientifique. (voir, le 05/03/2021, https://www.schneier.com/blog/archives/2021/03/no-rsa-is-not-broken.html ) l'av\u00e8nement d' ordinateurs quantiques , dont la vitesse d'ex\u00e9cution permettrait une factorisation rapide. Il est \u00e0 noter que l'algorithme de factorisation destin\u00e9 \u00e0 tourner sur un ordinateur quantique existe d\u00e9j\u00e0 : l'algorithme de Schor . 3. HTTPS : exemple d'utilisation conjointe d'un chiffrement asym\u00e9trique et d'un chiffrement sym\u00e9trique. \u2693\ufe0e 3.1 Principe g\u00e9n\u00e9ral \u2693\ufe0e Aujourd'hui, plus de 90 % du trafic sur internet est chiffr\u00e9 : les donn\u00e9es ne transitent plus en clair (protocole http ) mais de mani\u00e8re chiffr\u00e9e (protocole https ), ce qui emp\u00eache la lecture de paquets \u00e9ventuellements intercept\u00e9s. Le protocole https est la r\u00e9union de deux protocoles : le protocole TLS (Transport Layer Security, qui a succ\u00e9d\u00e9 au SSL) : ce protocole, bas\u00e9 sur du chiffrement asym\u00e9trique , va conduire \u00e0 la g\u00e9n\u00e9ration d'une cl\u00e9 identique chez le client et chez le serveur. le (bon vieux) protocole http , mais qui convoiera maintenant des donn\u00e9es chiffr\u00e9es avec la cl\u00e9 g\u00e9n\u00e9r\u00e9e \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Les donn\u00e9es peuvent toujours \u00eatre intercept\u00e9es, mais sont illisibles. Le chiffrement sym\u00e9trique utilis\u00e9 est actuellement le chiffrement AES. Pourquoi ne pas utiliser que le chiffrement asym\u00e9trique, RSA par exemple ? Car il est tr\u00e8s gourmand en ressources ! Le chiffrement/d\u00e9chiffrement doit \u00eatre rapide pour ne pas ralentir les communications ou l'exploitation des donn\u00e9es. Le chiffrement asym\u00e9trique est donc r\u00e9serv\u00e9 \u00e0 l'\u00e9change de cl\u00e9s (au d\u00e9but de la communication). Le chiffrement sym\u00e9trique, bien plus rapide, prend ensuite le relais pour l'ensemble de la communication. 3.2 (HP) Fonctionnement du TLS : explication du handshake \u2693\ufe0e Observons en d\u00e9tail le fonctionnement du protocole TLS , dont le r\u00f4le est de g\u00e9n\u00e9rer de mani\u00e8re s\u00e9curis\u00e9e une cl\u00e9 dont disposeront \u00e0 la fois le client et le serveur, leur permettant ainsi d'appliquer un chiffrement sym\u00e9trique \u00e0 leurs \u00e9changes. \u00e9tape 1 : le \u00abclient Hello\u00bb. Le client envoie sa version de TLS utilis\u00e9e. \u00e9tape 2 : le \u00abserver Hello\u00bb. Le serveur r\u00e9pond en renvoyant son certificat prouvant son identit\u00e9, ainsi que sa cl\u00e9 publique. \u00e9tape 3 : le client interroge l'autorit\u00e9 de certification pour valider le fait que le certificat est bien valide et que le serveur est bien celui qu'il pr\u00e9tend \u00eatre. Cette v\u00e9rification est faite gr\u00e2ce \u00e0 un m\u00e9canisme de chiffrement asym\u00e9trique. La pr\u00e9sentation du certificat \u00e0 l'autorit\u00e9 de certification peut se repr\u00e9senter comme le scan d'une pi\u00e8ce d'identit\u00e9 dans un a\u00e9roport. L'autorit\u00e9 de certification est alors l'\u00c9tat (dont la base de donn\u00e9es est interrog\u00e9e par un logiciel) qui valide que la pi\u00e8ce d'identit\u00e9 est bien un document officiel. \u00e9tape 4 : une fois v\u00e9rifi\u00e9e l'authenticit\u00e9 du serveur et que son certificat est valide, le client calcule ce qui sera la future cl\u00e9 de chiffrement sym\u00e9trique (appel\u00e9e \u00abcl\u00e9 AES\u00bb dans l'infographie). Cette cl\u00e9 est chiffr\u00e9e avec la cl\u00e9 publique du server (transmise \u00e0 l'\u00e9tape 1), ce qui assure la s\u00e9curit\u00e9 de son transfert. Le serveur d\u00e9chiffre cette cl\u00e9 gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e, et dispose ainsi lui aussi de la cl\u00e9. Le transmission par protocole http de donn\u00e9es chiffr\u00e9es au pr\u00e9alable avec la cl\u00e9 AES peut commencer. Remarque : en r\u00e9alit\u00e9, ce n'est pas la cl\u00e9 AES qui est transmise \u00e0 l'\u00e9tape 4, mais un nombre choisi par le client, qui permettra, avec deux autres nombres choisis par le client (\u00e9tape 1) et le serveur (\u00e9tape 2) de reconstituer la cl\u00e9 AES, qui sera donc identique c\u00f4t\u00e9 client et c\u00f4t\u00e9 serveur.", "title": "Cours"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#cryptographie", "text": "", "title": "Cryptographie"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#1-chiffrement-symetrique", "text": "", "title": "1. Chiffrement sym\u00e9trique"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#11-activite-du-masque-jetable", "text": "Exercice \u00c9nonc\u00e9 Aide Correction On consid\u00e8re la variable suivante : \ud83d\udc0d Script Python masque = \"CETTEPHRASEESTVRAIMENTTRESTRESLONGUEMAISCESTFAITEXPRES\" Cr\u00e9er une fonction chiffre(message, masque) qui chiffre message en le XORant avec masque . Cette fonction doit pouvoir aussi servir \u00e0 d\u00e9chiffrer le message chiffr\u00e9. Le XOR (voir ici ) est une op\u00e9ration sym\u00e9trique : \ud83d\udc0d Script Python >>> 34 ^ 23 53 >>> 53 ^ 23 34 La fonction ord permet de renvoyer le code ASCII d'un caract\u00e8re. La fonction chr fait l'op\u00e9ration inverse. \ud83d\udc0d Script Python >>> ord ( 'A' ) 65 >>> chr ( 65 ) 'A'", "title": "1.1 Activit\u00e9 du masque jetable"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#12-principe-du-chiffrement-symetrique", "text": "Chiffrement sym\u00e9trique Dans un chiffrement sym\u00e9trique, c'est la m\u00eame cl\u00e9 qui va servir au chiffrement et au d\u00e9chiffrement. Illustration :", "title": "1.2 Principe du chiffrement sym\u00e9trique"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#2-chiffrement-asymetrique", "text": "Invent\u00e9 par Whitfield Diffie et Martin Hellman en 1976, le chiffrement asym\u00e9trique vient r\u00e9soudre l'inconv\u00e9nient essentiel du chiffrement sym\u00e9trique : le n\u00e9cessaire partage d'un secret (la cl\u00e9) avant l'\u00e9tablissement de la communication s\u00e9curis\u00e9e.", "title": "2. Chiffrement asym\u00e9trique"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#21-principe-du-chiffrement-asymetrique", "text": "Le principe de base est l'existence d'une cl\u00e9 publique , appel\u00e9e \u00e0 \u00eatre distribu\u00e9e largement, et d'une cl\u00e9 priv\u00e9e , qui ne quitte jamais son propri\u00e9taire.", "title": "2.1 Principe du chiffrement asym\u00e9trique"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#22-le-role-interchangeable-des-cles-publiques-et-privees", "text": "L'illustration pr\u00e9c\u00e9dente associe : une image de cadenas \u00e0 la cl\u00e9 publique (car on s'en sert pour chiffrer les messages) une image de cl\u00e9 \u00e0 la cl\u00e9 priv\u00e9e (car on s'en sert pour d\u00e9chiffrer les messages) Concr\u00e8tement, (nous le verrons dans l'application par le chiffrement RSA), la cl\u00e9 priv\u00e9e et la cl\u00e9 publique sont deux nombres aux r\u00f4les identiques. Appelons-les A et B : il est impossible de trouver A en fonction de B. R\u00e9ciproquement, si on conna\u00eet A, il est impossible d'en d\u00e9duire B. si on chiffre un message avec A, on peut le d\u00e9chiffrer avec B. R\u00e9ciproquement, si on chiffre avec B, on peut d\u00e9chiffrer le message gr\u00e2ce \u00e0 A. on peut donc chiffrer avec une cl\u00e9 publique et d\u00e9chiffrer avec la cl\u00e9 priv\u00e9e associ\u00e9e (ce qui est fait dans l'exemple pr\u00e9c\u00e9dent). Mais on peut aussi chiffrer avec la cl\u00e9 priv\u00e9e, et d\u00e9chiffrer avec la cl\u00e9 publique associ\u00e9e. A et B ont donc des r\u00f4les interchangeables (chacun peut \u00eatre un cadenas, chacun peut \u00eatre une cl\u00e9), et ce n'est qu'en connaissant A et B qu'on peut d\u00e9chiffrer le message. Nous allons donc maintenant adopter une nouvelle convention infographique : Consid\u00e9rons ce message : Si ce message est chiffr\u00e9 avec la cl\u00e9 publique d'Alice, le message sera : Si on d\u00e9chiffre ce message avec la cl\u00e9 priv\u00e9e d'Alice, il deviendra et donc puisque l'application de la cl\u00e9 priv\u00e9e sur la cl\u00e9 publique, ou bien de la cl\u00e9 publique sur la cl\u00e9 priv\u00e9e, permet de retrouver le message en clair. De mani\u00e8re graphique, la connaissance des deux moiti\u00e9s du disque qui s'assemblent permet de les faire disparaitre, peu importe qu'on ait commenc\u00e9 par chiffrer avec la cl\u00e9 publique ou avec la cl\u00e9 priv\u00e9e.", "title": "2.2 Le r\u00f4le interchangeable des cl\u00e9s publiques et priv\u00e9es"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#23-communication-authentifiee", "text": "Dans la situation du 2.1, Alice (qui a distribu\u00e9 largement sa cl\u00e9 publique) ne peut pas s'assurer que le message vient bien de Bob. Il peut avoir \u00e9t\u00e9 cr\u00e9\u00e9 par Marc, qui signe \u00abBob\u00bb et usurpe ainsi son identit\u00e9. Le protocole que nous allons d\u00e9crire ci-dessous permet : d'emp\u00eacher qu'un message intercept\u00e9 soit d\u00e9chiffr\u00e9 (ce qui \u00e9tait d\u00e9j\u00e0 le cas dans le 2.1) mais aussi de s'assurer que chaque personne est bien celle qu'elle pr\u00e9tend \u00eatre : on r\u00e9sout le probl\u00e8me d'authentification . En r\u00e9sum\u00e9 : Alice est s\u00fbre que seul Bob pourra d\u00e9chiffrer le message qu'elle envoie. Bob est s\u00fbr que le message qu'il re\u00e7oit vient bien d'Alice.", "title": "2.3 Communication authentifi\u00e9e."}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#23-un-exemple-de-chiffrement-asymetrique-le-chiffrement-rsa", "text": "", "title": "2.3 Un exemple de chiffrement asym\u00e9trique : le chiffrement RSA"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#3-https-exemple-dutilisation-conjointe-dun-chiffrement-asymetrique-et-dun-chiffrement-symetrique", "text": "", "title": "3. HTTPS : exemple d'utilisation conjointe d'un chiffrement asym\u00e9trique et d'un chiffrement sym\u00e9trique."}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#31-principe-general", "text": "Aujourd'hui, plus de 90 % du trafic sur internet est chiffr\u00e9 : les donn\u00e9es ne transitent plus en clair (protocole http ) mais de mani\u00e8re chiffr\u00e9e (protocole https ), ce qui emp\u00eache la lecture de paquets \u00e9ventuellements intercept\u00e9s. Le protocole https est la r\u00e9union de deux protocoles : le protocole TLS (Transport Layer Security, qui a succ\u00e9d\u00e9 au SSL) : ce protocole, bas\u00e9 sur du chiffrement asym\u00e9trique , va conduire \u00e0 la g\u00e9n\u00e9ration d'une cl\u00e9 identique chez le client et chez le serveur. le (bon vieux) protocole http , mais qui convoiera maintenant des donn\u00e9es chiffr\u00e9es avec la cl\u00e9 g\u00e9n\u00e9r\u00e9e \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente. Les donn\u00e9es peuvent toujours \u00eatre intercept\u00e9es, mais sont illisibles. Le chiffrement sym\u00e9trique utilis\u00e9 est actuellement le chiffrement AES. Pourquoi ne pas utiliser que le chiffrement asym\u00e9trique, RSA par exemple ? Car il est tr\u00e8s gourmand en ressources ! Le chiffrement/d\u00e9chiffrement doit \u00eatre rapide pour ne pas ralentir les communications ou l'exploitation des donn\u00e9es. Le chiffrement asym\u00e9trique est donc r\u00e9serv\u00e9 \u00e0 l'\u00e9change de cl\u00e9s (au d\u00e9but de la communication). Le chiffrement sym\u00e9trique, bien plus rapide, prend ensuite le relais pour l'ensemble de la communication.", "title": "3.1 Principe g\u00e9n\u00e9ral"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/cours/#32-hp-fonctionnement-du-tls-explication-du-handshake", "text": "Observons en d\u00e9tail le fonctionnement du protocole TLS , dont le r\u00f4le est de g\u00e9n\u00e9rer de mani\u00e8re s\u00e9curis\u00e9e une cl\u00e9 dont disposeront \u00e0 la fois le client et le serveur, leur permettant ainsi d'appliquer un chiffrement sym\u00e9trique \u00e0 leurs \u00e9changes. \u00e9tape 1 : le \u00abclient Hello\u00bb. Le client envoie sa version de TLS utilis\u00e9e. \u00e9tape 2 : le \u00abserver Hello\u00bb. Le serveur r\u00e9pond en renvoyant son certificat prouvant son identit\u00e9, ainsi que sa cl\u00e9 publique. \u00e9tape 3 : le client interroge l'autorit\u00e9 de certification pour valider le fait que le certificat est bien valide et que le serveur est bien celui qu'il pr\u00e9tend \u00eatre. Cette v\u00e9rification est faite gr\u00e2ce \u00e0 un m\u00e9canisme de chiffrement asym\u00e9trique. La pr\u00e9sentation du certificat \u00e0 l'autorit\u00e9 de certification peut se repr\u00e9senter comme le scan d'une pi\u00e8ce d'identit\u00e9 dans un a\u00e9roport. L'autorit\u00e9 de certification est alors l'\u00c9tat (dont la base de donn\u00e9es est interrog\u00e9e par un logiciel) qui valide que la pi\u00e8ce d'identit\u00e9 est bien un document officiel. \u00e9tape 4 : une fois v\u00e9rifi\u00e9e l'authenticit\u00e9 du serveur et que son certificat est valide, le client calcule ce qui sera la future cl\u00e9 de chiffrement sym\u00e9trique (appel\u00e9e \u00abcl\u00e9 AES\u00bb dans l'infographie). Cette cl\u00e9 est chiffr\u00e9e avec la cl\u00e9 publique du server (transmise \u00e0 l'\u00e9tape 1), ce qui assure la s\u00e9curit\u00e9 de son transfert. Le serveur d\u00e9chiffre cette cl\u00e9 gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e, et dispose ainsi lui aussi de la cl\u00e9. Le transmission par protocole http de donn\u00e9es chiffr\u00e9es au pr\u00e9alable avec la cl\u00e9 AES peut commencer. Remarque : en r\u00e9alit\u00e9, ce n'est pas la cl\u00e9 AES qui est transmise \u00e0 l'\u00e9tape 4, mais un nombre choisi par le client, qui permettra, avec deux autres nombres choisis par le client (\u00e9tape 1) et le serveur (\u00e9tape 2) de reconstituer la cl\u00e9 AES, qui sera donc identique c\u00f4t\u00e9 client et c\u00f4t\u00e9 serveur.", "title": "3.2 (HP) Fonctionnement du TLS : explication du handshake"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/image/", "text": "\u00c0 la recherche du personnage myst\u00e8re \u2693\ufe0e Vous avez trouv\u00e9 une image bien \u00e9trange : Un visage semble se deviner derri\u00e8re un champ de fleurs... mais quel est ce visage ? L'image du champ de fleurs ne vous est pas inconnue, d'ailleurs en cherchant bien vous l'avez retrouv\u00e9e dans vos dossiers : On dirait que le personnage-myst\u00e8re a voulu se fondre dans le champ de fleurs... XORez-vous d\u00e9couvrir qui est ce personnage-myst\u00e8re ?", "title": "\u00c0 la recherche du personnage myst\u00e8re"}, {"location": "T5_Architecture_materielle/5.4_Cryptographie/image/#a-la-recherche-du-personnage-mystere", "text": "Vous avez trouv\u00e9 une image bien \u00e9trange : Un visage semble se deviner derri\u00e8re un champ de fleurs... mais quel est ce visage ? L'image du champ de fleurs ne vous est pas inconnue, d'ailleurs en cherchant bien vous l'avez retrouv\u00e9e dans vos dossiers : On dirait que le personnage-myst\u00e8re a voulu se fondre dans le champ de fleurs... XORez-vous d\u00e9couvrir qui est ce personnage-myst\u00e8re ?", "title": "\u00c0 la recherche du personnage myst\u00e8re"}, {"location": "T6_5_algos_coeur/algos/cours/", "text": "Algorithmes de r\u00e9f\u00e9rence \u2693\ufe0e 1. Factorielle r\u00e9cursive \u2693\ufe0e \ud83d\udc0d Script Python 1 2 3 4 5 def factorielle ( n ): if n == 1 : return 1 else : return n * factorielle ( n - 1 ) 2. PGCD r\u00e9cursif \u2693\ufe0e \ud83d\udc0d Script Python 1 2 3 4 5 def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b ) 3. Puissance r\u00e9cursive (simple) \u2693\ufe0e \ud83d\udc0d Script Python 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 ) 4. Puissance r\u00e9cursive (optimis\u00e9e) \u2693\ufe0e \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def puissance ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance ( x * x , n // 2 ) else : return x * puissance ( x * x , ( n - 1 ) // 2 ) 5. Recherche dichotomique r\u00e9cursive (avec slicing) \u2693\ufe0e Note : le slicing de liste n'est pas au programme de NSI. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( lst , m ): if len ( lst ) == 1 : if lst [ 0 ] == m : return True else : return False else : mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m )", "title": "Algorithmes de r\u00e9f\u00e9rence"}, {"location": "T6_5_algos_coeur/algos/cours/#algorithmes-de-reference", "text": "", "title": "Algorithmes de r\u00e9f\u00e9rence"}, {"location": "T6_5_algos_coeur/algos/cours/#1-factorielle-recursive", "text": "\ud83d\udc0d Script Python 1 2 3 4 5 def factorielle ( n ): if n == 1 : return 1 else : return n * factorielle ( n - 1 )", "title": "1. Factorielle r\u00e9cursive"}, {"location": "T6_5_algos_coeur/algos/cours/#2-pgcd-recursif", "text": "\ud83d\udc0d Script Python 1 2 3 4 5 def pgcd ( a , b ): if b == 0 : return a else : return pgcd ( b , a % b )", "title": "2. PGCD r\u00e9cursif"}, {"location": "T6_5_algos_coeur/algos/cours/#3-puissance-recursive-simple", "text": "\ud83d\udc0d Script Python 1 2 3 4 5 def puissance ( x , n ): if n == 0 : return 1 else : return x * puissance ( x , n - 1 )", "title": "3. Puissance r\u00e9cursive (simple)"}, {"location": "T6_5_algos_coeur/algos/cours/#4-puissance-recursive-optimisee", "text": "\ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def puissance ( x , n ): if n == 0 : return 1 else : if n % 2 == 0 : return puissance ( x * x , n // 2 ) else : return x * puissance ( x * x , ( n - 1 ) // 2 )", "title": "4. Puissance r\u00e9cursive (optimis\u00e9e)"}, {"location": "T6_5_algos_coeur/algos/cours/#5-recherche-dichotomique-recursive-avec-slicing", "text": "Note : le slicing de liste n'est pas au programme de NSI. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( lst , m ): if len ( lst ) == 1 : if lst [ 0 ] == m : return True else : return False else : mid = len ( lst ) // 2 if lst [ mid ] > m : return recherche ( lst [: mid ], m ) else : return recherche ( lst [ mid :], m )", "title": "5. Recherche dichotomique r\u00e9cursive (avec slicing)"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/", "text": "\u00c9preuve pratique \ud83d\udcbb \u2693\ufe0e Vous trouverez ci-dessous l'int\u00e9gralit\u00e9 des sujets de l'\u00e9preuve pratique, disponibles publiquement sur la Banque Nationale des Sujets (novembre 2021). Une nouvelle version (qui sera a priori en grande partie semblable \u00e0 celle-ci) sera publi\u00e9e en janvier 2022 sur le site Eduscol . update : les sujets sont disponibles, une premi\u00e8re version centralis\u00e9e se trouve ici Rappel des conditions de passation sur cette page . Pdf de l'int\u00e9gralit\u00e9 des exercices. Exercice 01.1 \u25a1 \u2693\ufe0e Exercice 01.1 \u00c9nonc\u00e9 Correction Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution Exercice 01.2 \u25a1 \u2693\ufe0e Exercice 01.2 \u00c9nonc\u00e9 Correction On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : \ud83d\udc0d Script Python from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Exercice 02.1 \u25a1 \u2693\ufe0e Exercice 02.1 \u00c9nonc\u00e9 Correction Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) Exercice 02.2 \u25a1 \u2693\ufe0e Exercice 02.2 \u00c9nonc\u00e9 Correction On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab Exercice 03.1 \u25a1 \u2693\ufe0e Exercice 03.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\times (-6)= - (5 \\times 6)\\) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Exercice 03.2 \u25a1 \u2693\ufe0e Exercice 03.2 \u00c9nonc\u00e9 Correction Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 04.1 \u25a1 \u2693\ufe0e Exercice 04.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. \ud83d\udc0d Script Python def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) Exercice 04.2 \u25a1 \u2693\ufe0e Exercice 04.2 \u00c9nonc\u00e9 Correction Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Exercice 05.1 \u25a1 \u2693\ufe0e Exercice 05.1 \u00c9nonc\u00e9 Correction On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : \ud83d\udc0d Script Python def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : \ud83d\udc0d Script Python >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total Exercice 05.2 \u25a1 \u2693\ufe0e Exercice 05.2 \u00c9nonc\u00e9 Correction La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : \ud83d\udc0d Script Python >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L Exercice 06.1 \u25a1 \u2693\ufe0e Exercice 06.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : \ud83d\udc0d Script Python >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour Exercice 06.2 \u25a1 \u2693\ufe0e \u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() Exercice 06.2 \u00c9nonc\u00e9 Correction On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : \ud83d\udc0d Script Python 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : \ud83d\udc0d Script Python >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None Exercice 07.1 \ud83d\uddf9 \u2693\ufe0e Exercice 07.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] Exercice 07.2 \u25a1 \u2693\ufe0e Exercice 07.2 \u00c9nonc\u00e9 Correction Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Exercice 08.1 \ud83d\uddf9 \u2693\ufe0e Exercice 08.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme Exercice 08.2 \u25a1 \u2693\ufe0e Exercice 08.2 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) Exercice 09.1 \u25a1 \u2693\ufe0e Exercice 09.1 \u00c9nonc\u00e9 Correction Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs Exercice 09.2 \u25a1 \u2693\ufe0e Exercice 09.2 \u00c9nonc\u00e9 Correction On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C Exercice 10.1 \ud83d\uddf9 \u2693\ufe0e Exercice 10.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) Exercice 10.2 \ud83d\uddf9 \u2693\ufe0e Exercice 10.2 \u00c9nonc\u00e9 Correction Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 Exercice 11.1 \u25a1 \u2693\ufe0e Exercice 11.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : \ud83d\udc0d Script Python >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def conv_bin ( n ): b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) Exercice 11.2 \u25a1 \u2693\ufe0e Exercice 11.2 \u00c9nonc\u00e9 Correction La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec \ud83d\udc0d Script Python for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T #version 2 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 ): for j in range ( n - 1 , i , - 1 ): if T [ j ] < T [ j - 1 ]: temp = T [ j ] T [ j ] = T [ j - 1 ] T [ j - 1 ] = temp return T Exercice 12.1 \u25a1 \u2693\ufe0e Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af Exercice 12.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) Exercice 12.2 \ud83d\uddf9 \u2693\ufe0e Exercice 12.2 \u00c9nonc\u00e9 Correction La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : \ud83d\udc0d Script Python >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve Exercice 13.1 \u25a1 \u2693\ufe0e Exercice 13.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : \ud83d\udc0d Script Python >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab Exercice 13.2 \u25a1 \u2693\ufe0e Exercice 13.2 \u00c9nonc\u00e9 Correction Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 100 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 0 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Exercice 14.1 \u25a1 \u2693\ufe0e Exercice 14.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices Exercice 14.2 \u25a1 \u2693\ufe0e Exercice 14.2 \u00c9nonc\u00e9 Correction Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 Exercice 15.1 \u25a1 \u2693\ufe0e Exercice 15.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } d = {} d [ 'min' ] = None d [ 'max' ] = None for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d Exercice 15.2 \u25a1 \u2693\ufe0e Exercice 15.2 \u00c9nonc\u00e9 Correction On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): for nb_coul in range ( 1 , 5 ): for val in range ( 1 , 14 ): self . contenu . append ( Carte ( nb_coul , val )) \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos in range ( 56 ) return self . contenu [ pos ] Exercice 16.1 \u25a1 \u2693\ufe0e Exercice 16.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) Exercice 16.2 \u25a1 \u2693\ufe0e Exercice 16.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : \ud83d\udc0d Script Python >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = '' a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Exercice 17.1 \ud83d\uddf9 \u2693\ufe0e Exercice 17.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 def indice_du_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min Exercice 17.2 \ud83d\uddf9 \u2693\ufe0e Exercice 17.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab Exercice 18.1 \u25a1 \u2693\ufe0e Exercice 18.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 Exercice 18.2 \u25a1 \u2693\ufe0e Exercice 18.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Sujet l\u00e9g\u00e8rement modifi\u00e9 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= ... : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l Exercice 19.1 \u25a1 \u2693\ufe0e Exercice 19.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 Exercice 19.2 \u25a1 \u2693\ufe0e Exercice 19.2 \u00c9nonc\u00e9 Correction Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat Exercice 20.1 \ud83d\uddf9 \u2693\ufe0e Exercice 20.1 \u00c9nonc\u00e9 Correction On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : \ud83d\udc0d Script Python >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini Exercice 20.2 \ud83d\uddf9 \u2693\ufe0e Exercice 20.2 \u00c9nonc\u00e9 Correction Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) Exercice 21.1 \u25a1 \u2693\ufe0e Exercice 21.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb Exercice 21.2 \u25a1 \u2693\ufe0e Exercice 21.2 \u00c9nonc\u00e9 Correction Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Exercice 22.1 \u25a1 \u2693\ufe0e Exercice 22.1 \u00c9nonc\u00e9 Correction \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : \ud83d\udc0d Script Python >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb Exercice 22.2 \u25a1 \u2693\ufe0e Exercice 22.2 \u00c9nonc\u00e9 Correction La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : \ud83d\udc0d Script Python >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu Exercice 23.1 \u25a1 \u2693\ufe0e Exercice 23.1 \u00c9nonc\u00e9 Correction L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def occurence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ Exercice 23.2 \u25a1 \u2693\ufe0e Exercice 23.2 \u00c9nonc\u00e9 Correction La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12 Exercice 24.1 \u25a1 \u2693\ufe0e identique au 18.1 Exercice 24.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 Exercice 24.2 \u25a1 \u2693\ufe0e Exercice 24.2 \u00c9nonc\u00e9 Correction On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Exercice 25.1 \u25a1 \u2693\ufe0e Exercice 25.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution Exercice 25.2 \u25a1 \u2693\ufe0e Exercice 25.2 \u00c9nonc\u00e9 Correction Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) Exercice 26.1 \u25a1 \u2693\ufe0e Exercice 26.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : \ud83d\udc0d Script Python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ] Exercice 26.2 \u25a1 \u2693\ufe0e Exercice 26.2 \u00c9nonc\u00e9 Correction On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L Exercice 27.1 \u25a1 \u2693\ufe0e Exercice 27.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : \ud83d\udc0d Script Python >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) Exercice 27.2 \u25a1 \u2693\ufe0e Exercice 27.2 \u00c9nonc\u00e9 Correction On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom Exercice 28.1 \u25a1 \u2693\ufe0e Exercice 28.1 \u00c9nonc\u00e9 Correction Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : \ud83d\udc0d Script Python >>> taille ( a , \u2019 F \u2019 ) 9 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 Exercice 28.2 \u25a1 \u2693\ufe0e Exercice 28.2 \u00c9nonc\u00e9 Correction On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ max ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : \ud83d\udc0d Script Python >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab Exercice 29.1 \u25a1 \u2693\ufe0e Exercice 29.1 \u00c9nonc\u00e9 Correction Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : \ud83d\udc0d Script Python >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] Exercice 29.2 \u25a1 \u2693\ufe0e Exercice 29.2 \u00c9nonc\u00e9 Correction On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exercice 30.1 \u25a1 \u2693\ufe0e Exercice 30.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat Exercice 30.2 \u25a1 \u2693\ufe0e Exercice 30.2 \u00c9nonc\u00e9 Correction Sources en Markdown Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m \ud83d\udccb Texte Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher`, donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T`, et `None` sinon. Les param\u00e8tres de la fonction sont : - `T`, le tableau dans lequel s'effectue la recherche ; - `n`, l'entier \u00e0 chercher dans le tableau ; - `i`, l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j`, l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)`. Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None`. Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? ``` L'ex\u00e9cution du code doit donner : ```python >>> chercher([1,5,6,6,9,12],7,0,10) Erreur >>> chercher([1,5,6,6,9,12],7,0,5) >>> chercher([1,5,6,6,9,12],9,0,5) 4 >>> chercher([1,5,6,6,9,12],6,0,5) 2 ```", "title": "(!!! old !!!) BNS 2021"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#epreuve-pratique", "text": "Vous trouverez ci-dessous l'int\u00e9gralit\u00e9 des sujets de l'\u00e9preuve pratique, disponibles publiquement sur la Banque Nationale des Sujets (novembre 2021). Une nouvelle version (qui sera a priori en grande partie semblable \u00e0 celle-ci) sera publi\u00e9e en janvier 2022 sur le site Eduscol . update : les sujets sont disponibles, une premi\u00e8re version centralis\u00e9e se trouve ici Rappel des conditions de passation sur cette page . Pdf de l'int\u00e9gralit\u00e9 des exercices.", "title": "\u00c9preuve pratique \ud83d\udcbb"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-011", "text": "Exercice 01.1 \u00c9nonc\u00e9 Correction Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution", "title": "Exercice 01.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-012", "text": "Exercice 01.2 \u00c9nonc\u00e9 Correction On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : \ud83d\udc0d Script Python from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\"", "title": "Exercice 01.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-021", "text": "Exercice 02.1 \u00c9nonc\u00e9 Correction Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab )", "title": "Exercice 02.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-022", "text": "Exercice 02.2 \u00c9nonc\u00e9 Correction On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab", "title": "Exercice 02.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-031", "text": "Exercice 03.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\times (-6)= - (5 \\times 6)\\) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat", "title": "Exercice 03.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-032", "text": "Exercice 03.2 \u00c9nonc\u00e9 Correction Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False", "title": "Exercice 03.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-041", "text": "Exercice 04.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. \ud83d\udc0d Script Python def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab )", "title": "Exercice 04.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-042", "text": "Exercice 04.2 \u00c9nonc\u00e9 Correction Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False,1 , False,2 et False,3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False", "title": "Exercice 04.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-051", "text": "Exercice 05.1 \u00c9nonc\u00e9 Correction On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : \ud83d\udc0d Script Python def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : \ud83d\udc0d Script Python >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total", "title": "Exercice 05.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-052", "text": "Exercice 05.2 \u00c9nonc\u00e9 Correction La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : \ud83d\udc0d Script Python >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L", "title": "Exercice 05.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-061", "text": "Exercice 06.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : \ud83d\udc0d Script Python >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour", "title": "Exercice 06.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-062", "text": "\u00e0 noter une erreur dans la version officielle, sur la m\u00e9thode enfile() Exercice 06.2 \u00c9nonc\u00e9 Correction On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : \ud83d\udc0d Script Python 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : \ud83d\udc0d Script Python >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None", "title": "Exercice 06.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-071", "text": "Exercice 07.1 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ]", "title": "Exercice 07.1 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-072", "text": "Exercice 07.2 \u00c9nonc\u00e9 Correction Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi )", "title": "Exercice 07.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-081", "text": "Exercice 08.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme", "title": "Exercice 08.1 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-082", "text": "Exercice 08.2 \u00c9nonc\u00e9 Correction On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets - le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] - (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre), on cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 68 ,[], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 ,[], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 )", "title": "Exercice 08.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-091", "text": "Exercice 09.1 \u00c9nonc\u00e9 Correction Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs", "title": "Exercice 09.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-092", "text": "Exercice 09.2 \u00c9nonc\u00e9 Correction On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C", "title": "Exercice 09.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-101", "text": "Exercice 10.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max )", "title": "Exercice 10.1 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-102", "text": "Exercice 10.2 \u00c9nonc\u00e9 Correction Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2", "title": "Exercice 10.2 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-111", "text": "Exercice 11.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : \ud83d\udc0d Script Python >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def conv_bin ( n ): b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits )", "title": "Exercice 11.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-112", "text": "Exercice 11.2 \u00c9nonc\u00e9 Correction La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \u00c9crire une autre version de l\u2019algorithme avec \ud83d\udc0d Script Python for i in range ( n - 1 ): en lieu et place de la troisi\u00e8me ligne du code pr\u00e9c\u00e9dent. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T #version 2 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 ): for j in range ( n - 1 , i , - 1 ): if T [ j ] < T [ j - 1 ]: temp = T [ j ] T [ j ] = T [ j - 1 ] T [ j - 1 ] = temp return T", "title": "Exercice 11.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-121", "text": "Ce sujet est le m\u00eame que le 10.1... \u00af\\_(\u30c4)_/\u00af Exercice 12.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max )", "title": "Exercice 12.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-122", "text": "Exercice 12.2 \u00c9nonc\u00e9 Correction La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : \ud83d\udc0d Script Python >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve", "title": "Exercice 12.2 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-131", "text": "Exercice 13.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : \ud83d\udc0d Script Python >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab", "title": "Exercice 13.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-132", "text": "Exercice 13.2 \u00c9nonc\u00e9 Correction Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 100 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 0 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere )", "title": "Exercice 13.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-141", "text": "Exercice 14.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices", "title": "Exercice 14.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-142", "text": "Exercice 14.2 \u00c9nonc\u00e9 Correction Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1", "title": "Exercice 14.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-151", "text": "Exercice 15.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } d = {} d [ 'min' ] = None d [ 'max' ] = None for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d", "title": "Exercice 15.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-152", "text": "Exercice 15.2 \u00c9nonc\u00e9 Correction On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): #A compl\u00e9ter \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): #A compl\u00e9ter Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): for nb_coul in range ( 1 , 5 ): for val in range ( 1 , 14 ): self . contenu . append ( Carte ( nb_coul , val )) \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos in range ( 56 ) return self . contenu [ pos ]", "title": "Exercice 15.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-161", "text": "Exercice 16.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab )", "title": "Exercice 16.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-162", "text": "Exercice 16.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : \ud83d\udc0d Script Python >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = '' a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a", "title": "Exercice 16.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-171", "text": "Exercice 17.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction indice_du_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> indice_du_min ([ 5 ]) 0 >>> indice_du_min ([ 2 , 4 , 1 ]) 2 >>> indice_du_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 def indice_du_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min", "title": "Exercice 17.1 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-172", "text": "Exercice 17.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab", "title": "Exercice 17.2 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-181", "text": "Exercice 18.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1", "title": "Exercice 18.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-182", "text": "Exercice 18.2 \u00c9nonc\u00e9 Correction On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. Sujet l\u00e9g\u00e8rement modifi\u00e9 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= ... : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l", "title": "Exercice 18.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-191", "text": "Exercice 19.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1", "title": "Exercice 19.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-192", "text": "Exercice 19.2 \u00c9nonc\u00e9 Correction Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat", "title": "Exercice 19.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-201", "text": "Exercice 20.1 \u00c9nonc\u00e9 Correction On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : \ud83d\udc0d Script Python >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini", "title": "Exercice 20.1 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-202", "text": "Exercice 20.2 \u00c9nonc\u00e9 Correction Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine )", "title": "Exercice 20.2 \ud83d\uddf9"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-211", "text": "Exercice 21.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 ,[ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' ,[ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 ,[ 1 , '! ' , 7 , 21 , 36 , 44 ]) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb", "title": "Exercice 21.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-212", "text": "Exercice 21.2 \u00c9nonc\u00e9 Correction Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a", "title": "Exercice 21.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-221", "text": "Exercice 22.1 \u00c9nonc\u00e9 Correction \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : \ud83d\udc0d Script Python >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb", "title": "Exercice 22.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-222", "text": "Exercice 22.2 \u00c9nonc\u00e9 Correction La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : \ud83d\udc0d Script Python >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu", "title": "Exercice 22.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-231", "text": "Exercice 23.1 \u00c9nonc\u00e9 Correction L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def occurence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ", "title": "Exercice 23.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-232", "text": "Exercice 23.2 \u00c9nonc\u00e9 Correction La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12", "title": "Exercice 23.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-241", "text": "identique au 18.1 Exercice 24.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1", "title": "Exercice 24.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-242", "text": "Exercice 24.2 \u00c9nonc\u00e9 Correction On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' )", "title": "Exercice 24.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-251", "text": "Exercice 25.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution", "title": "Exercice 25.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-252", "text": "Exercice 25.2 \u00c9nonc\u00e9 Correction Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , ... , val ) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val )", "title": "Exercice 25.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-261", "text": "Exercice 26.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o,','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : \ud83d\udc0d Script Python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ]", "title": "Exercice 26.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-262", "text": "Exercice 26.2 \u00c9nonc\u00e9 Correction On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L", "title": "Exercice 26.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-271", "text": "Exercice 27.1 \u00c9nonc\u00e9 Correction \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : \ud83d\udc0d Script Python >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab )", "title": "Exercice 27.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-272", "text": "Exercice 27.2 \u00c9nonc\u00e9 Correction On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom", "title": "Exercice 27.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-281", "text": "Exercice 28.1 \u00c9nonc\u00e9 Correction Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : \ud83d\udc0d Script Python >>> taille ( a , \u2019 F \u2019 ) 9 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1", "title": "Exercice 28.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-282", "text": "Exercice 28.2 \u00c9nonc\u00e9 Correction On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ max ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : \ud83d\udc0d Script Python >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab", "title": "Exercice 28.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-291", "text": "Exercice 29.1 \u00c9nonc\u00e9 Correction Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier n strictement positif et qui renvoie la liste des valeurs de la suite, en partant de n et jusqu'\u00e0 atteindre 1. Exemple : \ud83d\udc0d Script Python >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ]", "title": "Exercice 29.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-292", "text": "Exercice 29.2 \u00c9nonc\u00e9 Correction On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ]", "title": "Exercice 29.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-301", "text": "Exercice 30.1 \u00c9nonc\u00e9 Correction Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat", "title": "Exercice 30.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2021/#exercice-302", "text": "Exercice 30.2 \u00c9nonc\u00e9 Correction Sources en Markdown Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m \ud83d\udccb Texte Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher`, donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T`, et `None` sinon. Les param\u00e8tres de la fonction sont : - `T`, le tableau dans lequel s'effectue la recherche ; - `n`, l'entier \u00e0 chercher dans le tableau ; - `i`, l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j`, l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)`. Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None`. Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? ``` L'ex\u00e9cution du code doit donner : ```python >>> chercher([1,5,6,6,9,12],7,0,10) Erreur >>> chercher([1,5,6,6,9,12],7,0,5) >>> chercher([1,5,6,6,9,12],9,0,5) 4 >>> chercher([1,5,6,6,9,12],6,0,5) 2 ```", "title": "Exercice 30.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/", "text": "\u00c9preuve Pratique BNS 2022 \u2693\ufe0e \u00c0 lire Les sujets ci-dessous correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 24/02/2022 . Certains sujets (ceux de l'ann\u00e9e derni\u00e8re reconduits cette ann\u00e9e) ont parfois \u00e9t\u00e9 l\u00e9g\u00e8rement modifi\u00e9s par rapport \u00e0 la version 2021. La correspondance des num\u00e9rotations entre la BNS 2021 et la BNS 2022 peut se retrouver ici Certains de ces sujets comportent des erreurs. Elles ont \u00e9t\u00e9 corrig\u00e9es ou non. Dans le doute, comparer avec la version originale du sujet. Les versions originales de ces sujets sont disponibles en pdf au d\u00e9but de chaque sujet. (pour t\u00e9l\u00e9charger les 40 sujets en un seul fichier, c'est ici ) Pourquoi proposer une correction ? La BNS est une banque de sujets publique , publi\u00e9e bien en amont de l'\u00c9preuve Pratique, afin que les futurs candidats puissent s'entra\u00eener \u00e0 la r\u00e9solution des exercices. Pour permettre aux \u00e9l\u00e8ves de travailler en autonomie, une proposition de corrig\u00e9 (r\u00e9alis\u00e9e par Gilles Lassus) figure en regard de l'\u00e9nonc\u00e9. \u25b6 Sujet 01 \u2693\ufe0e Version originale du sujet en pdf. Exercice 01.1 \u25a1 \u2693\ufe0e Exercice 01.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `caractere`, un caract\u00e8re, et `mot`, une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de `caractere` dans `mot`, c\u2019est-\u00e0-dire le nombre de fois o\u00f9 `caractere` appara\u00eet dans `mot`. Exemples : ```python >>> recherche('e', \"sciences\") 2 >>> recherche('i',\"mississippi\") 4 >>> recherche('a',\"mississippi\") 0 ``` Exercice 01.2 \u25a1 \u2693\ufe0e Exercice 01.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] . (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre). On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] # (1) def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) Erreur dans l'\u00e9nonc\u00e9 officiel : Pieces On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 68 , [], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 , [], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste `pieces=[100, 50, 20, 10, 5, 2, 1]` . (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre). On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction `rendu_glouton` qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. ```python linenums='1' pieces = [100,50,20,10,5,2,1] # (1) def rendu_glouton(arendre, solution=[], i=0): if arendre == 0: return ... p = pieces[i] if p <= ... : solution.append(...) return rendu_glouton(arendre - p, solution,i) else : return rendu_glouton(arendre, solution, ...) Erreur dans l'\u00e9nonc\u00e9 officiel : Pieces On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 68 , [], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 , [], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] ``` \u25b6 Sujet 02 \u2693\ufe0e Version originale du sujet en pdf. Exercice 02.1 \u25a1 \u2693\ufe0e Exercice 02.1 \u00c9nonc\u00e9 Correction Source Markdown Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \ud83d\udccb Texte Soit le couple (`note`,`coefficient`): - `note` est un nombre de type flottant (`float`) compris entre 0 et 20 ; - `coefficient` est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples (`note`,`coefficient`). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression `moyenne([(15,2),(9,1),(12,3)])` devra renvoyer le r\u00e9sultat du calcul suivant : $\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5$ Exercice 02.2 \u25a1 \u2693\ufe0e Exercice 02.2 \u00c9nonc\u00e9 Correction Sources Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : ![ image ]( data/img9_2t.png ){: .center width=60%} Compl\u00e9ter la fonction `pascal` ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne `1` \u00e0 la ligne `n` o\u00f9 `n` est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 `2` (le tableau sera contenu dans la variable `C` ). La variable `Ck` doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro `k` , la `k` -i\u00e8me ligne du tableau. ```python linenums='1' def pascal(n): C= [[1]] for k in range(1,...): Ck = [...] for i in range(1,k): Ck.append(C[...][i-1]+C[...][...] ) Ck.append(...) C.append(Ck) return C Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] ``` \u25b6 Sujet 03 \u2693\ufe0e Version originale du sujet en pdf. Exercice 03.1 \u25a1 \u2693\ufe0e Exercice 03.1 \u00c9nonc\u00e9 Correction Source Markdown Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : \ud83d\udc0d Script Python >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] \ud83d\udc0d Script Python 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff \ud83d\udccb Texte Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction `delta` qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : ```python >>> delta([1000, 800, 802, 1000, 1003]) [1000, -200, 2, 198, 3] >>> delta([42]) [42] ``` Exercice 03.2 \u25a1 \u2693\ufe0e Exercice 03.2 \u00c9nonc\u00e9 Correction Sources Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : \ud83d\udc0d Script Python >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. ![ image ]( data/img3_2.png ){: .center width=30%} En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : $$3 \\times (8 + 7) \u2212 (2 + 1)$$ La classe `Noeud` ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive `expression_infixe` qui prend en param\u00e8tre un objet de la classe `Noeud` et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : ```python >>> e = Noeud(Noeud(Noeud(None, 3, None), '*', Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))), '-', Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))) >>> expression_infixe(e) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... ``` \u25b6 Sujet 04 \u2693\ufe0e Version originale du sujet en pdf. Exercice 04.1 \u25a1 \u2693\ufe0e Exercice 04.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tre un tableau de nombres entiers `tab`, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans `tab`. Exemples : ```python >>> recherche([1, 4, 3, 5]) [] >>> recherche([1, 4, 5, 3]) [(4, 5)] >>> recherche([7, 1, 2, 5, 3, 4]) [(1, 2), (3, 4)] >>> recherche([5, 1, 2, 3, 8, -5, -4, 7]) [(1, 2), (2, 3), (-5, -4)] ``` Exercice 04.2 \u25a1 \u2693\ufe0e Exercice 04.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None # (1) M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): # (2) propager ( M , i , ... , val ) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments `M[i][j]` , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 `0` soit \u00e0 `1` . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de `1` et de `0` qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de ![ image ]( data/252a.png ){: .center width=30%} sont ![ image ]( data/252b.png ){: .center width=30%} On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 `1` dans une image `M` , donner la valeur `val` \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction `propager` prend pour param\u00e8tre une image `M` , deux entiers `i` et `j` et une valeur enti\u00e8re `val` . Elle met \u00e0 la valeur `val` tous les pixels de la composante du pixel `M[i][j]` s\u2019il vaut `1` et ne fait rien s\u2019il vaut `0` . Par exemple, `propager(M,2,1,3)` donne ![ image ]( data/252c.png ){: .center width=30%} Compl\u00e9ter le code r\u00e9cursif de la fonction `propager` donn\u00e9 ci-dessous : ```python linenums='1' def propager(M, i, j, val): if M[i][j]== ...: return None # (1) M[i][j] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if ((i-1) >= 0 and M[i-1][j] == ...): propager(M, i-1, j, val) # l'\u00e9l\u00e9ment en bas fait partie de la composante if ((...) < len(M) and M[i+1][j] == 1): propager(M, ..., j, val) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if ((...) >= 0 and M[i][j-1] == 1): propager(M, i, ..., val) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if ((...) < len(M) and M[i][j+1] == 1): # (2) propager(M, i, ..., val) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] ``` \u25b6 Sujet 05 \u2693\ufe0e Version originale du sujet en pdf. Exercice 05.1 \u25a1 \u2693\ufe0e Exercice 05.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \ud83d\udccb Texte \u00c9crire une fonction `rechercheMinMax` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s `tab`, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> tableau = [0, 1, 4, 2, -2, 9, 3, 1, 7, 1] >>> resultat = rechercheMinMax(tableau) >>> resultat {'min': -2, 'max': 9} >>> tableau = [] >>> resultat = rechercheMinMax(tableau) >>> resultat {'min': None, 'max': None} ``` Exercice 05.2 \u25a1 \u2693\ufe0e Exercice 05.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Carte : \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): ??? = [ ??? for couleur in range ( 1 , ??? ) for valeur in range ( 1 , ??? )] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < ??? : return ??? Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): self . contenu = [ Carte ( couleur , valeur ) for couleur in range ( 1 , 5 ) for valeur in range ( 1 , 14 )] \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos in range ( 0 , 52 ) if 0 <= pos < len ( self . contenu ) : return self . contenu [ pos ] Markdown On dispose d\u2019un programme permettant de cr\u00e9er un objet de type `PaquetDeCarte` , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par `#A compl\u00e9ter` , puis ajouter des assertions dans l\u2019initialiseur de `Carte` , ainsi que dans la m\u00e9thode `getCarteAt()` . ```python linenums='1' class Carte: \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ (self, c, v): self.Couleur = c self.Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom(self): if ( self.Valeur > 1 and self.Valeur < 11): return str( self.Valeur) elif self.Valeur == 11: return \"Valet\" elif self.Valeur == 12: return \"Dame\" elif self.Valeur == 13: return \"Roi\" else: return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur(self): return [ 'pique', 'coeur', 'carreau', 'trefle' ][ self.Couleur - 1 ] class PaquetDeCarte: def __init__ (self): self.contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir(self): ??? = [ ??? for couleur in range(1, ???) for valeur in range( 1, ???)] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt(self, pos): if 0 <= pos < ??? : return ??? Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur ``` \u25b6 Sujet 06 \u2693\ufe0e Version originale du sujet en pdf. Exercice 06.1 \u25a1 \u2693\ufe0e Exercice 06.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \ud83d\udccb Texte \u00c9crire une fonction `maxi` qui prend en param\u00e8tre une liste `tab` de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ``` Exercice 06.2 \u25a1 \u2693\ufe0e Exercice 06.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : \ud83d\udc0d Script Python >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g + 1 and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve Markdown La fonction `recherche` prend en param\u00e8tres deux chaines de caract\u00e8res `gene` et `seq_adn` et renvoie `True` si on retrouve `gene` dans `seq_adn` et `False` sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction `recherche` . ```python linenums='1' def recherche(gene, seq_adn): n = len(seq_adn) g = len(gene) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene[j] == seq_adn[i+j]: ... if j == g: trouve = True ... return trouve Exemples : \ud83d\udc0d Script Python >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False ``` \u25b6 Sujet 07 \u2693\ufe0e Version originale du sujet en pdf. Exercice 07.1 \u25a1 \u2693\ufe0e Exercice 07.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : \ud83d\udc0d Script Python >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def conv_bin ( n ): # cas particulier pour n = 0 if n == 0 : return ([ 0 ], 1 ) # cas g\u00e9n\u00e9ral b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) \ud83d\udccb Texte \u00c9crire une fonction `conv_bin` qui prend en param\u00e8tre un entier positif `n` et renvoie un couple (`b,bit)` o\u00f9 : - `b` est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de `n`; - `bit` correspond aux nombre de bits qui constituent `b`. Exemple : ```python >>> conv_bin(9) ([1,0,0,1],4) ``` Aide : - l'op\u00e9rateur `//` donne le quotient de la division euclidienne : `5//2` donne `2` ; - l'op\u00e9rateur `%` donne le reste de la division euclidienne :` 5%2` donne `1` ; - `append` est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit `T=[5,2,4]`, alors `T.append(10)` ajoute `10` \u00e0 la liste `T`. Ainsi, `T` devient `[5,2,4,10]`. - `reverse` est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit `T=[5,2,4,10]`. Apr\u00e8s `T.reverse()`, la liste devient `[10,4,2,5]`. On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier `n` en partant de la gauche en appliquant successivement les instructions : `b = n%2` `n = n//2` r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. Exercice 07.2 \u25a1 \u2693\ufe0e Exercice 07.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T Markdown La fonction `tri_bulles` prend en param\u00e8tre une liste `T` d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction `tri_bulles` . ```python linenums='1' def tri_bulles(T): n = len(T) for i in range(...,...,-1): for j in range(i): if T[j] > T[...]: ... = T[j] T[j] = T[...] T[j+1] = temp return T ``` \u25b6 Sujet 08 \u2693\ufe0e Version originale du sujet en pdf. Exercice 08.1 \u25a1 \u2693\ufe0e Exercice 08.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ``` Exercice 08.2 \u25a1 \u2693\ufe0e Exercice 08.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= 0 : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l Markdown On consid\u00e8re la fonction `insere` ci-dessous qui prend en argument un entier `a` et un tableau `tab` d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur `a` dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. ```python linenums='1' def insere(a, tab): l = list(tab) #l contient les m\u00eames \u00e9l\u00e9ments que tab l.append(a) i = ... while a < ... and i >= 0: l[i+1] = ... l[i] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] ``` \u25b6 Sujet 09 \u2693\ufe0e Version originale du sujet en pdf. Exercice 09.1 \u25a1 \u2693\ufe0e Exercice 09.1 \u00c9nonc\u00e9 Correction Source Markdown Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier k strictement positif et qui renvoie la liste des valeurs de la suite, en partant de k et jusqu'\u00e0 atteindre 1. Exemple : \ud83d\udc0d Script Python >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def calcul ( k ): valeurs = [] n = k valeurs . append ( n ) while n != 1 : if n % 2 == 0 : n = n // 2 else : n = 3 * n + 1 valeurs . append ( n ) return valeurs \ud83d\udccb Texte Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : - s'il est pair, on le divise par 2 ; - s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite $(U_n)$ par : - $U_0=k$, o\u00f9 $k$ est un entier choisi initialement; - $U_{n+1} = \\dfrac{U_n}{2}$ si $U_n$ est pair; - $U_{n+1} = 3 \\times U_n + 1$ si $U_n$ est impair. **On admet que, quel que soit l'entier ```k``` choisi au d\u00e9part, la suite finit toujours sur la valeur 1.** \u00c9crire une fonction ```calcul``` prenant en param\u00e8tres un entier ```k``` strictement positif et qui renvoie la liste des valeurs de la suite, en partant de ```k``` et jusqu'\u00e0 atteindre 1. Exemple : ```python >>> calcul(7) [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] ``` Exercice 09.2 \u25a1 \u2693\ufe0e Exercice 09.2 \u00c9nonc\u00e9 Correction Sources Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son *code alphab\u00e9tique concat\u00e9n\u00e9* , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, *son code additionn\u00e9*, qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab *parfait* \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : - Pour le mot `\"PAUL\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1612112'` , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot `\"PAUL\"` n\u2019est pas parfait. - Pour le mot `\"ALAIN\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1121914'` , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot `\"ALAIN\"` est parfait. Compl\u00e9ter la fonction `est_parfait` ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res `mot` (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de `mot` , ainsi qu\u2019un bool\u00e9en qui indique si `mot` est parfait ou pas. ```python linenums='1' dico = {\"A\":1, \"B\":2, \"C\":3, \"D\":4, \"E\":5, \"F\":6, \"G\":7, \\ \"H\":8, \"I\":9, \"J\":10, \"K\":11, \"L\":12, \"M\":13, \\ \"N\":14, \"O\":15, \"P\":16, \"Q\":17, \"R\":18, \"S\":19, \\ \"T\":20, \"U\":21,\"V\":22, \"W\":23, \"X\":24, \"Y\":25, \"Z\":26} def est_parfait(mot) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int(code_c) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [code_a, code_c, mot_est_parfait] Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] ``` \u25b6 Sujet 10 \u2693\ufe0e Version originale du sujet en pdf. Exercice 10.1 \u25a1 \u2693\ufe0e Exercice 10.1 \u00c9nonc\u00e9 Correction Source Markdown L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurrence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def occurrence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ \ud83d\udccb Texte L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : - l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; - l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : `{'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1}` \u00c9crire une fonction `occurrence_lettres` prenant comme param\u00e8tre une variable `phrase` de type `str`. Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. Exercice 10.2 \u25a1 \u2693\ufe0e Exercice 10.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12 Markdown La fonction `fusion` prend deux listes `L1` , `L2` d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e `L12` qu\u2019elle renvoie. Le code Python de la fonction est ```python linenums='1' def fusion(L1,L2): n1 = len(L1) n2 = len(L2) L12 = [0]*(n1+n2) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1[i1] < L2[i2]: L12[i] = ... i1 = ... else: L12[i] = L2[i2] i2 = ... i += 1 while i1 < n1: L12[i] = ... i1 = i1 + 1 i = ... while i2 < n2: L12[i] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] ``` \u25b6 Sujet 11 \u2693\ufe0e Version originale du sujet en pdf. Exercice 11.1 \u25a1 \u2693\ufe0e Exercice 11.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres un tableau `tab` de nombres entiers tri\u00e9s par ordre croissant et un nombre entier `n`, et qui effectue une recherche dichotomique du nombre entier `n` dans le tableau non vide `tab`. Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, `-1` sinon. Exemples : ```python >>> recherche([2, 3, 4, 5, 6], 5) 3 >>> recherche([2, 3, 4, 6, 7], 5) -1 ``` Exercice 11.2 \u25a1 \u2693\ufe0e Exercice 11.2 \u00c9nonc\u00e9 Correction Sources Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction `position_alphabet` ci-dessous prend en param\u00e8tre un caract\u00e8re `lettre` et renvoie la position de `lettre` dans la cha\u00eene de caract\u00e8res `ALPHABET` s\u2019il s\u2019y trouve et `-1` sinon. La fonction `cesar` prend en param\u00e8tre une cha\u00eene de caract\u00e8res `message` et un nombre entier `decalage` et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage `decalage` . ```python linenums='1' ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet(lettre): return ALPHABET.find(lettre) def cesar(message, decalage): resultat = '' for ... in message: if lettre in ALPHABET: indice = ( ... ) % 26 resultat = resultat + ALPHABET[indice] else: resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' ``` \u25b6 Sujet 12 \u2693\ufe0e Version originale du sujet en pdf. Exercice 12.1 \u25a1 \u2693\ufe0e Exercice 12.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte Programmer la fonction ```moyenne``` prenant en param\u00e8tre un tableau d'entiers ```tab``` (type `list`) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : ```python >>> moyenne([5,3,8]) 5.333333333333333 >>> moyenne([1,2,3,4,5,6,7,8,9,10]) 5.5 >>> moyenne([]) 'erreur' ``` Exercice 12.2 \u25a1 \u2693\ufe0e Exercice 12.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab Markdown On consid\u00e8re un tableau d'entiers `tab` (type `list` dont les \u00e9l\u00e9ments sont des `0` ou des `1` ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des `0` , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des `1` . <table> <tr> <td>Zone de 0</td><td>Zone non tri\u00e9e</td><td>Zone de 1</td> </tr> </table> Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : - si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; - si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction `tri` suivante : ```python linenums='1' def tri(tab): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab[i]== 0: i = ... else : valeur = tab[j] tab[j] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ``` \u25b6 Sujet 13 \u2693\ufe0e Version originale du sujet en pdf. Exercice 13.1 \u25a1 \u2693\ufe0e Exercice 13.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : \ud83d\udc0d Script Python >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour \ud83d\udccb Texte On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e `rendu` dont le param\u00e8tre est un entier positif non nul `somme_a_rendre` et qui retourne une liste de trois entiers `n1`, `n2` et `n3` qui correspondent aux nombres de billets de 5 euros (`n1`) de pi\u00e8ces de 2 euros (`n2`) et de pi\u00e8ces de 1 euro (`n3`) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 `somme_a_rendre`. On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : ```python >>> rendu(13) [2,1,1] >>> rendu(64) [12,2,0] >>> rendu(89) [17,2,0] ``` Exercice 13.2 \u25a1 \u2693\ufe0e Exercice 13.2 \u00c9nonc\u00e9 Correction Sources Markdown On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : \ud83d\udc0d Script Python 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : \ud83d\udc0d Script Python >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None Markdown On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe ```Maillon``` permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : ```python linenums='1' class Maillon : def __init__ (self,v) : self.valeur = v self.suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : \ud83d\udc0d Script Python >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 ``` \u25b6 Sujet 14 \u2693\ufe0e Version originale du sujet en pdf. Exercice 14.1 \u25a1 \u2693\ufe0e Exercice 14.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res * . Par exemple INFO*MA*IQUE , ***I***E** et *S* sont des mots \u00e0 trous. Programmer une fonction correspond qui : prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res mot et mot_a_trous o\u00f9 mot_a_trous est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, renvoie : True si on peut obtenir mot en rempla\u00e7ant convenablement les caract\u00e8res '*' de mot_a_trous . False sinon. Exemple : \ud83d\udc0d Script Python >>> correspond ( 'INFORMATIQUE' , 'INFO*MA*IQUE' ) True >>> correspond ( 'AUTOMATIQUE' , 'INFO*MA*IQUE' ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def correspond ( mot , mot_a_trous ): if len ( mot ) != len ( mot_a_trous ): return False for i in range ( len ( mot )): if mot [ i ] != mot_a_trous [ i ] and mot_a_trous [ i ] != '*' : return False return True \ud83d\udccb Texte On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res `*`. Par exemple `INFO*MA*IQUE`, `***I***E**` et `*S*` sont des mots \u00e0 trous. Programmer une fonction correspond qui : - prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res `mot` et `mot_a_trous` o\u00f9 `mot_a_trous` est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, - renvoie : - `True` si on peut obtenir `mot` en rempla\u00e7ant convenablement les caract\u00e8res `'*'` de `mot_a_trous`. - `False` sinon. Exemple : ```python >>> correspond('INFORMATIQUE', 'INFO*MA*IQUE') True >>> correspond('AUTOMATIQUE', 'INFO*MA*IQUE') False ``` Exercice 14.2 \u25a1 \u2693\ufe0e Exercice 14.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : chaque personne ne peut envoyer des messages qu'\u00e0 la m\u00eame personne (\u00e9ventuellement elle-m\u00eame), chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : A envoie ses messages \u00e0 E E envoie ses messages \u00e0 B B envoie ses messages \u00e0 F F envoie ses messages \u00e0 A C envoie ses messages \u00e0 D D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'} Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'} comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle, on dit que le plan d\u2019envoi est cyclique . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : On part de la personne A et on inspecte les N \u2013 1 successeurs dans le plan d'envoi : Si un de ces N \u2013 1 successeurs est A lui-m\u00eame, on a trouv\u00e9 un cycle de taille inf\u00e9rieure ou \u00e9gale \u00e0 N \u2013 1. Il y a donc au moins deux cycles et le plan d'envoi n'est pas cyclique. Si on ne retombe pas sur A lors de cette inspection, on a un unique cycle qui passe par toutes les personnes : le plan d'envoi est cyclique. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. Remarque : la fonction python len permet d'obtenir la longueur d'un dictionnaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len ( ... ) for i in range ( ... ): if plan [ ... ] == ... : return ... else : personne = ... return ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len ( plan ) for i in range ( N - 1 ): if plan [ personne ] == 'A' : return False else : personne = plan [ personne ] return True print ( est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' })) print ( est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' })) Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : - chaque personne ne peut envoyer des messages qu'\u00e0 la m\u00eame personne (\u00e9ventuellement elle-m\u00eame), - chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : - A envoie ses messages \u00e0 E - E envoie ses messages \u00e0 B - B envoie ses messages \u00e0 F - F envoie ses messages \u00e0 A - C envoie ses messages \u00e0 D - D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : `plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'}` Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : `plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'}` comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle, on dit que le plan d\u2019envoi est *cyclique* . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : On part de la personne A et on inspecte les N \u2013 1 successeurs dans le plan d'envoi : - Si un de ces N \u2013 1 successeurs est A lui-m\u00eame, on a trouv\u00e9 un cycle de taille inf\u00e9rieure ou \u00e9gale \u00e0 N \u2013 1. Il y a donc au moins deux cycles et le plan d'envoi n'est pas cyclique. - Si on ne retombe pas sur A lors de cette inspection, on a un unique cycle qui passe par toutes les personnes : le plan d'envoi est cyclique. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. *Remarque :* la fonction python `len` permet d'obtenir la longueur d'un dictionnaire. ```python linenums='1' def est_cyclique(plan): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len(...) for i in range(...): if plan[...] == ...: return ... else: personne = ... return ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False ``` \u25b6 Sujet 15 \u2693\ufe0e Version originale du sujet en pdf. Exercice 15.1 \u25a1 \u2693\ufe0e Exercice 15.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 , [ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' , [ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 , [ 1 , '!' , 7 , 21 , 36 , 44 ]) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \ud83d\udccb Texte \u00c9crire une fonction python appel\u00e9e `nb_repetitions` qui prend en param\u00e8tres un \u00e9l\u00e9ment `elt` et une liste `tab` et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : ```python >>> nb_repetitions(5, [2, 5, 3, 5, 6, 9, 5]) 3 >>> nb_repetitions('A', ['B', 'A', 'B', 'A', 'R']) 2 >>> nb_repetitions(12, [1, '!', 7, 21, 36, 44]) 0 ``` Exercice 15.2 \u25a1 \u2693\ufe0e Exercice 15.2 \u00c9nonc\u00e9 Correction Sources Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : ![ image ]( data/img21_2.png ){: .center} Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : ```python linenums='1' def binaire(a): bin_a = str(...) a = a // 2 while a ... : bin_a = ...(a%2) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' ``` \u25b6 Sujet 16 \u2693\ufe0e Version originale du sujet en pdf. Exercice 16.1 \u25a1 \u2693\ufe0e Exercice 16.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \ud83d\udccb Texte \u00c9crire une fonction `maxi` qui prend en param\u00e8tre une liste `tab` de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ``` Exercice 16.2 \u25a1 \u2693\ufe0e Exercice 16.2 \u00c9nonc\u00e9 Correction Sources Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type `list` ). On rappelle que l\u2019expression `T1 = list(T)` fait une copie de `T ` ind\u00e9pendante de `T` , que l\u2019expression `x = T.pop()` enl\u00e8ve le sommet de la pile `T` et le place dans la variable `x` et, enfin, que l\u2019expression `T.append(v)` place la valeur `v` au sommet de la pile `T` . Compl\u00e9ter le code Python de la fonction `positif` ci-dessous qui prend une pile `T` de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable `T` . ```python linenums='1' def positif(T): T2 = ...(T) T3 = ... while T2 != []: x = ... if ... >= 0: T3.append(...) T2 = [] while T3 != ...: x = T3.pop() ... print('T = ',T) return T2 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] ``` \u25b6 Sujet 17 \u2693\ufe0e Version originale du sujet en pdf. Exercice 17.1 \u25a1 \u2693\ufe0e Exercice 17.1 \u00c9nonc\u00e9 Correction Source Markdown Pour cet exercice : On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace ' ' , se finissant : soit par un point '.' qui est alors coll\u00e9 au dernier mot, soit par un point d'exclamation '!' ou d'interrogation '?' qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace ' ' . Exemples : Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction nombre_de_mots qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. \ud83d\udc0d Script Python >>> nombre_de_mots ( 'Le point d exclamation est separe !' ) 6 >>> nombre_de_mots ( 'Il y a un seul espace entre les mots !' ) 9 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nombre_de_mots ( phrase ): nb_mots = 0 for caractere in phrase : if caractere == ' ' or caractere == '.' : nb_mots += 1 return nb_mots \ud83d\udccb Texte Pour cet exercice : - On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, - On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : - compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace `' '`, - se finissant : - soit par un point `'.'` qui est alors coll\u00e9 au dernier mot, - soit par un point d'exclamation `'!'` ou d'interrogation `'?'` qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace `' '`. *Exemples :* Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction `nombre_de_mots` qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. ```python >>> nombre_de_mots('Le point d exclamation est separe !') 6 >>> nombre_de_mots('Il y a un seul espace entre les mots !') 9 ``` Exercice 17.2 \u25a1 \u2693\ufe0e Exercice 17.2 \u00c9nonc\u00e9 Correction Sources Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , v , g , d ): self . valeur = v self . gauche = g self . droite = d class ABR : ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ ( self ): '''Cr\u00e9e un arbre binaire de recherche vide''' self . racine = None def est_vide ( self ): '''Renvoie True si l'ABR est vide et False sinon.''' return self . racine is None def parcours ( self , tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( ... ) ... return tab def insere ( self , element ): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self . est_vide (): self . racine = Noeud ( element , ABR (), ABR ()) else : if element < self . racine . valeur : self . racine . gauche . insere ( element ) else : self . racine . droite . insere ( element ) def recherche ( self , element ): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self . est_vide (): return ... else : if element < self . racine . valeur : return ... elif element > self . racine . valeur : return ... else : return ... Compl\u00e9ter les fonctions r\u00e9cursives parcours et recherche afin qu'elles respectent leurs sp\u00e9cifications. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> a = ABR () >>> a . insere ( 7 ) >>> a . insere ( 3 ) >>> a . insere ( 9 ) >>> a . insere ( 1 ) >>> a . insere ( 9 ) >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . recherche ( 4 ) False >>> a . recherche ( 3 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , v , g , d ): self . valeur = v self . gauche = g self . droite = d class ABR : ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ ( self ): '''Cr\u00e9e un arbre binaire de recherche vide''' self . racine = None def est_vide ( self ): '''Renvoie True si l'ABR est vide et False sinon.''' return self . racine is None def parcours ( self , tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( self . racine . valeur ) self . racine . droite . parcours ( tab ) return tab def insere ( self , element ): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self . est_vide (): self . racine = Noeud ( element , ABR (), ABR ()) else : if element < self . racine . valeur : self . racine . gauche . insere ( element ) else : self . racine . droite . insere ( element ) def recherche ( self , element ): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self . est_vide (): return False else : if element < self . racine . valeur : return self . racine . gauche . recherche ( element ) elif element > self . racine . valeur : return self . racine . droite . recherche ( element ) else : return True Cette mani\u00e8re de coder le parcours est maladroite car elle conduit \u00e0 ceci : \ud83d\udc0d Script Python >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 , 1 , 3 , 7 , 9 , 9 ] Comme le param\u00e8tre optionnel tab est un \u00e9l\u00e9ment mutable (de type list ), Python ne le r\u00e9initialise pas avant chaque appel de la fonction. Vous pouvez constater les cons\u00e9quences f\u00e2cheuses. Une solution pourrait \u00eatre d'\u00e9crire ceci : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def parcours ( self , tab = None ): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if tab is None : tab = [] if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( self . racine . valeur ) self . racine . droite . parcours ( tab ) return tab Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. ```python linenums='1' class Noeud: ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ (self, v, g, d): self.valeur = v self.gauche = g self.droite = d class ABR: ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ (self): '''Cr\u00e9e un arbre binaire de recherche vide''' self.racine = None def est_vide(self): '''Renvoie True si l'ABR est vide et False sinon.''' return self.racine is None def parcours(self, tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self.est_vide(): return tab else: self.racine.gauche.parcours(tab) tab.append(...) ... return tab def insere(self, element): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self.est_vide(): self.racine = Noeud(element, ABR(), ABR()) else: if element < self.racine.valeur: self.racine.gauche.insere(element) else : self.racine.droite.insere(element) def recherche(self, element): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self.est_vide(): return ... else: if element < self.racine.valeur: return ... elif element > self.racine.valeur: return ... else: return ... Compl\u00e9ter les fonctions r\u00e9cursives parcours et recherche afin qu'elles respectent leurs sp\u00e9cifications. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> a = ABR () >>> a . insere ( 7 ) >>> a . insere ( 3 ) >>> a . insere ( 9 ) >>> a . insere ( 1 ) >>> a . insere ( 9 ) >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . recherche ( 4 ) False >>> a . recherche ( 3 ) True ``` \u25b6 Sujet 18 \u2693\ufe0e Version originale du sujet en pdf. Exercice 18.1 \u25a1 \u2693\ufe0e Exercice 18.1 \u00c9nonc\u00e9 Correction Source Markdown On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : \ud83d\udc0d Script Python >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \ud83d\udccb Texte On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : ```python t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7] annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019] ``` \u00c9crire la fonction `mini` qui prend en param\u00e8tres le tableau `releve` des relev\u00e9s et le tableau `date` des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : ```python >>> mini(t_moy, annees) (12.5, 2016) ``` Exercice 18.2 \u25a1 \u2693\ufe0e Exercice 18.2 \u00c9nonc\u00e9 Correction Sources Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : *bob* , *radar* , et *non* sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction `est_nbre_palindrome` s\u2019appuiera sur la fonction `est_palindrome` qui elle-m\u00eame s\u2019appuiera sur la fonction `inverse_chaine` . La fonction `inverse_chaine` inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res `chaine` et renvoie la cha\u00eene invers\u00e9e. La fonction `est_palindrome` teste si une chaine de caract\u00e8res `chaine` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction `est_nbre_palindrome` teste si un nombre `nbre` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. ```python def inverse_chaine(chaine): result = ... for caractere in chaine: result = ... return result def est_palindrome(chaine): inverse = inverse_chaine(chaine) return ... def est_nbre_palindrome(nbre): chaine = ... return est_palindrome(chaine) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True ``` \u25b6 Sujet 19 \u2693\ufe0e Version originale du sujet en pdf. Exercice 19.1 \u25a1 \u2693\ufe0e Exercice 19.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : ```python >>> multiplication(3,5) 15 >>> multiplication(-4,-8) 32 >>> multiplication(-2,6) -12 >>> multiplication(-2,0) 0 ``` Exercice 19.2 \u25a1 \u2693\ufe0e Exercice 19.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m Markdown Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher` , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T` , et `None` sinon. Les param\u00e8tres de la fonction sont : - `T` , le tableau dans lequel s'effectue la recherche ; - `n` , l'entier \u00e0 chercher dans le tableau ; - `i` , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j` , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)` . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None` . Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 ``` \u25b6 Sujet 20 \u2693\ufe0e Version originale du sujet en pdf. Exercice 20.1 \u25a1 \u2693\ufe0e Exercice 20.1 \u00c9nonc\u00e9 Correction Source Markdown L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : \ud83d\udc0d Script Python a = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ] b = [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] c = [ 1 , 1 , 0 , 1 ] d = [ 0 , 0 , 1 , 1 ] \u00c9crire la fonction xor qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : \ud83d\udc0d Script Python assert ( xor ( a , b ) == [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ]) assert ( xor ( c , d ) == [ 1 , 1 , 1 , 0 ]) Correction propos\u00e9e par Yves Laurent \ud83d\udc0d Script Python def xor ( tab1 , tab2 ): \"\"\" Parameters ---------- tab1 : type(tab1) = list Binaire 1 tab2 : type(tab1) = list Binaire 2 Returns ------- resultat : list tab1 xor tab2. \"\"\" assert len ( tab1 ) == len ( tab2 ), \"pas la m\u00eame taille\" resultat = [] taille = len ( tab1 ) for compteur in range ( taille ): resultat . append ( tab1 [ compteur ] ^ tab2 [ compteur ]) return resultat \ud83d\udccb Texte L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : ```python a = [1, 0, 1, 0, 1, 1, 0, 1] b = [0, 1, 1, 1, 0, 1, 0, 0] c = [1, 1, 0, 1] d = [0, 0, 1, 1] ``` \u00c9crire la fonction ```xor``` qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position `i` est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position `i` des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : ```python assert(xor(a, b) == [1, 1, 0, 1, 1, 0, 0, 1]) assert(xor(c, d) == [1, 1, 1, 0]) ``` Exercice 20.2 \u25a1 \u2693\ufe0e Exercice 20.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. c4 n\u2019est pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter la fonction est_magique qui prend en param\u00e8tre un carr\u00e9 et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, False sinon. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( self . valeurs [ i ]) def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ i ][ j ] for i in range ( self . ordre )]) def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... , ... ): if carre . somme_ligne ( i ) != s : return ... #test de la somme de chaque colonne for j in range ( n ): if ... != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ ... ][ ... ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return ... Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( self . valeurs [ i ]) def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ i ][ j ] for i in range ( self . ordre )]) def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( 1 , n ): if carre . somme_ligne ( i ) != s : return False #test de la somme de chaque colonne for j in range ( n ): if carre . somme_col ( j ) != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ k ][ k ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return s c1 = Carre ([[ 1 , 1 ], [ 1 , 1 ]]) c2 = Carre ([[ 2 , 9 , 4 ], [ 7 , 5 , 3 ], [ 6 , 1 , 8 ]]) c3 = Carre ([[ 4 , 5 , 16 , 9 ], [ 14 , 7 , 2 , 11 ], [ 3 , 10 , 15 , 6 ], [ 13 , 12 , 8 , 1 ]]) assert est_magique ( c1 ) == 2 assert est_magique ( c2 ) == 15 assert est_magique ( c3 ) == False Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre $n$ un tableau de $n$ lignes et $n$ colonnes dont chaque case contient un entier naturel. Exemples : ![ image ]( data/img20_2.png ){: .center width=70%} Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. c4 n\u2019est pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe `Carre` ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter la fonction `est_magique` qui prend en param\u00e8tre un carr\u00e9 et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, `False` sinon. ```python linenums='1' class Carre: def __init__ (self, tableau = [[]]): self.ordre = len(tableau) self.valeurs = tableau def affiche(self): '''Affiche un carr\u00e9''' for i in range(self.ordre): print(self.valeurs[i]) def somme_ligne(self, i): '''Calcule la somme des valeurs de la ligne i''' return sum(self.valeurs[i]) def somme_col(self, j): '''Calcule la somme des valeurs de la colonne j''' return sum([self.valeurs[i][j] for i in range(self.ordre)]) def est_magique(carre): n = carre.ordre s = carre.somme_ligne(0) #test de la somme de chaque ligne for i in range(..., ...): if carre.somme_ligne(i) != s: return ... #test de la somme de chaque colonne for j in range(n): if ... != s: return False #test de la somme de chaque diagonale if sum([carre.valeurs[...][...] for k in range(n)]) != s: return False if sum([carre.valeurs[k][n-1-k] for k in range(n)]) != s: return False return ... Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4. ``` \u25b6 Sujet 21 \u2693\ufe0e Version originale du sujet en pdf. Exercice 21.1 \u25a1 \u2693\ufe0e Exercice 21.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\times (-6)= - (5 \\times 6)\\) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exercice 21.2 \u25a1 \u2693\ufe0e Exercice 21.2 \u00c9nonc\u00e9 Correction Sources Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False ``` \u25b6 Sujet 22 \u2693\ufe0e Version originale du sujet en pdf. Exercice 22.1 \u25a1 \u2693\ufe0e Exercice 22.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer une fonction renverse , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide mot et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene mot . Exemple : \ud83d\udc0d Script Python >>> renverse ( \"informatique\" ) \"euqitamrofni\" \ud83d\udc0d Script Python 1 2 3 4 5 def renverse ( mot ): sol = '' for lettre in mot : sol = lettre + sol return sol \ud83d\udccb Texte Programmer une fonction `renverse`, prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide `mot` et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene `mot`. Exemple : ```python >>> renverse(\"informatique\") \"euqitamrofni\" ``` Exercice 22.2 \u25a1 \u2693\ufe0e Exercice 22.2 \u00c9nonc\u00e9 Correction Sources Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre N fix\u00e9. On consid\u00e8re pour cela un tableau tab de N bool\u00e9ens, initialement tous \u00e9gaux \u00e0 True , sauf tab[0] et tab[1] qui valent False , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice i : si tab[i] vaut True : le nombre i est premier et on donne la valeur False \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de i , \u00e0 partir de 2*i (c\u2019est-\u00e0-dire 2*i , 3*i ...). si tab[i] vaut False : le nombre i n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction crible , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier N strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que N. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( N ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * N tab [ 0 ], tab [ 1 ] = False , False for i in range ( ... , N ): if tab [ i ] == ... : premiers . append ( ... ) for multiple in range ( 2 * i , N , ... ): tab [ multiple ] = ... return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Compl\u00e9ter le code de cette fonction. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( N ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * N tab [ 0 ], tab [ 1 ] = False , False for i in range ( 2 , N ): if tab [ i ] == True : premiers . append ( i ) for multiple in range ( 2 * i , N , i ): tab [ multiple ] = False return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre N fix\u00e9. On consid\u00e8re pour cela un tableau `tab` de N bool\u00e9ens, initialement tous \u00e9gaux \u00e0 `True` , sauf `tab[0]` et `tab[1]` qui valent `False` , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice `i` : - si `tab[i]` vaut `True` : le nombre `i` est premier et on donne la valeur `False` \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de `i` , \u00e0 partir de `2*i` (c\u2019est-\u00e0-dire `2*i` , `3*i` ...). - si `tab[i]` vaut `False` : le nombre `i` n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction `crible` , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier N strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que N. ```python linenums='1' def crible(N): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [True] * N tab[0], tab[1] = False, False for i in range(..., N): if tab[i] == ...: premiers.append(...) for multiple in range(2*i, N, ...): tab[multiple] = ... return premiers assert crible(40) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] Compl\u00e9ter le code de cette fonction. ``` \u25b6 Sujet 23 \u2693\ufe0e Version originale du sujet en pdf. Exercice 23.1 \u25a1 \u2693\ufe0e Exercice 23.1 \u00c9nonc\u00e9 Correction Source Markdown Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : \ud83d\udc0d Script Python >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def max_dico ( dico ): cle_max = '' val_max = 0 for cle in dico : if dico [ cle ] > val_max : val_max = dico [ cle ] cle_max = cle return ( cle_max , val_max ) \ud83d\udccb Texte Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : `{'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}` \u00c9crire une fonction `max_dico` qui : - Prend en param\u00e8tre un dictionnaire `dico` non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; - Renvoie un tuple dont : - La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; - La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : ```python >>> max_dico({'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}) ('Ada', 201) >>> max_dico({'Alan': 222, 'Ada': 201, 'Eve': 220, 'Tim': 50}) ('Alan', 222) ``` Exercice 23.2 \u25a1 \u2693\ufe0e Exercice 23.2 \u00c9nonc\u00e9 Correction Sources Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for element in tab : print ( element ) if element != '+' and element != '*' : p . empiler ( element ) else : if element == '+' : resultat = p . depiler () + p . depiler () else : resultat = p . depiler () * p . depiler () p . empiler ( resultat ) return p . depiler () Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : - Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; - Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. - \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe `Pile` qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction `eval_expression` qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : ```python >>> eval_expression([2, 3, '+', 5, '*']) 25 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... ``` \u25b6 Sujet 24 \u2693\ufe0e Version originale du sujet en pdf. Exercice 24.1 \u25a1 \u2693\ufe0e Exercice 24.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire la fonction maxliste , prenant en param\u00e8tre un tableau non vide de nombres tab (type list ) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : \ud83d\udc0d Script Python >>> maxliste ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maxliste ([ - 27 , 24 , - 3 , 15 ]) 24 \ud83d\udc0d Script Python 1 2 3 4 5 6 def maxliste ( tab ): maximum = tab [ 0 ] for element in tab : if element > maximum : maximum = element return maximum \ud83d\udccb Texte \u00c9crire la fonction `maxliste`, prenant en param\u00e8tre un tableau non vide de nombres `tab` (type `list`) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : ```python >>> maxliste([98, 12, 104, 23, 131, 9]) 131 >>> maxliste([-27, 24, -3, 15]) 24 ``` Exercice 24.2 \u25a1 \u2693\ufe0e Exercice 24.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, ((()())(())) est un parenth\u00e9sage correct. Les parenth\u00e9sages ())(() et (())(() sont, eux, incorrects. On dispose du code de la classe Pile suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self , valeurs = []): self . valeurs = valeurs def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene ch de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible !) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Compl\u00e9ter le code de la fonction parenthesage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self , valeurs = []): self . valeurs = valeurs def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == '(' : p . empiler ( c ) elif c == ')' : if p . est_vide (): return False else : p . depiler () return p . est_vide () print ( parenthesage ( \"((()())(()))\" )) assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : - le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. - en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, `((()())(()))` est un parenth\u00e9sage correct. Les parenth\u00e9sages `())(()` et `(())(()` sont, eux, incorrects. On dispose du code de la classe `Pile` suivant : ```python linenums='1' class Pile: \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ (self, valeurs=[]): self.valeurs = valeurs def est_vide(self): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self.valeurs == [] def empiler(self, c): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self.valeurs.append(c) def depiler(self): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self.est_vide() == False: self.valeurs.pop() On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene ch de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible !) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Compl\u00e9ter le code de la fonction parenthesage . ``` \u25b6 Sujet 25 \u2693\ufe0e Version originale du sujet en pdf. Exercice 25.1 \u25a1 \u2693\ufe0e Exercice 25.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont 'nom' , 'espece' , 'age' , 'enclos' . Voici un exemple d'une telle table : \ud83d\udc0d Script Python animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] Programmer une fonction selection_enclos qui : prend en param\u00e8tres : une table table_animaux contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), un num\u00e9ro d'enclos num_enclos ; renvoie une table contenant les enregistrements de table_animaux dont l'attribut 'enclos' est num_enclos . Exemples avec la table animaux ci-dessus : \ud83d\udc0d Script Python >>> selection_enclos ( animaux , 5 ) [{ 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] >>> selection_enclos ( animaux , 2 ) [{ 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }] >>> selection_enclos ( animaux , 7 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def selection_enclos ( table_animaux , num_enclos ): table = [] for animal in table_animaux : if animal [ 'enclos' ] == num_enclos : table . append ( animal ) return table \ud83d\udccb Texte On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont `'nom'`, `'espece'`, `'age'`, `'enclos'`. Voici un exemple d'une telle table : ```python animaux = [ {'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}, {'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Tom', 'espece':'chat', 'age':7, 'enclos':4}, {'nom':'Belle', 'espece':'chien', 'age':6, 'enclos':3}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] ``` Programmer une fonction `selection_enclos` qui : - prend en param\u00e8tres : - une table `table_animaux` contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), - un num\u00e9ro d'enclos `num_enclos` ; - renvoie une table contenant les enregistrements de `table_animaux` dont l'attribut `'enclos'` est `num_enclos`. Exemples avec la table animaux ci-dessus : ```python >>> selection_enclos(animaux, 5) [{'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] >>> selection_enclos(animaux, 2) [{'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}] >>> selection_enclos(animaux, 7) [] ``` Exercice 25.2 \u25a1 \u2693\ufe0e Exercice 25.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois et \u00e0 suivre, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : \ud83d\udc0d Script Python tab_a = [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] #l'intrus est 7 tab_b = [ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ] #l'intrus est 8 tab_c = [ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Compl\u00e9ter la fonction ci-dessous qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return tab [ g ] else : nombre_de_triplets = ( d - g ) // 3 indice = g + 3 * ( nombre_de_triplets // 2 ) if tab [ indice ] != tab [ indice + 1 ] : return trouver_intrus ( tab , g , indice ) else : return trouver_intrus ( tab , indice + 3 , d ) Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois et \u00e0 suivre, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : ```python tab_a = [3, 3, 3, 9, 9, 9, 1, 1, 1, 7, 2, 2, 2, 4, 4, 4, 8, 8, 8, 5, 5, 5] #l'intrus est 7 tab_b = [8, 5, 5, 5, 9, 9, 9, 18, 18, 18, 3, 3, 3] #l'intrus est 8 tab_c = [5, 5, 5, 1, 1, 1, 0, 0, 0, 6, 6, 6, 3, 8, 8, 8] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Compl\u00e9ter la fonction ci-dessous qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 ``` \u25b6 Sujet 26 \u2693\ufe0e Version originale du sujet en pdf. Exercice 26.1 \u25a1 \u2693\ufe0e Exercice 26.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction RechercheMin qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> RechercheMin ([ 5 ]) 0 >>> RechercheMin ([ 2 , 4 , 1 ]) 2 >>> RechercheMin ([ 5 , 3 , 2 , 2 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 def RechercheMin ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \ud83d\udccb Texte \u00c9crire une fonction `RechercheMin` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 `tab`, et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> RechercheMin([5]) 0 >>> RechercheMin([2, 4, 1]) 2 >>> RechercheMin([5, 3, 2, 2, 4]) 2 ``` Exercice 26.2 \u25a1 \u2693\ufe0e Exercice 26.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab Markdown On consid\u00e8re la fonction `separe` ci-dessous qui prend en argument un tableau `tab` dont les \u00e9l\u00e9ments sont des `0` et des `1` et qui s\u00e9pare les `0` des `1` en pla\u00e7ant les `0` en d\u00e9but de tableau et les `1` \u00e0 la suite. ```python linenums='1' def separe(tab): i = 0 j = ... while i < j : if tab[i] == 0 : i = ... else : tab[i], tab[j] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ``` \u25b6 Sujet 27 \u2693\ufe0e Version originale du sujet en pdf. Exercice 27.1 \u25a1 \u2693\ufe0e Exercice 27.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : \ud83d\udc0d Script Python >>> taille ( a , \u2019 F \u2019 ) 9 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 \ud83d\udccb Texte Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre ![image](data/img28_1.png){: .center width=40%} est stock\u00e9 dans ```python a = {'F':['B','G'], 'B':['A','D'], 'A':['',''], 'D':['C','E'], \\ 'C':['',''], 'E':['',''], 'G':['','I'], 'I':['','H'], \\ 'H':['','']} ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tres un arbre binaire `arbre` sous la forme d\u2019un dictionnaire et un caract\u00e8re `lettre` qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont `''`, le fils gauche seulement est `''`, le fils droit seulement est `''`, aucun des deux fils n\u2019est `''`. Exemple : ```python >>> taille(a, \u2019F\u2019) 9 ``` Exercice 27.2 \u25a1 \u2693\ufe0e Exercice 27.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ imax ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : \ud83d\udc0d Script Python >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : ```t = [41, 55, 21, 18, 12, 6, 25]``` - \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient `t = [41, 25, 21, 18, 12, 6, 55]` - \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments **sauf le dernier** , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : ```t = [6, 25, 21, 18, 12, 41, 55]``` Et ainsi de suite. La code de la fonction `tri_iteratif` qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. ```python linenums='1' def tri_iteratif(tab): for k in range(..., 0 ,-1): imax = ... for i in range(0, ...): if tab[i] > ... : imax = i if tab[imax] > ... : ..., tab[imax] = tab[imax], ... return tab Compl\u00e9ter le code qui doit donner : \ud83d\udc0d Script Python >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . ``` \u25b6 Sujet 28 \u2693\ufe0e Version originale du sujet en pdf. Exercice 28.1 \u25a1 \u2693\ufe0e Exercice 28.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> moyenne([1.0]) 1.0 >>> moyenne([1.0, 2.0, 4.0]) 2.3333333333333335 ``` Exercice 28.2 \u25a1 \u2693\ufe0e Exercice 28.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : \ud83d\udc0d Script Python >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown On consid\u00e8re la fonction `dec_to_bin` ci-dessous qui prend en param\u00e8tre un entier positif `a` en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. ```python linenums='1' def dec_to_bin(a): bin_a = ... a = a//2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : \ud83d\udc0d Script Python >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' ``` \u25b6 Sujet 29 \u2693\ufe0e Version originale du sujet en pdf. Exercice 29.1 \u25a1 \u2693\ufe0e Exercice 29.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] \ud83d\udccb Texte On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par `U1 = 1`, `U2 = 1` et, pour tout entier naturel `n`, par `Un+2 = Un+1 + Un`. Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction `fibonacci` qui prend un entier `n > 0` et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice `n` de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : ```python >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(25) 75025 >>> fibonacci(45) 1134903170 ``` Exercice 29.2 \u25a1 \u2693\ufe0e Exercice 29.2 \u00c9nonc\u00e9 Correction Sources Markdown Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Markdown Les variables `liste_eleves` et `liste_notes` ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction `meilleures_notes` renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction `meilleures_notes` ci-dessous. ```python linenums='1' liste_eleves = ['a','b','c','d','e','f','g','h','i','j'] liste_notes = [1, 40, 80, 60, 58, 80, 75, 80, 60, 24] def meilleures_notes(): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range(...): if liste_notes[compteur] == ...: nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi.append(liste_eleves[...]) if liste_notes[compteur] > note_maxi: note_maxi = liste_notes[compteur] nb_eleves_note_maxi = ... liste_maxi = [...] return (note_maxi,nb_eleves_note_maxi,liste_maxi) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) ``` \u25b6 Sujet 30 \u2693\ufe0e Version originale du sujet en pdf. Exercice 30.1 \u25a1 \u2693\ufe0e Exercice 30.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction fusion prenant en param\u00e8tres deux tableaux non vides tab1 et tab2 (type list ) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de tab1 et tab2 . Exemples : \ud83d\udc0d Script Python >>> fusion ([ 3 , 5 ], [ 2 , 5 ]) [ 2 , 3 , 5 , 5 ] >>> fusion ([ - 2 , 4 ], [ - 3 , 5 , 10 ]) [ - 3 , - 2 , 4 , 5 , 10 ] >>> fusion ([ 4 ], [ 2 , 6 ]) [ 2 , 4 , 6 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fusion ( tab1 , tab2 ): tab_fusion = [] i1 = 0 i2 = 0 while i1 < len ( tab1 ) and i2 < len ( tab2 ): if tab1 [ i1 ] < tab2 [ i2 ]: tab_fusion . append ( tab1 [ i1 ]) i1 += 1 else : tab_fusion . append ( tab2 [ i2 ]) i2 += 1 if i1 == len ( tab1 ): while i2 < len ( tab2 ): tab_fusion . append ( tab2 [ i2 ]) i2 += 1 else : while i1 < len ( tab1 ): tab_fusion . append ( tab1 [ i1 ]) i1 += 1 return tab_fusion \ud83d\udccb Texte Programmer la fonction `fusion` prenant en param\u00e8tres deux tableaux non vides `tab1` et `tab2` (type `list`) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de `tab1` et `tab2`. Exemples : ```python >>> fusion([3, 5], [2, 5]) [2, 3, 5, 5] >>> fusion([-2, 4], [-3, 5, 10]) [-3, -2, 4, 5, 10] >>> fusion([4], [2, 6]) [2, 4, 6] ``` Exercice 30.2 \u25a1 \u2693\ufe0e Exercice 30.2 \u00c9nonc\u00e9 Correction Sources Markdown Les chiffres romains sont un syst\u00e8me ancien d\u2019\u00e9criture des nombres. Les chiffres romains sont: I, V, X, L, C, D, et M. Ces symboles repr\u00e9sentent respectivement 1, 5, 10, 50, 100, 500, et 1000 en base dix. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur sup\u00e9rieure ou \u00e9gale \u00e0 celui de droite, le nombre s\u2019obtient en additionnant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"XVI\" est le nombre 16 car X + VI = 10 + 6. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur strictement inf\u00e9rieure \u00e0 celui de droite, le nombre s\u2019obtient en retranchant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"CDIII\" est le nombre 403 car DIII \u2013 C = 503 \u2013 100. On dispose d\u2019un dictionnaire dico , \u00e0 compl\u00e9ter, o\u00f9 les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et o\u00f9 les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale. On souhaite cr\u00e9er une fonction r\u00e9cursive rom_to_dec qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res (non vide) repr\u00e9sentant un nombre \u00e9crit en chiffres romains et renvoyant le nombre associ\u00e9 en \u00e9criture d\u00e9cimale : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def rom_to_dec ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = { \"I\" : 1 , \"V\" : 5 , ... } if len ( nombre ) == 1 : return ... else : ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre [ 1 :] if dico [ nombre [ 0 ]] >= dico [ nombre [ 1 ]]: return dico [ nombre [ 0 ]] + ... else : return ... assert rom_to_dec ( \"CXLII\" ) == 142 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def rom_to_dec ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } if len ( nombre ) == 1 : return dico [ nombre ] else : ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre [ 1 :] # (1) if dico [ nombre [ 0 ]] >= dico [ nombre [ 1 ]]: return dico [ nombre [ 0 ]] + rom_to_dec ( nombre_droite ) else : return rom_to_dec ( nombre_droite ) - dico [ nombre [ 0 ]] assert rom_to_dec ( \"CXLII\" ) == 142 Le slicing utilis\u00e9 ici n'est officiellement pas au programme en NSI... Markdown Les chiffres romains sont un syst\u00e8me ancien d\u2019\u00e9criture des nombres. Les chiffres romains sont: I, V, X, L, C, D, et M. Ces symboles repr\u00e9sentent respectivement 1, 5, 10, 50, 100, 500, et 1000 en base dix. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur sup\u00e9rieure ou \u00e9gale \u00e0 celui de droite, le nombre s\u2019obtient en additionnant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"XVI\" est le nombre 16 car X + VI = 10 + 6. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur strictement inf\u00e9rieure \u00e0 celui de droite, le nombre s\u2019obtient en retranchant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"CDIII\" est le nombre 403 car DIII \u2013 C = 503 \u2013 100. On dispose d\u2019un dictionnaire `dico` , \u00e0 compl\u00e9ter, o\u00f9 les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et o\u00f9 les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale. On souhaite cr\u00e9er une fonction r\u00e9cursive `rom_to_dec` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res (non vide) repr\u00e9sentant un nombre \u00e9crit en chiffres romains et renvoyant le nombre associ\u00e9 en \u00e9criture d\u00e9cimale : ```python linenums='1' def rom_to_dec(nombre): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = {\"I\":1, \"V\":5, ...} if len(nombre) == 1: return ... else: ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre[1:] if dico[nombre[0]] >= dico[nombre[1]]: return dico[nombre[0]] + ... else: return ... assert rom_to_dec(\"CXLII\") == 142 ``` \u25b6 Sujet 31 \u2693\ufe0e Version originale du sujet en pdf. Exercice 31.1 \u25a1 \u2693\ufe0e Exercice 31.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : \ud83d\udc0d Script Python >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb \ud83d\udccb Texte \u00c9crire en langage Python une fonction `recherche` prenant comme param\u00e8tres une variable `a` de type num\u00e9rique (`float` ou `int`) et un tableau `t` (type `list`) et qui renvoie le nombre d'occurrences de `a` dans `t`. Exemples : ```python >>> recherche(5,[]) 0 >>> recherche(5,[-2, 3, 4, 8]) 0 >>> recherche(5,[-2, 3, 1, 5, 3, 7, 4]) 1 >>> recherche(5,[-2, 5, 3, 5, 4, 5]) 3 ``` Exercice 31.2 \u25a1 \u2693\ufe0e Exercice 31.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : \ud83d\udc0d Script Python >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu Markdown La fonction `rendu_monnaie_centimes` prend en param\u00e8tres deux nombres entiers positifs `s_due` et` s_versee` et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence `s_versee \u2013 s_due` pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc `[1, 2, 5, 10, 20, 50, 100, 200]` . Ainsi, l\u2019instruction `rendu_monnaie_centimes(452, 500)` renverra `[20, 20, 5, 2, 1]` . En effet, la somme \u00e0 rendre est de `48` centimes soit `20 + 20 + 5 + 2 + 1` . Le code de la fonction est donn\u00e9 ci-dessous : ```python linenums='1' def rendu_monnaie_centimes(s_due, s_versee): pieces = [1, 2, 5, 10, 20, 50, 100, 200] rendu = ... a_rendre = ... i = len(pieces) - 1 while a_rendre > ... : if pieces[i] <= a_rendre : rendu.append(...) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : \ud83d\udc0d Script Python >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] ``` \u25b6 Sujet 32 \u2693\ufe0e Version originale du sujet en pdf. Exercice 32.1 \u25a1 \u2693\ufe0e Exercice 32.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ``` Exercice 32.2 \u25a1 \u2693\ufe0e Exercice 32.2 \u00c9nonc\u00e9 Correction Sources Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de `192.168.0.0` \u00e0 `192.168.0.255` . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP `192.168.0.0` et `192.168.0.255` sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe `AdresseIP` . ```python linenums='1' class AdresseIP: def __init__ (self, adresse): self.adresse = ... def liste_octet(self): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante(self): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254: octet_nouveau = ... + ... return AdresseIP('192.168.0.' + ...) else: return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' ``` \u25b6 Sujet 33 \u2693\ufe0e Version originale du sujet en pdf. Exercice 33.1 \u25a1 \u2693\ufe0e Exercice 33.1 \u00c9nonc\u00e9 Correction Source Markdown On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : \ud83d\udc0d Script Python def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : \ud83d\udc0d Script Python >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total \ud83d\udccb Texte On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau `[1, 0, 1, 0, 0, 1, 1]` repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est `2**6 + 2**4 + 2**1 + 2**0 = 83`. \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : ```python def convertir(T): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" ``` Exemple : ```python >>> convertir([1, 0, 1, 0, 0, 1, 1]) 83 >>> convertir([1, 0, 0, 0, 0, 0, 1, 0]) 130 ``` Exercice 33.2 \u25a1 \u2693\ufe0e Exercice 33.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : \ud83d\udc0d Script Python >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L Markdown La fonction `tri_insertion` suivante prend en argument une liste `L` et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. ```python linenums='1' def tri_insertion(L): n = len(L) # cas du tableau vide if ...: return L for j in range(1,n): e = L[j] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L[i-1] > ...: i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j: for k in range(j,i,...): L[k] = L[...] L[i] = ... return L Exemples : \ud83d\udc0d Script Python >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ``` \u25b6 Sujet 34 \u2693\ufe0e Version originale du sujet en pdf. Exercice 34.1 \u25a1 \u2693\ufe0e Exercice 34.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : \ud83d\udc0d Script Python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ] \ud83d\udccb Texte \u00c9crire une fonction `occurrence_max` prenant en param\u00e8tres une cha\u00eene de caract\u00e8res `chaine` et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau `alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']` et du tableau `occurrence` de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans `occurrence[i]` le nombre d\u2019apparitions de `alphabet[i]` dans la chaine. Puis on calculera l\u2019indice `k` d\u2019un maximum du tableau `occurrence` et on affichera `alphabet[k]`. Exemple : ```python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max(ch) \u2018e\u2019 ``` Exercice 34.2 \u25a1 \u2693\ufe0e Exercice 34.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : ```python linenums='1' def nbLig(image): '''renvoie le nombre de lignes de l'image''' return ... def nbCol(image): '''renvoie la largeur de l'image''' return ... def negatif(image): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range(len(image)): for j in range(...): L[i][j] = ... return L def binaire(image, seuil): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range(len(image)): for j in range(...): if image[i][j] < ... : L[i][j] = ... else: L[i][j] = ... return L Exemple : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] ``` \u25b6 Sujet 35 \u2693\ufe0e Version originale du sujet en pdf. Exercice 35.1 \u25a1 \u2693\ufe0e Exercice 35.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. \ud83d\udc0d Script Python def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. ```python def moyenne (tab): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne([1]) == 1 assert moyenne([1, 2, 3, 4, 5, 6, 7] == 4 assert moyenne([1, 2]) == 1.5 ``` Exercice 35.2 \u25a1 \u2693\ufe0e Exercice 35.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False, 1 , False, 2 et False, 3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False , 3 Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient `False` en renvoyant `False, 1` , `False, 2` et `False, 3` . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ...: return False,1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if (x < tab[0]) or ...: return False, 2 debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) ``` \u25b6 Sujet 36 \u2693\ufe0e Version originale du sujet en pdf. Exercice 36.1 \u25a1 \u2693\ufe0e Exercice 36.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \ud83d\udccb Texte Programmer la fonction `recherche`, prenant en param\u00e8tre un tableau non vide `tab` (type `list`) d'entiers et un entier `n`, et qui renvoie l'indice de la **derni\u00e8re** occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples ```python >>> recherche([5, 3],1) 2 >>> recherche([2,4],2) 0 >>> recherche([2,3,5,2,4],2) 3 ``` Exercice 36.2 \u25a1 \u2693\ufe0e Exercice 36.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : \ud83d\udc0d Script Python from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" assert int ( point1 [ 0 ]) == point1 [ 0 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point1 [ 1 ]) == point1 [ 1 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point2 [ 0 ]) == point2 [ 0 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point2 [ 1 ]) == point2 [ 1 ], \"coordonn\u00e9e non enti\u00e8re\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es $(x;y)$ et $(x';y')$ est donn\u00e9e par la formule : $$d=\\sqrt{(x-x')^2+(y-y')^2}$$ On importe pour cela la fonction racine carr\u00e9e ( `sqrt` ) du module `math` de Python. On dispose d'une fonction `distance` et d'une fonction `plus_courte_distance` : ```python from math import sqrt # import de la fonction racine carr\u00e9e def distance(point1, point2): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt((...)**2 + (...)**2) assert distance((1, 0), (5, 3)) == 5.0, \"erreur de calcul\" def plus_courte_distance(tab, depart): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab[0] min_dist = ... for i in range (1, ...): if distance(tab[i], depart)...: point = ... min_dist = ... return point assert plus_courte_distance([(7, 9), (2, 5), (5, 2)], (0, 0)) == (2, 5), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. ``` \u25b6 Sujet 37 \u2693\ufe0e Version originale du sujet en pdf. Exercice 37.1 \u25a1 \u2693\ufe0e Exercice 37.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction verifie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie True si ce tableau est tri\u00e9 dans l\u2019ordre croissant, False sinon. Exemples : \ud83d\udc0d Script Python Exemples : >>> verifie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> verifie ([ 8 , 12 , 4 ]) False >>> verifie ([ - 1 , 4 ]) True >>> verifie ([ 5 ]) True \ud83d\udc0d Script Python 1 2 3 4 5 def verifie ( tab ): for i in range ( 1 , len ( tab )): if tab [ i ] < tab [ i - 1 ]: return False return True \ud83d\udccb Texte Programmer la fonction `verifie` qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie `True` si ce tableau est tri\u00e9 dans l\u2019ordre croissant, `False` sinon. Exemples : ```python Exemples : >>> verifie([0, 5, 8, 8, 9]) True >>> verifie([8, 12, 4]) False >>> verifie([-1, 4]) True >>> verifie([5]) True ``` Exercice 37.2 \u25a1 \u2693\ufe0e Exercice 37.2 \u00c9nonc\u00e9 Correction Sources Markdown Chaque soir, les auditeurs d\u2019une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple : \ud83d\udc0d Script Python urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } # (1) >>> vainqueur ( election ) [ 'B' ] Attention, ceci est le bon r\u00e9sultat, le pdf officiel est erron\u00e9. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = {} for bulletin in urne : if bulletin in resultat : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : resultat [ bulletin ] = 1 return resultat def vainqueur ( election ): vainqueur = '' #(1) nmax = 0 for candidat in election : if election [ candidat ] > nmax : nmax = election [ candidat ] vainqueur = candidat #(2) liste_finale = [ nom for nom in election if election [ nom ] == nmax ] return liste_finale Il est pourtant tr\u00e8s d\u00e9conseill\u00e9 de nommer une variable avec le m\u00eame nom que la fonction qui la contient... Cette variable vainqueur est inutile, on ne s'en sert pas dans l'\u00e9laboration de la liste finale. Markdown Chaque soir, les auditeurs d\u2019une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple : ```python urne = ['A', 'A', 'A', 'B', 'C', 'B', 'C', 'B', 'C', 'B'] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } # (1) >>> vainqueur ( election ) [ 'B' ] Attention, ceci est le bon r\u00e9sultat, le pdf officiel est erron\u00e9. ``` \u25b6 Sujet 38 \u2693\ufe0e Version originale du sujet en pdf. Exercice 38.1 \u25a1 \u2693\ufe0e Exercice 38.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : \ud83d\udc0d Script Python >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \ud83d\udccb Texte \u00c9crire une fonction `tri_selection` qui prend en param\u00e8tre une liste `tab` de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : - on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; - on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; - on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : ```python >>> tri_selection([1,52,6,-9,12]) [-9, 1, 6, 12, 52] ``` Exercice 38.2 \u25a1 \u2693\ufe0e Exercice 38.2 \u00c9nonc\u00e9 Correction Sources Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 99 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 1 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : - le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; - si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; - si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction `randint` est utilis\u00e9e. Si a et b sont des entiers, `randint(a,b)` renvoie un nombre entier compris entre `a` et `b` . Compl\u00e9ter le code ci-dessous et le tester : ```python linenums='1' from random import randint def plus_ou_moins(): nb_mystere = randint(1,...) nb_test = int(input(\"Proposez un nombre entre 1 et 99 : \")) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test: nb_test = int(input(\"Trop petit ! Testez encore : \")) else: nb_test = int(input(\"Trop grand ! Testez encore : \")) if nb_mystere == nb_test: print (\"Bravo ! Le nombre \u00e9tait \",...) print(\"Nombre d'essais: \",...) else: print (\"Perdu ! Le nombre \u00e9tait \",...) ``` \u25b6 Sujet 39 \u2693\ufe0e Version originale du sujet en pdf. Exercice 39.1 \u25a1 \u2693\ufe0e Exercice 39.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : \ud83d\udc0d Script Python >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : ```python >>> moyenne([10,20,30,40,60,110]) 45.0 ``` Exercice 39.2 \u25a1 \u2693\ufe0e Exercice 39.2 \u00c9nonc\u00e9 Correction Sources Markdown On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom Markdown ![ image ]( data/272a.png ){: .center width=30%} On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction `affiche` permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction `zoomListe` prend en argument une liste `liste_depart` et un entier `k` . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de `liste_depart` est dupliqu\u00e9 `k` fois. La fonction `zoomDessin` prend en argument la grille `dessin` et renvoie une grille o\u00f9 toutes les lignes de `dessin` sont zoom\u00e9es `k` fois et r\u00e9p\u00e9t\u00e9es `k` fois. Soit le code ci-dessous : ```python linenums='1' coeur = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], \\ [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], \\ [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], \\ [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], \\ [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] def affiche(dessin): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin: for col in ligne: if col == 1: print(\" *\", end=\"\") else: print(\" \", end=\"\") print() def zoomListe(liste_depart,k): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range(k): ... return liste_zoom def zoomDessin(grille,k): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom=[] for elt in grille: liste_zoom = ... for i in range(k): ... .append(...) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ``` \u25b6 Sujet 40 \u2693\ufe0e Version originale du sujet en pdf. Exercice 40.1 \u25a1 \u2693\ufe0e Exercice 40.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre et `tab` un tableau de nombres, et qui renvoie le tableau des indices de `elt` dans `tab` si `elt` est dans `tab` et le tableau vide `[]` sinon. Exemples : ```python >>> recherche(3, [3, 2, 1, 3, 2, 1]) [0, 3] >>> recherche(4, [1, 2, 3]) [] ``` Exercice 40.2 \u25a1 \u2693\ufe0e Exercice 40.2 \u00c9nonc\u00e9 Correction Sources Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : - les clefs sont les noms des \u00e9l\u00e8ves ; - les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : ```python resultats = {'Dupont':{ 'DS1' : [15.5, 4], 'DM1' : [14.5, 1], 'DS2' : [13, 4], 'PROJET1' : [16, 3], 'DS3' : [14, 4]}, 'Durand':{ 'DS1' : [6 , 4], 'DM1' : [14.5, 1], 'DS2' : [8, 4], 'PROJET1' : [9, 3], 'IE1' : [7, 2], 'DS3' : [8, 4], 'DS4' :[15, 4]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 ``` Remerciements pour le signalement et la correction des nombreuses erreurs : Alexandre Hainaut, No\u00e9 Pierre, Cyrille Jochault, S\u00e9bastien Rivillon, Cl\u00e9mentine et Laorine (AEFE Montr\u00e9al), Th\u00e9o EwzZer, Laurent Briend, Matteo Gaillard, Pierre Mouries.", "title": "(!!! old !!!) BNS 2022"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#epreuve-pratique-bns-2022", "text": "\u00c0 lire Les sujets ci-dessous correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 24/02/2022 . Certains sujets (ceux de l'ann\u00e9e derni\u00e8re reconduits cette ann\u00e9e) ont parfois \u00e9t\u00e9 l\u00e9g\u00e8rement modifi\u00e9s par rapport \u00e0 la version 2021. La correspondance des num\u00e9rotations entre la BNS 2021 et la BNS 2022 peut se retrouver ici Certains de ces sujets comportent des erreurs. Elles ont \u00e9t\u00e9 corrig\u00e9es ou non. Dans le doute, comparer avec la version originale du sujet. Les versions originales de ces sujets sont disponibles en pdf au d\u00e9but de chaque sujet. (pour t\u00e9l\u00e9charger les 40 sujets en un seul fichier, c'est ici ) Pourquoi proposer une correction ? La BNS est une banque de sujets publique , publi\u00e9e bien en amont de l'\u00c9preuve Pratique, afin que les futurs candidats puissent s'entra\u00eener \u00e0 la r\u00e9solution des exercices. Pour permettre aux \u00e9l\u00e8ves de travailler en autonomie, une proposition de corrig\u00e9 (r\u00e9alis\u00e9e par Gilles Lassus) figure en regard de l'\u00e9nonc\u00e9.", "title": "\u00c9preuve Pratique BNS 2022"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-01", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 01"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-011", "text": "Exercice 01.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres caractere , un caract\u00e8re, et mot , une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de caractere dans mot , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans mot . Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( caractere , mot ): somme = 0 for lettre in mot : if lettre == caractere : somme += 1 return somme \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `caractere`, un caract\u00e8re, et `mot`, une cha\u00eene de caract\u00e8res, et qui renvoie le nombre d\u2019occurrences de `caractere` dans `mot`, c\u2019est-\u00e0-dire le nombre de fois o\u00f9 `caractere` appara\u00eet dans `mot`. Exemples : ```python >>> recherche('e', \"sciences\") 2 >>> recherche('i',\"mississippi\") 4 >>> recherche('a',\"mississippi\") 0 ```", "title": "Exercice 01.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-012", "text": "Exercice 01.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste pieces=[100, 50, 20, 10, 5, 2, 1] . (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre). On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] # (1) def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return ... p = pieces [ i ] if p <= ... : solution . append ( ... ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , ... ) Erreur dans l'\u00e9nonc\u00e9 officiel : Pieces On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 68 , [], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 , [], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( arendre , solution = [], i = 0 ): if arendre == 0 : return solution p = pieces [ i ] if p <= arendre : solution . append ( p ) return rendu_glouton ( arendre - p , solution , i ) else : return rendu_glouton ( arendre , solution , i + 1 ) Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste `pieces=[100, 50, 20, 10, 5, 2, 1]` . (on supposera qu\u2019il n\u2019y a pas de limitation quant \u00e0 leur nombre). On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction `rendu_glouton` qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. ```python linenums='1' pieces = [100,50,20,10,5,2,1] # (1) def rendu_glouton(arendre, solution=[], i=0): if arendre == 0: return ... p = pieces[i] if p <= ... : solution.append(...) return rendu_glouton(arendre - p, solution,i) else : return rendu_glouton(arendre, solution, ...) Erreur dans l'\u00e9nonc\u00e9 officiel : Pieces On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 68 , [], 0 ) [ 50 , 10 , 5 , 2 , 1 ] >>> rendu_glouton ( 291 , [], 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] ```", "title": "Exercice 01.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-02", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 02"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-021", "text": "Exercice 02.1 \u00c9nonc\u00e9 Correction Source Markdown Soit le couple ( note , coefficient ): note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples ( note , coefficient ). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer le r\u00e9sultat du calcul suivant : \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme_notes = 0 somme_coeffs = 0 for devoir in tab : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \ud83d\udccb Texte Soit le couple (`note`,`coefficient`): - `note` est un nombre de type flottant (`float`) compris entre 0 et 20 ; - `coefficient` est un nombre entier positif. Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste compos\u00e9e de couples (`note`,`coefficient`). \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Par exemple, l\u2019expression `moyenne([(15,2),(9,1),(12,3)])` devra renvoyer le r\u00e9sultat du calcul suivant : $\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5$", "title": "Exercice 02.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-022", "text": "Exercice 02.2 \u00c9nonc\u00e9 Correction Sources Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : Compl\u00e9ter la fonction pascal ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne 1 \u00e0 la ligne n o\u00f9 n est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 2 (le tableau sera contenu dans la variable C ). La variable Ck doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro k , la k -i\u00e8me ligne du tableau. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , ... ): Ck = [ ... ] for i in range ( 1 , k ): Ck . append ( C [ ... ][ i - 1 ] + C [ ... ][ ... ] ) Ck . append ( ... ) C . append ( Ck ) return C Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): C = [[ 1 ]] for k in range ( 1 , n + 1 ): Ck = [ 1 ] for i in range ( 1 , k ): Ck . append ( C [ k - 1 ][ i - 1 ] + C [ k - 1 ][ i ] ) Ck . append ( 1 ) C . append ( Ck ) return C Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal. Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre 1. Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l\u2019int\u00e9rieur du tableau s\u2019obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus, comme l\u2019indique la figure suivante : ![ image ]( data/img9_2t.png ){: .center width=60%} Compl\u00e9ter la fonction `pascal` ci-apr\u00e8s. Elle doit renvoyer une liste correspondant au triangle de Pascal de la ligne `1` \u00e0 la ligne `n` o\u00f9 `n` est un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 `2` (le tableau sera contenu dans la variable `C` ). La variable `Ck` doit, quant \u00e0 elle, contenir, \u00e0 l\u2019\u00e9tape num\u00e9ro `k` , la `k` -i\u00e8me ligne du tableau. ```python linenums='1' def pascal(n): C= [[1]] for k in range(1,...): Ck = [...] for i in range(1,k): Ck.append(C[...][i-1]+C[...][...] ) Ck.append(...) C.append(Ck) return C Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] ```", "title": "Exercice 02.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-03", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 03"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-031", "text": "Exercice 03.1 \u00c9nonc\u00e9 Correction Source Markdown Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : \ud83d\udc0d Script Python >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] \ud83d\udc0d Script Python 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff \ud83d\udccb Texte Le codage par diff\u00e9rence (delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction `delta` qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : ```python >>> delta([1000, 800, 802, 1000, 1003]) [1000, -200, 2, 198, 3] >>> delta([42]) [42] ```", "title": "Exercice 03.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-032", "text": "Exercice 03.2 \u00c9nonc\u00e9 Correction Sources Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[3 \\times (8 + 7) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : \ud83d\udc0d Script Python >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212,\u00d7,\u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. ![ image ]( data/img3_2.png ){: .center width=30%} En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : $$3 \\times (8 + 7) \u2212 (2 + 1)$$ La classe `Noeud` ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive `expression_infixe` qui prend en param\u00e8tre un objet de la classe `Noeud` et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : ```python >>> e = Noeud(Noeud(Noeud(None, 3, None), '*', Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))), '-', Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))) >>> expression_infixe(e) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , g , v , d ): self . gauche = g self . valeur = v self . droit = d def est_une_feuille ( self ): '''Renvoie True si et seulement si le noeud est une feuille''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s # (1) Attention, l'\u00e9nonc\u00e9 original fait pr\u00e9c\u00e9der ce return d'un if ... qui a \u00e9t\u00e9 supprim\u00e9 ici. Il faudrait \u00e9crire if True: , ce qui est inutile... ```", "title": "Exercice 03.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-04", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 04"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-041", "text": "Exercice 04.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tre un tableau de nombres entiers tab , et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ([ 1 , 4 , 3 , 5 ]) [] >>> recherche ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> recherche ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> recherche ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tre un tableau de nombres entiers `tab`, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans `tab`. Exemples : ```python >>> recherche([1, 4, 3, 5]) [] >>> recherche([1, 4, 5, 3]) [(4, 5)] >>> recherche([7, 1, 2, 5, 3, 4]) [(1, 2), (3, 4)] >>> recherche([5, 1, 2, 3, 8, -5, -4, 7]) [(1, 2), (2, 3), (-5, -4)] ```", "title": "Exercice 04.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-042", "text": "Exercice 04.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M , deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M,2,1,3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : return None # (1) M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == ... ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( ... ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , ... , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( ... ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , ... , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( ... ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): # (2) propager ( M , i , ... , val ) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def propager ( M , i , j , val ): if M [ i ][ j ] == 0 : return None M [ i ][ j ] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if (( i - 1 ) >= 0 and M [ i - 1 ][ j ] == 1 ): propager ( M , i - 1 , j , val ) # l'\u00e9l\u00e9ment en bas fait partie de la composante if (( i + 1 ) < len ( M ) and M [ i + 1 ][ j ] == 1 ): propager ( M , i + 1 , j , val ) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if (( j - 1 ) >= 0 and M [ i ][ j - 1 ] == 1 ): propager ( M , i , j - 1 , val ) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if (( j + 1 ) < len ( M ) and M [ i ][ j + 1 ] == 1 ): propager ( M , i , j + 1 , val ) Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments `M[i][j]` , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 `0` soit \u00e0 `1` . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de `1` et de `0` qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de ![ image ]( data/252a.png ){: .center width=30%} sont ![ image ]( data/252b.png ){: .center width=30%} On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 `1` dans une image `M` , donner la valeur `val` \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction `propager` prend pour param\u00e8tre une image `M` , deux entiers `i` et `j` et une valeur enti\u00e8re `val` . Elle met \u00e0 la valeur `val` tous les pixels de la composante du pixel `M[i][j]` s\u2019il vaut `1` et ne fait rien s\u2019il vaut `0` . Par exemple, `propager(M,2,1,3)` donne ![ image ]( data/252c.png ){: .center width=30%} Compl\u00e9ter le code r\u00e9cursif de la fonction `propager` donn\u00e9 ci-dessous : ```python linenums='1' def propager(M, i, j, val): if M[i][j]== ...: return None # (1) M[i][j] = val # l'\u00e9l\u00e9ment en haut fait partie de la composante if ((i-1) >= 0 and M[i-1][j] == ...): propager(M, i-1, j, val) # l'\u00e9l\u00e9ment en bas fait partie de la composante if ((...) < len(M) and M[i+1][j] == 1): propager(M, ..., j, val) # l'\u00e9l\u00e9ment \u00e0 gauche fait partie de la composante if ((...) >= 0 and M[i][j-1] == 1): propager(M, i, ..., val) # l'\u00e9l\u00e9ment \u00e0 droite fait partie de la composante if ((...) < len(M) and M[i][j+1] == 1): # (2) propager(M, i, ..., val) Dans l'\u00e9nonc\u00e9 original, il n'y a rien apr\u00e8s le return . Il faudrait \u00e9crire len(M[0]) plut\u00f4t que len(M) . (\u00e9quivalent ici car l'image est carr\u00e9e...) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ],[ 0 , 1 , 0 , 1 ],[ 1 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] ```", "title": "Exercice 04.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-05", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 05"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-051", "text": "Exercice 05.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction rechercheMinMax qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s tab , et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> tableau = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : - 2 , 'max' : 9 } >>> tableau = [] >>> resultat = rechercheMinMax ( tableau ) >>> resultat { 'min' : None , 'max' : None } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rechercheMinMax ( tab ): if tab == []: return { 'min' : None , 'max' : None } d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \ud83d\udccb Texte \u00c9crire une fonction `rechercheMinMax` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9s `tab`, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s \u2018min\u2019 et \u2018max\u2019. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> tableau = [0, 1, 4, 2, -2, 9, 3, 1, 7, 1] >>> resultat = rechercheMinMax(tableau) >>> resultat {'min': -2, 'max': 9} >>> tableau = [] >>> resultat = rechercheMinMax(tableau) >>> resultat {'min': None, 'max': None} ```", "title": "Exercice 05.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-052", "text": "Exercice 05.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019un programme permettant de cr\u00e9er un objet de type PaquetDeCarte , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par #A compl\u00e9ter , puis ajouter des assertions dans l\u2019initialiseur de Carte , ainsi que dans la m\u00e9thode getCarteAt() . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Carte : \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ ( self , c , v ): self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): ??? = [ ??? for couleur in range ( 1 , ??? ) for valeur in range ( 1 , ??? )] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt ( self , pos ): if 0 <= pos < ??? : return ??? Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur Attention, le code propos\u00e9 ne respecte pas les standards de notation : il ne faut pas de majuscules sur les noms des attributs la docstring se place \u00e0 l'int\u00e9rieur de la fonction et non au dessus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carte : \"\"\"Initialise Couleur (entre 1 \u00e0 4), et Valeur (entre 1 \u00e0 13)\"\"\" def __init__ ( self , c , v ): assert c in range ( 1 , 5 ) assert v in range ( 1 , 14 ) self . Couleur = c self . Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom ( self ): if ( self . Valeur > 1 and self . Valeur < 11 ): return str ( self . Valeur ) elif self . Valeur == 11 : return \"Valet\" elif self . Valeur == 12 : return \"Dame\" elif self . Valeur == 13 : return \"Roi\" else : return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur ( self ): return [ 'pique' , 'coeur' , 'carreau' , 'trefle' ][ self . Couleur - 1 ] class PaquetDeCarte : def __init__ ( self ): self . contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir ( self ): self . contenu = [ Carte ( couleur , valeur ) for couleur in range ( 1 , 5 ) for valeur in range ( 1 , 14 )] \"\"\"Renvoie la Carte qui se trouve \u00e0 la position donn\u00e9e\"\"\" def getCarteAt ( self , pos ): assert pos in range ( 0 , 52 ) if 0 <= pos < len ( self . contenu ) : return self . contenu [ pos ] Markdown On dispose d\u2019un programme permettant de cr\u00e9er un objet de type `PaquetDeCarte` , selon les \u00e9l\u00e9ments indiqu\u00e9s dans le code ci-dessous. Compl\u00e9ter ce code aux endroits indiqu\u00e9s par `#A compl\u00e9ter` , puis ajouter des assertions dans l\u2019initialiseur de `Carte` , ainsi que dans la m\u00e9thode `getCarteAt()` . ```python linenums='1' class Carte: \"\"\"Initialise Couleur (entre 1 a 4), et Valeur (entre 1 a 13)\"\"\" def __init__ (self, c, v): self.Couleur = c self.Valeur = v \"\"\"Renvoie le nom de la Carte As, 2, ... 10, Valet, Dame, Roi\"\"\" def getNom(self): if ( self.Valeur > 1 and self.Valeur < 11): return str( self.Valeur) elif self.Valeur == 11: return \"Valet\" elif self.Valeur == 12: return \"Dame\" elif self.Valeur == 13: return \"Roi\" else: return \"As\" \"\"\"Renvoie la couleur de la Carte (parmi pique, coeur, carreau, trefle\"\"\" def getCouleur(self): return [ 'pique', 'coeur', 'carreau', 'trefle' ][ self.Couleur - 1 ] class PaquetDeCarte: def __init__ (self): self.contenu = [] \"\"\"Remplit le paquet de cartes\"\"\" def remplir(self): ??? = [ ??? for couleur in range(1, ???) for valeur in range( 1, ???)] \"\"\"Renvoie la Carte qui se trouve a la position donnee\"\"\" def getCarteAt(self, pos): if 0 <= pos < ??? : return ??? Exemple : \ud83d\udc0d Script Python >>> unPaquet = PaquetDeCarte () >>> unPaquet . remplir () >>> uneCarte = unPaquet . getCarteAt ( 20 ) >>> print ( uneCarte . getNom () + \" de \" + uneCarte . getCouleur ()) 8 de coeur ```", "title": "Exercice 05.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-06", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 06"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-061", "text": "Exercice 06.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \ud83d\udccb Texte \u00c9crire une fonction `maxi` qui prend en param\u00e8tre une liste `tab` de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ```", "title": "Exercice 06.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-062", "text": "Exercice 06.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction recherche prend en param\u00e8tres deux chaines de caract\u00e8res gene et seq_adn et renvoie True si on retrouve gene dans seq_adn et False sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction recherche . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: ... if j == g : trouve = True ... return trouve Exemples : \ud83d\udc0d Script Python >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def recherche ( gene , seq_adn ): n = len ( seq_adn ) g = len ( gene ) i = 0 trouve = False while i < n - g + 1 and trouve == False : j = 0 while j < g and gene [ j ] == seq_adn [ i + j ]: j += 1 if j == g : trouve = True i += 1 return trouve Markdown La fonction `recherche` prend en param\u00e8tres deux chaines de caract\u00e8res `gene` et `seq_adn` et renvoie `True` si on retrouve `gene` dans `seq_adn` et `False` sinon. Compl\u00e9ter le code Python ci-dessous pour qu\u2019il impl\u00e9mente la fonction `recherche` . ```python linenums='1' def recherche(gene, seq_adn): n = len(seq_adn) g = len(gene) i = ... trouve = False while i < ... and trouve == ... : j = 0 while j < g and gene[j] == seq_adn[i+j]: ... if j == g: trouve = True ... return trouve Exemples : \ud83d\udc0d Script Python >>> recherche ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> recherche ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False ```", "title": "Exercice 06.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-07", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 07"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-071", "text": "Exercice 07.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction conv_bin qui prend en param\u00e8tre un entier positif n et renvoie un couple ( b,bit) o\u00f9 : b est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de n ; bit correspond aux nombre de bits qui constituent b . Exemple : \ud83d\udc0d Script Python >>> conv_bin ( 9 ) ([ 1 , 0 , 0 , 1 ], 4 ) Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def conv_bin ( n ): # cas particulier pour n = 0 if n == 0 : return ([ 0 ], 1 ) # cas g\u00e9n\u00e9ral b = [] bits = 0 while n != 0 : b . append ( n % 2 ) bits += 1 n = n // 2 b . reverse () return ( b , bits ) \ud83d\udccb Texte \u00c9crire une fonction `conv_bin` qui prend en param\u00e8tre un entier positif `n` et renvoie un couple (`b,bit)` o\u00f9 : - `b` est une liste d'entiers correspondant \u00e0 la repr\u00e9sentation binaire de `n`; - `bit` correspond aux nombre de bits qui constituent `b`. Exemple : ```python >>> conv_bin(9) ([1,0,0,1],4) ``` Aide : - l'op\u00e9rateur `//` donne le quotient de la division euclidienne : `5//2` donne `2` ; - l'op\u00e9rateur `%` donne le reste de la division euclidienne :` 5%2` donne `1` ; - `append` est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit `T=[5,2,4]`, alors `T.append(10)` ajoute `10` \u00e0 la liste `T`. Ainsi, `T` devient `[5,2,4,10]`. - `reverse` est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit `T=[5,2,4,10]`. Apr\u00e8s `T.reverse()`, la liste devient `[10,4,2,5]`. On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier `n` en partant de la gauche en appliquant successivement les instructions : `b = n%2` `n = n//2` r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire.", "title": "Exercice 07.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-072", "text": "Exercice 07.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_bulles ( T ): n = len ( T ) for i in range ( n - 1 , 0 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T Markdown La fonction `tri_bulles` prend en param\u00e8tre une liste `T` d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction `tri_bulles` . ```python linenums='1' def tri_bulles(T): n = len(T) for i in range(...,...,-1): for j in range(i): if T[j] > T[...]: ... = T[j] T[j] = T[...] T[j+1] = temp return T ```", "title": "Exercice 07.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-08", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 08"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-081", "text": "Exercice 08.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ```", "title": "Exercice 08.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-082", "text": "Exercice 08.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= 0 : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def insere ( a , tab ): l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l Markdown On consid\u00e8re la fonction `insere` ci-dessous qui prend en argument un entier `a` et un tableau `tab` d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur `a` dans le tableau et renvoie le nouveau tableau. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes python. ```python linenums='1' def insere(a, tab): l = list(tab) #l contient les m\u00eames \u00e9l\u00e9ments que tab l.append(a) i = ... while a < ... and i >= 0: l[i+1] = ... l[i] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 ,[ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 10 ,[ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 10 , 12 , 14 , 25 ] >>> insere ( 1 ,[ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] ```", "title": "Exercice 08.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-09", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 09"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-091", "text": "Exercice 09.1 \u00c9nonc\u00e9 Correction Source Markdown Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : s'il est pair, on le divise par 2 ; s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite \\((U_n)\\) par : \\(U_0=k\\) , o\u00f9 \\(k\\) est un entier choisi initialement; \\(U_{n+1} = \\dfrac{U_n}{2}\\) si \\(U_n\\) est pair; \\(U_{n+1} = 3 \\times U_n + 1\\) si \\(U_n\\) est impair. On admet que, quel que soit l'entier k choisi au d\u00e9part, la suite finit toujours sur la valeur 1. \u00c9crire une fonction calcul prenant en param\u00e8tres un entier k strictement positif et qui renvoie la liste des valeurs de la suite, en partant de k et jusqu'\u00e0 atteindre 1. Exemple : \ud83d\udc0d Script Python >>> calcul ( 7 ) [ 7 , 22 , 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8 , 4 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def calcul ( k ): valeurs = [] n = k valeurs . append ( n ) while n != 1 : if n % 2 == 0 : n = n // 2 else : n = 3 * n + 1 valeurs . append ( n ) return valeurs \ud83d\udccb Texte Soit un nombre entier sup\u00e9rieur ou \u00e9gal \u00e0 1 : - s'il est pair, on le divise par 2 ; - s\u2019il est impair, on le multiplie par 3 et on ajoute 1. Puis on recommence ces \u00e9tapes avec le nombre entier obtenu, jusqu\u2019\u00e0 ce que l\u2019on obtienne la valeur 1. On d\u00e9finit ainsi la suite $(U_n)$ par : - $U_0=k$, o\u00f9 $k$ est un entier choisi initialement; - $U_{n+1} = \\dfrac{U_n}{2}$ si $U_n$ est pair; - $U_{n+1} = 3 \\times U_n + 1$ si $U_n$ est impair. **On admet que, quel que soit l'entier ```k``` choisi au d\u00e9part, la suite finit toujours sur la valeur 1.** \u00c9crire une fonction ```calcul``` prenant en param\u00e8tres un entier ```k``` strictement positif et qui renvoie la liste des valeurs de la suite, en partant de ```k``` et jusqu'\u00e0 atteindre 1. Exemple : ```python >>> calcul(7) [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] ```", "title": "Exercice 09.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-092", "text": "Exercice 09.2 \u00c9nonc\u00e9 Correction Sources Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int ( code_c ) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \\ \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \\ \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \\ \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = 0 for c in mot : code_c = code_c + str ( dico [ c ]) code_a = code_a + dico [ c ] code_c = int ( code_c ) if code_c % code_a == 0 : mot_est_parfait = True else : mot_est_parfait = False return [ code_a , code_c , mot_est_parfait ] Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son *code alphab\u00e9tique concat\u00e9n\u00e9* , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, *son code additionn\u00e9*, qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab *parfait* \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : - Pour le mot `\"PAUL\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1612112'` , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot `\"PAUL\"` n\u2019est pas parfait. - Pour le mot `\"ALAIN\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1121914'` , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot `\"ALAIN\"` est parfait. Compl\u00e9ter la fonction `est_parfait` ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res `mot` (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de `mot` , ainsi qu\u2019un bool\u00e9en qui indique si `mot` est parfait ou pas. ```python linenums='1' dico = {\"A\":1, \"B\":2, \"C\":3, \"D\":4, \"E\":5, \"F\":6, \"G\":7, \\ \"H\":8, \"I\":9, \"J\":10, \"K\":11, \"L\":12, \"M\":13, \\ \"N\":14, \"O\":15, \"P\":16, \"Q\":17, \"R\":18, \"S\":19, \\ \"T\":20, \"U\":21,\"V\":22, \"W\":23, \"X\":24, \"Y\":25, \"Z\":26} def est_parfait(mot) : #mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_c = \"\" code_a = ??? for c in mot : code_c = code_c + ??? code_a = ??? code_c = int(code_c) if ??? : mot_est_parfait = True else : mot_est_parfait = False return [code_a, code_c, mot_est_parfait] Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) [ 50 , 1612112 , False ] >>> est_parfait ( \"ALAIN\" ) [ 37 , 1121914 , True ] ```", "title": "Exercice 09.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-10", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 10"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-101", "text": "Exercice 10.1 \u00c9nonc\u00e9 Correction Source Markdown L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} \u00c9crire une fonction occurrence_lettres prenant comme param\u00e8tre une variable phrase de type str . Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def occurrence_lettres ( phrase ): occ = {} for caractere in phrase : if caractere in occ : occ [ caractere ] += 1 else : occ [ caractere ] = 1 return occ \ud83d\udccb Texte L\u2019occurrence d\u2019un caract\u00e8re dans un phrase est le nombre de fois o\u00f9 ce caract\u00e8re est pr\u00e9sent. Exemples : - l\u2019occurrence du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; - l\u2019occurrence du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - l\u2019occurrence du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - l\u2019occurrence du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : `{'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1}` \u00c9crire une fonction `occurrence_lettres` prenant comme param\u00e8tre une variable `phrase` de type `str`. Cette fonction doit renvoyer un dictionnaire de type constitu\u00e9 des occurrences des caract\u00e8res pr\u00e9sents dans la phrase.", "title": "Exercice 10.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-102", "text": "Exercice 10.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction fusion prend deux listes L1 , L2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e L12 qu\u2019elle renvoie. Le code Python de la fonction est \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = ... i1 = ... else : L12 [ i ] = L2 [ i2 ] i2 = ... i += 1 while i1 < n1 : L12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : L12 [ i ] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( L1 , L2 ): n1 = len ( L1 ) n2 = len ( L2 ) L12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if L1 [ i1 ] < L2 [ i2 ]: L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 else : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : L12 [ i ] = L1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : L12 [ i ] = L2 [ i2 ] i2 = i2 + 1 i = i + 1 return L12 Markdown La fonction `fusion` prend deux listes `L1` , `L2` d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e `L12` qu\u2019elle renvoie. Le code Python de la fonction est ```python linenums='1' def fusion(L1,L2): n1 = len(L1) n2 = len(L2) L12 = [0]*(n1+n2) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if L1[i1] < L2[i2]: L12[i] = ... i1 = ... else: L12[i] = L2[i2] i2 = ... i += 1 while i1 < n1: L12[i] = ... i1 = i1 + 1 i = ... while i2 < n2: L12[i] = ... i2 = i2 + 1 i = ... return L12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] ```", "title": "Exercice 10.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-11", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 11"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-111", "text": "Exercice 11.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres un tableau `tab` de nombres entiers tri\u00e9s par ordre croissant et un nombre entier `n`, et qui effectue une recherche dichotomique du nombre entier `n` dans le tableau non vide `tab`. Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, `-1` sinon. Exemples : ```python >>> recherche([2, 3, 4, 5, 6], 5) 3 >>> recherche([2, 3, 4, 6, 7], 5) -1 ```", "title": "Exercice 11.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-112", "text": "Exercice 11.2 \u00c9nonc\u00e9 Correction Sources Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve et -1 sinon. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for ... in message : if lettre in ALPHABET : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ALPHABET . find ( lettre ) def cesar ( message , decalage ): resultat = '' for lettre in message : if lettre in ALPHABET : indice = ( position_alphabet ( lettre ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + lettre return resultat Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019\u2026) ne sont pas cod\u00e9s. La fonction `position_alphabet` ci-dessous prend en param\u00e8tre un caract\u00e8re `lettre` et renvoie la position de `lettre` dans la cha\u00eene de caract\u00e8res `ALPHABET` s\u2019il s\u2019y trouve et `-1` sinon. La fonction `cesar` prend en param\u00e8tre une cha\u00eene de caract\u00e8res `message` et un nombre entier `decalage` et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage `decalage` . ```python linenums='1' ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet(lettre): return ALPHABET.find(lettre) def cesar(message, decalage): resultat = '' for ... in message: if lettre in ALPHABET: indice = ( ... ) % 26 resultat = resultat + ALPHABET[indice] else: resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' ```", "title": "Exercice 11.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-12", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 12"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-121", "text": "Exercice 12.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) 'erreur' L'\u00e9nonc\u00e9 n'est pas tr\u00e8s clair quand il dit \u00abd'afficher 'erreur'\u00bb (ce qui suppose un print et non un return ). Nous choississons donc dans ce cas de renvoyer None . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'erreur' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte Programmer la fonction ```moyenne``` prenant en param\u00e8tre un tableau d'entiers ```tab``` (type `list`) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide et affiche 'erreur' si le tableau est vide. Exemples : ```python >>> moyenne([5,3,8]) 5.333333333333333 >>> moyenne([1,2,3,4,5,6,7,8,9,10]) 5.5 >>> moyenne([]) 'erreur' ```", "title": "Exercice 12.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-122", "text": "Exercice 12.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau d'entiers tab (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def tri ( tab ): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab Markdown On consid\u00e8re un tableau d'entiers `tab` (type `list` dont les \u00e9l\u00e9ments sont des `0` ou des `1` ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri,le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des `0` , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des `1` . <table> <tr> <td>Zone de 0</td><td>Zone non tri\u00e9e</td><td>Zone de 1</td> </tr> </table> Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : - si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; - si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction `tri` suivante : ```python linenums='1' def tri(tab): #i est le premier indice de la zone non triee, j le dernier indice. #Au debut, la zone non triee est le tableau entier. i = ... j = ... while i != j : if tab[i]== 0: i = ... else : valeur = tab[j] tab[j] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ```", "title": "Exercice 12.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-13", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 13"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-131", "text": "Exercice 13.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif non nul somme_a_rendre et qui retourne une liste de trois entiers n1 , n2 et n3 qui correspondent aux nombres de billets de 5 euros ( n1 ) de pi\u00e8ces de 2 euros ( n2 ) et de pi\u00e8ces de 1 euro ( n3 ) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : \ud83d\udc0d Script Python >>> rendu ( 13 ) [ 2 , 1 , 1 ] >>> rendu ( 64 ) [ 12 , 2 , 0 ] >>> rendu ( 89 ) [ 17 , 2 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def rendu ( somme_a_rendre ): pieces = [ 5 , 2 , 1 ] retour = [ 0 , 0 , 0 ] reste_a_rendre = somme_a_rendre for i in range ( 3 ): retour [ i ] = reste_a_rendre // pieces [ i ] reste_a_rendre = reste_a_rendre % pieces [ i ] return retour \ud83d\udccb Texte On s\u2019int\u00e9resse au probl\u00e8me du rendu de monnaie. On suppose qu\u2019on dispose d\u2019un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d\u2019\u00e9crire une fonction nomm\u00e9e `rendu` dont le param\u00e8tre est un entier positif non nul `somme_a_rendre` et qui retourne une liste de trois entiers `n1`, `n2` et `n3` qui correspondent aux nombres de billets de 5 euros (`n1`) de pi\u00e8ces de 2 euros (`n2`) et de pi\u00e8ces de 1 euro (`n3`) \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 `somme_a_rendre`. On utilisera un algorithme glouton : on commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euros. Exemples : ```python >>> rendu(13) [2,1,1] >>> rendu(64) [12,2,0] >>> rendu(89) [17,2,0] ```", "title": "Exercice 13.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-132", "text": "Exercice 13.2 \u00c9nonc\u00e9 Correction Sources Markdown On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe Maillon permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : \ud83d\udc0d Script Python 1 2 3 4 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : \ud83d\udc0d Script Python >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Maillon : def __init__ ( self , v ) : self . valeur = v self . suivant = None class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( element ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = nouveau_maillon def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != None : print ( maillon . valeur ) maillon = maillon . suivant def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = self . dernier_file while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = maillon . suivant . valeur maillon . suivant = None return resultat return None Markdown On veut \u00e9crire une classe pour g\u00e9rer une file \u00e0 l\u2019aide d\u2019une liste cha\u00een\u00e9e. On dispose d\u2019une classe ```Maillon``` permettant la cr\u00e9ation d\u2019un maillon de la cha\u00eene, celui-ci \u00e9tant constitu\u00e9 d\u2019une valeur et d\u2019une r\u00e9f\u00e9rence au maillon suivant de la cha\u00eene : ```python linenums='1' class Maillon : def __init__ (self,v) : self.valeur = v self.suivant = None Compl\u00e9ter la classe File suivante o\u00f9 l\u2019attribut dernier_file contient le maillon correspondant \u00e0 l\u2019\u00e9l\u00e9ment arriv\u00e9 en dernier dans la file : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class File : def __init__ ( self ) : self . dernier_file = None def enfile ( self , element ) : nouveau_maillon = Maillon ( ... ) nouveau_maillon . suivant = self . dernier_file self . dernier_file = ... def est_vide ( self ) : return self . dernier_file == None def affiche ( self ) : maillon = self . dernier_file while maillon != ... : print ( maillon . valeur ) maillon = ... def defile ( self ) : if not self . est_vide () : if self . dernier_file . suivant == None : resultat = self . dernier_file . valeur self . dernier_file = None return resultat maillon = ... while maillon . suivant . suivant != None : maillon = maillon . suivant resultat = ... maillon . suivant = None return resultat return None On pourra tester le fonctionnement de la classe en utilisant les commandes suivantes dans la console Python : \ud83d\udc0d Script Python >>> F = File () >>> F . est_vide () True >>> F . enfile ( 2 ) >>> F . affiche () 2 >>> F . est_vide () False >>> F . enfile ( 5 ) >>> F . enfile ( 7 ) >>> F . affiche () 7 5 2 >>> F . defile () 2 >>> F . defile () 5 >>> F . affiche () 7 ```", "title": "Exercice 13.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-14", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 14"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-141", "text": "Exercice 14.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res * . Par exemple INFO*MA*IQUE , ***I***E** et *S* sont des mots \u00e0 trous. Programmer une fonction correspond qui : prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res mot et mot_a_trous o\u00f9 mot_a_trous est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, renvoie : True si on peut obtenir mot en rempla\u00e7ant convenablement les caract\u00e8res '*' de mot_a_trous . False sinon. Exemple : \ud83d\udc0d Script Python >>> correspond ( 'INFORMATIQUE' , 'INFO*MA*IQUE' ) True >>> correspond ( 'AUTOMATIQUE' , 'INFO*MA*IQUE' ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def correspond ( mot , mot_a_trous ): if len ( mot ) != len ( mot_a_trous ): return False for i in range ( len ( mot )): if mot [ i ] != mot_a_trous [ i ] and mot_a_trous [ i ] != '*' : return False return True \ud83d\udccb Texte On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res `*`. Par exemple `INFO*MA*IQUE`, `***I***E**` et `*S*` sont des mots \u00e0 trous. Programmer une fonction correspond qui : - prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res `mot` et `mot_a_trous` o\u00f9 `mot_a_trous` est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, - renvoie : - `True` si on peut obtenir `mot` en rempla\u00e7ant convenablement les caract\u00e8res `'*'` de `mot_a_trous`. - `False` sinon. Exemple : ```python >>> correspond('INFORMATIQUE', 'INFO*MA*IQUE') True >>> correspond('AUTOMATIQUE', 'INFO*MA*IQUE') False ```", "title": "Exercice 14.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-142", "text": "Exercice 14.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : chaque personne ne peut envoyer des messages qu'\u00e0 la m\u00eame personne (\u00e9ventuellement elle-m\u00eame), chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : A envoie ses messages \u00e0 E E envoie ses messages \u00e0 B B envoie ses messages \u00e0 F F envoie ses messages \u00e0 A C envoie ses messages \u00e0 D D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'} Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'} comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle, on dit que le plan d\u2019envoi est cyclique . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : On part de la personne A et on inspecte les N \u2013 1 successeurs dans le plan d'envoi : Si un de ces N \u2013 1 successeurs est A lui-m\u00eame, on a trouv\u00e9 un cycle de taille inf\u00e9rieure ou \u00e9gale \u00e0 N \u2013 1. Il y a donc au moins deux cycles et le plan d'envoi n'est pas cyclique. Si on ne retombe pas sur A lors de cette inspection, on a un unique cycle qui passe par toutes les personnes : le plan d'envoi est cyclique. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. Remarque : la fonction python len permet d'obtenir la longueur d'un dictionnaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len ( ... ) for i in range ( ... ): if plan [ ... ] == ... : return ... else : personne = ... return ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len ( plan ) for i in range ( N - 1 ): if plan [ personne ] == 'A' : return False else : personne = plan [ personne ] return True print ( est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' })) print ( est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' })) Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : - chaque personne ne peut envoyer des messages qu'\u00e0 la m\u00eame personne (\u00e9ventuellement elle-m\u00eame), - chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : - A envoie ses messages \u00e0 E - E envoie ses messages \u00e0 B - B envoie ses messages \u00e0 F - F envoie ses messages \u00e0 A - C envoie ses messages \u00e0 D - D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : `plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'}` Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : `plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'}` comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle, on dit que le plan d\u2019envoi est *cyclique* . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : On part de la personne A et on inspecte les N \u2013 1 successeurs dans le plan d'envoi : - Si un de ces N \u2013 1 successeurs est A lui-m\u00eame, on a trouv\u00e9 un cycle de taille inf\u00e9rieure ou \u00e9gale \u00e0 N \u2013 1. Il y a donc au moins deux cycles et le plan d'envoi n'est pas cyclique. - Si on ne retombe pas sur A lors de cette inspection, on a un unique cycle qui passe par toutes les personnes : le plan d'envoi est cyclique. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. *Remarque :* la fonction python `len` permet d'obtenir la longueur d'un dictionnaire. ```python linenums='1' def est_cyclique(plan): ''' Prend en param\u00e8tre un dictionnaire plan correspondant \u00e0 un plan d'envoi de messages entre N personnes A, B, C, D, E, F ...(avec N <= 26). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' personne = 'A' N = len(...) for i in range(...): if plan[...] == ...: return ... else: personne = ... return ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False ```", "title": "Exercice 14.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-15", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 15"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-151", "text": "Exercice 15.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 , [ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' , [ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 , [ 1 , '!' , 7 , 21 , 36 , 44 ]) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \ud83d\udccb Texte \u00c9crire une fonction python appel\u00e9e `nb_repetitions` qui prend en param\u00e8tres un \u00e9l\u00e9ment `elt` et une liste `tab` et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : ```python >>> nb_repetitions(5, [2, 5, 3, 5, 6, 9, 5]) 3 >>> nb_repetitions('A', ['B', 'A', 'B', 'A', 'R']) 2 >>> nb_repetitions(12, [1, '!', 7, 21, 36, 44]) 0 ```", "title": "Exercice 15.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-152", "text": "Exercice 15.2 \u00c9nonc\u00e9 Correction Sources Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : ![ image ]( data/img21_2.png ){: .center} Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : ```python linenums='1' def binaire(a): bin_a = str(...) a = a // 2 while a ... : bin_a = ...(a%2) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' ```", "title": "Exercice 15.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-16", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 16"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-161", "text": "Exercice 16.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction maxi qui prend en param\u00e8tre une liste tab de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : \ud83d\udc0d Script Python >>> maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def maxi ( tab ): val_max = tab [ 0 ] pos_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] pos_max = i return ( val_max , pos_max ) \ud83d\udccb Texte \u00c9crire une fonction `maxi` qui prend en param\u00e8tre une liste `tab` de nombres entiers et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l\u2019indice de la premi\u00e8re apparition de ce maximum dans la liste. Exemple : ```python >>> maxi([1,5,6,9,1,2,3,7,9,8]) (9,3) ```", "title": "Exercice 16.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-162", "text": "Exercice 16.2 \u00c9nonc\u00e9 Correction Sources Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression T1 = list(T) fait une copie de T ind\u00e9pendante de T , que l\u2019expression x = T.pop() enl\u00e8ve le sommet de la pile T et le place dans la variable x et, enfin, que l\u2019expression T.append(v) place la valeur v au sommet de la pile T . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile T de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable T . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = ... ( T ) T3 = ... while T2 != []: x = ... if ... >= 0 : T3 . append ( ... ) T2 = [] while T3 != ... : x = T3 . pop () ... print ( 'T = ' , T ) return T2 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def positif ( T ): T2 = list ( T ) T3 = [] while T2 != []: x = T2 . pop () if x >= 0 : T3 . append ( x ) T2 = [] # <- NB : cette ligne est inutile while T3 != []: x = T3 . pop () T2 . append ( x ) print ( 'T = ' , T ) return T2 Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type `list` ). On rappelle que l\u2019expression `T1 = list(T)` fait une copie de `T ` ind\u00e9pendante de `T` , que l\u2019expression `x = T.pop()` enl\u00e8ve le sommet de la pile `T` et le place dans la variable `x` et, enfin, que l\u2019expression `T.append(v)` place la valeur `v` au sommet de la pile `T` . Compl\u00e9ter le code Python de la fonction `positif` ci-dessous qui prend une pile `T` de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable `T` . ```python linenums='1' def positif(T): T2 = ...(T) T3 = ... while T2 != []: x = ... if ... >= 0: T3.append(...) T2 = [] while T3 != ...: x = T3.pop() ... print('T = ',T) return T2 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) T = [ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ] [ 0 , 5 , 4 , 10 , 9 ] ```", "title": "Exercice 16.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-17", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 17"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-171", "text": "Exercice 17.1 \u00c9nonc\u00e9 Correction Source Markdown Pour cet exercice : On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace ' ' , se finissant : soit par un point '.' qui est alors coll\u00e9 au dernier mot, soit par un point d'exclamation '!' ou d'interrogation '?' qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace ' ' . Exemples : Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction nombre_de_mots qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. \ud83d\udc0d Script Python >>> nombre_de_mots ( 'Le point d exclamation est separe !' ) 6 >>> nombre_de_mots ( 'Il y a un seul espace entre les mots !' ) 9 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nombre_de_mots ( phrase ): nb_mots = 0 for caractere in phrase : if caractere == ' ' or caractere == '.' : nb_mots += 1 return nb_mots \ud83d\udccb Texte Pour cet exercice : - On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, - On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : - compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace `' '`, - se finissant : - soit par un point `'.'` qui est alors coll\u00e9 au dernier mot, - soit par un point d'exclamation `'!'` ou d'interrogation `'?'` qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace `' '`. *Exemples :* Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction `nombre_de_mots` qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. ```python >>> nombre_de_mots('Le point d exclamation est separe !') 6 >>> nombre_de_mots('Il y a un seul espace entre les mots !') 9 ```", "title": "Exercice 17.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-172", "text": "Exercice 17.2 \u00c9nonc\u00e9 Correction Sources Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , v , g , d ): self . valeur = v self . gauche = g self . droite = d class ABR : ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ ( self ): '''Cr\u00e9e un arbre binaire de recherche vide''' self . racine = None def est_vide ( self ): '''Renvoie True si l'ABR est vide et False sinon.''' return self . racine is None def parcours ( self , tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( ... ) ... return tab def insere ( self , element ): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self . est_vide (): self . racine = Noeud ( element , ABR (), ABR ()) else : if element < self . racine . valeur : self . racine . gauche . insere ( element ) else : self . racine . droite . insere ( element ) def recherche ( self , element ): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self . est_vide (): return ... else : if element < self . racine . valeur : return ... elif element > self . racine . valeur : return ... else : return ... Compl\u00e9ter les fonctions r\u00e9cursives parcours et recherche afin qu'elles respectent leurs sp\u00e9cifications. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> a = ABR () >>> a . insere ( 7 ) >>> a . insere ( 3 ) >>> a . insere ( 9 ) >>> a . insere ( 1 ) >>> a . insere ( 9 ) >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . recherche ( 4 ) False >>> a . recherche ( 3 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Noeud : ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ ( self , v , g , d ): self . valeur = v self . gauche = g self . droite = d class ABR : ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ ( self ): '''Cr\u00e9e un arbre binaire de recherche vide''' self . racine = None def est_vide ( self ): '''Renvoie True si l'ABR est vide et False sinon.''' return self . racine is None def parcours ( self , tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( self . racine . valeur ) self . racine . droite . parcours ( tab ) return tab def insere ( self , element ): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self . est_vide (): self . racine = Noeud ( element , ABR (), ABR ()) else : if element < self . racine . valeur : self . racine . gauche . insere ( element ) else : self . racine . droite . insere ( element ) def recherche ( self , element ): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self . est_vide (): return False else : if element < self . racine . valeur : return self . racine . gauche . recherche ( element ) elif element > self . racine . valeur : return self . racine . droite . recherche ( element ) else : return True Cette mani\u00e8re de coder le parcours est maladroite car elle conduit \u00e0 ceci : \ud83d\udc0d Script Python >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 , 1 , 3 , 7 , 9 , 9 ] Comme le param\u00e8tre optionnel tab est un \u00e9l\u00e9ment mutable (de type list ), Python ne le r\u00e9initialise pas avant chaque appel de la fonction. Vous pouvez constater les cons\u00e9quences f\u00e2cheuses. Une solution pourrait \u00eatre d'\u00e9crire ceci : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def parcours ( self , tab = None ): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if tab is None : tab = [] if self . est_vide (): return tab else : self . racine . gauche . parcours ( tab ) tab . append ( self . racine . valeur ) self . racine . droite . parcours ( tab ) return tab Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. ```python linenums='1' class Noeud: ''' Classe impl\u00e9mentant un noeud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00e9tiquette, - gauche : le sous-arbre gauche. - droit : le sous-arbre droit. ''' def __init__ (self, v, g, d): self.valeur = v self.gauche = g self.droite = d class ABR: ''' Classe impl\u00e9mentant une structure d'arbre binaire de recherche. ''' def __init__ (self): '''Cr\u00e9e un arbre binaire de recherche vide''' self.racine = None def est_vide(self): '''Renvoie True si l'ABR est vide et False sinon.''' return self.racine is None def parcours(self, tab = []): ''' Renvoie la liste tab compl\u00e9t\u00e9e avec tous les \u00e9l\u00e9ments de l'ABR tri\u00e9s par ordre croissant. ''' if self.est_vide(): return tab else: self.racine.gauche.parcours(tab) tab.append(...) ... return tab def insere(self, element): '''Ins\u00e8re un \u00e9l\u00e9ment dans l'arbre binaire de recherche.''' if self.est_vide(): self.racine = Noeud(element, ABR(), ABR()) else: if element < self.racine.valeur: self.racine.gauche.insere(element) else : self.racine.droite.insere(element) def recherche(self, element): ''' Renvoie True si element est pr\u00e9sent dans l'arbre binaire et False sinon. ''' if self.est_vide(): return ... else: if element < self.racine.valeur: return ... elif element > self.racine.valeur: return ... else: return ... Compl\u00e9ter les fonctions r\u00e9cursives parcours et recherche afin qu'elles respectent leurs sp\u00e9cifications. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> a = ABR () >>> a . insere ( 7 ) >>> a . insere ( 3 ) >>> a . insere ( 9 ) >>> a . insere ( 1 ) >>> a . insere ( 9 ) >>> a . parcours () [ 1 , 3 , 7 , 9 , 9 ] >>> a . recherche ( 4 ) False >>> a . recherche ( 3 ) True ```", "title": "Exercice 17.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-18", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 18"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-181", "text": "Exercice 18.1 \u00c9nonc\u00e9 Correction Source Markdown On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres le tableau releve des relev\u00e9s et le tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : \ud83d\udc0d Script Python >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \ud83d\udccb Texte On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : ```python t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7] annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019] ``` \u00c9crire la fonction `mini` qui prend en param\u00e8tres le tableau `releve` des relev\u00e9s et le tableau `date` des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. Exemple : ```python >>> mini(t_moy, annees) (12.5, 2016) ```", "title": "Exercice 18.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-182", "text": "Exercice 18.2 \u00c9nonc\u00e9 Correction Sources Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : *bob* , *radar* , et *non* sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction `est_nbre_palindrome` s\u2019appuiera sur la fonction `est_palindrome` qui elle-m\u00eame s\u2019appuiera sur la fonction `inverse_chaine` . La fonction `inverse_chaine` inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res `chaine` et renvoie la cha\u00eene invers\u00e9e. La fonction `est_palindrome` teste si une chaine de caract\u00e8res `chaine` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction `est_nbre_palindrome` teste si un nombre `nbre` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. ```python def inverse_chaine(chaine): result = ... for caractere in chaine: result = ... return result def est_palindrome(chaine): inverse = inverse_chaine(chaine) return ... def est_nbre_palindrome(nbre): chaine = ... return est_palindrome(chaine) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True ```", "title": "Exercice 18.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-19", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 19"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-191", "text": "Exercice 19.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : ```python >>> multiplication(3,5) 15 >>> multiplication(-4,-8) 32 >>> multiplication(-2,6) -12 >>> multiplication(-2,0) 0 ```", "title": "Exercice 19.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-192", "text": "Exercice 19.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit T un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur n appara\u00eet \u00e9ventuellement dans T , et None sinon. Les param\u00e8tres de la fonction sont : T , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction chercher est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si 0 <= i et j < len(T) . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche \"Erreur\" puis renvoie None . Recopier et compl\u00e9ter le code de la fonction chercher propos\u00e9e ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or ??? : print ( \"Erreur\" ) return None if i > j : return None m = ( i + j ) // ??? if T [ m ] < ??? : return chercher ( T , n , ??? , ??? ) elif ??? : return chercher ( T , n , ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( T , n , i , j ): if i < 0 or j >= len ( T ) : print ( 'Erreur' ) return None if i > j : return None m = ( i + j ) // 2 if T [ m ] < n : return chercher ( T , n , m + 1 , j ) elif T [ m ] > n : return chercher ( T , n , i , m - 1 ) else : return m Markdown Soit `T` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher` , donn\u00e9e \u00e0 la page suivante, doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet \u00e9ventuellement dans `T` , et `None` sinon. Les param\u00e8tres de la fonction sont : - `T` , le tableau dans lequel s'effectue la recherche ; - `n` , l'entier \u00e0 chercher dans le tableau ; - `i` , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j` , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. La fonction `chercher` est une fonction r\u00e9cursive bas\u00e9e sur le principe \u00ab diviser pour r\u00e9gner \u00bb. Le code de la fonction commence par v\u00e9rifier si `0 <= i` et `j < len(T)` . Si cette condition n\u2019est pas v\u00e9rifi\u00e9e, elle affiche `\"Erreur\"` puis renvoie `None` . Recopier et compl\u00e9ter le code de la fonction `chercher` propos\u00e9e ci-dessous : ```python linenums='1' def chercher(T, n, i, j): if i < 0 or ??? : print(\"Erreur\") return None if i > j : return None m = (i + j) // ??? if T[m] < ??? : return chercher(T, n, ??? , ???) elif ??? : return chercher(T, n, ??? , ??? ) else : return ??? L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) Erreur >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 ```", "title": "Exercice 19.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-20", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 20"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-201", "text": "Exercice 20.1 \u00c9nonc\u00e9 Correction Source Markdown L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : \ud83d\udc0d Script Python a = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ] b = [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] c = [ 1 , 1 , 0 , 1 ] d = [ 0 , 0 , 1 , 1 ] \u00c9crire la fonction xor qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : \ud83d\udc0d Script Python assert ( xor ( a , b ) == [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ]) assert ( xor ( c , d ) == [ 1 , 1 , 1 , 0 ]) Correction propos\u00e9e par Yves Laurent \ud83d\udc0d Script Python def xor ( tab1 , tab2 ): \"\"\" Parameters ---------- tab1 : type(tab1) = list Binaire 1 tab2 : type(tab1) = list Binaire 2 Returns ------- resultat : list tab1 xor tab2. \"\"\" assert len ( tab1 ) == len ( tab2 ), \"pas la m\u00eame taille\" resultat = [] taille = len ( tab1 ) for compteur in range ( taille ): resultat . append ( tab1 [ compteur ] ^ tab2 [ compteur ]) return resultat \ud83d\udccb Texte L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents : 0 \u2295 0 = 0 , 0 \u2295 1 = 1 , 1 \u2295 0 = 1 , 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : ```python a = [1, 0, 1, 0, 1, 1, 0, 1] b = [0, 1, 1, 1, 0, 1, 0, 0] c = [1, 1, 0, 1] d = [0, 0, 1, 1] ``` \u00c9crire la fonction ```xor``` qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position `i` est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position `i` des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction doit passer les tests suivants : ```python assert(xor(a, b) == [1, 1, 0, 1, 1, 0, 0, 1]) assert(xor(c, d) == [1, 1, 1, 0]) ```", "title": "Exercice 20.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-202", "text": "Exercice 20.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. c4 n\u2019est pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter la fonction est_magique qui prend en param\u00e8tre un carr\u00e9 et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, False sinon. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( self . valeurs [ i ]) def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ i ][ j ] for i in range ( self . ordre )]) def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... , ... ): if carre . somme_ligne ( i ) != s : return ... #test de la somme de chaque colonne for j in range ( n ): if ... != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ ... ][ ... ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return ... Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Carre : def __init__ ( self , tableau = [[]]): self . ordre = len ( tableau ) self . valeurs = tableau def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . valeurs [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' return sum ( self . valeurs [ i ]) def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' return sum ([ self . valeurs [ i ][ j ] for i in range ( self . ordre )]) def est_magique ( carre ): n = carre . ordre s = carre . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( 1 , n ): if carre . somme_ligne ( i ) != s : return False #test de la somme de chaque colonne for j in range ( n ): if carre . somme_col ( j ) != s : return False #test de la somme de chaque diagonale if sum ([ carre . valeurs [ k ][ k ] for k in range ( n )]) != s : return False if sum ([ carre . valeurs [ k ][ n - 1 - k ] for k in range ( n )]) != s : return False return s c1 = Carre ([[ 1 , 1 ], [ 1 , 1 ]]) c2 = Carre ([[ 2 , 9 , 4 ], [ 7 , 5 , 3 ], [ 6 , 1 , 8 ]]) c3 = Carre ([[ 4 , 5 , 16 , 9 ], [ 14 , 7 , 2 , 11 ], [ 3 , 10 , 15 , 6 ], [ 13 , 12 , 8 , 1 ]]) assert est_magique ( c1 ) == 2 assert est_magique ( c2 ) == 15 assert est_magique ( c3 ) == False Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre $n$ un tableau de $n$ lignes et $n$ colonnes dont chaque case contient un entier naturel. Exemples : ![ image ]( data/img20_2.png ){: .center width=70%} Un carr\u00e9 est dit magique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne et chaque diagonale sont \u00e9gales. Ainsi c2 et c3 sont magiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 2 pour c2 et 15 pour c3. c4 n\u2019est pas magique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 34 alors que celle de la derni\u00e8re colonne est \u00e9gale \u00e0 27. La classe `Carre` ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. Compl\u00e9ter la fonction `est_magique` qui prend en param\u00e8tre un carr\u00e9 et qui renvoie la valeur de la somme si ce carr\u00e9 est magique, `False` sinon. ```python linenums='1' class Carre: def __init__ (self, tableau = [[]]): self.ordre = len(tableau) self.valeurs = tableau def affiche(self): '''Affiche un carr\u00e9''' for i in range(self.ordre): print(self.valeurs[i]) def somme_ligne(self, i): '''Calcule la somme des valeurs de la ligne i''' return sum(self.valeurs[i]) def somme_col(self, j): '''Calcule la somme des valeurs de la colonne j''' return sum([self.valeurs[i][j] for i in range(self.ordre)]) def est_magique(carre): n = carre.ordre s = carre.somme_ligne(0) #test de la somme de chaque ligne for i in range(..., ...): if carre.somme_ligne(i) != s: return ... #test de la somme de chaque colonne for j in range(n): if ... != s: return False #test de la somme de chaque diagonale if sum([carre.valeurs[...][...] for k in range(n)]) != s: return False if sum([carre.valeurs[k][n-1-k] for k in range(n)]) != s: return False return ... Tester la fonction est_magique sur les carr\u00e9s c2, c3 et c4. ```", "title": "Exercice 20.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-21", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 21"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-211", "text": "Exercice 21.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \u00c9nonc\u00e9 peu clair, on ne sait pas si n1 et n2 sont entiers naturels ou relatifs. Nous d\u00e9cidons qu'ils sont relatifs et donc qu'ils peuvent \u00eatre n\u00e9gatifs, auquel cas on utilise le fait que \\(5 \\times (-6)= - (5 \\times 6)\\) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction.", "title": "Exercice 21.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-212", "text": "Exercice 21.2 \u00c9nonc\u00e9 Correction Sources Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False ```", "title": "Exercice 21.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-22", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 22"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-221", "text": "Exercice 22.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer une fonction renverse , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide mot et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene mot . Exemple : \ud83d\udc0d Script Python >>> renverse ( \"informatique\" ) \"euqitamrofni\" \ud83d\udc0d Script Python 1 2 3 4 5 def renverse ( mot ): sol = '' for lettre in mot : sol = lettre + sol return sol \ud83d\udccb Texte Programmer une fonction `renverse`, prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide `mot` et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene `mot`. Exemple : ```python >>> renverse(\"informatique\") \"euqitamrofni\" ```", "title": "Exercice 22.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-222", "text": "Exercice 22.2 \u00c9nonc\u00e9 Correction Sources Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre N fix\u00e9. On consid\u00e8re pour cela un tableau tab de N bool\u00e9ens, initialement tous \u00e9gaux \u00e0 True , sauf tab[0] et tab[1] qui valent False , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice i : si tab[i] vaut True : le nombre i est premier et on donne la valeur False \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de i , \u00e0 partir de 2*i (c\u2019est-\u00e0-dire 2*i , 3*i ...). si tab[i] vaut False : le nombre i n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction crible , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier N strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que N. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( N ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * N tab [ 0 ], tab [ 1 ] = False , False for i in range ( ... , N ): if tab [ i ] == ... : premiers . append ( ... ) for multiple in range ( 2 * i , N , ... ): tab [ multiple ] = ... return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Compl\u00e9ter le code de cette fonction. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( N ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * N tab [ 0 ], tab [ 1 ] = False , False for i in range ( 2 , N ): if tab [ i ] == True : premiers . append ( i ) for multiple in range ( 2 * i , N , i ): tab [ multiple ] = False return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre N fix\u00e9. On consid\u00e8re pour cela un tableau `tab` de N bool\u00e9ens, initialement tous \u00e9gaux \u00e0 `True` , sauf `tab[0]` et `tab[1]` qui valent `False` , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice `i` : - si `tab[i]` vaut `True` : le nombre `i` est premier et on donne la valeur `False` \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de `i` , \u00e0 partir de `2*i` (c\u2019est-\u00e0-dire `2*i` , `3*i` ...). - si `tab[i]` vaut `False` : le nombre `i` n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction `crible` , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier N strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que N. ```python linenums='1' def crible(N): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [True] * N tab[0], tab[1] = False, False for i in range(..., N): if tab[i] == ...: premiers.append(...) for multiple in range(2*i, N, ...): tab[multiple] = ... return premiers assert crible(40) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] Compl\u00e9ter le code de cette fonction. ```", "title": "Exercice 22.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-23", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 23"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-231", "text": "Exercice 23.1 \u00c9nonc\u00e9 Correction Source Markdown Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : \ud83d\udc0d Script Python >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def max_dico ( dico ): cle_max = '' val_max = 0 for cle in dico : if dico [ cle ] > val_max : val_max = dico [ cle ] cle_max = cle return ( cle_max , val_max ) \ud83d\udccb Texte Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : `{'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}` \u00c9crire une fonction `max_dico` qui : - Prend en param\u00e8tre un dictionnaire `dico` non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; - Renvoie un tuple dont : - La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; - La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : ```python >>> max_dico({'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}) ('Ada', 201) >>> max_dico({'Alan': 222, 'Ada': 201, 'Eve': 220, 'Tim': 50}) ('Alan', 222) ```", "title": "Exercice 23.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-232", "text": "Exercice 23.2 \u00c9nonc\u00e9 Correction Sources Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for element in tab : print ( element ) if element != '+' and element != '*' : p . empiler ( element ) else : if element == '+' : resultat = p . depiler () + p . depiler () else : resultat = p . depiler () * p . depiler () p . empiler ( resultat ) return p . depiler () Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : - Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; - Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. - \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe `Pile` qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction `eval_expression` qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. Exemple : ```python >>> eval_expression([2, 3, '+', 5, '*']) 25 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... ```", "title": "Exercice 23.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-24", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 24"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-241", "text": "Exercice 24.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire la fonction maxliste , prenant en param\u00e8tre un tableau non vide de nombres tab (type list ) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : \ud83d\udc0d Script Python >>> maxliste ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maxliste ([ - 27 , 24 , - 3 , 15 ]) 24 \ud83d\udc0d Script Python 1 2 3 4 5 6 def maxliste ( tab ): maximum = tab [ 0 ] for element in tab : if element > maximum : maximum = element return maximum \ud83d\udccb Texte \u00c9crire la fonction `maxliste`, prenant en param\u00e8tre un tableau non vide de nombres `tab` (type `list`) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : ```python >>> maxliste([98, 12, 104, 23, 131, 9]) 131 >>> maxliste([-27, 24, -3, 15]) 24 ```", "title": "Exercice 24.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-242", "text": "Exercice 24.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, ((()())(())) est un parenth\u00e9sage correct. Les parenth\u00e9sages ())(() et (())(() sont, eux, incorrects. On dispose du code de la classe Pile suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self , valeurs = []): self . valeurs = valeurs def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene ch de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible !) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Compl\u00e9ter le code de la fonction parenthesage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self , valeurs = []): self . valeurs = valeurs def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == '(' : p . empiler ( c ) elif c == ')' : if p . est_vide (): return False else : p . depiler () return p . est_vide () print ( parenthesage ( \"((()())(()))\" )) assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : - le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. - en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, `((()())(()))` est un parenth\u00e9sage correct. Les parenth\u00e9sages `())(()` et `(())(()` sont, eux, incorrects. On dispose du code de la classe `Pile` suivant : ```python linenums='1' class Pile: \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ (self, valeurs=[]): self.valeurs = valeurs def est_vide(self): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self.valeurs == [] def empiler(self, c): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self.valeurs.append(c) def depiler(self): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self.est_vide() == False: self.valeurs.pop() On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene ch de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible !) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () assert parenthesage ( \"((()())(()))\" ) == True assert parenthesage ( \"())(()\" ) == False assert parenthesage ( \"(())(()\" ) == False Compl\u00e9ter le code de la fonction parenthesage . ```", "title": "Exercice 24.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-25", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 25"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-251", "text": "Exercice 25.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont 'nom' , 'espece' , 'age' , 'enclos' . Voici un exemple d'une telle table : \ud83d\udc0d Script Python animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] Programmer une fonction selection_enclos qui : prend en param\u00e8tres : une table table_animaux contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), un num\u00e9ro d'enclos num_enclos ; renvoie une table contenant les enregistrements de table_animaux dont l'attribut 'enclos' est num_enclos . Exemples avec la table animaux ci-dessus : \ud83d\udc0d Script Python >>> selection_enclos ( animaux , 5 ) [{ 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] >>> selection_enclos ( animaux , 2 ) [{ 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }] >>> selection_enclos ( animaux , 7 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def selection_enclos ( table_animaux , num_enclos ): table = [] for animal in table_animaux : if animal [ 'enclos' ] == num_enclos : table . append ( animal ) return table \ud83d\udccb Texte On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont `'nom'`, `'espece'`, `'age'`, `'enclos'`. Voici un exemple d'une telle table : ```python animaux = [ {'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}, {'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Tom', 'espece':'chat', 'age':7, 'enclos':4}, {'nom':'Belle', 'espece':'chien', 'age':6, 'enclos':3}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] ``` Programmer une fonction `selection_enclos` qui : - prend en param\u00e8tres : - une table `table_animaux` contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), - un num\u00e9ro d'enclos `num_enclos` ; - renvoie une table contenant les enregistrements de `table_animaux` dont l'attribut `'enclos'` est `num_enclos`. Exemples avec la table animaux ci-dessus : ```python >>> selection_enclos(animaux, 5) [{'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] >>> selection_enclos(animaux, 2) [{'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}] >>> selection_enclos(animaux, 7) [] ```", "title": "Exercice 25.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-252", "text": "Exercice 25.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois et \u00e0 suivre, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : \ud83d\udc0d Script Python tab_a = [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] #l'intrus est 7 tab_b = [ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ] #l'intrus est 8 tab_c = [ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Compl\u00e9ter la fonction ci-dessous qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return tab [ g ] else : nombre_de_triplets = ( d - g ) // 3 indice = g + 3 * ( nombre_de_triplets // 2 ) if tab [ indice ] != tab [ indice + 1 ] : return trouver_intrus ( tab , g , indice ) else : return trouver_intrus ( tab , indice + 3 , d ) Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois et \u00e0 suivre, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : ```python tab_a = [3, 3, 3, 9, 9, 9, 1, 1, 1, 7, 2, 2, 2, 4, 4, 4, 8, 8, 8, 5, 5, 5] #l'intrus est 7 tab_b = [8, 5, 5, 5, 9, 9, 9, 18, 18, 18, 3, 3, 3] #l'intrus est 8 tab_c = [5, 5, 5, 1, 1, 1, 0, 0, 0, 6, 6, 6, 3, 8, 8, 8] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Compl\u00e9ter la fonction ci-dessous qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 ```", "title": "Exercice 25.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-26", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 26"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-261", "text": "Exercice 26.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction RechercheMin qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> RechercheMin ([ 5 ]) 0 >>> RechercheMin ([ 2 , 4 , 1 ]) 2 >>> RechercheMin ([ 5 , 3 , 2 , 2 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 def RechercheMin ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \ud83d\udccb Texte \u00c9crire une fonction `RechercheMin` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 `tab`, et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> RechercheMin([5]) 0 >>> RechercheMin([2, 4, 1]) 2 >>> RechercheMin([5, 3, 2, 2, 4]) 2 ```", "title": "Exercice 26.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-262", "text": "Exercice 26.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = ... while i < j : if tab [ i ] == 0 : i = ... else : tab [ i ], tab [ j ] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): i = 0 j = len ( tab ) - 1 while i < j : if tab [ i ] == 0 : i = i + 1 else : tab [ i ], tab [ j ] = tab [ j ], tab [ i ] j = j - 1 return tab Markdown On consid\u00e8re la fonction `separe` ci-dessous qui prend en argument un tableau `tab` dont les \u00e9l\u00e9ments sont des `0` et des `1` et qui s\u00e9pare les `0` des `1` en pla\u00e7ant les `0` en d\u00e9but de tableau et les `1` \u00e0 la suite. ```python linenums='1' def separe(tab): i = 0 j = ... while i < j : if tab[i] == 0 : i = ... else : tab[i], tab[j] = ... j = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ```", "title": "Exercice 26.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-27", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 27"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-271", "text": "Exercice 27.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont '' , le fils gauche seulement est '' , le fils droit seulement est '' , aucun des deux fils n\u2019est '' . Exemple : \ud83d\udc0d Script Python >>> taille ( a , \u2019 F \u2019 ) 9 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 \ud83d\udccb Texte Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre ![image](data/img28_1.png){: .center width=40%} est stock\u00e9 dans ```python a = {'F':['B','G'], 'B':['A','D'], 'A':['',''], 'D':['C','E'], \\ 'C':['',''], 'E':['',''], 'G':['','I'], 'I':['','H'], \\ 'H':['','']} ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tres un arbre binaire `arbre` sous la forme d\u2019un dictionnaire et un caract\u00e8re `lettre` qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153ud. On pourra distinguer les 4 cas o\u00f9 les deux \u00ab fils \u00bb du n\u0153ud sont `''`, le fils gauche seulement est `''`, le fils droit seulement est `''`, aucun des deux fils n\u2019est `''`. Exemple : ```python >>> taille(a, \u2019F\u2019) 9 ```", "title": "Exercice 27.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-272", "text": "Exercice 27.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient t = [41, 25, 21, 18, 12, 6, 55] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le dernier , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : t = [6, 25, 21, 18, 12, 41, 55] Et ainsi de suite. La code de la fonction tri_iteratif qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( ... , 0 , - 1 ): imax = ... for i in range ( 0 , ... ): if tab [ i ] > ... : imax = i if tab [ imax ] > ... : ... , tab [ imax ] = tab [ imax ], ... return tab Compl\u00e9ter le code qui doit donner : \ud83d\udc0d Script Python >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def tri_iteratif ( tab ): for k in range ( len ( tab ) - 1 , 0 , - 1 ): imax = 0 for i in range ( 0 , k ): if tab [ i ] > tab [ imax ] : imax = i if tab [ imax ] > tab [ k ] : tab [ k ], tab [ imax ] = tab [ imax ], tab [ k ] return tab Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt depuis le d\u00e9but du tableau tous les \u00e9l\u00e9ments non rang\u00e9s et on place en derni\u00e8re position le plus grand \u00e9l\u00e9ment. Exemple avec le tableau : ```t = [41, 55, 21, 18, 12, 6, 25]``` - \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus grand \u00e9l\u00e9ment avec le dernier. Le tableau devient `t = [41, 25, 21, 18, 12, 6, 55]` - \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments **sauf le dernier** , on permute le plus grand \u00e9l\u00e9ment trouv\u00e9 avec l'avant dernier. Le tableau devient : ```t = [6, 25, 21, 18, 12, 41, 55]``` Et ainsi de suite. La code de la fonction `tri_iteratif` qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. ```python linenums='1' def tri_iteratif(tab): for k in range(..., 0 ,-1): imax = ... for i in range(0, ...): if tab[i] > ... : imax = i if tab[imax] > ... : ..., tab[imax] = tab[imax], ... return tab Compl\u00e9ter le code qui doit donner : \ud83d\udc0d Script Python >>> tri_iteratif ([ 41 , 55 , 21 , 18 , 12 , 6 , 25 ]) [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et b . ```", "title": "Exercice 27.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-28", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 28"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-281", "text": "Exercice 28.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> moyenne([1.0]) 1.0 >>> moyenne([1.0, 2.0, 4.0]) 2.3333333333333335 ```", "title": "Exercice 28.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-282", "text": "Exercice 28.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction dec_to_bin ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : \ud83d\udc0d Script Python >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def dec_to_bin ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown On consid\u00e8re la fonction `dec_to_bin` ci-dessous qui prend en param\u00e8tre un entier positif `a` en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. ```python linenums='1' def dec_to_bin(a): bin_a = ... a = a//2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter la fonction dec_to_bin . Exemples : \ud83d\udc0d Script Python >>> dec_to_bin ( 83 ) '1010011' >>> dec_to_bin ( 127 ) '1111111' ```", "title": "Exercice 28.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-29", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 29"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-291", "text": "Exercice 29.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par U1 = 1 , U2 = 1 et, pour tout entier naturel n , par Un+2 = Un+1 + Un . Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction fibonacci qui prend un entier n > 0 et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice n de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 On utilise un dictionnaire pour stocker au fur et \u00e0 mesure les valeurs. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonnaci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] \ud83d\udccb Texte On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par `U1 = 1`, `U2 = 1` et, pour tout entier naturel `n`, par `Un+2 = Un+1 + Un`. Elle s\u2019appelle la suite de Fibonacci. \u00c9crire la fonction `fibonacci` qui prend un entier `n > 0` et qui renvoie l\u2019\u00e9l\u00e9ment d\u2019indice `n` de cette suite. On utilisera une programmation dynamique (pas de r\u00e9cursivit\u00e9). Exemple : ```python >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(25) 75025 >>> fibonacci(45) 1134903170 ```", "title": "Exercice 29.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-292", "text": "Exercice 29.2 \u00c9nonc\u00e9 Correction Sources Markdown Les variables liste_eleves et liste_notes ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction meilleures_notes renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction meilleures_notes ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range ( ... ): if liste_notes [ compteur ] == ... : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ ... ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = ... liste_maxi = [ ... ] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 liste_eleves = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] liste_notes = [ 1 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] def meilleures_notes (): note_maxi = 0 nb_eleves_note_maxi = 0 liste_maxi = [] for compteur in range ( len ( liste_eleves )): if liste_notes [ compteur ] == note_maxi : nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi . append ( liste_eleves [ compteur ]) if liste_notes [ compteur ] > note_maxi : note_maxi = liste_notes [ compteur ] nb_eleves_note_maxi = 1 liste_maxi = [ liste_eleves [ compteur ]] return ( note_maxi , nb_eleves_note_maxi , liste_maxi ) Markdown Les variables `liste_eleves` et `liste_notes` ayant \u00e9t\u00e9 pr\u00e9alablement d\u00e9finies et \u00e9tant de m\u00eame longueur, la fonction `meilleures_notes` renvoie la note maximale qui a \u00e9t\u00e9 attribu\u00e9e, le nombre d\u2019\u00e9l\u00e8ves ayant obtenu cette note et la liste des noms de ces \u00e9l\u00e8ves. Compl\u00e9ter le code Python de la fonction `meilleures_notes` ci-dessous. ```python linenums='1' liste_eleves = ['a','b','c','d','e','f','g','h','i','j'] liste_notes = [1, 40, 80, 60, 58, 80, 75, 80, 60, 24] def meilleures_notes(): note_maxi = 0 nb_eleves_note_maxi = ... liste_maxi = ... for compteur in range(...): if liste_notes[compteur] == ...: nb_eleves_note_maxi = nb_eleves_note_maxi + 1 liste_maxi.append(liste_eleves[...]) if liste_notes[compteur] > note_maxi: note_maxi = liste_notes[compteur] nb_eleves_note_maxi = ... liste_maxi = [...] return (note_maxi,nb_eleves_note_maxi,liste_maxi) Une fois compl\u00e9t\u00e9, le code ci-dessus donne \ud83d\udc0d Script Python >>> meilleures_notes () ( 80 , 3 , [ 'c' , 'f' , 'h' ]) ```", "title": "Exercice 29.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-30", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 30"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-301", "text": "Exercice 30.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction fusion prenant en param\u00e8tres deux tableaux non vides tab1 et tab2 (type list ) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de tab1 et tab2 . Exemples : \ud83d\udc0d Script Python >>> fusion ([ 3 , 5 ], [ 2 , 5 ]) [ 2 , 3 , 5 , 5 ] >>> fusion ([ - 2 , 4 ], [ - 3 , 5 , 10 ]) [ - 3 , - 2 , 4 , 5 , 10 ] >>> fusion ([ 4 ], [ 2 , 6 ]) [ 2 , 4 , 6 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fusion ( tab1 , tab2 ): tab_fusion = [] i1 = 0 i2 = 0 while i1 < len ( tab1 ) and i2 < len ( tab2 ): if tab1 [ i1 ] < tab2 [ i2 ]: tab_fusion . append ( tab1 [ i1 ]) i1 += 1 else : tab_fusion . append ( tab2 [ i2 ]) i2 += 1 if i1 == len ( tab1 ): while i2 < len ( tab2 ): tab_fusion . append ( tab2 [ i2 ]) i2 += 1 else : while i1 < len ( tab1 ): tab_fusion . append ( tab1 [ i1 ]) i1 += 1 return tab_fusion \ud83d\udccb Texte Programmer la fonction `fusion` prenant en param\u00e8tres deux tableaux non vides `tab1` et `tab2` (type `list`) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de `tab1` et `tab2`. Exemples : ```python >>> fusion([3, 5], [2, 5]) [2, 3, 5, 5] >>> fusion([-2, 4], [-3, 5, 10]) [-3, -2, 4, 5, 10] >>> fusion([4], [2, 6]) [2, 4, 6] ```", "title": "Exercice 30.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-302", "text": "Exercice 30.2 \u00c9nonc\u00e9 Correction Sources Markdown Les chiffres romains sont un syst\u00e8me ancien d\u2019\u00e9criture des nombres. Les chiffres romains sont: I, V, X, L, C, D, et M. Ces symboles repr\u00e9sentent respectivement 1, 5, 10, 50, 100, 500, et 1000 en base dix. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur sup\u00e9rieure ou \u00e9gale \u00e0 celui de droite, le nombre s\u2019obtient en additionnant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"XVI\" est le nombre 16 car X + VI = 10 + 6. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur strictement inf\u00e9rieure \u00e0 celui de droite, le nombre s\u2019obtient en retranchant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"CDIII\" est le nombre 403 car DIII \u2013 C = 503 \u2013 100. On dispose d\u2019un dictionnaire dico , \u00e0 compl\u00e9ter, o\u00f9 les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et o\u00f9 les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale. On souhaite cr\u00e9er une fonction r\u00e9cursive rom_to_dec qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res (non vide) repr\u00e9sentant un nombre \u00e9crit en chiffres romains et renvoyant le nombre associ\u00e9 en \u00e9criture d\u00e9cimale : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def rom_to_dec ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = { \"I\" : 1 , \"V\" : 5 , ... } if len ( nombre ) == 1 : return ... else : ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre [ 1 :] if dico [ nombre [ 0 ]] >= dico [ nombre [ 1 ]]: return dico [ nombre [ 0 ]] + ... else : return ... assert rom_to_dec ( \"CXLII\" ) == 142 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def rom_to_dec ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } if len ( nombre ) == 1 : return dico [ nombre ] else : ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre [ 1 :] # (1) if dico [ nombre [ 0 ]] >= dico [ nombre [ 1 ]]: return dico [ nombre [ 0 ]] + rom_to_dec ( nombre_droite ) else : return rom_to_dec ( nombre_droite ) - dico [ nombre [ 0 ]] assert rom_to_dec ( \"CXLII\" ) == 142 Le slicing utilis\u00e9 ici n'est officiellement pas au programme en NSI... Markdown Les chiffres romains sont un syst\u00e8me ancien d\u2019\u00e9criture des nombres. Les chiffres romains sont: I, V, X, L, C, D, et M. Ces symboles repr\u00e9sentent respectivement 1, 5, 10, 50, 100, 500, et 1000 en base dix. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur sup\u00e9rieure ou \u00e9gale \u00e0 celui de droite, le nombre s\u2019obtient en additionnant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"XVI\" est le nombre 16 car X + VI = 10 + 6. Lorsque deux caract\u00e8res successifs sont tels que le caract\u00e8re plac\u00e9 \u00e0 gauche poss\u00e8de une valeur strictement inf\u00e9rieure \u00e0 celui de droite, le nombre s\u2019obtient en retranchant le caract\u00e8re de gauche \u00e0 la valeur de la cha\u00eene situ\u00e9e \u00e0 droite. Ainsi, \"CDIII\" est le nombre 403 car DIII \u2013 C = 503 \u2013 100. On dispose d\u2019un dictionnaire `dico` , \u00e0 compl\u00e9ter, o\u00f9 les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et o\u00f9 les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale. On souhaite cr\u00e9er une fonction r\u00e9cursive `rom_to_dec` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res (non vide) repr\u00e9sentant un nombre \u00e9crit en chiffres romains et renvoyant le nombre associ\u00e9 en \u00e9criture d\u00e9cimale : ```python linenums='1' def rom_to_dec(nombre): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" dico = {\"I\":1, \"V\":5, ...} if len(nombre) == 1: return ... else: ### on supprime le premier caract\u00e8re de la cha\u00eene contenue dans la variable nombre ### et cette nouvelle cha\u00eene est enregistr\u00e9e dans la variable nombre_droite nombre_droite = nombre[1:] if dico[nombre[0]] >= dico[nombre[1]]: return dico[nombre[0]] + ... else: return ... assert rom_to_dec(\"CXLII\") == 142 ```", "title": "Exercice 30.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-31", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 31"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-311", "text": "Exercice 31.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau t (type list ) et qui renvoie le nombre d'occurrences de a dans t . Exemples : \ud83d\udc0d Script Python >>> recherche ( 5 ,[]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 ,[ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 ,[ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( a , t ): nb = 0 for element in t : if element == a : nb += 1 return nb \ud83d\udccb Texte \u00c9crire en langage Python une fonction `recherche` prenant comme param\u00e8tres une variable `a` de type num\u00e9rique (`float` ou `int`) et un tableau `t` (type `list`) et qui renvoie le nombre d'occurrences de `a` dans `t`. Exemples : ```python >>> recherche(5,[]) 0 >>> recherche(5,[-2, 3, 4, 8]) 0 >>> recherche(5,[-2, 3, 1, 5, 3, 7, 4]) 1 >>> recherche(5,[-2, 5, 3, 5, 4, 5]) 3 ```", "title": "Exercice 31.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-312", "text": "Exercice 31.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction rendu_monnaie_centimes prend en param\u00e8tres deux nombres entiers positifs s_due et s_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence s_versee \u2013 s_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie_centimes(452, 500) renverra [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 centimes soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : \ud83d\udc0d Script Python >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie_centimes ( s_due , s_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = s_versee - s_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu Markdown La fonction `rendu_monnaie_centimes` prend en param\u00e8tres deux nombres entiers positifs `s_due` et` s_versee` et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence `s_versee \u2013 s_due` pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. La fonction renvoie la liste des pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en centimes d\u2019euros. Les valeurs possibles pour les pi\u00e8ces sont donc `[1, 2, 5, 10, 20, 50, 100, 200]` . Ainsi, l\u2019instruction `rendu_monnaie_centimes(452, 500)` renverra `[20, 20, 5, 2, 1]` . En effet, la somme \u00e0 rendre est de `48` centimes soit `20 + 20 + 5 + 2 + 1` . Le code de la fonction est donn\u00e9 ci-dessous : ```python linenums='1' def rendu_monnaie_centimes(s_due, s_versee): pieces = [1, 2, 5, 10, 20, 50, 100, 200] rendu = ... a_rendre = ... i = len(pieces) - 1 while a_rendre > ... : if pieces[i] <= a_rendre : rendu.append(...) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code pour qu'il donne : \ud83d\udc0d Script Python >>> rendu_monnaie_centimes ( 700 , 700 ) [] >>> rendu_monnaie_centimes ( 112 , 500 ) [ 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 ] ```", "title": "Exercice 31.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-32", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 32"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-321", "text": "Exercice 32.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ```", "title": "Exercice 32.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-322", "text": "Exercice 32.2 \u00c9nonc\u00e9 Correction Sources Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de `192.168.0.0` \u00e0 `192.168.0.255` . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP `192.168.0.0` et `192.168.0.255` sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe `AdresseIP` . ```python linenums='1' class AdresseIP: def __init__ (self, adresse): self.adresse = ... def liste_octet(self): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante(self): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254: octet_nouveau = ... + ... return AdresseIP('192.168.0.' + ...) else: return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' ```", "title": "Exercice 32.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-33", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 33"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-331", "text": "Exercice 33.1 \u00c9nonc\u00e9 Correction Source Markdown On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : \ud83d\udc0d Script Python def convertir ( T ): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" Exemple : \ud83d\udc0d Script Python >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def convertir ( T ): puissance = 0 total = 0 for i in range ( len ( T ) - 1 , - 1 , - 1 ): total += T [ i ] * ( 2 ** puissance ) puissance += 1 return total \ud83d\udccb Texte On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau `[1, 0, 1, 0, 0, 1, 1]` repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est `2**6 + 2**4 + 2**1 + 2**0 = 83`. \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : ```python def convertir(T): \"\"\" T est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau T \"\"\" ``` Exemple : ```python >>> convertir([1, 0, 1, 0, 0, 1, 1]) 83 >>> convertir([1, 0, 0, 0, 0, 0, 1, 0]) 130 ```", "title": "Exercice 33.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-332", "text": "Exercice 33.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_insertion suivante prend en argument une liste L et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if ... : return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > ... : i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , ... ): L [ k ] = L [ ... ] L [ i ] = ... return L Exemples : \ud83d\udc0d Script Python >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def tri_insertion ( L ): n = len ( L ) # cas du tableau vide if L == []: return L for j in range ( 1 , n ): e = L [ j ] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L [ i - 1 ] > e : i = i - 1 # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j : for k in range ( j , i , - 1 ): L [ k ] = L [ k - 1 ] L [ i ] = e return L Markdown La fonction `tri_insertion` suivante prend en argument une liste `L` et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. ```python linenums='1' def tri_insertion(L): n = len(L) # cas du tableau vide if ...: return L for j in range(1,n): e = L[j] i = j # A l'\u00e9tape j, le sous-tableau L[0,j-1] est tri\u00e9 # et on ins\u00e8re L[j] dans ce sous-tableau en d\u00e9terminant # le plus petit i tel que 0 <= i <= j et L[i-1] > L[j]. while i > 0 and L[i-1] > ...: i = ... # si i != j, on d\u00e9cale le sous tableau L[i,j-1] d\u2019un cran # vers la droite et on place L[j] en position i if i != j: for k in range(j,i,...): L[k] = L[...] L[i] = ... return L Exemples : \ud83d\udc0d Script Python >>> tri_insertion ([ 2 , 5 , - 1 , 7 , 0 , 28 ]) [ - 1 , 0 , 2 , 5 , 7 , 28 ] >>> tri_insertion ([ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ]) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ```", "title": "Exercice 33.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-34", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 34"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-341", "text": "Exercice 34.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction occurrence_max prenant en param\u00e8tres une cha\u00eene de caract\u00e8res chaine et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] et du tableau occurrence de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans occurrence[i] le nombre d\u2019apparitions de alphabet[i] dans la chaine. Puis on calculera l\u2019indice k d\u2019un maximum du tableau occurrence et on affichera alphabet[k] . Exemple : \ud83d\udc0d Script Python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max ( ch ) \u2018 e \u2019 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 alphabet = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o,' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' ] def occurrence_max ( chaine ): occurence = [ 0 ] * 26 for i in range ( 26 ): compteur = 0 for caractere in chaine : if caractere == alphabet [ i ]: compteur += 1 occurence [ i ] = compteur ind_max = 0 for i in range ( 26 ): if occurence [ i ] > occurence [ ind_max ]: ind_max = i return alphabet [ ind_max ] \ud83d\udccb Texte \u00c9crire une fonction `occurrence_max` prenant en param\u00e8tres une cha\u00eene de caract\u00e8res `chaine` et qui renvoie le caract\u00e8re le plus fr\u00e9quent de la cha\u00eene. La chaine ne contient que des lettres en minuscules sans accent. On pourra s\u2019aider du tableau `alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']` et du tableau `occurrence` de 26 \u00e9l\u00e9ments o\u00f9 l\u2019on mettra dans `occurrence[i]` le nombre d\u2019apparitions de `alphabet[i]` dans la chaine. Puis on calculera l\u2019indice `k` d\u2019un maximum du tableau `occurrence` et on affichera `alphabet[k]`. Exemple : ```python >>> ch = 'je suis en terminale et je passe le bac et je souhaite poursuivre des etudes pour devenir expert en informatique' >>> occurrence_max(ch) \u2018e\u2019 ```", "title": "Exercice 34.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-342", "text": "Exercice 34.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemple : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range ( len ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Compl\u00e9ter le programme ci-dessous : ```python linenums='1' def nbLig(image): '''renvoie le nombre de lignes de l'image''' return ... def nbCol(image): '''renvoie la largeur de l'image''' return ... def negatif(image): '''renvoie le n\u00e9gatif de l'image sous la forme d'une liste de listes''' L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] # on cr\u00e9\u00e9 une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range(len(image)): for j in range(...): L[i][j] = ... return L def binaire(image, seuil): '''renvoie une image binaris\u00e9e de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inf\u00e9rieure au seuil et 1 sinon''' L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] # on cr\u00e9e une image de 0 aux m\u00eames dimensions que le param\u00e8tre image for i in range(len(image)): for j in range(...): if image[i][j] < ... : L[i][j] = ... else: L[i][j] = ... return L Exemple : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 287 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , - 32 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( negatif ( img ), 120 ) [[ 1 , 1 , 0 , 0 , 1 ], [ 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 ], [ 0 , 1 , 1 , 0 , 0 ]] ```", "title": "Exercice 34.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-35", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 35"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-351", "text": "Exercice 35.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. \ud83d\udc0d Script Python def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] == 4 assert moyenne ([ 1 , 2 ]) == 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. ```python def moyenne (tab): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne([1]) == 1 assert moyenne([1, 2, 3, 4, 5, 6, 7] == 4 assert moyenne([1, 2]) == 1.5 ```", "title": "Exercice 35.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-352", "text": "Exercice 35.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False, 1 , False, 2 et False, 3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab = []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False , 3 Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide. L'algorithme est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient `False` en renvoyant `False, 1` , `False, 2` et `False, 3` . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ...: return False,1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if (x < tab[0]) or ...: return False, 2 debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) ```", "title": "Exercice 35.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-36", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 36"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-361", "text": "Exercice 36.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \ud83d\udccb Texte Programmer la fonction `recherche`, prenant en param\u00e8tre un tableau non vide `tab` (type `list`) d'entiers et un entier `n`, et qui renvoie l'indice de la **derni\u00e8re** occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples ```python >>> recherche([5, 3],1) 2 >>> recherche([2,4],2) 0 >>> recherche([2,3,5,2,4],2) 3 ```", "title": "Exercice 36.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-362", "text": "Exercice 36.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. On dispose d'une fonction distance et d'une fonction plus_courte_distance : \ud83d\udc0d Script Python from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" assert int ( point1 [ 0 ]) == point1 [ 0 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point1 [ 1 ]) == point1 [ 1 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point2 [ 0 ]) == point2 [ 0 ], \"coordonn\u00e9e non enti\u00e8re\" assert int ( point2 [ 1 ]) == point2 [ 1 ], \"coordonn\u00e9e non enti\u00e8re\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) assert distance (( 1 , 0 ), ( 5 , 3 )) == 5.0 , \"erreur de calcul\" def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point assert plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) == ( 2 , 5 ), \"erreur\" Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es $(x;y)$ et $(x';y')$ est donn\u00e9e par la formule : $$d=\\sqrt{(x-x')^2+(y-y')^2}$$ On importe pour cela la fonction racine carr\u00e9e ( `sqrt` ) du module `math` de Python. On dispose d'une fonction `distance` et d'une fonction `plus_courte_distance` : ```python from math import sqrt # import de la fonction racine carr\u00e9e def distance(point1, point2): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt((...)**2 + (...)**2) assert distance((1, 0), (5, 3)) == 5.0, \"erreur de calcul\" def plus_courte_distance(tab, depart): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab[0] min_dist = ... for i in range (1, ...): if distance(tab[i], depart)...: point = ... min_dist = ... return point assert plus_courte_distance([(7, 9), (2, 5), (5, 2)], (0, 0)) == (2, 5), \"erreur\" Recopier sous Python (sans les commentaires) ces deux fonctions puis compl\u00e9ter leur code et ajouter une ou des d\u00e9clarations ( assert ) \u00e0 la fonction distance permettant de v\u00e9rifier la ou les pr\u00e9conditions. ```", "title": "Exercice 36.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-37", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 37"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-371", "text": "Exercice 37.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction verifie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie True si ce tableau est tri\u00e9 dans l\u2019ordre croissant, False sinon. Exemples : \ud83d\udc0d Script Python Exemples : >>> verifie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> verifie ([ 8 , 12 , 4 ]) False >>> verifie ([ - 1 , 4 ]) True >>> verifie ([ 5 ]) True \ud83d\udc0d Script Python 1 2 3 4 5 def verifie ( tab ): for i in range ( 1 , len ( tab )): if tab [ i ] < tab [ i - 1 ]: return False return True \ud83d\udccb Texte Programmer la fonction `verifie` qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie `True` si ce tableau est tri\u00e9 dans l\u2019ordre croissant, `False` sinon. Exemples : ```python Exemples : >>> verifie([0, 5, 8, 8, 9]) True >>> verifie([8, 12, 4]) False >>> verifie([-1, 4]) True >>> verifie([5]) True ```", "title": "Exercice 37.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-372", "text": "Exercice 37.2 \u00c9nonc\u00e9 Correction Sources Markdown Chaque soir, les auditeurs d\u2019une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple : \ud83d\udc0d Script Python urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } # (1) >>> vainqueur ( election ) [ 'B' ] Attention, ceci est le bon r\u00e9sultat, le pdf officiel est erron\u00e9. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = {} for bulletin in urne : if bulletin in resultat : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : resultat [ bulletin ] = 1 return resultat def vainqueur ( election ): vainqueur = '' #(1) nmax = 0 for candidat in election : if election [ candidat ] > nmax : nmax = election [ candidat ] vainqueur = candidat #(2) liste_finale = [ nom for nom in election if election [ nom ] == nmax ] return liste_finale Il est pourtant tr\u00e8s d\u00e9conseill\u00e9 de nommer une variable avec le m\u00eame nom que la fonction qui la contient... Cette variable vainqueur est inutile, on ne s'en sert pas dans l'\u00e9laboration de la liste finale. Markdown Chaque soir, les auditeurs d\u2019une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple : ```python urne = ['A', 'A', 'A', 'B', 'C', 'B', 'C', 'B', 'C', 'B'] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } # (1) >>> vainqueur ( election ) [ 'B' ] Attention, ceci est le bon r\u00e9sultat, le pdf officiel est erron\u00e9. ```", "title": "Exercice 37.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-38", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 38"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-381", "text": "Exercice 38.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : \ud83d\udc0d Script Python >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \ud83d\udccb Texte \u00c9crire une fonction `tri_selection` qui prend en param\u00e8tre une liste `tab` de nombres entiers et qui renvoie le tableau tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : - on recherche le plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; - on recherche le second plus petit \u00e9l\u00e9ment du tableau, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; - on continue de cette fa\u00e7on jusqu'\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : ```python >>> tri_selection([1,52,6,-9,12]) [-9, 1, 6, 12, 52] ```", "title": "Exercice 38.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-382", "text": "Exercice 38.2 \u00c9nonc\u00e9 Correction Sources Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers, randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 99 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 1 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : - le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; - si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; - si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction `randint` est utilis\u00e9e. Si a et b sont des entiers, `randint(a,b)` renvoie un nombre entier compris entre `a` et `b` . Compl\u00e9ter le code ci-dessous et le tester : ```python linenums='1' from random import randint def plus_ou_moins(): nb_mystere = randint(1,...) nb_test = int(input(\"Proposez un nombre entre 1 et 99 : \")) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test: nb_test = int(input(\"Trop petit ! Testez encore : \")) else: nb_test = int(input(\"Trop grand ! Testez encore : \")) if nb_mystere == nb_test: print (\"Bravo ! Le nombre \u00e9tait \",...) print(\"Nombre d'essais: \",...) else: print (\"Perdu ! Le nombre \u00e9tait \",...) ```", "title": "Exercice 38.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-39", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 39"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-391", "text": "Exercice 39.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : \ud83d\udc0d Script Python >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` prenant en param\u00e8tres une liste d\u2019entiers et qui renvoie la moyenne des valeurs de cette liste. Exemple : ```python >>> moyenne([10,20,30,40,60,110]) 45.0 ```", "title": "Exercice 39.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-392", "text": "Exercice 39.2 \u00c9nonc\u00e9 Correction Sources Markdown On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom Markdown ![ image ]( data/272a.png ){: .center width=30%} On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction `affiche` permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction `zoomListe` prend en argument une liste `liste_depart` et un entier `k` . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de `liste_depart` est dupliqu\u00e9 `k` fois. La fonction `zoomDessin` prend en argument la grille `dessin` et renvoie une grille o\u00f9 toutes les lignes de `dessin` sont zoom\u00e9es `k` fois et r\u00e9p\u00e9t\u00e9es `k` fois. Soit le code ci-dessous : ```python linenums='1' coeur = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], \\ [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], \\ [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], \\ [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], \\ [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] def affiche(dessin): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin: for col in ligne: if col == 1: print(\" *\", end=\"\") else: print(\" \", end=\"\") print() def zoomListe(liste_depart,k): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range(k): ... return liste_zoom def zoomDessin(grille,k): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom=[] for elt in grille: liste_zoom = ... for i in range(k): ... .append(...) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ```", "title": "Exercice 39.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#sujet-40", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 40"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-401", "text": "Exercice 40.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre et tab un tableau de nombres, et qui renvoie le tableau des indices de elt dans tab si elt est dans tab et le tableau vide [] sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [ 0 , 3 ] >>> recherche ( 4 , [ 1 , 2 , 3 ]) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( elt , tab ): tab_indices = [] for i in range ( len ( tab )): if tab [ i ] == elt : tab_indices . append ( i ) return tab_indices \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre et `tab` un tableau de nombres, et qui renvoie le tableau des indices de `elt` dans `tab` si `elt` est dans `tab` et le tableau vide `[]` sinon. Exemples : ```python >>> recherche(3, [3, 2, 1, 3, 2, 1]) [0, 3] >>> recherche(4, [1, 2, 3]) [] ```", "title": "Exercice 40.1 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2022/#exercice-402", "text": "Exercice 40.2 \u00c9nonc\u00e9 Correction Sources Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 resultats = { 'Dupont' :{ 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ]}, 'Durand' :{ 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ]}} def moyenne ( nom ): if nom in resultats : notes = resultats [ nom ] total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : - les clefs sont les noms des \u00e9l\u00e8ves ; - les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients. Avec : ```python resultats = {'Dupont':{ 'DS1' : [15.5, 4], 'DM1' : [14.5, 1], 'DS2' : [13, 4], 'PROJET1' : [16, 3], 'DS3' : [14, 4]}, 'Durand':{ 'DS1' : [6 , 4], 'DM1' : [14.5, 1], 'DS2' : [8, 4], 'PROJET1' : [9, 3], 'IE1' : [7, 2], 'DS3' : [8, 4], 'DS4' :[15, 4]}} L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ces \u00e9l\u00e8ves et lui renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom ): if nom in ... : notes = resultats [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 ``` Remerciements pour le signalement et la correction des nombreuses erreurs : Alexandre Hainaut, No\u00e9 Pierre, Cyrille Jochault, S\u00e9bastien Rivillon, Cl\u00e9mentine et Laorine (AEFE Montr\u00e9al), Th\u00e9o EwzZer, Laurent Briend, Matteo Gaillard, Pierre Mouries.", "title": "Exercice 40.2 \u25a1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/", "text": "\u00c9preuve Pratique BNS 2023 \u2693\ufe0e Les sujets ci-dessous correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 25/01/2023 . T\u00e9l\u00e9chargements Une archive contenant les 45 dossiers (contenant chacun les deux fichiers .pdf et .py ) : BNS_2023.zip (2,9 Mo) Un pdf unique de tous les sujets : BNS_2023_pdf_unique.pdf (3,2 Mo) \u25b6 Sujet 01 \u2693\ufe0e Version originale du sujet en pdf. Exercice 01.1 \u2693\ufe0e Exercice 01.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction verifie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie True si ce tableau est tri\u00e9 dans l\u2019ordre croissant, False sinon. Exemples : \ud83d\udc0d Script Python Exemples : >>> verifie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> verifie ([ 8 , 12 , 4 ]) False >>> verifie ([ - 1 , 4 ]) True >>> verifie ([ 5 ]) True \ud83d\udc0d Script Python 1 2 3 4 5 def verifie ( tab ): for i in range ( 1 , len ( tab )): if tab [ i ] < tab [ i - 1 ]: return False return True \ud83d\udccb Texte Programmer la fonction `verifie` qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie `True` si ce tableau est tri\u00e9 dans l\u2019ordre croissant, `False` sinon. Exemples : ```python Exemples : >>> verifie([0, 5, 8, 8, 9]) True >>> verifie([8, 12, 4]) False >>> verifie([-1, 4]) True >>> verifie([5]) True ``` R\u00e9digez votre code sur Basthon Exercice 01.2 \u2693\ufe0e Exercice 01.2 \u00c9nonc\u00e9 Correction Sources Markdown Les r\u00e9sultats d'un vote ayant trois issues possibles 'A', 'B' et 'C' sont stock\u00e9s dans un tableau. Exemple : \ud83d\udc0d Script Python urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } >>> vainqueur ( election ) [ 'B' ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = {} for bulletin in urne : if bulletin in resultat : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : resultat [ bulletin ] = 1 return resultat def vainqueur ( election ): vainqueur = '' #(1) nmax = 0 for candidat in election : if election [ candidat ] > nmax : nmax = election [ candidat ] vainqueur = candidat #(2) liste_finale = [ nom for nom in election if election [ nom ] == nmax ] return liste_finale Il est pourtant tr\u00e8s d\u00e9conseill\u00e9 de nommer une variable avec le m\u00eame nom que la fonction qui la contient... Cette variable vainqueur est inutile, on ne s'en sert pas dans l'\u00e9laboration de la liste finale. Markdown Les r\u00e9sultats d'un vote ayant trois issues possibles 'A', 'B' et 'C' sont stock\u00e9s dans un tableau. Exemple : ```python urne = ['A', 'A', 'A', 'B', 'C', 'B', 'C', 'B', 'C', 'B'] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } >>> vainqueur ( election ) [ 'B' ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 02 \u2693\ufe0e Version originale du sujet en pdf. Exercice 02.1 \u2693\ufe0e Exercice 02.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction indices_maxi qui prend en param\u00e8tre une liste tab , non vide, de nombres entiers et renvoie un couple donnant d\u2019une part le plus grand \u00e9l\u00e9ment de cette liste et d\u2019autre part la liste des indices de la liste tab o\u00f9 appara\u00eet ce plus grand \u00e9l\u00e9ment. Exemple : \ud83d\udc0d Script Python >>> indices_maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , [ 3 , 8 ]) >>> indices_maxi ([ 7 ]) ( 7 , [ 0 ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def indices_maxi ( tab ): val_max = tab [ 0 ] ind_max = [] for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] for i in range ( len ( tab )): if tab [ i ] == val_max : ind_max . append ( i ) return ( val_max , ind_max ) \ud83d\udccb Texte \u00c9crire une fonction `indices_maxi` qui prend en param\u00e8tre une liste `tab`, non vide, de nombres entiers et renvoie un couple donnant d\u2019une part le plus grand \u00e9l\u00e9ment de cette liste et d\u2019autre part la liste des indices de la liste `tab` o\u00f9 appara\u00eet ce plus grand \u00e9l\u00e9ment. Exemple : ```python >>> indices_maxi([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) (9, [3, 8]) >>> indices_maxi([7]) (7, [0]) ``` R\u00e9digez votre code sur Basthon Exercice 02.2 \u2693\ufe0e Exercice 02.2 \u00c9nonc\u00e9 Correction Sources Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression liste_1 = list(liste) fait une copie de liste ind\u00e9pendante de liste , que l\u2019expression x = liste.pop() enl\u00e8ve le sommet de la pile liste et le place dans la variable x et, enfin, que l\u2019expression liste.append(v) place la valeur v au sommet de la pile liste . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile liste de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable liste . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def positif ( pile ): pile_1 = ... ( pile ) pile_2 = ... while pile_1 != []: x = ... if ... >= 0 : pile_2 . append ( ... ) while pile_2 != ... : x = pile_2 . pop () ... return pile_1 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) [ 0 , 5 , 4 , 10 , 9 ] >>> positif ([ - 2 ]) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def positif ( pile ): pile_1 = list ( pile ) pile_2 = [] while pile_1 != []: x = pile_1 . pop () if x >= 0 : pile_2 . append ( x ) while pile_2 != []: x = pile_2 . pop () pile_1 . append ( x ) return pile_1 Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type `list` ). On rappelle que l\u2019expression `liste_1 = list(liste)` fait une copie de `liste ` ind\u00e9pendante de `liste` , que l\u2019expression `x = liste.pop()` enl\u00e8ve le sommet de la pile `liste` et le place dans la variable `x` et, enfin, que l\u2019expression `liste.append(v)` place la valeur `v` au sommet de la pile `liste` . Compl\u00e9ter le code Python de la fonction `positif` ci-dessous qui prend une pile `liste` de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable `liste` . ```python linenums='1' def positif(pile): pile_1 = ...(pile) pile_2 = ... while pile_1 != []: x = ... if ... >= 0: pile_2.append(...) while pile_2 != ...: x = pile_2.pop() ... return pile_1 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) [ 0 , 5 , 4 , 10 , 9 ] >>> positif ([ - 2 ]) [] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 03 \u2693\ufe0e Version originale du sujet en pdf. Exercice 03.1 \u2693\ufe0e Exercice 03.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, les nombres sont des entiers ou des flottants. \u00c9crire une fonction moyenne renvoyant la moyenne pond\u00e9r\u00e9e d\u2019une liste non vide, pass\u00e9e en param\u00e8tre, de tuples \u00e0 deux \u00e9l\u00e9ments de la forme ( valeur , coefficient ) o\u00f9 valeur et coefficient sont des nombres positifs ou nuls. Si la somme des coefficients est nulle, la fonction renvoie None , si la somme des coefficients est non nulle, la fonction renvoie, sous forme de flottant, la moyenne des valeurs affect\u00e9es de leur coefficient. Exemple : \ud83d\udc0d Script Python >>> moyenne ([( 8 , 2 ), ( 12 , 0 ), ( 13.5 , 1 ), ( 5 , 0.5 )]) 9.142857142857142 >>> moyenne ([( 3 , 0 ), ( 5 , 0 )]) None Dans le premier exemple la moyenne est calcul\u00e9e par la formule : \\(\\dfrac{8 \\times 2 + 12 \\times 0 + 13,5 \\times 1 + 5 \\times 0,5}{2+0+1+0,5}\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme = 0 coeffs = 0 for couple in tab : somme += couple [ 0 ] * couple [ 1 ] coeffs += couple [ 1 ] if coeffs == 0 : return None return somme / coeffs \ud83d\udccb Texte Dans cet exercice, les nombres sont des entiers ou des flottants. \u00c9crire une fonction `moyenne` renvoyant la moyenne pond\u00e9r\u00e9e d\u2019une liste non vide, pass\u00e9e en param\u00e8tre, de tuples \u00e0 deux \u00e9l\u00e9ments de la forme (`valeur`, `coefficient`) o\u00f9 `valeur` et `coefficient` sont des nombres positifs ou nuls. Si la somme des coefficients est nulle, la fonction renvoie `None`, si la somme des coefficients est non nulle, la fonction renvoie, sous forme de flottant, la moyenne des valeurs affect\u00e9es de leur coefficient. Exemple : ```python >>> moyenne([(8, 2), (12, 0), (13.5, 1), (5, 0.5)]) 9.142857142857142 >>> moyenne([(3, 0), (5, 0)]) None ``` Dans le premier exemple la moyenne est calcul\u00e9e par la formule : $\\dfrac{8 \\times 2 + 12 \\times 0 + 13,5 \\times 1 + 5 \\times 0,5}{2+0+1+0,5}$ R\u00e9digez votre code sur Basthon Exercice 03.2 \u2693\ufe0e Exercice 03.2 \u00c9nonc\u00e9 Correction Sources Markdown On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom Markdown ![ image ]( data2023/03_coeur.png ){: .center width=30%} On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction `affiche` permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction `zoomListe` prend en argument une liste `liste_depart` et un entier `k` . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de `liste_depart` est dupliqu\u00e9 `k` fois. La fonction `zoomDessin` prend en argument la grille `dessin` et renvoie une grille o\u00f9 toutes les lignes de `dessin` sont zoom\u00e9es `k` fois et r\u00e9p\u00e9t\u00e9es `k` fois. Soit le code ci-dessous : ```python linenums='1' coeur = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], \\ [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], \\ [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], \\ [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], \\ [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] def affiche(dessin): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin: for col in ligne: if col == 1: print(\" *\", end=\"\") else: print(\" \", end=\"\") print() def zoomListe(liste_depart,k): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range(k): ... return liste_zoom def zoomDessin(grille,k): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom=[] for elt in grille: liste_zoom = ... for i in range(k): ... .append(...) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 04 \u2693\ufe0e Version originale du sujet en pdf. Exercice 04.1 \u2693\ufe0e Exercice 04.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction a_doublon qui prend en param\u00e8tre une liste tri\u00e9e de nombres et renvoie True si la liste contient au moins deux nombres identiques, False sinon. Par exemple : \ud83d\udc0d Script Python >>> a_doublon ([]) False >>> a_doublon ([ 1 ]) False >>> a_doublon ([ 1 , 2 , 4 , 6 , 6 ]) True >>> a_doublon ([ 2 , 5 , 7 , 7 , 7 , 9 ]) True >>> a_doublon ([ 0 , 2 , 3 ]) False \ud83d\udc0d Script Python 1 2 3 4 5 def a_doublon ( lst ): for i in range ( len ( lst ) - 1 ): if lst [ i ] == lst [ i + 1 ]: return True return False \ud83d\udccb Texte \u00c9crire une fonction `a_doublon` qui prend en param\u00e8tre une liste **tri\u00e9e** de nombres et renvoie `True` si la liste contient au moins deux nombres identiques, `False` sinon. Par exemple : ```python >>> a_doublon([]) False >>> a_doublon([1]) False >>> a_doublon([1, 2, 4, 6, 6]) True >>> a_doublon([2, 5, 7, 7, 7, 9]) True >>> a_doublon([0, 2, 3]) False ``` R\u00e9digez votre code sur Basthon Exercice 04.2 \u2693\ufe0e Exercice 04.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite g\u00e9n\u00e9rer des grilles du jeu de d\u00e9mineur \u00e0 partir de la position des bombes \u00e0 placer. On se limite \u00e0 la g\u00e9n\u00e9ration de grilles carr\u00e9es de taille \\(n \\times n\\) o\u00f9 \\(n\\) est le nombre de bombes du jeu. Dans le jeu du d\u00e9mineur, chaque case de la grille contient soit une bombe, soit une valeur qui correspond aux nombres de bombes situ\u00e9es dans le voisinage direct de la case (au- dessus, en dessous, \u00e0 droite, \u00e0 gauche ou en diagonale : chaque case a donc 8 voisins si elle n'est pas situ\u00e9e au bord de la grille). Voici un exemple de grille \\(5 \\times 5\\) de d\u00e9mineur dans laquelle la bombe est repr\u00e9sent\u00e9e par une \u00e9toile : On utilise une liste de listes pour repr\u00e9senter la grille et on choisit de coder une bombe par la valeur -1. L'exemple ci-contre sera donc cod\u00e9 par la liste : \ud83d\udc0d Script Python [[ 1 , 1 , 1 , 0 , 0 ], [ 1 , - 1 , 1 , 1 , 1 ], [ 2 , 2 , 3 , 2 , - 1 ], [ 1 , - 1 , 2 , - 1 , 3 ], [ 1 , 1 , 2 , 2 , - 1 ]] Compl\u00e9ter le code suivant afin de g\u00e9n\u00e9rer des grilles de d\u00e9mineur, on pourra v\u00e9rifier que l\u2019instruction genere_grille([(1, 1), (2, 4), (3, 1), (3, 3), (4, 4)]) produit bien la liste donn\u00e9e en exemple. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = ... for l , c in voisins : if grille [ l ][ c ] != ... : # si ce n'est pas une bombe ... # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = ... # place la bombe ... # incr\u00e9mente ses voisins return grille \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = voisinage ( len ( grille ), ligne , colonne ) for l , c in voisins : if grille [ l ][ c ] != - 1 : # si ce n'est pas une bombe grille [ l ][ c ] += 1 # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = - 1 # place la bombe incremente_voisins ( grille , ligne , colonne ) # incr\u00e9mente ses voisins return grille Markdown On souhaite g\u00e9n\u00e9rer des grilles du jeu de d\u00e9mineur \u00e0 partir de la position des bombes \u00e0 placer. On se limite \u00e0 la g\u00e9n\u00e9ration de grilles carr\u00e9es de taille $n \\times n$ o\u00f9 $n$ est le nombre de bombes du jeu. Dans le jeu du d\u00e9mineur, chaque case de la grille contient soit une bombe, soit une valeur qui correspond aux nombres de bombes situ\u00e9es dans le voisinage direct de la case (au- dessus, en dessous, \u00e0 droite, \u00e0 gauche ou en diagonale : chaque case a donc 8 voisins si elle n'est pas situ\u00e9e au bord de la grille). Voici un exemple de grille $5 \\times 5$ de d\u00e9mineur dans laquelle la bombe est repr\u00e9sent\u00e9e par une \u00e9toile : ![ image ]( data2023/04grille.png ){: .center} On utilise une liste de listes pour repr\u00e9senter la grille et on choisit de coder une bombe par la valeur -1. L'exemple ci-contre sera donc cod\u00e9 par la liste : ```python [[1, 1, 1, 0, 0], [1, -1, 1, 1, 1], [2, 2, 3, 2, -1], [1, -1, 2, -1, 3], [1, 1, 2, 2, -1]] Compl\u00e9ter le code suivant afin de g\u00e9n\u00e9rer des grilles de d\u00e9mineur, on pourra v\u00e9rifier que l\u2019instruction genere_grille([(1, 1), (2, 4), (3, 1), (3, 3), (4, 4)]) produit bien la liste donn\u00e9e en exemple. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = ... for l , c in voisins : if grille [ l ][ c ] != ... : # si ce n'est pas une bombe ... # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = ... # place la bombe ... # incr\u00e9mente ses voisins return grille ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 05 \u2693\ufe0e Version originale du sujet en pdf. Exercice 05.1 \u2693\ufe0e Exercice 05.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire en python deux fonctions : lancer de param\u00e8tre n , un entier positif, qui renvoie un tableau de type list de n entiers obtenus al\u00e9atoirement entre 1 et 6 (1 et 6 inclus) ; paire_6 de param\u00e8tre tab , un tableau de type list de n entiers entre 1 et 6 obtenus al\u00e9atoirement, qui renvoie un bool\u00e9en \u00e9gal \u00e0 True si le nombre de 6 est sup\u00e9rieur ou \u00e9gal \u00e0 2, False sinon. On pourra utiliser la fonction randint(a,b) du module random pour laquelle la documentation officielle est la suivante : Renvoie un entier al\u00e9atoire N tel que a <=N <= b. Exemples : \ud83d\udc0d Script Python >>> lancer1 = lancer ( 5 ) [ 5 , 6 , 6 , 2 , 2 ] >>> paire_6 ( lancer1 ) True >>> lancer2 = lancer ( 5 ) [ 6 , 5 , 1 , 6 , 6 ] >>> paire_6 ( lancer2 ) True >>> lancer3 = lancer ( 3 ) [ 2 , 2 , 6 ] >>> paire_6 ( lancer3 ) False >>> lancer4 = lancer ( 0 ) [] >>> paire_6 ( lancer4 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from random import randint def lancer ( n ): return [ randint ( 1 , 6 ) for _ in range ( n )] def paire_6 ( tab ): nb = 0 for elt in tab : if elt == 6 : nb += 1 if nb >= 2 : return True else : return False \ud83d\udccb Texte \u00c9crire en python deux fonctions : - `lancer` de param\u00e8tre `n`, un entier positif, qui renvoie un tableau de type `list` de `n` entiers obtenus al\u00e9atoirement entre 1 et 6 (1 et 6 inclus) ; - `paire_6` de param\u00e8tre `tab`, un tableau de type `list` de `n` entiers entre 1 et 6 obtenus al\u00e9atoirement, qui renvoie un bool\u00e9en \u00e9gal \u00e0 `True` si le nombre de 6 est sup\u00e9rieur ou \u00e9gal \u00e0 2, `False` sinon. On pourra utiliser la fonction `randint(a,b)` du module `random` pour laquelle la documentation officielle est la suivante : `Renvoie un entier al\u00e9atoire N tel que a <=N <= b.` Exemples : ```python >>> lancer1 = lancer(5) [5, 6, 6, 2, 2] >>> paire_6(lancer1) True >>> lancer2 = lancer(5) [6, 5, 1, 6, 6] >>> paire_6(lancer2) True >>> lancer3 = lancer(3) [2, 2, 6] >>> paire_6(lancer3) False >>> lancer4 = lancer(0) [] >>> paire_6(lancer4) False ``` R\u00e9digez votre code sur Basthon Exercice 05.2 \u2693\ufe0e Exercice 05.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Le n\u00e9gatif d\u2019une image est l\u2019image constitu\u00e9e des pixels x_n tels que x_n + x_i = 255 o\u00f9 x_i est le pixel correspondant de l\u2019image initiale. Compl\u00e9ter le programme suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] for i in range ( nbLig ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] for i in range ( nbLig ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemples : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 237 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , 18 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( img , 120 ) [[ 0 , 0 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 0 , 0 ], [ 1 , 0 , 0 , 1 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] for i in range ( nbLig ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] for i in range ( nbLig ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Le n\u00e9gatif d\u2019une image est l\u2019image constitu\u00e9e des pixels `x_n` tels que `x_n + x_i = 255` o\u00f9 `x_i` est le pixel correspondant de l\u2019image initiale. Compl\u00e9ter le programme suivant : ```python linenums='1' def nbLig(image): '''renvoie le nombre de lignes de l'image''' return ... def nbCol(image): '''renvoie la largeur de l'image''' return ... def negatif(image): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] for i in range(nbLig(image)): for j in range(...): L[i][j] = ... return L def binaire(image, seuil): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] for i in range(nbLig(image)): for j in range(...): if image[i][j] < ... : L[i][j] = ... else: L[i][j] = ... return L Exemples : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 237 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , 18 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( img , 120 ) [[ 0 , 0 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 0 , 0 ], [ 1 , 0 , 0 , 1 , 1 ]] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 06 \u2693\ufe0e Version originale du sujet en pdf. Exercice 06.1 \u2693\ufe0e Exercice 06.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \ud83d\udccb Texte Programmer la fonction `recherche`, prenant en param\u00e8tre un tableau non vide `tab` (type `list`) d'entiers et un entier `n`, et qui renvoie l'indice de la **derni\u00e8re** occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples ```python >>> recherche([5, 3],1) 2 >>> recherche([2,4],2) 0 >>> recherche([2,3,5,2,4],2) 3 ``` R\u00e9digez votre code sur Basthon Exercice 06.2 \u2693\ufe0e Exercice 06.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. Compl\u00e9ter le code des fonctions distance et plus_courte_distance fournies ci-dessous pour qu\u2019elles r\u00e9pondent \u00e0 leurs sp\u00e9cifications. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point Exemples : \ud83d\udc0d Script Python >>> distance (( 1 , 0 ), ( 5 , 3 )) 5.0 >>> distance (( 1 , 0 ), ( 0 , 1 )) 1.4142135623730951 >>> plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) ( 2 , 5 ) >>> plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 5 , 2 )) ( 5 , 2 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es $(x;y)$ et $(x';y')$ est donn\u00e9e par la formule : $$d=\\sqrt{(x-x')^2+(y-y')^2}$$ On importe pour cela la fonction racine carr\u00e9e ( `sqrt` ) du module `math` de Python. Compl\u00e9ter le code des fonctions `distance` et `plus_courte_distance` fournies ci-dessous pour qu\u2019elles r\u00e9pondent \u00e0 leurs sp\u00e9cifications. ```python linenums='1' from math import sqrt # import de la fonction racine carr\u00e9e def distance(point1, point2): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt((...)**2 + (...)**2) def plus_courte_distance(tab, depart): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab[0] min_dist = ... for i in range (1, ...): if distance(tab[i], depart)...: point = ... min_dist = ... return point Exemples : \ud83d\udc0d Script Python >>> distance (( 1 , 0 ), ( 5 , 3 )) 5.0 >>> distance (( 1 , 0 ), ( 0 , 1 )) 1.4142135623730951 >>> plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) ( 2 , 5 ) >>> plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 5 , 2 )) ( 5 , 2 ) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 07 \u2693\ufe0e Version originale du sujet en pdf. Exercice 07.1 \u2693\ufe0e Exercice 07.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction fusion prenant en param\u00e8tres deux tableaux non vides tab1 et tab2 (type list ) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de tab1 et tab2 . Exemples : \ud83d\udc0d Script Python >>> fusion ([ 3 , 5 ], [ 2 , 5 ]) [ 2 , 3 , 5 , 5 ] >>> fusion ([ - 2 , 4 ], [ - 3 , 5 , 10 ]) [ - 3 , - 2 , 4 , 5 , 10 ] >>> fusion ([ 4 ], [ 2 , 6 ]) [ 2 , 4 , 6 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fusion ( tab1 , tab2 ): tab_fusion = [] i1 = 0 i2 = 0 while i1 < len ( tab1 ) and i2 < len ( tab2 ): if tab1 [ i1 ] < tab2 [ i2 ]: tab_fusion . append ( tab1 [ i1 ]) i1 += 1 else : tab_fusion . append ( tab2 [ i2 ]) i2 += 1 if i1 == len ( tab1 ): while i2 < len ( tab2 ): tab_fusion . append ( tab2 [ i2 ]) i2 += 1 else : while i1 < len ( tab1 ): tab_fusion . append ( tab1 [ i1 ]) i1 += 1 return tab_fusion \ud83d\udccb Texte Programmer la fonction `fusion` prenant en param\u00e8tres deux tableaux non vides `tab1` et `tab2` (type `list`) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de `tab1` et `tab2`. Exemples : ```python >>> fusion([3, 5], [2, 5]) [2, 3, 5, 5] >>> fusion([-2, 4], [-3, 5, 10]) [-3, -2, 4, 5, 10] >>> fusion([4], [2, 6]) [2, 4, 6] ``` R\u00e9digez votre code sur Basthon Exercice 07.2 \u2693\ufe0e Exercice 07.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de cet exercice est d\u2019\u00e9crire une fonction r\u00e9cursive traduire_romain qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res, non vide, repr\u00e9sentant un nombre \u00e9crit en chiffres romains et qui renvoie son \u00e9criture d\u00e9cimale. Les chiffres romains consid\u00e9r\u00e9s sont : I, V, X, L, C, D et M. Ils repr\u00e9sentent respectivement les nombres 1, 5, 10, 50, 100, 500, et 1000 en base dix. On dispose d\u2019un dictionnaire romains dont les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale : romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000} Le code de la fonction traduire_romain fournie repose sur le principe suivant : la valeur d\u2019un caract\u00e8re est ajout\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur sup\u00e9rieure (ou \u00e9gale) \u00e0 celle du caract\u00e8re qui le suit ; la valeur d\u2019un caract\u00e8re est retranch\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur strictement inf\u00e9rieure \u00e0 celle du caract\u00e8re qui le suit. Ainsi, XIV correspond au nombre 10 + 5 - 1 puisque : la valeur de X (10) est sup\u00e9rieure \u00e0 celle de I (1), on ajoute donc 10 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire IV ; la valeur de I (1) est strictement inf\u00e9rieure \u00e0 celle de V (5), on soustrait donc 1 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire V. On rappelle que pour priver une cha\u00eene de caract\u00e8res de son premier caract\u00e8re, on utilisera l\u2019instruction : nom_de_variable[1:] Par exemple, si la variable mot contient la cha\u00eene \"CDI\" , mot[1:] renvoie \"DI\" . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 romains = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } def traduire_romain ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len ( nombre ) == 1 : return ... elif romains [ nombre [ 0 ]] >= ... return romains [ nombre [ 0 ]] + ... else : return ... Compl\u00e9ter le code de la fonction traduire_romain et le tester. Exemples : \ud83d\udc0d Script Python >>> traduire_romain ( \"XIV\" ) 14 >>> traduire_romain ( \"CXLII\" ) 142 >>> traduire_romain ( \"MMXXIII\" ) 2023 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 romains = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } def traduire_romain ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len ( nombre ) == 1 : return romains [ nombre ] elif romains [ nombre [ 0 ]] >= romains [ nombre [ 1 ]]: return romains [ nombre [ 0 ]] + traduire_romain ( nombre [ 1 :]) else : return traduire_romain ( nombre [ 1 :]) - romains [ nombre [ 0 ]] Markdown Le but de cet exercice est d\u2019\u00e9crire une fonction r\u00e9cursive `traduire_romain` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res, non vide, repr\u00e9sentant un nombre \u00e9crit en chiffres romains et qui renvoie son \u00e9criture d\u00e9cimale. Les chiffres romains consid\u00e9r\u00e9s sont : I, V, X, L, C, D et M. Ils repr\u00e9sentent respectivement les nombres 1, 5, 10, 50, 100, 500, et 1000 en base dix. On dispose d\u2019un dictionnaire `romains` dont les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale : `romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000}` Le code de la fonction `traduire_romain` fournie repose sur le principe suivant : - la valeur d\u2019un caract\u00e8re est ajout\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur sup\u00e9rieure (ou \u00e9gale) \u00e0 celle du caract\u00e8re qui le suit ; - la valeur d\u2019un caract\u00e8re est retranch\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur strictement inf\u00e9rieure \u00e0 celle du caract\u00e8re qui le suit. Ainsi, XIV correspond au nombre 10 + 5 - 1 puisque : - la valeur de X (10) est sup\u00e9rieure \u00e0 celle de I (1), on ajoute donc 10 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire IV ; - la valeur de I (1) est strictement inf\u00e9rieure \u00e0 celle de V (5), on soustrait donc 1 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire V. On rappelle que pour priver une cha\u00eene de caract\u00e8res de son premier caract\u00e8re, on utilisera l\u2019instruction : `nom_de_variable[1:]` Par exemple, si la variable `mot` contient la cha\u00eene `\"CDI\"` , `mot[1:]` renvoie `\"DI\"` . ```python linenums='1' romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000} def traduire_romain(nombre): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len(nombre) == 1: return ... elif romains[nombre[0]] >= ... return romains[nombre[0]] + ... else: return ... Compl\u00e9ter le code de la fonction traduire_romain et le tester. Exemples : \ud83d\udc0d Script Python >>> traduire_romain ( \"XIV\" ) 14 >>> traduire_romain ( \"CXLII\" ) 142 >>> traduire_romain ( \"MMXXIII\" ) 2023 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 08 \u2693\ufe0e Version originale du sujet en pdf. Exercice 08.1 \u2693\ufe0e Exercice 08.1 \u00c9nonc\u00e9 Correction Source Markdown Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : \ud83d\udc0d Script Python >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def max_dico ( dico ): cle_max = '' val_max = 0 for cle in dico : if dico [ cle ] > val_max : val_max = dico [ cle ] cle_max = cle return ( cle_max , val_max ) \ud83d\udccb Texte Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : `{'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}` \u00c9crire une fonction `max_dico` qui : - Prend en param\u00e8tre un dictionnaire `dico` non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; - Renvoie un tuple dont : - La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; - La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : ```python >>> max_dico({'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}) ('Ada', 201) >>> max_dico({'Alan': 222, 'Ada': 201, 'Eve': 220, 'Tim': 50}) ('Alan', 222) ``` R\u00e9digez votre code sur Basthon Exercice 08.2 \u2693\ufe0e Exercice 08.2 \u00c9nonc\u00e9 Correction Sources Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... Exemple : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for element in tab : if element != '+' and element != '*' : p . empiler ( element ) else : if element == '+' : resultat = p . depiler () + p . depiler () else : resultat = p . depiler () * p . depiler () p . empiler ( resultat ) return p . depiler () Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : - Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; - Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. - \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe `Pile` qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction `eval_expression` qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. ```python linenums='1' class Pile: \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ (self): self.contenu = [] def est_vide(self): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self.contenu == [] def empiler(self, v): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self.contenu.append(v) def depiler(self): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self.est_vide(): return self.contenu.pop() def eval_expression(tab): p = Pile() for ... in tab: if element != '+' ... element != '*': p.empiler(...) else: if element == ...: resultat = p.depiler() + ... else: resultat = ... p.empiler(...) return ... Exemple : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 09 \u2693\ufe0e Version originale du sujet en pdf. Exercice 09.1 \u2693\ufe0e Exercice 09.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : ```python >>> multiplication(3,5) 15 >>> multiplication(-4,-8) 32 >>> multiplication(-2,6) -12 >>> multiplication(-2,0) 0 ``` R\u00e9digez votre code sur Basthon Exercice 09.2 \u2693\ufe0e Exercice 09.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit tab un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher ci-dessous doit renvoyer un indice o\u00f9 la valeur n appara\u00eet dans tab si cette valeur y figure et None sinon. Les param\u00e8tres de la fonction sont : tab , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. L\u2019algorithme demand\u00e9 est une recherche dichotomique r\u00e9cursive. Recopier et compl\u00e9ter le code de la fonction chercher suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def chercher ( tab , n , i , j ): if i < 0 or j > len ( tab ) : return None if i > j : return None m = ( i + j ) // ... if ... < n : return chercher ( tab , n , ... , ... ) elif ... > n : return chercher ( tab , n , ... , ... ) else : return ... L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def chercher ( tab , n , i , j ): if i < 0 or j > len ( tab ) : return None if i > j : return None m = ( i + j ) // 2 if tab [ m ] < n : return chercher ( tab , n , m + 1 , j ) elif tab [ m ] > n : return chercher ( tab , n , i , m - 1 ) else : return m Markdown Soit `tab` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher` ci-dessous doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet dans `tab` si cette valeur y figure et `None` sinon. Les param\u00e8tres de la fonction sont : - `tab` , le tableau dans lequel s'effectue la recherche ; - `n` , l'entier \u00e0 chercher dans le tableau ; - `i` , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j` , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. L\u2019algorithme demand\u00e9 est une recherche dichotomique r\u00e9cursive. Recopier et compl\u00e9ter le code de la fonction `chercher` suivante : ```python linenums='1' def chercher(tab, n, i, j): if i < 0 or j > len(tab) : return None if i > j : return None m = (i + j) // ... if ... < n : return chercher(tab, n, ... , ...) elif ... > n : return chercher(tab, n, ... , ... ) else : return ... L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 10 \u2693\ufe0e Version originale du sujet en pdf. Exercice 10.1 \u2693\ufe0e Exercice 10.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire la fonction maxliste , prenant en param\u00e8tre un tableau non vide de nombres tab (de type list ) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : \ud83d\udc0d Script Python >>> maxliste ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maxliste ([ - 27 , 24 , - 3 , 15 ]) 24 \ud83d\udc0d Script Python 1 2 3 4 5 6 def maxliste ( tab ): maximum = tab [ 0 ] for element in tab : if element > maximum : maximum = element return maximum \ud83d\udccb Texte \u00c9crire la fonction `maxliste`, prenant en param\u00e8tre un tableau non vide de nombres `tab` (de type `list`) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : ```python >>> maxliste([98, 12, 104, 23, 131, 9]) 131 >>> maxliste([-27, 24, -3, 15]) 24 ``` R\u00e9digez votre code sur Basthon Exercice 10.2 \u2693\ufe0e Exercice 10.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, ((()())(())) est un parenth\u00e9sage correct. Les parenth\u00e9sages ())(() et (())(() sont, eux, incorrects. On dispose du code de la classe Pile suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self ): self . valeurs = [] def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res ch form\u00e9e de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () Compl\u00e9ter le code de la fonction parenthesage . Exemples : \ud83d\udc0d Script Python >>> parenthesage ( \"((()())(()))\" ) True >>> parenthesage ( \"())(()\" ) False >>> parenthesage ( \"(())(()\" ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self ): self . valeurs = [] def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == '(' : p . empiler ( c ) elif c == ')' : if p . est_vide (): return False else : p . depiler () return p . est_vide () Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : - le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. - en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, `((()())(()))` est un parenth\u00e9sage correct. Les parenth\u00e9sages `())(()` et `(())(()` sont, eux, incorrects. On dispose du code de la classe `Pile` suivant : ```python linenums='1' class Pile: \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ (self): self.valeurs = [] def est_vide(self): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self.valeurs == [] def empiler(self, c): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self.valeurs.append(c) def depiler(self): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self.est_vide() == False: self.valeurs.pop() On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res ch form\u00e9e de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () Compl\u00e9ter le code de la fonction parenthesage . Exemples : \ud83d\udc0d Script Python >>> parenthesage ( \"((()())(()))\" ) True >>> parenthesage ( \"())(()\" ) False >>> parenthesage ( \"(())(()\" ) False ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 11 \u2693\ufe0e Version originale du sujet en pdf. Exercice 11.1 \u2693\ufe0e Exercice 11.1 \u00c9nonc\u00e9 Correction Source Markdown On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : \ud83d\udc0d Script Python def convertir ( tab ): \"\"\" tab est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau tab \"\"\" Exemple : \ud83d\udc0d Script Python >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def convertir ( tab ): puissance = 0 total = 0 for i in range ( len ( tab ) - 1 , - 1 , - 1 ): total += tab [ i ] * ( 2 ** puissance ) puissance += 1 return total \ud83d\udccb Texte On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau `[1, 0, 1, 0, 0, 1, 1]` repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est `2**6 + 2**4 + 2**1 + 2**0 = 83`. \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction `convertir` r\u00e9pondant aux sp\u00e9cifications suivantes : ```python def convertir(tab): \"\"\" tab est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau tab \"\"\" ``` Exemple : ```python >>> convertir([1, 0, 1, 0, 0, 1, 1]) 83 >>> convertir([1, 0, 0, 0, 0, 0, 1, 0]) 130 ``` R\u00e9digez votre code sur Basthon Exercice 11.2 \u2693\ufe0e Exercice 11.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_insertion suivante prend en argument une liste tab et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. On rappelle le principe du tri par insertion : on consid\u00e8re les \u00e9l\u00e9ments \u00e0 trier un par un, le premier \u00e9l\u00e9ment constituant, \u00e0 lui tout seul, une liste tri\u00e9e de longueur 1. On range ensuite le second \u00e9l\u00e9ment pour constituer une liste tri\u00e9e de longueur 2, puis on range le troisi\u00e8me \u00e9l\u00e9ment pour avoir une liste tri\u00e9e de longueur 3 et ainsi de suite\u2026 A chaque \u00e9tape, le premier \u00e9l\u00e9ment de la sous-liste non tri\u00e9e est plac\u00e9 dans la sous-liste des \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s de sorte que cette sous-liste demeure tri\u00e9e. Le principe du tri par insertion est donc d'ins\u00e9rer \u00e0 la n-i\u00e8me it\u00e9ration, le n-i\u00e8me \u00e9l\u00e9ment \u00e0 la bonne place. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tri_insertion ( tab ): n = len ( tab ) for i in range ( 1 , n ): valeur_insertion = tab [ ... ] # la variable j sert \u00e0 d\u00e9terminer o\u00f9 placer la valeur \u00e0 ranger j = ... # tant qu'on a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer # on d\u00e9cale les valeurs du tableau vers la droite while j > ... and valeur_insertion < tab [ ... ]: tab [ j ] = tab [ j - 1 ] j = ... tab [ j ] = ... Exemples : \ud83d\udc0d Script Python >>> liste = [ 9 , 5 , 8 , 4 , 0 , 2 , 7 , 1 , 10 , 3 , 6 ] >>> tri_insertion ( liste ) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tri_insertion ( tab ): n = len ( tab ) for i in range ( 1 , n ): valeur_insertion = tab [ i ] # la variable j sert \u00e0 d\u00e9terminer o\u00f9 placer la valeur \u00e0 ranger j = i # tant qu'on a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer # on d\u00e9cale les valeurs du tableau vers la droite while j > 0 and valeur_insertion < tab [ j - 1 ]: tab [ j ] = tab [ j - 1 ] j = j - 1 tab [ j ] = valeur_insertion Markdown La fonction `tri_insertion` suivante prend en argument une liste `tab` et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. On rappelle le principe du tri par insertion : on consid\u00e8re les \u00e9l\u00e9ments \u00e0 trier un par un, le premier \u00e9l\u00e9ment constituant, \u00e0 lui tout seul, une liste tri\u00e9e de longueur 1. On range ensuite le second \u00e9l\u00e9ment pour constituer une liste tri\u00e9e de longueur 2, puis on range le troisi\u00e8me \u00e9l\u00e9ment pour avoir une liste tri\u00e9e de longueur 3 et ainsi de suite\u2026 A chaque \u00e9tape, le premier \u00e9l\u00e9ment de la sous-liste non tri\u00e9e est plac\u00e9 dans la sous-liste des \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s de sorte que cette sous-liste demeure tri\u00e9e. Le principe du tri par insertion est donc d'ins\u00e9rer \u00e0 la n-i\u00e8me it\u00e9ration, le n-i\u00e8me \u00e9l\u00e9ment \u00e0 la bonne place. ```python linenums='1' def tri_insertion(tab): n = len(tab) for i in range(1, n): valeur_insertion = tab[...] # la variable j sert \u00e0 d\u00e9terminer o\u00f9 placer la valeur \u00e0 ranger j = ... # tant qu'on a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer # on d\u00e9cale les valeurs du tableau vers la droite while j > ... and valeur_insertion < tab[...]: tab[j] = tab[j-1] j = ... tab[j] = ... Exemples : \ud83d\udc0d Script Python >>> liste = [ 9 , 5 , 8 , 4 , 0 , 2 , 7 , 1 , 10 , 3 , 6 ] >>> tri_insertion ( liste ) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 12 \u2693\ufe0e Version originale du sujet en pdf. Exercice 12.1 \u2693\ufe0e Exercice 12.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re la classe ABR , dont le constructeur est le suivant : \ud83d\udc0d Script Python class ABR : def __init__ ( self , g0 , v0 , d0 ): self . gauche = g0 self . cle = v0 self . droit = d0 def __repr__ ( self ): if self is None : return '' else : return '(' + ( self . gauche ) . __repr__ () + ',' + str ( self . cle ) + ',' + ( self . droit ) . __repr__ () + ')' Ainsi, l\u2019arbre binaire de recherche abr1 ci- contre est cr\u00e9\u00e9 par le code python ci- dessous \ud83d\udc0d Script Python n0 = ABR ( None , 0 , None ) n3 = ABR ( None , 3 , None ) n2 = ABR ( None , 2 , n3 ) n3 = ABR ( n0 , 1 , n2 ) Dans tout le code, None correspondra \u00e0 un arbre vide. La classe ABR dispose aussi d\u2019une m\u00e9thode de repr\u00e9sentation ( __repr__ ), qui affiche entre parenth\u00e8ses le contenu du sous arbre gauche, puis la cl\u00e9 de l\u2019arbre, et enfin le contenu du sous arbre droit. Elle s\u2019utilise en console de la mani\u00e8re suivante : \ud83d\udc0d Script Python >>> abr1 (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) \u00c9crire une fonction r\u00e9cursive ajoute(cle, a) qui prend en param\u00e8tres une cl\u00e9 cle et un arbre binaire de recherche a , et qui renvoie un arbre binaire de recherche dans lequel cle a \u00e9t\u00e9 ins\u00e9r\u00e9e. Dans le cas o\u00f9 cle est d\u00e9j\u00e0 pr\u00e9sente dans a , la fonction renvoie l\u2019arbre a inchang\u00e9. R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> a = ajoute ( 4 , abr1 ) >>> a (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 ,( None , 4 , None )))) >>> ajoute ( - 5 , abr1 ) ((( None , - 5 , None ), 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) >>> ajoute ( 2 , abr1 ) (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def ajoute ( cle , a ): if a is None : a = ABR ( None , cle , None ) elif cle > a . cle : a . droit = ajoute ( cle , a . droit ) elif cle < a . cle : a . gauche = ajoute ( cle , a . gauche ) return a \ud83d\udccb Texte On consid\u00e8re la classe `ABR`, dont le constructeur est le suivant : ```python class ABR: def __init__(self, g0, v0, d0): self.gauche = g0 self.cle = v0 self.droit = d0 def __repr__(self): if self is None: return '' else: return '(' + (self.gauche).__repr__() + ',' + str(self.cle) + ',' +(self.droit).__repr__() + ')' ``` ![image](data2023/12_arbre.png){: .center width=30%} Ainsi, l\u2019arbre binaire de recherche `abr1` ci- contre est cr\u00e9\u00e9 par le code python ci- dessous ```python n0 = ABR(None, 0, None) n3 = ABR(None, 3, None) n2 = ABR(None, 2, n3) n3 = ABR(n0, 1, n2) ``` Dans tout le code, `None` correspondra \u00e0 un arbre vide. La classe `ABR` dispose aussi d\u2019une m\u00e9thode de repr\u00e9sentation (```__repr__``` ), qui affiche entre parenth\u00e8ses le contenu du sous arbre gauche, puis la cl\u00e9 de l\u2019arbre, et enfin le contenu du sous arbre droit. Elle s\u2019utilise en console de la mani\u00e8re suivante : ```python >>> abr1 ((None,0,None),1,(None,2,(None,3,None))) ``` \u00c9crire une fonction r\u00e9cursive `ajoute(cle, a)` qui prend en param\u00e8tres une cl\u00e9 `cle` et un arbre binaire de recherche ```a``` , et qui renvoie un arbre binaire de recherche dans lequel `cle` a \u00e9t\u00e9 ins\u00e9r\u00e9e. Dans le cas o\u00f9 `cle` est d\u00e9j\u00e0 pr\u00e9sente dans `a`, la fonction renvoie l\u2019arbre `a` inchang\u00e9. R\u00e9sultats \u00e0 obtenir : ```python >>> a = ajoute(4, abr1) >>> a ((None,0,None),1,(None,2,(None,3,(None,4,None)))) >>> ajoute(-5, abr1) (((None,-5,None),0,None),1,(None,2,(None,3,None))) >>> ajoute(2, abr1) ((None,0,None),1,(None,2,(None,3,None))) ``` R\u00e9digez votre code sur Basthon Exercice 12.2 \u2693\ufe0e Exercice 12.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019un ensemble d\u2019objets dont on conna\u00eet, pour chacun, la masse. On souhaite ranger l\u2019ensemble de ces objets dans des boites identiques de telle mani\u00e8re que la somme des masses des objets contenus dans une bo\u00eete ne d\u00e9passe pas la capacit\u00e9 c de la bo\u00eete. On souhaite utiliser le moins de bo\u00eetes possibles pour ranger cet ensemble d\u2019objets. Pour r\u00e9soudre ce probl\u00e8me, on utilisera un algorithme glouton consistant \u00e0 placer chacun des objets dans la premi\u00e8re bo\u00eete o\u00f9 cela est possible. Par exemple, pour ranger dans des bo\u00eetes de capacit\u00e9 c = 5 un ensemble de trois objets dont les masses sont repr\u00e9sent\u00e9es en Python par la liste [1, 5, 2] , on proc\u00e8de de la fa\u00e7on suivante : Le premier objet, de masse 1, va dans une premi\u00e8re boite. Le deuxi\u00e8me objet, de masse 5, ne peut pas aller dans la m\u00eame boite que le premier objet car cela d\u00e9passerait la capacit\u00e9 de la boite. On place donc cet objet dans une deuxi\u00e8me bo\u00eete. Le troisi\u00e8me objet, de masse 2, va dans la premi\u00e8re bo\u00eete. On a donc utilis\u00e9 deux bo\u00eetes de capacit\u00e9 c = 5 pour ranger les 3 objets. Compl\u00e9ter la fonction Python empaqueter(liste_masses, c) suivante pour qu\u2019elle renvoie le nombre de bo\u00eetes de capacit\u00e9 c n\u00e9cessaires pour empaqueter un ensemble d\u2019objets dont les masses sont contenues dans la liste liste_masses . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def empaqueter ( liste_masses , c ): n = len ( liste_masses ) nb_boites = 0 boites = [ 0 ] * n for masse in ... : i = 0 while i <= nb_boites and boites [ i ] + ... > C : i = i + 1 if i == nb_boites + 1 : ... boites [ i ] = ... return ... Tester ensuite votre fonction : \ud83d\udc0d Script Python >>> empaqueter ([ 7 , 6 , 3 , 4 , 8 , 5 , 9 , 2 ], 11 ) 5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def empaqueterR ( liste_masses , c ): n = len ( liste_masses ) nb_boites = 0 boites = [ 0 ] * n for masse in liste_masses : i = 0 while i <= nb_boites and boites [ i ] + masse > c : i = i + 1 if i == nb_boites + 1 : nb_boites = nb_boites + 1 boites [ i ] = boites [ i ] + masse return nb_boites + 1 Markdown On dispose d\u2019un ensemble d\u2019objets dont on conna\u00eet, pour chacun, la masse. On souhaite ranger l\u2019ensemble de ces objets dans des boites identiques de telle mani\u00e8re que la somme des masses des objets contenus dans une bo\u00eete ne d\u00e9passe pas la capacit\u00e9 `c` de la bo\u00eete. On souhaite utiliser le moins de bo\u00eetes possibles pour ranger cet ensemble d\u2019objets. Pour r\u00e9soudre ce probl\u00e8me, on utilisera un algorithme glouton consistant \u00e0 placer chacun des objets dans la premi\u00e8re bo\u00eete o\u00f9 cela est possible. Par exemple, pour ranger dans des bo\u00eetes de capacit\u00e9 `c = 5` un ensemble de trois objets dont les masses sont repr\u00e9sent\u00e9es en Python par la liste `[1, 5, 2]` , on proc\u00e8de de la fa\u00e7on suivante : - Le premier objet, de masse 1, va dans une premi\u00e8re boite. - Le deuxi\u00e8me objet, de masse 5, ne peut pas aller dans la m\u00eame boite que le premier objet car cela d\u00e9passerait la capacit\u00e9 de la boite. On place donc cet objet dans une deuxi\u00e8me bo\u00eete. - Le troisi\u00e8me objet, de masse 2, va dans la premi\u00e8re bo\u00eete. On a donc utilis\u00e9 deux bo\u00eetes de capacit\u00e9 `c = 5` pour ranger les 3 objets. Compl\u00e9ter la fonction Python `empaqueter(liste_masses, c)` suivante pour qu\u2019elle renvoie le nombre de bo\u00eetes de capacit\u00e9 c n\u00e9cessaires pour empaqueter un ensemble d\u2019objets dont les masses sont contenues dans la liste `liste_masses` . ```python linenums='1' def empaqueter(liste_masses, c): n = len(liste_masses) nb_boites = 0 boites = [0]*n for masse in ... : i = 0 while i <= nb_boites and boites[i] + ... > C: i = i + 1 if i == nb_boites + 1: ... boites[i] = ... return ... Tester ensuite votre fonction : \ud83d\udc0d Script Python >>> empaqueter ([ 7 , 6 , 3 , 4 , 8 , 5 , 9 , 2 ], 11 ) 5 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 13 \u2693\ufe0e Version originale du sujet en pdf. Exercice 13.1 \u2693\ufe0e Exercice 13.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau tab (type list ) et qui renvoie le nombre d'occurrences de a dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ( 5 , []) 0 >>> recherche ( 5 , [ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 , [ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 , [ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( a , tab ): nb = 0 for element in tab : if element == a : nb += 1 return nb \ud83d\udccb Texte \u00c9crire en langage Python une fonction `recherche` prenant comme param\u00e8tres une variable `a` de type num\u00e9rique (`float` ou `int`) et un tableau `tab` (type `list`) et qui renvoie le nombre d'occurrences de `a` dans `tab`. Exemples : ```python >>> recherche(5, []) 0 >>> recherche(5, [-2, 3, 4, 8]) 0 >>> recherche(5, [-2, 3, 1, 5, 3, 7, 4]) 1 >>> recherche(5, [-2, 5, 3, 5, 4, 5]) 3 ``` R\u00e9digez votre code sur Basthon Exercice 13.2 \u2693\ufe0e Exercice 13.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction rendu_monnaie prend en param\u00e8tres deux nombres entiers positifs somme_due et somme_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence somme_versee \u2013 somme_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme glouton qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. Par la suite, on assimilera les billets \u00e0 des pi\u00e8ces. La fonction rendu_monnaie renvoie un tableau de type list contenant les pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie(452, 500) renvoie le tableau [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 euros soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction rendu_monnaie est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie ( somme_due , somme_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code et le tester : \ud83d\udc0d Script Python >>> rendu_monnaie ( 700 , 700 ) [] >>> rendu_monnaie ( 102 , 500 ) [ 200 , 100 , 50 , 20 , 20 , 5 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie ( somme_due , somme_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = somme_versee - somme_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu Markdown La fonction `rendu_monnaie` prend en param\u00e8tres deux nombres entiers positifs `somme_due` et `somme_versee` et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence `somme_versee \u2013 somme_due` pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme glouton qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. Par la suite, on assimilera les billets \u00e0 des pi\u00e8ces. La fonction `rendu_monnaie` renvoie un tableau de type `list` contenant les pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en euros. Les valeurs possibles pour les pi\u00e8ces sont donc `[1, 2, 5, 10, 20, 50, 100, 200]` . Ainsi, l\u2019instruction `rendu_monnaie(452, 500)` renvoie le tableau `[20, 20, 5, 2, 1]` . En effet, la somme \u00e0 rendre est de `48` euros soit `20 + 20 + 5 + 2 + 1` . Le code de la fonction `rendu_monnaie` est donn\u00e9 ci-dessous : ```python linenums='1' def rendu_monnaie(somme_due, somme_versee): pieces = [1, 2, 5, 10, 20, 50, 100, 200] rendu = ... a_rendre = ... i = len(pieces) - 1 while a_rendre > ... : if pieces[i] <= a_rendre : rendu.append(...) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code et le tester : \ud83d\udc0d Script Python >>> rendu_monnaie ( 700 , 700 ) [] >>> rendu_monnaie ( 102 , 500 ) [ 200 , 100 , 50 , 20 , 20 , 5 , 2 , 1 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 14 \u2693\ufe0e Version originale du sujet en pdf. Exercice 14.1 \u2693\ufe0e Exercice 14.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def recherche ( elt , tab ): ''' renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. ''' assert tab != [], \"le tableau est vide\" for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ``` R\u00e9digez votre code sur Basthon Exercice 14.2 \u2693\ufe0e Exercice 14.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction cr\u00e9e et renvoie un nouveau tableau \u00e0 partir de celui fourni en param\u00e8tre en y ins\u00e9rant la valeur a de sorte que le tableau renvoy\u00e9 soit encore tri\u00e9 par ordre croissant. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes Python. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( a , tab ): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= 0 : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 , [ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 30 , [ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 12 , 14 , 25 , 30 ] >>> insere ( 1 , [ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] >>> insere ( 1 , []) [ 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( a , tab ): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l Markdown On consid\u00e8re la fonction `insere` ci-dessous qui prend en argument un entier `a` et un tableau `tab` d'entiers tri\u00e9s par ordre croissant. Cette fonction cr\u00e9e et renvoie un nouveau tableau \u00e0 partir de celui fourni en param\u00e8tre en y ins\u00e9rant la valeur `a` de sorte que le tableau renvoy\u00e9 soit encore tri\u00e9 par ordre croissant. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes Python. ```python linenums='1' def insere(a, tab): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" l = list(tab) #l contient les m\u00eames \u00e9l\u00e9ments que tab l.append(a) i = ... while a < ... and i >= 0: l[i+1] = ... l[i] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 , [ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 30 , [ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 12 , 14 , 25 , 30 ] >>> insere ( 1 , [ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] >>> insere ( 1 , []) [ 1 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 15 \u2693\ufe0e Version originale du sujet en pdf. Exercice 15.1 \u2693\ufe0e Exercice 15.1 \u00c9nonc\u00e9 Correction Source Markdown On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres un tableau releve des relev\u00e9s et un tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. On suppose que la temp\u00e9rature minimale est atteinte une seule fois. Exemple : \ud83d\udc0d Script Python >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \ud83d\udccb Texte On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : ```python t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7] annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019] ``` \u00c9crire la fonction `mini` qui prend en param\u00e8tres un tableau `releve` des relev\u00e9s et un tableau `date` des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. On suppose que la temp\u00e9rature minimale est atteinte une seule fois. Exemple : ```python >>> mini(t_moy, annees) (12.5, 2016) ``` R\u00e9digez votre code sur Basthon Exercice 15.2 \u2693\ufe0e Exercice 15.2 \u00c9nonc\u00e9 Correction Sources Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : *bob* , *radar* , et *non* sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction `est_nbre_palindrome` s\u2019appuiera sur la fonction `est_palindrome` qui elle-m\u00eame s\u2019appuiera sur la fonction `inverse_chaine` . La fonction `inverse_chaine` inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res `chaine` et renvoie la cha\u00eene invers\u00e9e. La fonction `est_palindrome` teste si une chaine de caract\u00e8res `chaine` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction `est_nbre_palindrome` teste si un nombre `nbre` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. ```python linenums='1' def inverse_chaine(chaine): result = ... for caractere in chaine: result = ... return result def est_palindrome(chaine): inverse = inverse_chaine(chaine) return ... def est_nbre_palindrome(nbre): chaine = ... return est_palindrome(chaine) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 16 \u2693\ufe0e Version originale du sujet en pdf. Exercice 16.1 \u2693\ufe0e Exercice 16.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_indices_classement qui prend en param\u00e8tres un entier elt et une liste d\u2019entiers tab , et qui renvoie trois listes : la premi\u00e8re liste contient les indices des valeurs de la liste tab strictement inf\u00e9rieures \u00e0 elt ; la deuxi\u00e8me liste contient les indices des valeurs de la liste tab \u00e9gales \u00e0 elt ; la troisi\u00e8me liste contient les indices des valeurs de la liste tab strictement sup\u00e9rieures \u00e0 elt . Exemples : \ud83d\udc0d Script Python >>> recherche_indices_classement ( 3 , [ 1 , 3 , 4 , 2 , 4 , 6 , 3 , 0 ]) ([ 0 , 3 , 7 ], [ 1 , 6 ], [ 2 , 4 , 5 ]) >>> recherche_indices_classement ( 3 , [ 1 , 4 , 2 , 4 , 6 , 0 ]) ([ 0 , 2 , 5 ], [], [ 1 , 3 , 4 ]) >>> recherche_indices_classement ( 3 , [ 1 , 1 , 1 , 1 ]) ([ 0 , 1 , 2 , 3 ], [], []) >>> recherche_indices_classement ( 3 , []) ([], [], []) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche_indices_classement ( elt , tab ): ind_inf = [] ind_egal = [] ind_sup = [] for i in range ( len ( tab )): if tab [ i ] < elt : ind_inf . append ( i ) elif tab [ i ] > elt : ind_sup . append ( i ) else : ind_egal . append ( i ) return ( ind_inf , ind_egal , ind_sup ) \ud83d\udccb Texte \u00c9crire une fonction `recherche_indices_classement` qui prend en param\u00e8tres un entier `elt` et une liste d\u2019entiers `tab`, et qui renvoie trois listes : - la premi\u00e8re liste contient les indices des valeurs de la liste `tab` strictement inf\u00e9rieures \u00e0 `elt` ; - la deuxi\u00e8me liste contient les indices des valeurs de la liste `tab` \u00e9gales \u00e0 `elt` ; - la troisi\u00e8me liste contient les indices des valeurs de la liste `tab` strictement sup\u00e9rieures \u00e0 `elt`. Exemples : ```python >>> recherche_indices_classement(3, [1, 3, 4, 2, 4, 6, 3, 0]) ([0, 3, 7], [1, 6], [2, 4, 5]) >>> recherche_indices_classement(3, [1, 4, 2, 4, 6, 0]) ([0, 2, 5], [], [1, 3, 4]) >>>recherche_indices_classement(3, [1, 1, 1, 1]) ([0, 1, 2, 3], [], []) >>> recherche_indices_classement(3, []) ([], [], []) ``` R\u00e9digez votre code sur Basthon Exercice 16.2 \u2693\ufe0e Exercice 16.2 \u00c9nonc\u00e9 Correction Sources Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves sous forme de cha\u00eene de caract\u00e8res et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients dans une liste. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' : { 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ] }, 'Durand' : { 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ] } } L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ses \u00e9l\u00e8ves et renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom , dico_result ): if nom in ... : notes = dico_result [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom , dico_result ): if nom in dico_result : notes = dico_result [ nom ] total_points = 0. total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : - les clefs sont les noms des \u00e9l\u00e8ves ; - les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves sous forme de cha\u00eene de caract\u00e8res et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients dans une liste. Avec : ```python resultats = {'Dupont': { 'DS1': [15.5, 4], 'DM1': [14.5, 1], 'DS2': [13, 4], 'PROJET1': [16, 3], 'DS3': [14, 4] }, 'Durand': { 'DS1': [6 , 4], 'DM1': [14.5, 1], 'DS2': [8, 4], 'PROJET1': [9, 3], 'IE1': [7, 2], 'DS3': [8, 4], 'DS4':[15, 4] } } L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ses \u00e9l\u00e8ves et renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom , dico_result ): if nom in ... : notes = dico_result [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 17 \u2693\ufe0e Version originale du sujet en pdf. Exercice 17.1 \u2693\ufe0e Exercice 17.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne(liste_notes) qui renvoie la moyenne pond\u00e9r\u00e9e des r\u00e9sultats contenus dans la liste liste_notes , non vide, donn\u00e9e en param\u00e8tre. Cette liste contient des couples (note, coefficient) dans lesquels : note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier strictement positif. Ainsi l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer 12.5 . \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( liste_notes ): somme_notes = 0 somme_coeffs = 0 for devoir in liste_notes : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \ud83d\udccb Texte \u00c9crire une fonction `moyenne(liste_notes)` qui renvoie la moyenne pond\u00e9r\u00e9e des r\u00e9sultats contenus dans la liste `liste_notes`, non vide, donn\u00e9e en param\u00e8tre. Cette liste contient des couples `(note, coefficient)` dans lesquels : - `note` est un nombre de type flottant (`float`) compris entre 0 et 20 ; - `coefficient` est un nombre entier strictement positif. Ainsi l\u2019expression `moyenne([(15,2),(9,1),(12,3)])` devra renvoyer `12.5`. $\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5$ R\u00e9digez votre code sur Basthon Exercice 17.2 \u2693\ufe0e Exercice 17.2 \u00c9nonc\u00e9 Correction Sources Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal (Figure 1). Dans le triangle de Pascal, chaque ligne commence et se termine par le nombre 1. Comme l\u2019illustre la Figure 2, on additionne deux valeurs successives d\u2019une ligne pour obtenir la valeur qui se situe sous la deuxi\u00e8me valeur. Compl\u00e9ter la fonction pascal ci-apr\u00e8s prenant en param\u00e8tre un entier n sup\u00e9rieur ou \u00e9gal \u00e0 2. Cette fonction doit renvoyer une liste correspondant au triangle de Pascal de la ligne 0 \u00e0 la ligne n . Le tableau repr\u00e9sentant le triangle de Pascal sera contenu dans la variable triangle . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): triangle = [[ 1 ]] for k in range ( 1 , ... ): ligne_k = [ ... ] for i in range ( 1 , k ): ligne_k . append ( triangle [ ... ][ i - 1 ] + triangle [ ... ][ ... ]) ligne_k . append ( ... ) triangle . append ( ligne_k ) return triangle Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): triangle = [[ 1 ]] for k in range ( 1 , n + 1 ): ligne_k = [ 1 ] for i in range ( 1 , k ): ligne_k . append ( triangle [ k - 1 ][ i - 1 ] + triangle [ k - 1 ][ i ]) ligne_k . append ( 1 ) triangle . append ( ligne_k ) return triangle Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal (Figure 1). Dans le triangle de Pascal, chaque ligne commence et se termine par le nombre 1. Comme l\u2019illustre la Figure 2, on additionne deux valeurs successives d\u2019une ligne pour obtenir la valeur qui se situe sous la deuxi\u00e8me valeur. ![ image ]( data2023/17_triangle.png ){: .center width=60%} Compl\u00e9ter la fonction `pascal` ci-apr\u00e8s prenant en param\u00e8tre un entier `n` sup\u00e9rieur ou \u00e9gal \u00e0 2. Cette fonction doit renvoyer une liste correspondant au triangle de Pascal de la ligne 0 \u00e0 la ligne `n` . Le tableau repr\u00e9sentant le triangle de Pascal sera contenu dans la variable `triangle` . ```python linenums='1' def pascal(n): triangle = [[1]] for k in range(1,...): ligne_k = [...] for i in range(1,k): ligne_k.append(triangle[...][i-1]+triangle[...][...]) ligne_k.append(...) triangle.append(ligne_k) return triangle Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 18 \u2693\ufe0e Version originale du sujet en pdf. Exercice 18.1 \u2693\ufe0e Exercice 18.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction max_et_indice qui prend en param\u00e8tre une liste non vide tab de nombres entiers et qui renvoie la valeur du plus grand \u00e9l\u00e9ment de cette liste ainsi que l\u2019indice de sa premi\u00e8re apparition dans cette liste. L\u2019utilisation de la fonction native max n\u2019est pas autoris\u00e9e. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : \ud83d\udc0d Script Python >>> max_et_indice ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) >>> max_et_indice ([ - 2 ]) ( - 2 , 0 ) >>> max_et_indice ([ - 1 , - 1 , 3 , 3 , 3 ]) ( 3 , 2 ) >>> max_et_indice ([ 1 , 1 , 1 , 1 ]) ( 1 , 0 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def max_et_indice ( tab ): ''' renvoie la valeur du plus grand \u00e9l\u00e9ment de cette liste ainsi que l\u2019indice de sa premi\u00e8re apparition dans cette liste. ''' assert tab != [], 'le tableau est vide' val_max = tab [ 0 ] ind_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] ind_max = i return ( val_max , ind_max ) \ud83d\udccb Texte \u00c9crire une fonction `max_et_indice` qui prend en param\u00e8tre une liste non vide `tab` de nombres entiers et qui renvoie la valeur du plus grand \u00e9l\u00e9ment de cette liste ainsi que l\u2019indice de sa premi\u00e8re apparition dans cette liste. L\u2019utilisation de la fonction native `max` n\u2019est pas autoris\u00e9e. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : ```python >>> max_et_indice([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) (9, 3) >>> max_et_indice([-2]) (-2, 0) >>> max_et_indice([-1, -1, 3, 3, 3]) (3, 2) >>> max_et_indice([1, 1, 1, 1]) (1, 0) ``` R\u00e9digez votre code sur Basthon Exercice 18.2 \u2693\ufe0e Exercice 18.2 \u00c9nonc\u00e9 Correction Sources Markdown L\u2019ordre des g\u00e8nes sur un chromosome est repr\u00e9sent\u00e9 par un tableau ordre de n cases d\u2019entiers distincts deux \u00e0 deux et compris entre 1 et n . Par exemple, ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9] dans le cas n = 9 . On dit qu\u2019il y a un point de rupture dans ordre dans chacune des situations suivantes : la premi\u00e8re valeur de ordre n\u2019est pas 1 ; l\u2019\u00e9cart entre deux g\u00e8nes cons\u00e9cutifs n\u2019est pas \u00e9gal \u00e0 1 ; la derni\u00e8re valeur de ordre n\u2019est pas n. Par exemple, si ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9] avec n = 9 , on a un point de rupture au d\u00e9but car 5 est diff\u00e9rent de 1 un point de rupture entre 3 et 6 (l\u2019\u00e9cart est de 3) un point de rupture entre 7 et 2 (l\u2019\u00e9cart est de 5) un point de rupture entre 1 et 8 (l\u2019\u00e9cart est de 7) Il y a donc 4 points de rupture. Compl\u00e9ter les fonctions Python est_un_ordre et nombre_points_rupture propos\u00e9es \u00e0 la page suivante pour que : la fonction est_un_ordre renvoie True si le tableau pass\u00e9 en param\u00e8tre repr\u00e9sente bien un ordre de g\u00e8nes de chromosome et False sinon ; la fonction nombre_points_rupture renvoie le nombre de points de rupture d\u2019un tableau pass\u00e9 en param\u00e8tre repr\u00e9sentant l\u2019ordre de g\u00e8nes d\u2019un chromosome. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def est_un_ordre ( tab ): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' for i in range ( 1 , ... ): if ... : return False return True def nombre_points_rupture ( ordre ): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' assert ... # ordre n'est pas un ordre de g\u00e8nes n = len ( ordre ) nb = 0 if ordre [ ... ] != 1 : # le premier n'est pas 1 nb = nb + 1 i = 0 while i < ... : if ... not in [ - 1 , 1 ]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre [ ... ] != n : # le dernier n'est pas n nb = nb + 1 return nb Exemples : \ud83d\udc0d Script Python >>> est_un_ordre ([ 1 , 6 , 2 , 8 , 3 , 7 ]) False >>> est_un_ordre ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) True >>> nombre_points_rupture ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) 4 >>> nombre_points_rupture ([ 1 , 2 , 3 , 4 , 5 ]) 0 >>> nombre_points_rupture ([ 1 , 6 , 2 , 8 , 3 , 7 , 4 , 5 ]) 7 >>> nombre_points_rupture ([ 2 , 1 , 3 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def est_un_ordre ( tab ): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' for i in range ( 1 , len ( tab ) + 1 ): if i not in tab : return False return True def nombre_points_rupture ( ordre ): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' assert est_un_ordre ( ordre ) # ordre n'est pas un ordre de g\u00e8nes n = len ( ordre ) nb = 0 if ordre [ 0 ] != 1 : # le premier n'est pas 1 nb = nb + 1 i = 0 while i < n - 1 : if ordre [ i + 1 ] - ordre [ i ] not in [ - 1 , 1 ]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre [ n - 1 ] != n : # le dernier n'est pas n nb = nb + 1 return nb Markdown L\u2019ordre des g\u00e8nes sur un chromosome est repr\u00e9sent\u00e9 par un tableau `ordre` de `n` cases d\u2019entiers distincts deux \u00e0 deux et compris entre 1 et `n` . Par exemple, `ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9]` dans le cas `n = 9` . On dit qu\u2019il y a un point de rupture dans `ordre` dans chacune des situations suivantes : - la premi\u00e8re valeur de `ordre` n\u2019est pas 1 ; - l\u2019\u00e9cart entre deux g\u00e8nes cons\u00e9cutifs n\u2019est pas \u00e9gal \u00e0 1 ; - la derni\u00e8re valeur de `ordre` n\u2019est pas n. Par exemple, si `ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9]` avec `n = 9` , on a - un point de rupture au d\u00e9but car 5 est diff\u00e9rent de 1 - un point de rupture entre 3 et 6 (l\u2019\u00e9cart est de 3) - un point de rupture entre 7 et 2 (l\u2019\u00e9cart est de 5) - un point de rupture entre 1 et 8 (l\u2019\u00e9cart est de 7) Il y a donc 4 points de rupture. Compl\u00e9ter les fonctions Python `est_un_ordre` et `nombre_points_rupture` propos\u00e9es \u00e0 la page suivante pour que : - la fonction `est_un_ordre` renvoie `True` si le tableau pass\u00e9 en param\u00e8tre repr\u00e9sente bien un ordre de g\u00e8nes de chromosome et `False` sinon ; - la fonction `nombre_points_rupture` renvoie le nombre de points de rupture d\u2019un tableau pass\u00e9 en param\u00e8tre repr\u00e9sentant l\u2019ordre de g\u00e8nes d\u2019un chromosome. ```python linenums='1' def est_un_ordre(tab): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' for i in range(1,...): if ...: return False return True def nombre_points_rupture(ordre): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' assert ... # ordre n'est pas un ordre de g\u00e8nes n = len(ordre) nb = 0 if ordre[...] != 1: # le premier n'est pas 1 nb = nb + 1 i = 0 while i < ...: if ... not in [-1, 1]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre[...] != n: # le dernier n'est pas n nb = nb + 1 return nb Exemples : \ud83d\udc0d Script Python >>> est_un_ordre ([ 1 , 6 , 2 , 8 , 3 , 7 ]) False >>> est_un_ordre ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) True >>> nombre_points_rupture ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) 4 >>> nombre_points_rupture ([ 1 , 2 , 3 , 4 , 5 ]) 0 >>> nombre_points_rupture ([ 1 , 6 , 2 , 8 , 3 , 7 , 4 , 5 ]) 7 >>> nombre_points_rupture ([ 2 , 1 , 3 , 4 ]) 2 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 19 \u2693\ufe0e Version originale du sujet en pdf. Exercice 19.1 \u2693\ufe0e Exercice 19.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres un tableau `tab` de nombres entiers tri\u00e9s par ordre croissant et un nombre entier `n`, et qui effectue une recherche dichotomique du nombre entier `n` dans le tableau non vide `tab`. Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, `-1` sinon. Exemples : ```python >>> recherche([2, 3, 4, 5, 6], 5) 3 >>> recherche([2, 3, 4, 6, 7], 5) -1 ``` R\u00e9digez votre code sur Basthon Exercice 19.2 \u2693\ufe0e Exercice 19.2 \u00c9nonc\u00e9 Correction Sources Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019 ...) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ord ( lettre ) - ord ( 'A' ) def cesar ( message , decalage ): resultat = '' for ... in message : if 'A' <= c and c <= 'Z' : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ord ( lettre ) - ord ( 'A' ) def cesar ( message , decalage ): resultat = '' for c in message : if 'A' <= c and c <= 'Z' : indice = ( position_alphabet ( c ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + c return resultat Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019 ...) ne sont pas cod\u00e9s. La fonction `position_alphabet` ci-dessous prend en param\u00e8tre un caract\u00e8re `lettre` et renvoie la position de `lettre` dans la cha\u00eene de caract\u00e8res `ALPHABET` s\u2019il s\u2019y trouve. La fonction `cesar` prend en param\u00e8tre une cha\u00eene de caract\u00e8res `message` et un nombre entier `decalage` et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage `decalage` . ```python linenums='1' ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet(lettre): return ord(lettre) - ord('A') def cesar(message, decalage): resultat = '' for ... in message: if 'A' <= c and c <= 'Z': indice = ( ... ) % 26 resultat = resultat + ALPHABET[indice] else: resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 20 \u2693\ufe0e Version originale du sujet en pdf. Exercice 20.1 \u2693\ufe0e Exercice 20.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction ajoute_dictionnaires qui prend en param\u00e8tres deux dictionnaires d1 et d2 dont les cl\u00e9s sont des nombres et renvoie le dictionnaire d d\u00e9fini de la fa\u00e7on suivante : Les cl\u00e9s de d sont celles de d1 et celles de d2 r\u00e9unies. Si une cl\u00e9 est pr\u00e9sente dans les deux dictionnaires d1 et d2 , sa valeur associ\u00e9e dans le dictionnaire d est la somme de ses valeurs dans les dictionnaires d1 et d2 . Si une cl\u00e9 n\u2019est pr\u00e9sente que dans un des deux dictionnaires, sa valeur associ\u00e9e dans le dictionnaire d est la m\u00eame que sa valeur dans le dictionnaire o\u00f9 elle est pr\u00e9sente. Exemples : \ud83d\udc0d Script Python >>> ajoute_dictionnaires ({ 1 : 5 , 2 : 7 }, { 2 : 9 , 3 : 11 }) { 1 : 5 , 2 : 16 , 3 : 11 } >>> ajoute_dictionnaires ({}, { 2 : 9 , 3 : 11 }) { 2 : 9 , 3 : 11 } >>> ajoute_dictionnaires ({ 1 : 5 , 2 : 7 }, {}) { 1 : 5 , 2 : 7 } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def ajoute_dictionnaires ( d1 , d2 ): for cle in d2 : if cle in d1 : d1 [ cle ] += d2 [ cle ] else : d1 [ cle ] = d2 [ cle ] return d1 \ud83d\udccb Texte \u00c9crire une fonction `ajoute_dictionnaires` qui prend en param\u00e8tres deux dictionnaires `d1` et `d2` dont les cl\u00e9s sont des nombres et renvoie le dictionnaire `d` d\u00e9fini de la fa\u00e7on suivante : - Les cl\u00e9s de `d` sont celles de `d1` et celles de `d2` r\u00e9unies. - Si une cl\u00e9 est pr\u00e9sente dans les deux dictionnaires `d1` et `d2`, sa valeur associ\u00e9e dans le dictionnaire d est la somme de ses valeurs dans les dictionnaires `d1` et `d2`. - Si une cl\u00e9 n\u2019est pr\u00e9sente que dans un des deux dictionnaires, sa valeur associ\u00e9e dans le dictionnaire `d` est la m\u00eame que sa valeur dans le dictionnaire o\u00f9 elle est pr\u00e9sente. Exemples : ```python >>> ajoute_dictionnaires({1: 5, 2: 7}, {2: 9, 3: 11}) {1: 5, 2: 16, 3: 11} >>> ajoute_dictionnaires({}, {2: 9, 3: 11}) {2: 9, 3: 11} >>> ajoute_dictionnaires({1: 5, 2: 7}, {}) {1: 5, 2: 7} ``` R\u00e9digez votre code sur Basthon Exercice 20.2 \u2693\ufe0e Exercice 20.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une piste carr\u00e9e qui contient 4 cases par c\u00f4t\u00e9. Les cases sont num\u00e9rot\u00e9es de 0 inclus \u00e0 12 exclu comme ci-dessous : L\u2019objectif de l\u2019exercice est d\u2019impl\u00e9menter le jeu suivant : Au d\u00e9part, le joueur place son pion sur la case 0. A chaque coup, il lance un d\u00e9 \u00e9quilibr\u00e9 \u00e0 six faces et avance son pion d\u2019autant de cases que le nombre indiqu\u00e9 par le d\u00e9 (entre 1 et 6 inclus) dans le sens des aiguilles d\u2019une montre. Par exemple, s\u2019il obtient 2 au premier lancer, il pose son pion sur la case 2 puis s\u2019il obtient 6 au deuxi\u00e8me lancer, il le pose sur la case 8, puis s\u2019il obtient \u00e0 nouveau 6, il pose le pion sur la case 2. Le jeu se termine lorsque le joueur a pos\u00e9 son pion sur toutes les cases de la piste. Compl\u00e9ter la fonction nbre_coups ci-dessous de sorte qu\u2019elle renvoie le nombre de lancers al\u00e9atoires n\u00e9cessaires pour terminer le jeu. Proposer ensuite quelques tests pour en v\u00e9rifier le fonctionnement. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from random import randint def nbre_coups (): n = ... cases_vues = [ 0 ] case_en_cours = 0 nbre_cases = 12 while ... < ... : x = randint ( 1 , 6 ) case_en_cours = ( case_en_cours + ... ) % ... if ... : cases_vues . append ( case_en_cours ) n = ... return n \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from random import randint def nbre_coups (): n = 0 cases_vues = [ 0 ] case_en_cours = 0 nbre_cases = 12 while len ( cases_vues ) < nbre_cases : x = randint ( 1 , 6 ) case_en_cours = ( case_en_cours + x ) % nbre_cases if case_en_cours not in cases_vues : cases_vues . append ( case_en_cours ) n = n + 1 return n Markdown On consid\u00e8re une piste carr\u00e9e qui contient 4 cases par c\u00f4t\u00e9. Les cases sont num\u00e9rot\u00e9es de 0 inclus \u00e0 12 exclu comme ci-dessous : ![ image ]( data2023/20_carre.png ){: .center width=20%} L\u2019objectif de l\u2019exercice est d\u2019impl\u00e9menter le jeu suivant : Au d\u00e9part, le joueur place son pion sur la case 0. A chaque coup, il lance un d\u00e9 \u00e9quilibr\u00e9 \u00e0 six faces et avance son pion d\u2019autant de cases que le nombre indiqu\u00e9 par le d\u00e9 (entre 1 et 6 inclus) dans le sens des aiguilles d\u2019une montre. Par exemple, s\u2019il obtient 2 au premier lancer, il pose son pion sur la case 2 puis s\u2019il obtient 6 au deuxi\u00e8me lancer, il le pose sur la case 8, puis s\u2019il obtient \u00e0 nouveau 6, il pose le pion sur la case 2. Le jeu se termine lorsque le joueur a pos\u00e9 son pion sur **toutes les cases** de la piste. Compl\u00e9ter la fonction `nbre_coups` ci-dessous de sorte qu\u2019elle renvoie le nombre de lancers al\u00e9atoires n\u00e9cessaires pour terminer le jeu. Proposer ensuite quelques tests pour en v\u00e9rifier le fonctionnement. ```python linenums='1' from random import randint def nbre_coups(): n = ... cases_vues = [0] case_en_cours = 0 nbre_cases = 12 while ... < ...: x = randint(1, 6) case_en_cours = (case_en_cours + ...) % ... if ...: cases_vues.append(case_en_cours) n = ... return n ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 21 \u2693\ufe0e Version originale du sujet en pdf. Exercice 21.1 \u2693\ufe0e Exercice 21.1 \u00c9nonc\u00e9 Correction Source Markdown Le codage par diff\u00e9rence ( delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es plus petit, n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta(liste) qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : \ud83d\udc0d Script Python >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] \ud83d\udc0d Script Python 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff \ud83d\udccb Texte Le codage par diff\u00e9rence (*delta encoding* en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es plus petit, n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction `delta(liste)` qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : ```python >>> delta([1000, 800, 802, 1000, 1003]) [1000, -200, 2, 198, 3] >>> delta([42]) [42] ``` R\u00e9digez votre code sur Basthon Exercice 21.2 \u2693\ufe0e Exercice 21.2 \u00c9nonc\u00e9 Correction Sources Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212, \u00d7, \u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[(3 \\times (8 + 7)) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : \ud83d\udc0d Script Python >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Noeud : ''' classe impl\u00e9mentant un noeud d'arbre binaire ''' def __init__ ( self , g , v , d ): ''' un objet Noeud poss\u00e8de 3 attributs : - gauche : le sous-arbre gauche, - valeur : la valeur de l'\u00e9tiquette, - droit : le sous-arbre droit. ''' self . gauche = g self . valeur = v self . droit = d def __str__ ( self ): ''' renvoie la repr\u00e9sentation du noeud en chaine de caract\u00e8res ''' return str ( self . valeur ) def est_une_feuille ( self ): ''' renvoie True si et seulement si le noeud est une feuille ''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Noeud : ''' classe impl\u00e9mentant un noeud d'arbre binaire ''' def __init__ ( self , g , v , d ): ''' un objet Noeud poss\u00e8de 3 attributs : - gauche : le sous-arbre gauche, - valeur : la valeur de l'\u00e9tiquette, - droit : le sous-arbre droit. ''' self . gauche = g self . valeur = v self . droit = d def __str__ ( self ): ''' renvoie la repr\u00e9sentation du noeud en chaine de caract\u00e8res ''' return str ( self . valeur ) def est_une_feuille ( self ): ''' renvoie True si et seulement si le noeud est une feuille ''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212, \u00d7, \u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. ![ image ]( data2023/21_arbre.png ){: .center width=30%} En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : $$(3 \\times (8 + 7)) \u2212 (2 + 1)$$ La classe `Noeud` ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive `expression_infixe` qui prend en param\u00e8tre un objet de la classe `Noeud` et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : ```python >>> e = Noeud(Noeud(Noeud(None, 3, None), '*', Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))), '-', Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))) >>> expression_infixe(e) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Noeud : ''' classe impl\u00e9mentant un noeud d'arbre binaire ''' def __init__ ( self , g , v , d ): ''' un objet Noeud poss\u00e8de 3 attributs : - gauche : le sous-arbre gauche, - valeur : la valeur de l'\u00e9tiquette, - droit : le sous-arbre droit. ''' self . gauche = g self . valeur = v self . droit = d def __str__ ( self ): ''' renvoie la repr\u00e9sentation du noeud en chaine de caract\u00e8res ''' return str ( self . valeur ) def est_une_feuille ( self ): ''' renvoie True si et seulement si le noeud est une feuille ''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 22 \u2693\ufe0e Version originale du sujet en pdf. Exercice 22.1 \u2693\ufe0e Exercice 22.1 \u00c9nonc\u00e9 Correction Source Markdown On rappelle que : le nombre \\(a^n\\) est le nombre \\(a \\times a \\times a \\times \\dots \\times a\\) , o\u00f9 le facteur \\(a\\) appara\u00eet \\(n\\) fois, en langage Python, l\u2019instruction t[-1] permet d\u2019acc\u00e9der au dernier \u00e9l\u00e9ment du tableau t . Dans cet exercice, l\u2019op\u00e9rateur ** et la fonction pow ne sont pas autoris\u00e9s. Programmer en langage Python une fonction liste_puissances qui prend en argument un nombre entier a , un entier strictement positif n et qui renvoie la liste de ses puissances \\(\\rm{[a^1, a^2, ..., a^n]}\\) . Programmer \u00e9galement une fonction liste_puisssances_borne qui prend en argument un nombre entier a sup\u00e9rieur ou \u00e9gal \u00e0 2 et un entier borne , et qui renvoie la liste de ses puissances, \u00e0 l\u2019exclusion de \\(\\rm{a^0}\\) , strictement inf\u00e9rieures \u00e0 borne . Exemples : \ud83d\udc0d Script Python >>> liste_puissances ( 3 , 5 ) [ 3 , 9 , 27 , 81 , 243 ] >>> liste_puissances ( - 2 , 4 ) [ - 2 , 4 , - 8 , 16 ] >>> liste_puissances_borne ( 2 , 16 ) [ 2 , 4 , 8 ] >>> liste_puissances_borne ( 2 , 17 ) [ 2 , 4 , 8 , 16 ] >>> liste_puissances_borne ( 5 , 5 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def liste_puissances ( a , n ): puissances = [ a ] for i in range ( n - 1 ): puissances . append ( puissances [ - 1 ] * a ) return puissances def liste_puissances_borne ( a , borne ): lst = [] val = a while val < borne : lst . append ( val ) val = val * a return lst \ud83d\udccb Texte On rappelle que : - le nombre $a^n$ est le nombre $a \\times a \\times a \\times \\dots \\times a$, o\u00f9 le facteur $a$ appara\u00eet $n$ fois, - en langage Python, l\u2019instruction `t[-1]` permet d\u2019acc\u00e9der au dernier \u00e9l\u00e9ment du tableau `t`. Dans cet exercice, l\u2019op\u00e9rateur ```**``` et la fonction `pow` ne sont pas autoris\u00e9s. Programmer en langage Python une fonction `liste_puissances` qui prend en argument un nombre entier `a`, un entier strictement positif `n` et qui renvoie la liste de ses puissances $\\rm{[a^1, a^2, ..., a^n]}$. Programmer \u00e9galement une fonction `liste_puisssances_borne` qui prend en argument un nombre entier `a` sup\u00e9rieur ou \u00e9gal \u00e0 2 et un entier `borne`, et qui renvoie la liste de ses puissances, \u00e0 l\u2019exclusion de $\\rm{a^0}$, strictement inf\u00e9rieures \u00e0 `borne`. Exemples : ```python >>> liste_puissances(3, 5) [3, 9, 27, 81, 243] >>> liste_puissances(-2, 4) [-2, 4, -8, 16] >>> liste_puissances_borne(2, 16) [2, 4, 8] >>> liste_puissances_borne(2, 17) [2, 4, 8, 16] >>> liste_puissances_borne(5, 5) [] ``` R\u00e9digez votre code sur Basthon Exercice 22.2 \u2693\ufe0e Exercice 22.2 \u00c9nonc\u00e9 Correction Sources Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M 1 2 3 4 5 6 7 8 9 10 11 12 13 N O P Q R S T U V W X Y Z 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ): # mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_concatene = \"\" code_additionne = ... for c in mot : code_concatene = code_concatene + ... code_additionne = ... code_concatene = int ( code_concatene ) if ... : mot_est_parfait = True else : mot_est_parfait = False return code_additionne , code_concatene , mot_est_parfait Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) ( 50 , 1612112 , False ) >>> est_parfait ( \"ALAIN\" ) ( 37 , 1121914 , True ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ): # mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_concatene = \"\" code_additionne = 0 for c in mot : code_concatene = code_concatene + str ( dico [ c ]) code_additionne = code_additionne + dico [ c ] code_concatene = int ( code_concatene ) if code_concatene % code_additionne == 0 : mot_est_parfait = True else : mot_est_parfait = False return code_additionne , code_concatene , mot_est_parfait Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : | A | B | C | D | E | F | G | H | I | J | K | L | M | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son *code alphab\u00e9tique concat\u00e9n\u00e9* , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, *son code additionn\u00e9*, qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab *parfait* \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : - Pour le mot `\"PAUL\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1612112'` , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot `\"PAUL\"` n\u2019est pas parfait. - Pour le mot `\"ALAIN\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1121914'` , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot `\"ALAIN\"` est parfait. Compl\u00e9ter la fonction `est_parfait` ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res `mot` (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de `mot` , ainsi qu\u2019un bool\u00e9en qui indique si `mot` est parfait ou pas. ```python linenums='1' dico = {\"A\": 1, \"B\": 2, \"C\": 3, \"D\": 4, \"E\": 5, \"F\": 6, \"G\": 7, \"H\": 8, \"I\": 9, \"J\": 10, \"K\": 11, \"L\": 12, \"M\": 13, \"N\": 14, \"O\": 15, \"P\": 16, \"Q\": 17, \"R\": 18, \"S\": 19, \"T\": 20, \"U\": 21, \"V\": 22, \"W\": 23, \"X\": 24, \"Y\": 25, \"Z\": 26} def est_parfait(mot): # mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_concatene = \"\" code_additionne = ... for c in mot: code_concatene = code_concatene + ... code_additionne = ... code_concatene = int(code_concatene) if ... : mot_est_parfait = True else: mot_est_parfait = False return code_additionne, code_concatene, mot_est_parfait Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) ( 50 , 1612112 , False ) >>> est_parfait ( \"ALAIN\" ) ( 37 , 1121914 , True ) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 23 \u2693\ufe0e Version originale du sujet en pdf. Exercice 23.1 \u2693\ufe0e Exercice 23.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont 'nom' , 'espece' , 'age' , 'enclos' . Voici un exemple d'une telle table : \ud83d\udc0d Script Python animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] Programmer une fonction selection_enclos qui : prend en param\u00e8tres : une table table_animaux contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), un num\u00e9ro d'enclos num_enclos ; renvoie une table contenant les enregistrements de table_animaux dont l'attribut 'enclos' est num_enclos . Exemples avec la table animaux ci-dessus : \ud83d\udc0d Script Python >>> selection_enclos ( animaux , 5 ) [{ 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] >>> selection_enclos ( animaux , 2 ) [{ 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }] >>> selection_enclos ( animaux , 7 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def selection_enclos ( table_animaux , num_enclos ): table = [] for animal in table_animaux : if animal [ 'enclos' ] == num_enclos : table . append ( animal ) return table \ud83d\udccb Texte On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont `'nom'`, `'espece'`, `'age'`, `'enclos'`. Voici un exemple d'une telle table : ```python animaux = [ {'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}, {'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Tom', 'espece':'chat', 'age':7, 'enclos':4}, {'nom':'Belle', 'espece':'chien', 'age':6, 'enclos':3}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] ``` Programmer une fonction `selection_enclos` qui : - prend en param\u00e8tres : - une table `table_animaux` contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), - un num\u00e9ro d'enclos `num_enclos` ; - renvoie une table contenant les enregistrements de `table_animaux` dont l'attribut `'enclos'` est `num_enclos`. Exemples avec la table `animaux` ci-dessus : ```python >>> selection_enclos(animaux, 5) [{'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] >>> selection_enclos(animaux, 2) [{'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}] >>> selection_enclos(animaux, 7) [] ``` R\u00e9digez votre code sur Basthon Exercice 23.2 \u2693\ufe0e Exercice 23.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois \u00e0 la suite, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : \ud83d\udc0d Script Python tab_a = [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] #l'intrus est 7 tab_b = [ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ] #l'intrus est 8 tab_c = [ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Par exemple, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 12, on voit les valeurs 2 et 4 qui sont diff\u00e9rentes : l\u2019intrus est donc \u00e0 gauche de l\u2019indice 12 (indice 12 compris) En revanche, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 3, on voit les valeurs 9 et 9 qui sont identiques : l\u2019intrus est donc \u00e0 droite des indices 3-4-5, donc \u00e0 partir de l\u2019indice 6. Compl\u00e9ter la fonction r\u00e9cursive trouver_intrus propos\u00e9e page suivante qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return tab [ g ] else : nombre_de_triplets = ( d - g ) // 3 indice = g + 3 * ( nombre_de_triplets // 2 ) if tab [ indice ] != tab [ indice + 1 ] : return trouver_intrus ( tab , g , indice ) else : return trouver_intrus ( tab , indice + 3 , d ) Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois \u00e0 la suite, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : ```python tab_a = [3, 3, 3, 9, 9, 9, 1, 1, 1, 7, 2, 2, 2, 4, 4, 4, 8, 8, 8, 5, 5, 5] #l'intrus est 7 tab_b = [8, 5, 5, 5, 9, 9, 9, 18, 18, 18, 3, 3, 3] #l'intrus est 8 tab_c = [5, 5, 5, 1, 1, 1, 0, 0, 0, 6, 6, 6, 3, 8, 8, 8] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Par exemple, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 12, on voit les valeurs 2 et 4 qui sont diff\u00e9rentes : l\u2019intrus est donc \u00e0 gauche de l\u2019indice 12 (indice 12 compris) En revanche, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 3, on voit les valeurs 9 et 9 qui sont identiques : l\u2019intrus est donc \u00e0 droite des indices 3-4-5, donc \u00e0 partir de l\u2019indice 6. Compl\u00e9ter la fonction r\u00e9cursive trouver_intrus propos\u00e9e page suivante qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 24 \u2693\ufe0e Version originale du sujet en pdf. Exercice 24.1 \u2693\ufe0e Exercice 24.1 \u00c9nonc\u00e9 Correction Source Markdown Le nombre d\u2019occurrences d\u2019un caract\u00e8re dans une cha\u00eene de caract\u00e8re est le nombre d\u2019apparitions de ce caract\u00e8re dans la cha\u00eene. Exemples : le nombre d\u2019occurrences du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; le nombre d\u2019occurrences du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; le nombre d\u2019occurrences du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; le nombre d\u2019occurrences du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} L\u2019ordre des clefs n\u2019a pas d\u2019importance. \u00c9crire une fonction nbr_occurrences prenant comme param\u00e8tre une cha\u00eene de caract\u00e8res chaine et renvoyant le dictionnaire des nombres d\u2019occurrences des caract\u00e8res de cette cha\u00eene. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def nbr_occurrences ( chaine ): nb_occ = {} for caractere in chaine : if caractere in nb_occ : nb_occ [ caractere ] += 1 else : nb_occ [ caractere ] = 1 return nb_occ \ud83d\udccb Texte Le nombre d\u2019occurrences d\u2019un caract\u00e8re dans une cha\u00eene de caract\u00e8re est le nombre d\u2019apparitions de ce caract\u00e8re dans la cha\u00eene. Exemples : - le nombre d\u2019occurrences du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; - le nombre d\u2019occurrences du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - le nombre d\u2019occurrences du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - le nombre d\u2019occurrences du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : `{'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1}` *L\u2019ordre des clefs n\u2019a pas d\u2019importance.* \u00c9crire une fonction `nbr_occurrences` prenant comme param\u00e8tre une cha\u00eene de caract\u00e8res `chaine` et renvoyant le dictionnaire des nombres d\u2019occurrences des caract\u00e8res de cette cha\u00eene. R\u00e9digez votre code sur Basthon Exercice 24.2 \u2693\ufe0e Exercice 24.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction fusion prend deux listes lst1 , lst2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e lst12 qu\u2019elle renvoie. Le code Python de la fonction fusion est \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( lst1 , lst2 ): n1 = len ( lst1 ) n2 = len ( lst2 ) lst12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if lst1 [ i1 ] < lst2 [ i2 ]: lst12 [ i ] = ... i1 = ... else : lst12 [ i ] = lst2 [ i2 ] i2 = ... i += 1 while i1 < n1 : lst12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : lst12 [ i ] = ... i2 = i2 + 1 i = ... return lst12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( lst1 , lst2 ): n1 = len ( lst1 ) n2 = len ( lst2 ) lst12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if lst1 [ i1 ] < lst2 [ i2 ]: lst12 [ i ] = lst1 [ i1 ] i1 = i1 + 1 else : lst12 [ i ] = lst2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : lst12 [ i ] = lst1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : lst12 [ i ] = lst2 [ i2 ] i2 = i2 + 1 i = i + 1 return lst12 Markdown La fonction `fusion` prend deux listes `lst1` , `lst2` d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e `lst12` qu\u2019elle renvoie. Le code Python de la fonction `fusion` est ```python linenums='1' def fusion(lst1,lst2): n1 = len(lst1) n2 = len(lst2) lst12 = [0] * (n1 + n2) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if lst1[i1] < lst2[i2]: lst12[i] = ... i1 = ... else: lst12[i] = lst2[i2] i2 = ... i += 1 while i1 < n1: lst12[i] = ... i1 = i1 + 1 i = ... while i2 < n2: lst12[i] = ... i2 = i2 + 1 i = ... return lst12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 25 \u2693\ufe0e Version originale du sujet en pdf. Exercice 25.1 \u2693\ufe0e Exercice 25.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction enumere qui prend en param\u00e8tre une liste L et renvoie un dictionnaire d dont les cl\u00e9s sont les \u00e9l\u00e9ments de L avec pour valeur associ\u00e9e la liste des indices de l\u2019\u00e9l\u00e9ment dans la liste L . Exemple : \ud83d\udc0d Script Python >>> enumere ([ 1 , 1 , 2 , 3 , 2 , 1 ]) { 1 : [ 0 , 1 , 5 ], 2 : [ 2 , 4 ], 3 : [ 3 ]} \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def enumere ( L ): d = {} for i in range ( len ( L )): if L [ i ] in d : d [ L [ i ]] . append ( i ) else : d [ L [ i ]] = [ i ] return d \ud83d\udccb Texte \u00c9crire une fonction `enumere` qui prend en param\u00e8tre une liste `L` et renvoie un dictionnaire `d` dont les cl\u00e9s sont les \u00e9l\u00e9ments de `L` avec pour valeur associ\u00e9e la liste des indices de l\u2019\u00e9l\u00e9ment dans la liste `L`. Exemple : ```python >>> enumere([1, 1, 2, 3, 2, 1]) {1: [0, 1, 5], 2: [2, 4], 3: [3]} ``` R\u00e9digez votre code sur Basthon Exercice 25.2 \u2693\ufe0e Exercice 25.2 \u00c9nonc\u00e9 Correction Sources Markdown Un arbre binaire est impl\u00e9ment\u00e9 par la classe Arbre donn\u00e9e ci-dessous. Les attributs fg et fd prennent pour valeurs des instances de la classe Arbre ou None . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 class Arbre : def __init__ ( self , etiquette ): self . v = etiquette self . fg = None self . fd = None def parcours ( arbre , liste ): if arbre != None : parcours ( arbre . fg , liste ) liste . append ( arbre . v ) parcours ( arbre . fd , liste ) return liste La fonction r\u00e9cursive parcours renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre impl\u00e9ment\u00e9 par l\u2019instance arbre dans l\u2019ordre du parcours en profondeur infixe \u00e0 partir d\u2019une liste vide pass\u00e9e en argument. Compl\u00e9ter le code de la fonction insere qui ins\u00e8re un n\u0153ud d\u2019\u00e9tiquette cle en feuille de l\u2019arbre impl\u00e9ment\u00e9 par l\u2019instance arbre selon la sp\u00e9cification indiqu\u00e9e et de fa\u00e7on que l\u2019arbre ainsi compl\u00e9t\u00e9 soit encore un arbre binaire de recherche. Tester ensuite ce code en utilisant la fonction parcours et en ins\u00e9rant successivement des n\u0153uds d\u2019\u00e9tiquette 1, 4, 6 et 8 dans l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci- dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( arbre , cle ): \"\"\" arbre est une instance de la classe Arbre qui impl\u00e9mente un arbre binaire de recherche. \"\"\" if ... : if ... : insere ( arbre . fg , cle ) else : arbre . fg = Arbre ( cle ) else : if ... : insere ( arbre . fd , cle ) else : arbre . fd = Arbre ( cle ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( arbre , cle ): \"\"\" arbre est une instance de la classe Arbre qui impl\u00e9mente un arbre binaire de recherche. \"\"\" if cle < arbre . v : if arbre . fg is not None : insere ( arbre . fg , cle ) else : arbre . fg = Arbre ( cle ) else : if arbre . fd is not None : insere ( arbre . fd , cle ) else : arbre . fd = Arbre ( cle ) Tests : \ud83d\udc0d Script Python >>> a = Arbre ( 5 ) >>> insere ( a , 2 ) >>> insere ( a , 7 ) >>> insere ( a , 3 ) >>> parcours ( a , []) [ 2 , 3 , 5 , 7 ] >>> insere ( a , 1 ) >>> insere ( a , 4 ) >>> insere ( a , 6 ) >>> insere ( a , 8 ) >>> parcours ( a , []) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] Markdown Un arbre binaire est impl\u00e9ment\u00e9 par la classe `Arbre` donn\u00e9e ci-dessous. Les attributs `fg` et `fd` prennent pour valeurs des instances de la classe `Arbre` ou `None` . ```python linenums='1' class Arbre: def __init__ (self, etiquette): self.v = etiquette self.fg = None self.fd = None def parcours(arbre, liste): if arbre != None: parcours(arbre.fg, liste) liste.append(arbre.v) parcours(arbre.fd, liste) return liste La fonction r\u00e9cursive parcours renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre impl\u00e9ment\u00e9 par l\u2019instance arbre dans l\u2019ordre du parcours en profondeur infixe \u00e0 partir d\u2019une liste vide pass\u00e9e en argument. Compl\u00e9ter le code de la fonction insere qui ins\u00e8re un n\u0153ud d\u2019\u00e9tiquette cle en feuille de l\u2019arbre impl\u00e9ment\u00e9 par l\u2019instance arbre selon la sp\u00e9cification indiqu\u00e9e et de fa\u00e7on que l\u2019arbre ainsi compl\u00e9t\u00e9 soit encore un arbre binaire de recherche. Tester ensuite ce code en utilisant la fonction parcours et en ins\u00e9rant successivement des n\u0153uds d\u2019\u00e9tiquette 1, 4, 6 et 8 dans l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci- dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( arbre , cle ): \"\"\" arbre est une instance de la classe Arbre qui impl\u00e9mente un arbre binaire de recherche. \"\"\" if ... : if ... : insere ( arbre . fg , cle ) else : arbre . fg = Arbre ( cle ) else : if ... : insere ( arbre . fd , cle ) else : arbre . fd = Arbre ( cle ) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 26 \u2693\ufe0e Version originale du sujet en pdf. Exercice 26.1 \u2693\ufe0e Exercice 26.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def multiplication ( n1 , n2 ): # on se ram\u00e8ne d'abord au cas o\u00f9 n1 et n2 sont tous les deux positifs : if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. ```python >>> multiplication(3, 5) 15 >>> multiplication(-4, -8) 32 >>> multiplication(-2, 6) -12 >>> multiplication(-2, 0) 0 ``` R\u00e9digez votre code sur Basthon Exercice 26.2 \u2693\ufe0e Exercice 26.2 \u00c9nonc\u00e9 Correction Sources Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 27 \u2693\ufe0e Version originale du sujet en pdf. Exercice 27.1 \u2693\ufe0e Exercice 27.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> recherche_min ([ 5 ]) 0 >>> recherche_min ([ 2 , 4 , 1 ]) 2 >>> recherche_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \ud83d\udccb Texte \u00c9crire une fonction `recherche_min` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 `tab`, et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> recherche_min([5]) 0 >>> recherche_min([2, 4, 1]) 2 >>> recherche_min([5, 3, 2, 2, 4]) 2 ``` R\u00e9digez votre code sur Basthon Exercice 27.2 \u2693\ufe0e Exercice 27.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): gauche = 0 droite = ... while gauche < droite : if tab [ gauche ] == 0 : gauche = ... else : tab [ gauche ], tab [ droite ] = ... droite = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Description d\u2019\u00e9tapes effectu\u00e9es par la fonction separe sur le tableau ci-dessous : tab = [1, 0, 1, 0, 1, 0, 1, 0] Etape 1 : on regarde la premi\u00e8re case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec la derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus la derni\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 2 : on regarde \u00e0 nouveau la premi\u00e8re case, qui contient maintenant un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la premi\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 3 : on regarde la seconde case, qui contient un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la seconde case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 4 : on regarde la troisi\u00e8me case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec l\u2019avant-derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus l\u2019avant-derni\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Et ainsi de suite... tab = [0, 0, 0, 0, 1, 1, 1, 1] Compl\u00e9ter la fonction separe pr\u00e9sent\u00e9e \u00e0 la page pr\u00e9c\u00e9dente \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): gauche = 0 droite = len ( tab ) - 1 while gauche < droite : if tab [ gauche ] == 0 : gauche = gauche + 1 else : tab [ gauche ], tab [ droite ] = tab [ droite ], tab [ gauche ] droite = droite - 1 return tab Markdown On consid\u00e8re la fonction `separe` ci-dessous qui prend en argument un tableau `tab` dont les \u00e9l\u00e9ments sont des `0` et des `1` et qui s\u00e9pare les `0` des `1` en pla\u00e7ant les `0` en d\u00e9but de tableau et les `1` \u00e0 la suite. ```python linenums='1' def separe(tab): gauche = 0 droite = ... while gauche < droite : if tab[gauche] == 0 : gauche = ... else : tab[gauche], tab[droite] = ... droite = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Description d\u2019\u00e9tapes effectu\u00e9es par la fonction separe sur le tableau ci-dessous : tab = [1, 0, 1, 0, 1, 0, 1, 0] Etape 1 : on regarde la premi\u00e8re case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec la derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus la derni\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 2 : on regarde \u00e0 nouveau la premi\u00e8re case, qui contient maintenant un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la premi\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 3 : on regarde la seconde case, qui contient un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la seconde case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 4 : on regarde la troisi\u00e8me case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec l\u2019avant-derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus l\u2019avant-derni\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Et ainsi de suite... tab = [0, 0, 0, 0, 1, 1, 1, 1] Compl\u00e9ter la fonction separe pr\u00e9sent\u00e9e \u00e0 la page pr\u00e9c\u00e9dente ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 28 \u2693\ufe0e Version originale du sujet en pdf. Exercice 28.1 \u2693\ufe0e Exercice 28.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. \ud83d\udc0d Script Python def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]) == 4 assert moyenne ([ 1 , 2 ]) == 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. ```python def moyenne (tab): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne([1]) == 1 assert moyenne([1, 2, 3, 4, 5, 6, 7]) == 4 assert moyenne([1, 2]) == 1.5 ``` R\u00e9digez votre code sur Basthon Exercice 28.2 \u2693\ufe0e Exercice 28.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide et il est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False, 1 , False, 2 et False, 3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab == []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False , 3 Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide et il est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient `False` en renvoyant `False, 1` , `False, 2` et `False, 3` . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ...: return False, 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if (x < tab[0]) or ...: return False, 2 debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 29 \u2693\ufe0e Version originale du sujet en pdf. Exercice 29.1 \u2693\ufe0e Exercice 29.1 \u00c9nonc\u00e9 Correction Source Markdown Un arbre binaire est impl\u00e9ment\u00e9 par la classe Arbre donn\u00e9e ci-dessous. Les attributs fg et fd prennent pour valeurs des instances de la classe Arbre ou None . \ud83d\udc0d Script Python class Arbre : def __init__ ( self , etiquette ): self . v = etiquette self . fg = None self . fd = None L\u2019arbre ci-dessus sera donc impl\u00e9ment\u00e9 de la mani\u00e8re suivante : \ud83d\udc0d Script Python a = Arbre ( 1 ) a . fg = Arbre ( 4 ) a . fd = Arbre ( 0 ) a . fd . fd = Arbre ( 7 ) \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tre une instance a de la classe Arbre et qui renvoie la taille de l\u2019arbre que cette instance impl\u00e9mente. \u00c9crire de m\u00eame une fonction r\u00e9cursive hauteur prenant en param\u00e8tre une instance a de la classe Arbre et qui renvoie la hauteur de l\u2019arbre que cette instance impl\u00e9mente. Si un arbre a un seul n\u0153ud, sa taille et sa hauteur sont \u00e9gales \u00e0 1. S\u2019il est vide, sa taille et sa hauteur sont \u00e9gales \u00e0 0. Tester les deux fonctions sur l\u2019arbre repr\u00e9sent\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def taille ( a ): if a is None : return 0 else : return 1 + taille ( a . fg ) + taille ( a . fd ) def hauteur ( a ): if a is None : return 0 else : return 1 + max ( hauteur ( a . fg ), hauteur ( a . fd )) Tests : \ud83d\udc0d Script Python a = Arbre ( 0 ) a . fg = Arbre ( 1 ) a . fd = Arbre ( 2 ) a . fg . fg = Arbre ( 3 ) a . fd . fg = Arbre ( 4 ) a . fd . fd = Arbre ( 5 ) a . fd . fg . fd = Arbre ( 6 ) \ud83d\udc0d Script Python >>> taille ( a ) 7 >>> hauteur ( a ) 4 \ud83d\udccb Texte Un arbre binaire est impl\u00e9ment\u00e9 par la classe `Arbre` donn\u00e9e ci-dessous. Les attributs `fg` et `fd` prennent pour valeurs des instances de la classe `Arbre` ou `None`. ```python class Arbre: def __init__(self, etiquette): self.v = etiquette self.fg = None self.fd = None ``` ![image](data2023/29_arbre1.png){: .center} L\u2019arbre ci-dessus sera donc impl\u00e9ment\u00e9 de la mani\u00e8re suivante : ```python a = Arbre(1) a.fg = Arbre(4) a.fd = Arbre(0) a.fd.fd = Arbre(7) ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tre une instance `a` de la classe `Arbre` et qui renvoie la taille de l\u2019arbre que cette instance impl\u00e9mente. \u00c9crire de m\u00eame une fonction r\u00e9cursive `hauteur` prenant en param\u00e8tre une instance `a` de la classe `Arbre` et qui renvoie la hauteur de l\u2019arbre que cette instance impl\u00e9mente. Si un arbre a un seul n\u0153ud, sa taille et sa hauteur sont \u00e9gales \u00e0 1. S\u2019il est vide, sa taille et sa hauteur sont \u00e9gales \u00e0 0. Tester les deux fonctions sur l\u2019arbre repr\u00e9sent\u00e9 ci-dessous : ![image](data2023/29_arbre2.png){: .center} R\u00e9digez votre code sur Basthon Exercice 29.2 \u2693\ufe0e Exercice 29.2 \u00c9nonc\u00e9 Correction Sources Markdown La m\u00e9thode insert de la classe list permet d\u2019ins\u00e9rer un \u00e9l\u00e9ment dans une liste \u00e0 un indice donn\u00e9. Le but de cet exercice est, sans utiliser cette m\u00e9thode , d\u2019\u00e9crire une fonction ajoute r\u00e9alisant cette insertion en produisant une nouvelle liste. Cette fonction ajoute prend en param\u00e8tres trois variables indice , element et liste et renvoie une liste L dans laquelle les \u00e9l\u00e9ments sont ceux de la liste liste avec, en plus, l\u2019\u00e9l\u00e9ment element \u00e0 l\u2019indice indice . On consid\u00e8re que les variables indice et element sont des entiers positifs et que les \u00e9l\u00e9ments de liste sont \u00e9galement des entiers positifs. Les \u00e9l\u00e9ments de la liste liste , dont les indices sont sup\u00e9rieurs ou \u00e9gaux \u00e0 indice apparaissent d\u00e9cal\u00e9s vers la droite dans la liste L . Si indice est sup\u00e9rieur ou \u00e9gal au nombre d\u2019\u00e9l\u00e9ments de la liste liste , l\u2019\u00e9l\u00e9ment element est ajout\u00e9 dans L apr\u00e8s tous les \u00e9l\u00e9ments de la liste liste . Exemple : \ud83d\udc0d Script Python >>> ajoute ( 1 , 4 , [ 7 , 8 , 9 ]) [ 7 , 4 , 8 , 9 ] >>> ajoute ( 3 , 4 , [ 7 , 8 , 9 ]) [ 7 , 8 , 9 , 4 ] >>> ajoute ( 4 , 4 , [ 7 , 8 , 9 ]) [ 7 , 8 , 9 , 4 ] Compl\u00e9ter et tester le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def ajoute ( indice , element , liste ): nbre_elts = len ( liste ) L = [ 0 for i in range ( nbre_elts + 1 )] if ... : for i in range ( indice ): L [ i ] = ... L [ ... ] = ... for i in range ( indice + 1 , nbre_elts + 1 ): L [ i ] = ... else : for i in range ( nbre_elts ): L [ i ] = ... L [ ... ] = ... return L \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def ajoute ( indice , element , liste ): nbre_elts = len ( liste ) L = [ 0 for i in range ( nbre_elts + 1 )] if indice < nbre_elts : for i in range ( indice ): L [ i ] = liste [ i ] L [ indice ] = element for i in range ( indice + 1 , nbre_elts + 1 ): L [ i ] = liste [ i - 1 ] else : for i in range ( nbre_elts ): L [ i ] = liste [ i ] L [ nbre_elts ] = element return L Markdown La m\u00e9thode `insert` de la classe `list` permet d\u2019ins\u00e9rer un \u00e9l\u00e9ment dans une liste \u00e0 un `indice` donn\u00e9. Le but de cet exercice est, *sans utiliser cette m\u00e9thode* , d\u2019\u00e9crire une fonction `ajoute` r\u00e9alisant cette insertion en produisant une nouvelle liste. Cette fonction `ajoute` prend en param\u00e8tres trois variables `indice` , `element` et `liste` et renvoie une liste `L` dans laquelle les \u00e9l\u00e9ments sont ceux de la liste `liste` avec, en plus, l\u2019\u00e9l\u00e9ment `element` \u00e0 l\u2019indice `indice` . On consid\u00e8re que les variables `indice` et `element` sont des entiers positifs et que les \u00e9l\u00e9ments de `liste` sont \u00e9galement des entiers positifs. Les \u00e9l\u00e9ments de la liste `liste` , dont les indices sont sup\u00e9rieurs ou \u00e9gaux \u00e0 `indice` apparaissent d\u00e9cal\u00e9s vers la droite dans la liste `L` . Si `indice` est sup\u00e9rieur ou \u00e9gal au nombre d\u2019\u00e9l\u00e9ments de la liste `liste` , l\u2019\u00e9l\u00e9ment element est ajout\u00e9 dans `L` apr\u00e8s tous les \u00e9l\u00e9ments de la liste `liste` . Exemple : ```python >>> ajoute(1, 4, [7, 8, 9]) [7, 4, 8, 9] >>> ajoute(3, 4, [7, 8, 9]) [7, 8, 9, 4] >>> ajoute(4, 4, [7, 8, 9]) [7, 8, 9, 4] Compl\u00e9ter et tester le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def ajoute ( indice , element , liste ): nbre_elts = len ( liste ) L = [ 0 for i in range ( nbre_elts + 1 )] if ... : for i in range ( indice ): L [ i ] = ... L [ ... ] = ... for i in range ( indice + 1 , nbre_elts + 1 ): L [ i ] = ... else : for i in range ( nbre_elts ): L [ i ] = ... L [ ... ] = ... return L ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 30 \u2693\ufe0e Version originale du sujet en pdf. Exercice 30.1 \u2693\ufe0e Exercice 30.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> moyenne([1.0]) 1.0 >>> moyenne([1.0, 2.0, 4.0]) 2.3333333333333335 ``` R\u00e9digez votre code sur Basthon Exercice 30.2 \u2693\ufe0e Exercice 30.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction binaire ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. L\u2019algorithme utilise la m\u00e9thode des divisions euclidiennes successives comme l\u2019illustre l\u2019exemple ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter le code de la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 83 ) '1010011' >>> binaire ( 127 ) '1111111' >>> binaire ( 0 ) '0' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown On consid\u00e8re la fonction `binaire` ci-dessous qui prend en param\u00e8tre un entier positif `a` en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. L\u2019algorithme utilise la m\u00e9thode des divisions euclidiennes successives comme l\u2019illustre l\u2019exemple ci-apr\u00e8s. ![ image ]( data2023/30_divisions.png ){: .center} ```python linenums='1' def binaire(a): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter le code de la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 83 ) '1010011' >>> binaire ( 127 ) '1111111' >>> binaire ( 0 ) '0' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 31 \u2693\ufe0e Version originale du sujet en pdf. Exercice 31.1 \u2693\ufe0e Exercice 31.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction Python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 , [ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' , [ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 , [ 1 , '!' , 7 , 21 , 36 , 44 ]) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \ud83d\udccb Texte \u00c9crire une fonction Python appel\u00e9e `nb_repetitions` qui prend en param\u00e8tres un \u00e9l\u00e9ment `elt` et une liste `tab` et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : ```python >>> nb_repetitions(5, [2, 5, 3, 5, 6, 9, 5]) 3 >>> nb_repetitions('A', ['B', 'A', 'B', 'A', 'R']) 2 >>> nb_repetitions(12, [1, '!', 7, 21, 36, 44]) 0 ``` R\u00e9digez votre code sur Basthon Exercice 31.2 \u2693\ufe0e Exercice 31.2 \u00c9nonc\u00e9 Correction Sources Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : ![ image ]( data2023/31_divisions.png ){: .center} Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : ```python linenums='1' def binaire(a): bin_a = str(...) a = a // 2 while a ... : bin_a = ...(a%2) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 32 \u2693\ufe0e Version originale du sujet en pdf. Exercice 32.1 \u2693\ufe0e Exercice 32.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction min_et_max qui prend en param\u00e8tre un tableau de nombres tab non vide, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s min et max . Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. L\u2019utilisation des fonctions natives min , max et sorted , ainsi que la m\u00e9thode sort n\u2019est pas autoris\u00e9e. Exemples : \ud83d\udc0d Script Python >>> min_et_max ([ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ]) { 'min' : - 2 , 'max' : 9 } >>> min_et_max ([ 0 , 1 , 2 , 3 ]) { 'min' : 0 , 'max' : 3 } >>> min_et_max ([ 3 ]) { 'min' : 3 , 'max' : 3 } >>> min_et_max ([ 1 , 3 , 2 , 1 , 3 ]) { 'min' : 1 , 'max' : 3 } >>> min_et_max ([ - 1 , - 1 , - 1 , - 1 , - 1 ]) { 'min' : - 1 , 'max' : - 1 } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def min_et_max ( tab ): d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \ud83d\udccb Texte \u00c9crire une fonction `min_et_max` qui prend en param\u00e8tre un tableau de nombres `tab` non vide, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s `min` et `max`. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. L\u2019utilisation des fonctions natives `min`, `max` et `sorted`, ainsi que la m\u00e9thode `sort` n\u2019est pas autoris\u00e9e. Exemples : ```python >>> min_et_max([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) {'min': -2, 'max': 9} >>> min_et_max([0, 1, 2, 3]) {'min': 0, 'max': 3} >>> min_et_max([3]) {'min': 3, 'max': 3} >>> min_et_max([1, 3, 2, 1, 3]) {'min': 1, 'max': 3} >>> min_et_max([-1, -1, -1, -1, -1]) {'min': -1, 'max': -1} ``` R\u00e9digez votre code sur Basthon Exercice 32.2 \u2693\ufe0e Exercice 32.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019une classe Carte permettant de cr\u00e9er des objets mod\u00e9lisant des cartes \u00e0 jouer. Compl\u00e9ter la classe Paquet_de_cartes suivante en respectant les sp\u00e9cifications donn\u00e9es dans les cha\u00eenes de documentation. Ajouter une assertion dans la m\u00e9thode get_carte afin de v\u00e9rifier que le param\u00e8tre pos est correct. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Carte : def __init__ ( self , c , v ): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def get_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def get_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" # A compl\u00e9ter def get_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" # A compl\u00e9ter Exemple : \ud83d\udc0d Script Python Exemple : >>> jeu = Paquet_de_cartes () >>> carte1 = jeu . get_carte ( 20 ) >>> print ( carte1 . get_valeur () + \" de \" + carte1 . get_couleur ()) 8 de coeur >>> carte2 = jeu . get_carte ( 0 ) >>> print ( carte2 . get_valeur () + \" de \" + carte2 . get_couleur ()) As de pique >>> carte3 = jeu . get_carte ( 52 ) AssertionError : param\u00e8tre pos invalide \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Carte : def __init__ ( self , c , v ): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def get_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def get_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" self . contenu = [ Carte ( c , v ) for c in range ( 1 , 5 ) for v in range ( 1 , 14 )] def get_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" assert 0 <= pos <= 51 , 'param\u00e8tre pos invalide' return self . contenu [ pos ] Markdown On dispose d\u2019une classe `Carte` permettant de cr\u00e9er des objets mod\u00e9lisant des cartes \u00e0 jouer. Compl\u00e9ter la classe `Paquet_de_cartes` suivante en respectant les sp\u00e9cifications donn\u00e9es dans les cha\u00eenes de documentation. Ajouter une assertion dans la m\u00e9thode `get_carte` afin de v\u00e9rifier que le param\u00e8tre `pos` est correct. ```python linenums='1' class Carte: def __init__ (self, c, v): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self.couleur = c self.valeur = v def get_valeur(self): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = ['As','2', '3', '4', '5', '6', '7', '8', '9', '10', 'Valet', 'Dame', 'Roi'] return valeurs[self.valeur - 1] def get_couleur(self): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = ['pique', 'coeur', 'carreau', 'tr\u00e8fle'] return couleurs[self.couleur - 1] class Paquet_de_cartes: def __init__ (self): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" # A compl\u00e9ter def get_carte(self, pos): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" # A compl\u00e9ter Exemple : \ud83d\udc0d Script Python Exemple : >>> jeu = Paquet_de_cartes () >>> carte1 = jeu . get_carte ( 20 ) >>> print ( carte1 . get_valeur () + \" de \" + carte1 . get_couleur ()) 8 de coeur >>> carte2 = jeu . get_carte ( 0 ) >>> print ( carte2 . get_valeur () + \" de \" + carte2 . get_couleur ()) As de pique >>> carte3 = jeu . get_carte ( 52 ) AssertionError : param\u00e8tre pos invalide ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 33 \u2693\ufe0e Version originale du sujet en pdf. Exercice 33.1 \u2693\ufe0e Exercice 33.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153uds. On observe que, par exemple, arbre[lettre][0] , respectivement arbre[lettre][1] , permet d\u2019atteindre la cl\u00e9 du sous-arbre gauche, respectivement droit, de l\u2019arbre arbre de sommet lettre . Exemple : \ud83d\udc0d Script Python >>> taille ( a , \u2019 F \u2019 ) 9 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 ou plus simplement : \ud83d\udc0d Script Python 1 2 3 4 def taille ( arbre , lettre ): if lettre == '' : return 0 return 1 + taille ( arbre , arbre [ lettre ][ 0 ]) + taille ( arbre , arbre [ lettre ][ 1 ]) \ud83d\udccb Texte Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre ![image](data2023/33_arbre.png){: .center} est stock\u00e9 dans ```python a = {'F':['B','G'], 'B':['A','D'], 'A':['',''], 'D':['C','E'], \\ 'C':['',''], 'E':['',''], 'G':['','I'], 'I':['','H'], \\ 'H':['','']} ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tres un arbre binaire `arbre` sous la forme d\u2019un dictionnaire et un caract\u00e8re `lettre` qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153uds. On observe que, par exemple, `arbre[lettre][0]`, respectivement `arbre[lettre][1]`, permet d\u2019atteindre la cl\u00e9 du sous-arbre gauche, respectivement droit, de l\u2019arbre `arbre` de sommet `lettre`. Exemple : ```python >>> taille(a, \u2019F\u2019) 9 ``` R\u00e9digez votre code sur Basthon Exercice 33.2 \u2693\ufe0e Exercice 33.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt le sous- tableau des \u00e9l\u00e9ments non rang\u00e9s et on place le plus petit \u00e9l\u00e9ment en premi\u00e8re position de ce sous-tableau. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus petit \u00e9l\u00e9ment avec le premier. Le tableau devient t = [6, 55, 21, 18, 12, 41, 25] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le premier, on permute le plus petit \u00e9l\u00e9ment trouv\u00e9 avec le second. Le tableau devient : t = [6, 12, 21, 18, 55, 41, 25] Et ainsi de suite. La code de la fonction tri_selection qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): N = len ( tab ) for k in range ( ... ): imin = ... for i in range ( ... , N ): if tab [ i ] < ... : imin = i ... , tab [ imin ] = tab [ imin ] , ... Compl\u00e9ter le code de cette fonction de fa\u00e7on \u00e0 obtenir : \ud83d\udc0d Script Python >>> liste = [ 41 , 55 , 21 , 18 , 12 , 6 , 25 ] >>> tri_selection ( liste ) >>> liste [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et de b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): N = len ( tab ) for k in range ( N ): imin = k for i in range ( k + 1 , N ): if tab [ i ] < tab [ imin ] : imin = i tab [ k ] , tab [ imin ] = tab [ imin ] , tab [ k ] Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt le sous- tableau des \u00e9l\u00e9ments non rang\u00e9s et on place le plus petit \u00e9l\u00e9ment en premi\u00e8re position de ce sous-tableau. Exemple avec le tableau : ```t = [41, 55, 21, 18, 12, 6, 25]``` - \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus petit \u00e9l\u00e9ment avec le premier. Le tableau devient `t = [6, 55, 21, 18, 12, 41, 25]` - \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le premier, on permute le plus petit \u00e9l\u00e9ment trouv\u00e9 avec le second. Le tableau devient : ```t = [6, 12, 21, 18, 55, 41, 25]``` Et ainsi de suite. La code de la fonction `tri_selection` qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. ```python linenums='1' def tri_selection(tab): N = len(tab) for k in range(...): imin = ... for i in range(... , N): if tab[i] < ... : imin = i ... , tab[imin] = tab[imin] , ... Compl\u00e9ter le code de cette fonction de fa\u00e7on \u00e0 obtenir : \ud83d\udc0d Script Python >>> liste = [ 41 , 55 , 21 , 18 , 12 , 6 , 25 ] >>> tri_selection ( liste ) >>> liste [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et de b . ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 34 \u2693\ufe0e Version originale du sujet en pdf. Exercice 34.1 \u2693\ufe0e Exercice 34.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (de type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide. Proposer une fa\u00e7on de traiter le cas o\u00f9 le tableau pass\u00e9 en param\u00e8tre est vide. Dans cet exercice, on s\u2019interdira d\u2019utiliser la fonction Python sum . Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) # Comportement diff\u00e9rent suivant le traitement propos\u00e9. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'Le tableau donn\u00e9 est vide' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte Programmer la fonction ```moyenne``` prenant en param\u00e8tre un tableau d'entiers ```tab``` (de type `list`) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide. Proposer une fa\u00e7on de traiter le cas o\u00f9 le tableau pass\u00e9 en param\u00e8tre est vide. Dans cet exercice, on s\u2019interdira d\u2019utiliser la fonction Python `sum`. Exemples : ```python >>> moyenne([5,3,8]) 5.333333333333333 >>> moyenne([1,2,3,4,5,6,7,8,9,10]) 5.5 >>> moyenne([]) # Comportement diff\u00e9rent suivant le traitement propos\u00e9. ``` R\u00e9digez votre code sur Basthon Exercice 34.2 \u2693\ufe0e Exercice 34.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau d'entiers tab (de type list ) dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tri ( tab ): # i est le premier indice de la zone non tri\u00e9e, # j est le dernier indice de cette zone non tri\u00e9e. # Au d\u00e9but, la zone non tri\u00e9e est le tableau complet. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tri ( tab ): # i est le premier indice de la zone non tri\u00e9e, # j est le dernier indice de cette zone non tri\u00e9e. # Au d\u00e9but, la zone non tri\u00e9e est le tableau complet. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab Markdown On consid\u00e8re un tableau d'entiers `tab` (de type `list` ) dont les \u00e9l\u00e9ments sont des `0` ou des `1` ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des `0` , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des `1` . <table> <tr> <td>Zone de 0</td><td>Zone non tri\u00e9e</td><td>Zone de 1</td> </tr> </table> Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : - si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; - si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction `tri` suivante : ```python linenums='1' def tri(tab): # i est le premier indice de la zone non tri\u00e9e, # j est le dernier indice de cette zone non tri\u00e9e. # Au d\u00e9but, la zone non tri\u00e9e est le tableau complet. i = ... j = ... while i != j: if tab[i]== 0: i = ... else: valeur = tab[j] tab[j] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 35 \u2693\ufe0e Version originale du sujet en pdf. Exercice 35.1 \u2693\ufe0e Exercice 35.1 \u00c9nonc\u00e9 Correction Source Markdown L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents. Il est symbolis\u00e9 par le caract\u00e8re \u2295. Ainsi : 0 \u2295 0 = 0 0 \u2295 1 = 1 1 \u2295 0 = 1 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : \ud83d\udc0d Script Python a = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ] b = [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] c = [ 1 , 1 , 0 , 1 ] d = [ 0 , 0 , 1 , 1 ] \u00c9crire la fonction ou_exclusif qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction donne : \ud83d\udc0d Script Python >>> ou_exclusif ( a , b ) [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ] >>> ou_exclusif ( c , d ) [ 1 , 1 , 1 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 def ou_exclusif ( tab1 , tab2 ): resultat = [] taille = len ( tab1 ) for i in range ( taille ): resultat . append ( tab1 [ i ] ^ tab2 [ i ]) return resultat Si on ne connait pas la fonction native ^ qui fait le \u00abou exclusif\u00bb de deux entiers en Python, on peut la recoder : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def ou_exc ( a , b ): if a == 0 and b == 0 : return 0 if a == 0 and b == 1 : return 1 if a == 1 and b == 0 : return 1 if a == 1 and b == 1 : return 0 Le code devient alors : \ud83d\udc0d Script Python 1 2 3 4 5 6 def ou_exclusif ( tab1 , tab2 ): resultat = [] taille = len ( tab1 ) for i in range ( taille ): resultat . append ( ou_exc ( tab1 [ i ], tab2 [ i ])) return resultat \ud83d\udccb Texte L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents. Il est symbolis\u00e9 par le caract\u00e8re \u2295. Ainsi : - 0 \u2295 0 = 0 - 0 \u2295 1 = 1 - 1 \u2295 0 = 1 - 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : ```python a = [1, 0, 1, 0, 1, 1, 0, 1] b = [0, 1, 1, 1, 0, 1, 0, 0] c = [1, 1, 0, 1] d = [0, 0, 1, 1] ``` \u00c9crire la fonction ```ou_exclusif``` qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position `i` est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position `i` des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction donne : ```python >>> ou_exclusif(a, b) [1, 1, 0, 1, 1, 0, 0, 1] >>> ou_exclusif(c, d) [1, 1, 1, 0] ``` R\u00e9digez votre code sur Basthon Exercice 35.2 \u2693\ufe0e Exercice 35.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit semimagique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne sont \u00e9gales. Ainsi c2 et c3 sont semimagiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 8 pour c2 et 12 pour c3. Le carre c3bis n'est pas semimagique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 15 alors que celle de la deuxi\u00e8me ligne est \u00e9gale \u00e0 10. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. La m\u00e9thode constructeur cr\u00e9e un carr\u00e9 sous forme d\u2019un tableau \u00e0 deux dimensions \u00e0 partir d\u2019une liste d\u2019entiers, et d\u2019un ordre. La m\u00e9thode affiche permet d\u2019afficher le carr\u00e9 cr\u00e9\u00e9. Exemple : \ud83d\udc0d Script Python >>> liste = ( 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ) >>> c3 = Carre ( liste , 3 ) >>> c3 . affiche () [ 3 , 4 , 5 ] [ 4 , 4 , 4 ] [ 5 , 4 , 3 ] Compl\u00e9ter la m\u00e9thode est_semimagique qui renvoie True si le carr\u00e9 est semimagique, False sinon. Puis tester la fonction est_semimagique sur les carr\u00e9s c2, c3 et c3bis. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... ): if ... != s : return ... #test de la somme de chaque colonne for j in range ( ... ): if ... != s : return ... return ... Listes permettant de g\u00e9n\u00e9rer les carr\u00e9s c2, c3 et c3bis : \ud83d\udc0d Script Python 1 2 3 lst_c2 = [ 1 , 7 , 7 , 1 ] lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] lst_c3bis = [ 2 , 9 , 4 , 7 , 0 , 3 , 6 , 1 , 8 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( self . ordre ): if self . somme_ligne ( i ) != s : return False #test de la somme de chaque colonne for j in range ( self . ordre ): if self . somme_col ( j ) != s : return False return True Tests avec : \ud83d\udc0d Script Python 1 2 3 lst_c2 = [ 1 , 7 , 7 , 1 ] lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] lst_c3bis = [ 2 , 9 , 4 , 7 , 0 , 3 , 6 , 1 , 8 ] \ud83d\udc0d Script Python >>> c2 = Carre ( lst_c2 , 2 ) >>> c2 . est_semimagique () True >>> c3 = Carre ( lst_c3 , 3 ) >>> c3 . est_semimagique () True >>> c3bis = Carre ( lst_c3bis , 2 ) >>> c3bis . est_semimagique () False Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre $n$ un tableau de $n$ lignes et $n$ colonnes dont chaque case contient un entier naturel. Exemples : ![ image ]( data2023/35_carre.png ){: .center} Un carr\u00e9 est dit semimagique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne sont \u00e9gales. - Ainsi c2 et c3 sont semimagiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 8 pour c2 et 12 pour c3. - Le carre c3bis n'est pas semimagique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 15 alors que celle de la deuxi\u00e8me ligne est \u00e9gale \u00e0 10. La classe `Carre` ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. - La m\u00e9thode constructeur cr\u00e9e un carr\u00e9 sous forme d\u2019un tableau \u00e0 deux dimensions \u00e0 partir d\u2019une liste d\u2019entiers, et d\u2019un ordre. - La m\u00e9thode `affiche` permet d\u2019afficher le carr\u00e9 cr\u00e9\u00e9. Exemple : ```python >>> liste = (3, 4, 5, 4, 4, 4, 5, 4, 3) >>> c3 = Carre(liste, 3) >>> c3.affiche() [3, 4, 5] [4, 4, 4] [5, 4, 3] Compl\u00e9ter la m\u00e9thode est_semimagique qui renvoie True si le carr\u00e9 est semimagique, False sinon. Puis tester la fonction est_semimagique sur les carr\u00e9s c2, c3 et c3bis. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... ): if ... != s : return ... #test de la somme de chaque colonne for j in range ( ... ): if ... != s : return ... return ... Listes permettant de g\u00e9n\u00e9rer les carr\u00e9s c2, c3 et c3bis : \ud83d\udc0d Script Python 1 2 3 lst_c2 = [ 1 , 7 , 7 , 1 ] lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] lst_c3bis = [ 2 , 9 , 4 , 7 , 0 , 3 , 6 , 1 , 8 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 36 \u2693\ufe0e Version originale du sujet en pdf. Exercice 36.1 \u2693\ufe0e Exercice 36.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction couples_consecutifs qui prend en param\u00e8tre une liste de nombres entiers tab non vide, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> couples_consecutifs ([ 1 , 4 , 3 , 5 ]) [] >>> couples_consecutifs ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> couples_consecutifs ([ 1 , 1 , 2 , 4 ]) [( 1 , 2 )] >>> couples_consecutifs ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> couples_consecutifs ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] \ud83d\udc0d Script Python 1 2 3 4 5 6 def couples_consecutifs ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \ud83d\udccb Texte \u00c9crire une fonction `couples_consecutifs` qui prend en param\u00e8tre une liste de nombres entiers `tab` non vide, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans `tab`. Exemples : ```python >>> couples_consecutifs([1, 4, 3, 5]) [] >>> couples_consecutifs([1, 4, 5, 3]) [(4, 5)] >>> couples_consecutifs([1, 1, 2, 4]) [(1, 2)] >>> couples_consecutifs([7, 1, 2, 5, 3, 4]) [(1, 2), (3, 4)] >>> couples_consecutifs([5, 1, 2, 3, 8, -5, -4, 7]) [(1, 2), (2, 3), (-5, -4)] ``` R\u00e9digez votre code sur Basthon Exercice 36.2 \u2693\ufe0e Exercice 36.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M (repr\u00e9sent\u00e9e par une liste de listes), deux entiers i et j et unevaleur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M, 2, 1, 3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : M [ i ][ j ] = val # l'element en haut fait partie de la composante if i - 1 >= 0 and M [ i - 1 ][ j ] == ... : propager ( M , i - 1 , j , val ) # l'element en bas fait partie de la composante if ... < len ( M ) and M [ i + 1 ][ j ] == 1 : propager ( M , ... , j , val ) # l'element \u00e0 gauche fait partie de la composante if ... and M [ i ][ j - 1 ] == 1 : propager ( M , ... , ... , val ) # l'element \u00e0 droite fait partie de la composante if ... and ... : propager ( ... , ... , ... , ... ) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def propager ( M , i , j , val ): if M [ i ][ j ] == 1 : M [ i ][ j ] = val # l'element en haut fait partie de la composante if i - 1 >= 0 and M [ i - 1 ][ j ] == 1 : propager ( M , i - 1 , j , val ) # l'element en bas fait partie de la composante if i + 1 < len ( M ) and M [ i + 1 ][ j ] == 1 : propager ( M , i + 1 , j , val ) # l'element \u00e0 gauche fait partie de la composante if j - 1 >= 0 and M [ i ][ j - 1 ] == 1 : propager ( M , i , j - 1 , val ) # l'element \u00e0 droite fait partie de la composante if j + 1 < len ( M [ i ]) and M [ i ][ j + 1 ] == 1 : propager ( M , i , j + 1 , val ) ce code va d\u00e9clencher la propagation m\u00eame si la cellule i,j n'est pas \u00e0 1. C'est sans doute une erreur d'\u00e9nonc\u00e9. Il faudrait plut\u00f4t \u00e9crire ceci : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def propager ( M , i , j , val ): if M [ i ][ j ] == 1 : M [ i ][ j ] = val # l'element en haut fait partie de la composante if i - 1 >= 0 and M [ i - 1 ][ j ] == 1 : propager ( M , i - 1 , j , val ) # l'element en bas fait partie de la composante if i + 1 < len ( M ) and M [ i + 1 ][ j ] == 1 : propager ( M , i + 1 , j , val ) # l'element \u00e0 gauche fait partie de la composante if j - 1 >= 0 and M [ i ][ j - 1 ] == 1 : propager ( M , i , j - 1 , val ) # l'element \u00e0 droite fait partie de la composante if j + 1 < len ( M [ i ]) and M [ i ][ j + 1 ] == 1 : propager ( M , i , j + 1 , val ) Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments `M[i][j]` , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 `0` soit \u00e0 `1` . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de `1` et de `0` qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de ![ image ]( data2023/36_carre1.png ){: .center} sont ![ image ]( data2023/36_carre2.png ){: .center width=30%} On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 `1` dans une image `M` , donner la valeur `val` \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction `propager` prend pour param\u00e8tre une image `M` (repr\u00e9sent\u00e9e par une liste de listes), deux entiers `i` et `j` et unevaleur enti\u00e8re `val` . Elle met \u00e0 la valeur `val` tous les pixels de la composante du pixel `M[i][j]` s\u2019il vaut `1` et ne fait rien s\u2019il vaut `0` . Par exemple, `propager(M, 2, 1, 3)` donne ![ image ]( data2023/36_carre3.png ){: .center width=30%} Compl\u00e9ter le code r\u00e9cursif de la fonction `propager` donn\u00e9 ci-dessous : ```python linenums='1' def propager(M, i, j, val): if M[i][j] == ...: M[i][j] = val # l'element en haut fait partie de la composante if i-1 >= 0 and M[i-1][j] == ...: propager(M, i-1, j, val) # l'element en bas fait partie de la composante if ... < len(M) and M[i+1][j] == 1: propager(M, ..., j, val) # l'element \u00e0 gauche fait partie de la composante if ... and M[i][j-1] == 1: propager(M, ..., ..., val) # l'element \u00e0 droite fait partie de la composante if ... and ...: propager(..., ..., ..., ...) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 37 \u2693\ufe0e Version originale du sujet en pdf. Exercice 37.1 \u2693\ufe0e Exercice 37.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la derni\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 1 , [ 1 , 0 , 42 , 7 ]) 0 >>> recherche ( 1 , [ 1 , 50 , 1 ]) 2 >>> recherche ( 1 , [ 8 , 1 , 10 , 1 , 7 , 1 , 8 ]) 5 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab ) - 1 , - 1 , - 1 ): if tab [ i ] == elt : return i return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la derni\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(1, [1, 0, 42, 7]) 0 >>> recherche(1, [1, 50, 1]) 2 >>> recherche(1, [8, 1, 10, 1, 7, 1, 8]) 5 ``` R\u00e9digez votre code sur Basthon Exercice 37.2 \u2693\ufe0e Exercice 37.2 \u00c9nonc\u00e9 Correction Sources Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de `192.168.0.0` \u00e0 `192.168.0.255` . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP `192.168.0.0` et `192.168.0.255` sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe `AdresseIP` . ```python linenums='1' class AdresseIP: def __init__ (self, adresse): self.adresse = ... def liste_octet(self): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante(self): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254: octet_nouveau = ... + ... return AdresseIP('192.168.0.' + ...) else: return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 38 \u2693\ufe0e Version originale du sujet en pdf. Exercice 38.1 \u2693\ufe0e Exercice 38.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res * . Par exemple INFO*MA*IQUE , ***I***E** et *S* sont des mots \u00e0 trous. Programmer une fonction correspond qui : prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res mot et mot_a_trous o\u00f9 mot_a_trous est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, renvoie : True si on peut obtenir mot en rempla\u00e7ant convenablement les caract\u00e8res '*' de mot_a_trous . False sinon. Exemple : \ud83d\udc0d Script Python >>> correspond ( 'INFORMATIQUE' , 'INFO*MA*IQUE' ) True >>> correspond ( 'AUTOMATIQUE' , 'INFO*MA*IQUE' ) False >>> correspond ( 'STOP' , 'S*' ) False >>> correspond ( 'AUTO' , '*UT*' ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def correspond ( mot , mot_a_trous ): if len ( mot ) != len ( mot_a_trous ): return False for i in range ( len ( mot )): if mot [ i ] != mot_a_trous [ i ] and mot_a_trous [ i ] != '*' : return False return True \ud83d\udccb Texte On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res `*`. Par exemple `INFO*MA*IQUE`, `***I***E**` et `*S*` sont des mots \u00e0 trous. Programmer une fonction `correspond` qui : - prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res `mot` et `mot_a_trous` o\u00f9 `mot_a_trous` est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, - renvoie : - `True` si on peut obtenir `mot` en rempla\u00e7ant convenablement les caract\u00e8res `'*'` de `mot_a_trous`. - `False` sinon. Exemple : ```python >>> correspond('INFORMATIQUE', 'INFO*MA*IQUE') True >>> correspond('AUTOMATIQUE', 'INFO*MA*IQUE') False >>> correspond('STOP', 'S*') False >>> correspond('AUTO', '*UT*') True ``` R\u00e9digez votre code sur Basthon Exercice 38.2 \u2693\ufe0e Exercice 38.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : chaque personne ne peut envoyer des messages qu'\u00e0 une seule personne (\u00e9ventuellement elle-m\u00eame), chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : A envoie ses messages \u00e0 E E envoie ses messages \u00e0 B B envoie ses messages \u00e0 F F envoie ses messages \u00e0 A C envoie ses messages \u00e0 D D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'} Un cycle est une suite de personnes dans laquelle la derni\u00e8re est la m\u00eame que la premi\u00e8re. Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'} comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle , on dit que le plan d\u2019envoi est cyclique . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : on part d\u2019un exp\u00e9diteur (ici A) et on inspecte son destinataire dans le plan d'envoi, chaque destinataire devient \u00e0 son tour exp\u00e9diteur, selon le plan d\u2019envoi, tant qu\u2019on ne \u00ab retombe \u00bb pas sur l\u2019exp\u00e9diteur initial, le plan d\u2019envoi est cyclique si on l\u2019a parcouru en entier. Compl\u00e9ter la fonction est_cyclique en respectant la sp\u00e9cification. Remarque : la fonction python len permet d'obtenir la longueur d'un dictionnaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' expediteur = 'A' destinataire = plan [ ... ] nb_destinaires = 1 while destinataire != ... : destinataire = plan [ ... ] nb_destinaires += ... return nb_destinaires == ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' expediteur = 'A' destinataire = plan [ expediteur ] nb_destinaires = 1 while destinataire != expediteur : destinataire = plan [ destinataire ] nb_destinaires += 1 return nb_destinaires == len ( plan ) #tests print ( est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' })) print ( est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' })) Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : - chaque personne ne peut envoyer des messages qu'\u00e0 une seule personne (\u00e9ventuellement elle-m\u00eame), - chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : - A envoie ses messages \u00e0 E - E envoie ses messages \u00e0 B - B envoie ses messages \u00e0 F - F envoie ses messages \u00e0 A - C envoie ses messages \u00e0 D - D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : `plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'}` Un cycle est une suite de personnes dans laquelle la derni\u00e8re est la m\u00eame que la premi\u00e8re. Sur le plan d'envoi `plan_a` des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi `plan_b` ci-dessous : `plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'}` comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un *unique cycle* , on dit que le plan d\u2019envoi est *cyclique* . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : - on part d\u2019un exp\u00e9diteur (ici A) et on inspecte son destinataire dans le plan d'envoi, - chaque destinataire devient \u00e0 son tour exp\u00e9diteur, selon le plan d\u2019envoi, tant qu\u2019on ne \u00ab retombe \u00bb pas sur l\u2019exp\u00e9diteur initial, - le plan d\u2019envoi est cyclique si on l\u2019a parcouru en entier. Compl\u00e9ter la fonction `est_cyclique` en respectant la sp\u00e9cification. *Remarque :* la fonction python `len` permet d'obtenir la longueur d'un dictionnaire. ```python linenums='1' def est_cyclique(plan): ''' Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' expediteur = 'A' destinataire = plan[ ... ] nb_destinaires = 1 while destinataire != ...: destinataire = plan[ ... ] nb_destinaires += ... return nb_destinaires == ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 39 \u2693\ufe0e Version originale du sujet en pdf. Exercice 39.1 \u2693\ufe0e Exercice 39.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par : les deux premiers termes sont \u00e9gaux \u00e0 1, ensuite, chaque terme est obtenu en faisant la somme des deux termes qui le pr\u00e9c\u00e8dent. En math\u00e9matiques, on le formule ainsi : \\(U_1 = 1\\) , \\(U_2 = 1\\) et, pour tout entier naturel non nul \\(n\\) , par \\(U_{n+2} = U_{n+1} + U_n\\) . Cette suite est connue sous le nom de suite de Fibonacci. \u00c9crire en Python une fonction fibonacci qui prend en param\u00e8tre un entier n suppos\u00e9 strictement positif et qui renvoie le terme d\u2019indice n de cette suite. Exemples : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 Version r\u00e9cursive : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonacci ( n ): if n == 1 : return 1 elif n == 1 : return 1 else : return fibonacci ( n - 1 ) + fibonacci ( n - 2 ) Version imp\u00e9rative : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def fibonacci ( n ): a = 1 b = 1 for k in range ( n - 2 ): t = b b = a + b a = t return b Version programmation dynamique : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonacci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] On peut constater que la version r\u00e9cursive \u00e9choue \u00e0 calculer fibonacci(45) , alors que les deux autres versions le font quasi-imm\u00e9diatement. \ud83d\udccb Texte On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par : - les deux premiers termes sont \u00e9gaux \u00e0 1, - ensuite, chaque terme est obtenu en faisant la somme des deux termes qui le pr\u00e9c\u00e8dent. En math\u00e9matiques, on le formule ainsi : $U_1 = 1$, $U_2 = 1$ et, pour tout entier naturel non nul $n$, par $U_{n+2} = U_{n+1} + U_n$. Cette suite est connue sous le nom de suite de Fibonacci. \u00c9crire en Python une fonction `fibonacci` qui prend en param\u00e8tre un entier `n` suppos\u00e9 strictement positif et qui renvoie le terme d\u2019indice `n` de cette suite. Exemples : ```python >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(25) 75025 >>> fibonacci(45) 1134903170 ``` R\u00e9digez votre code sur Basthon Exercice 39.2 \u2693\ufe0e Exercice 39.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction pantheon prenant en param\u00e8tres eleves et notes deux tableaux de m\u00eame longueur, le premier contenant le nom des \u00e9l\u00e8ves et le second, des entiers positifs d\u00e9signant leur note \u00e0 un contr\u00f4le de sorte que eleves[i] a obtenu la note notes[i] . Cette fonction renvoie le couple constitu\u00e9 de la note maximale attribu\u00e9e et des noms des \u00e9l\u00e8ves ayant obtenu cette note regroup\u00e9s dans un tableau. Ainsi, l\u2019instruction pantheon(['a', 'b', 'c', 'd'], [15, 18, 12, 18]) renvoie le couple (18, ['b', 'd']) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def pantheon ( eleves , notes ): note_maxi = 0 meilleurs_eleves = ... for i in range ( ... ) : if notes [ i ] == ... : meilleurs_eleves . append ( ... ) elif notes [ i ] > note_maxi : note_maxi = ... meilleurs_eleves = [ ... ] return ( note_maxi , meilleurs_eleves ) Compl\u00e9ter ce code. Exemples : \ud83d\udc0d Script Python >>> eleves_nsi = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] >>> notes_nsi = [ 30 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] >>> pantheon ( eleves_nsi , notes_nsi ) ( 80 , [ 'c' , 'f' , 'h' ]) >>> pantheon ([],[]) ( 0 , []) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def pantheon ( eleves , notes ): note_maxi = 0 meilleurs_eleves = [] for i in range ( len ( eleves )) : if notes [ i ] == note_maxi : meilleurs_eleves . append ( eleves [ i ]) elif notes [ i ] > note_maxi : note_maxi = notes [ i ] meilleurs_eleves = [ eleves [ i ]] return ( note_maxi , meilleurs_eleves ) Markdown On consid\u00e8re la fonction `pantheon` prenant en param\u00e8tres `eleves` et `notes` deux tableaux de m\u00eame longueur, le premier contenant le nom des \u00e9l\u00e8ves et le second, des entiers positifs d\u00e9signant leur note \u00e0 un contr\u00f4le de sorte que `eleves[i]` a obtenu la note `notes[i]` . Cette fonction renvoie le couple constitu\u00e9 de la note maximale attribu\u00e9e et des noms des \u00e9l\u00e8ves ayant obtenu cette note regroup\u00e9s dans un tableau. Ainsi, l\u2019instruction `pantheon(['a', 'b', 'c', 'd'], [15, 18, 12, 18])` renvoie le couple `(18, ['b', 'd'])` . ```python linenums='1' def pantheon(eleves, notes): note_maxi = 0 meilleurs_eleves = ... for i in range(...) : if notes[i] == ... : meilleurs_eleves.append(...) elif notes[i] > note_maxi: note_maxi = ... meilleurs_eleves = [...] return (note_maxi,meilleurs_eleves) Compl\u00e9ter ce code. Exemples : \ud83d\udc0d Script Python >>> eleves_nsi = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] >>> notes_nsi = [ 30 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] >>> pantheon ( eleves_nsi , notes_nsi ) ( 80 , [ 'c' , 'f' , 'h' ]) >>> pantheon ([],[]) ( 0 , []) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 40 \u2693\ufe0e Version originale du sujet en pdf. Exercice 40.1 \u2693\ufe0e Exercice 40.1 \u00c9nonc\u00e9 Correction Source Markdown Pour cet exercice : On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace ' ' , se finissant : soit par un point '.' qui est alors coll\u00e9 au dernier mot, soit par un point d'exclamation '!' ou d'interrogation '?' qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace ' ' . Exemples : 'Cet exercice est simple.' 'Le point d exclamation est separe !' Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction nombre_de_mots qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. \ud83d\udc0d Script Python >>> nombre_de_mots ( 'Le point d exclamation est separe !' ) 6 >>> nombre_de_mots ( 'Il y a un seul espace entre les mots !' ) 9 >>> nombre_de_mots ( 'Combien de mots y a t il dans cette phrase ?' ) 10 >>> nombre_de_mots ( 'Fin.' ) 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nombre_de_mots ( phrase ): nb_mots = 0 for caractere in phrase : if caractere == ' ' or caractere == '.' : nb_mots += 1 return nb_mots \ud83d\udccb Texte Pour cet exercice : - On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, - On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : - compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace `' '`, - se finissant : - soit par un point `'.'` qui est alors coll\u00e9 au dernier mot, - soit par un point d'exclamation `'!'` ou d'interrogation `'?'` qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace `' '`. *Exemples :* - 'Cet exercice est simple.' - 'Le point d exclamation est separe !' Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction `nombre_de_mots` qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. ```python >>> nombre_de_mots('Le point d exclamation est separe !') 6 >>> nombre_de_mots('Il y a un seul espace entre les mots !') 9 >>> nombre_de_mots('Combien de mots y a t il dans cette phrase ?') 10 >>> nombre_de_mots('Fin.') 1 ``` R\u00e9digez votre code sur Basthon Exercice 40.2 \u2693\ufe0e Exercice 40.2 \u00c9nonc\u00e9 Correction Sources Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Noeud : def __init__ ( self , valeur ): '''M\u00e9thode constructeur pour la classe Noeud. Param\u00e8tre d'entr\u00e9e : valeur (str)''' self . valeur = valeur self . gauche = None self . droit = None def getValeur ( self ): '''M\u00e9thode accesseur pour obtenir la valeur du noeud Aucun param\u00e8tre en entr\u00e9e''' return self . valeur def droitExiste ( self ): '''M\u00e9thode renvoyant True si l'enfant droit existe Aucun param\u00e8tre en entr\u00e9e''' return ( self . droit is not None ) def gaucheExiste ( self ): '''M\u00e9thode renvoyant True si l'enfant gauche existe Aucun param\u00e8tre en entr\u00e9e''' return ( self . gauche is not None ) def inserer ( self , cle ): '''M\u00e9thode d'insertion de cl\u00e9 dans un arbre binaire de recherche Param\u00e8tre d'entr\u00e9e : cle (int)''' if cle < ... : # on ins\u00e8re \u00e0 gauche if self . gaucheExiste (): # on descend \u00e0 gauche et on retente l'insertion de la cl\u00e9 ... else : # on cr\u00e9e un fils gauche self . gauche = ... elif cle > ... : # on ins\u00e8re \u00e0 droite if ... : # on descend \u00e0 droite et on retente l'insertion de la cl\u00e9 ... else : # on cr\u00e9e un fils droit ... = Noeud ( cle ) Compl\u00e9ter la fonction r\u00e9cursive inserer afin qu'elle permette d\u2019ins\u00e9rer un n\u0153ud dans l\u2019arbre binaire de recherche propos\u00e9, \u00e0 l\u2019aide de sa cl\u00e9. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> arbre = Noeud ( 7 ) >>> for cle in ( 3 , 9 , 1 , 6 ): arbre . inserer ( cle ) >>> arbre . gauche . getValeur () 3 >>> arbre . droit . getValeur () 9 >>> arbre . gauche . gauche . getValeur () 1 >>> arbre . gauche . droit . getValeur () 6 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Noeud : def __init__ ( self , valeur ): '''M\u00e9thode constructeur pour la classe Noeud. Param\u00e8tre d'entr\u00e9e : valeur (str)''' self . valeur = valeur self . gauche = None self . droit = None def getValeur ( self ): '''M\u00e9thode accesseur pour obtenir la valeur du noeud Aucun param\u00e8tre en entr\u00e9e''' return self . valeur def droitExiste ( self ): '''M\u00e9thode renvoyant True si l'enfant droit existe Aucun param\u00e8tre en entr\u00e9e''' return ( self . droit is not None ) def gaucheExiste ( self ): '''M\u00e9thode renvoyant True si l'enfant gauche existe Aucun param\u00e8tre en entr\u00e9e''' return ( self . gauche is not None ) def inserer ( self , cle ): '''M\u00e9thode d'insertion de cl\u00e9 dans un arbre binaire de recherche Param\u00e8tre d'entr\u00e9e : cle (int)''' if cle < self . valeur : # on ins\u00e8re \u00e0 gauche if self . gaucheExiste (): # on descend \u00e0 gauche et on retente l'insertion de la cl\u00e9 self . gauche . inserer ( cle ) else : # on cr\u00e9e un fils gauche self . gauche = Noeud ( cle ) elif cle > self . valeur : # on ins\u00e8re \u00e0 droite if self . droitExiste (): # on descend \u00e0 droite et on retente l'insertion de la cl\u00e9 self . droit . inserer ( cle ) else : # on cr\u00e9e un fils droit self . droit = Noeud ( cle ) Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. ```python linenums='1' class Noeud: def __init__ (self, valeur): '''M\u00e9thode constructeur pour la classe Noeud. Param\u00e8tre d'entr\u00e9e : valeur (str)''' self.valeur = valeur self.gauche = None self.droit = None def getValeur(self): '''M\u00e9thode accesseur pour obtenir la valeur du noeud Aucun param\u00e8tre en entr\u00e9e''' return self.valeur def droitExiste(self): '''M\u00e9thode renvoyant True si l'enfant droit existe Aucun param\u00e8tre en entr\u00e9e''' return (self.droit is not None) def gaucheExiste(self): '''M\u00e9thode renvoyant True si l'enfant gauche existe Aucun param\u00e8tre en entr\u00e9e''' return (self.gauche is not None) def inserer(self, cle): '''M\u00e9thode d'insertion de cl\u00e9 dans un arbre binaire de recherche Param\u00e8tre d'entr\u00e9e : cle (int)''' if cle < ...: # on ins\u00e8re \u00e0 gauche if self.gaucheExiste(): # on descend \u00e0 gauche et on retente l'insertion de la cl\u00e9 ... else: # on cr\u00e9e un fils gauche self.gauche = ... elif cle > ... : # on ins\u00e8re \u00e0 droite if ... : # on descend \u00e0 droite et on retente l'insertion de la cl\u00e9 ... else: # on cr\u00e9e un fils droit ... = Noeud(cle) Compl\u00e9ter la fonction r\u00e9cursive inserer afin qu'elle permette d\u2019ins\u00e9rer un n\u0153ud dans l\u2019arbre binaire de recherche propos\u00e9, \u00e0 l\u2019aide de sa cl\u00e9. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> arbre = Noeud ( 7 ) >>> for cle in ( 3 , 9 , 1 , 6 ): arbre . inserer ( cle ) >>> arbre . gauche . getValeur () 3 >>> arbre . droit . getValeur () 9 >>> arbre . gauche . gauche . getValeur () 1 >>> arbre . gauche . droit . getValeur () 6 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 41 \u2693\ufe0e Version originale du sujet en pdf. Exercice 41.1 \u2693\ufe0e Exercice 41.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche(caractere, chaine) qui prend en param\u00e8tres caractere , un unique caract\u00e8re (c\u2019est-\u00e0-dire une cha\u00eene de caract\u00e8re de longueur 1), et chaine , une cha\u00eene de caract\u00e8res. Cette fonction renvoie le nombre d\u2019occurrences de caractere dans chaine , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans chaine. Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( caractere , chaine ): somme = 0 for lettre in chaine : if lettre == caractere : somme += 1 return somme \ud83d\udccb Texte \u00c9crire une fonction `recherche(caractere, chaine)` qui prend en param\u00e8tres `caractere`, un unique caract\u00e8re (c\u2019est-\u00e0-dire une cha\u00eene de caract\u00e8re de longueur 1), et `chaine`, une cha\u00eene de caract\u00e8res. Cette fonction renvoie le nombre d\u2019occurrences de `caractere` dans `chaine`, c\u2019est-\u00e0-dire le nombre de fois o\u00f9 `caractere` appara\u00eet dans chaine. Exemples : ```python >>> recherche('e', \"sciences\") 2 >>> recherche('i',\"mississippi\") 4 >>> recherche('a',\"mississippi\") 0 ``` R\u00e9digez votre code sur Basthon Exercice 41.2 \u2693\ufe0e Exercice 41.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste valeurs = [100, 50, 20, 10, 5, 2, 1] . On suppose que les pi\u00e8ces et billets sont disponibles sans limitation. On cherche \u00e0 donner la liste des valeurs \u00e0 rendre pour une somme donn\u00e9e en argument. L\u2019algorithme utilis\u00e9 est de type glouton. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 valeurs = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( a_rendre , rang ): if a_rendre == 0 : return ... v = valeurs [ rang ] if v <= ... : return ... + rendu_glouton ( a_rendre - v , rang ) else : return rendu_glouton ( a_rendre , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 67 , 0 ) [ 50 , 10 , 5 , 2 ] >>> rendu_glouton ( 291 , 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] >>> rendu_glouton ( 291 , 1 ) # si on ne dispose pas de billets de 100 [ 50 , 50 , 50 , 50 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 valeurs = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( a_rendre , rang ): if a_rendre == 0 : return [] v = valeurs [ rang ] if v <= a_rendre : return [ v ] + rendu_glouton ( a_rendre - v , rang ) else : return rendu_glouton ( a_rendre , rang + 1 ) Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste `valeurs = [100, 50, 20, 10, 5, 2, 1]`. On suppose que les pi\u00e8ces et billets sont disponibles sans limitation. On cherche \u00e0 donner la liste des valeurs \u00e0 rendre pour une somme donn\u00e9e en argument. L\u2019algorithme utilis\u00e9 est de type glouton. Compl\u00e9ter le code Python ci-dessous de la fonction `rendu_glouton` qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. ```python linenums='1' valeurs = [100, 50, 20, 10, 5, 2, 1] def rendu_glouton(a_rendre, rang): if a_rendre == 0: return ... v = valeurs[rang] if v <= ... : return ... + rendu_glouton(a_rendre - v, rang) else : return rendu_glouton(a_rendre, ...) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 67 , 0 ) [ 50 , 10 , 5 , 2 ] >>> rendu_glouton ( 291 , 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] >>> rendu_glouton ( 291 , 1 ) # si on ne dispose pas de billets de 100 [ 50 , 50 , 50 , 50 , 50 , 20 , 20 , 1 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 42 \u2693\ufe0e Version originale du sujet en pdf. Exercice 42.1 \u2693\ufe0e Exercice 42.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie la liste tri\u00e9e par ordre croissant. Il est demand\u00e9 de ne pas cr\u00e9er de nouvelle liste mais de modifier celle fournie. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment de la liste, en la parcourant du rang 0 au dernier rang, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche ensuite le plus petit \u00e9l\u00e9ment de la liste restreinte du rang 1 au dernier rang, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que la liste soit enti\u00e8rement tri\u00e9e. Exemple : \ud83d\udc0d Script Python >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \ud83d\udccb Texte \u00c9crire une fonction `tri_selection` qui prend en param\u00e8tre une liste `tab` de nombres entiers et qui renvoie la liste tri\u00e9e par ordre croissant. Il est demand\u00e9 de ne pas cr\u00e9er de nouvelle liste mais de modifier celle fournie. On utilisera l\u2019algorithme suivant : - on recherche le plus petit \u00e9l\u00e9ment de la liste, en la parcourant du rang 0 au dernier rang, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; - on recherche ensuite le plus petit \u00e9l\u00e9ment de la liste restreinte du rang 1 au dernier rang, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; - on continue de cette fa\u00e7on jusqu'\u00e0 ce que la liste soit enti\u00e8rement tri\u00e9e. Exemple : ```python >>> tri_selection([1, 52, 6, -9, 12]) [-9, 1, 6, 12, 52] ``` R\u00e9digez votre code sur Basthon Exercice 42.2 \u2693\ufe0e Exercice 42.2 \u00c9nonc\u00e9 Correction Sources Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers tels que a <= b , randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 99 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 1 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : - le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; - si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; - si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction `randint` est utilis\u00e9e. Si a et b sont des entiers tels que `a <= b` , `randint(a,b)` renvoie un nombre entier compris entre `a` et `b` . Compl\u00e9ter le code ci-dessous et le tester : ```python linenums='1' from random import randint def plus_ou_moins(): nb_mystere = randint(1,...) nb_test = int(input(\"Proposez un nombre entre 1 et 99 : \")) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test: nb_test = int(input(\"Trop petit ! Testez encore : \")) else: nb_test = int(input(\"Trop grand ! Testez encore : \")) if nb_mystere == nb_test: print (\"Bravo ! Le nombre \u00e9tait \",...) print(\"Nombre d'essais: \",...) else: print (\"Perdu ! Le nombre \u00e9tait \",...) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 43 \u2693\ufe0e Version originale du sujet en pdf. Exercice 43.1 \u2693\ufe0e Exercice 43.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction ecriture_binaire_entier_positif qui prend en param\u00e8tre un entier positif n et renvoie une liste d'entiers correspondant \u00e0 l\u2018\u00e9criture binaire de n . Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : \ud83d\udc0d Script Python >>> ecriture_binaire_entier_positif ( 0 ) [ 0 ] >>> ecriture_binaire_entier_positif ( 2 ) [ 1 , 0 ] >>> ecriture_binaire_entier_positif ( 105 ) [ 1 , 1 , 0 , 1 , 0 , 0 , 1 ] Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def ecriture_binaire_entier_positif ( n ): # cas particulier pour n = 0 if n == 0 : return [ 0 ] # cas g\u00e9n\u00e9ral b = [] while n != 0 : b . append ( n % 2 ) n = n // 2 b . reverse () return b \ud83d\udccb Texte \u00c9crire une fonction `ecriture_binaire_entier_positif` qui prend en param\u00e8tre un entier positif `n` et renvoie une liste d'entiers correspondant \u00e0 l\u2018\u00e9criture binaire de `n`. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : ```python >>> ecriture_binaire_entier_positif(0) [0] >>> ecriture_binaire_entier_positif(2) [1, 0] >>> ecriture_binaire_entier_positif(105) [1, 1, 0, 1, 0, 0, 1] ``` Aide : - l'op\u00e9rateur `//` donne le quotient de la division euclidienne : `5//2` donne `2` ; - l'op\u00e9rateur `%` donne le reste de la division euclidienne :` 5%2` donne `1` ; - `append` est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit `T=[5,2,4]`, alors `T.append(10)` ajoute `10` \u00e0 la liste `T`. Ainsi, `T` devient `[5,2,4,10]`. - `reverse` est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit `T=[5,2,4,10]`. Apr\u00e8s `T.reverse()`, la liste devient `[10,4,2,5]`. On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier `n` en partant de la gauche en appliquant successivement les instructions : `b = n%2` `n = n//2` r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. R\u00e9digez votre code sur Basthon Exercice 43.2 \u2693\ufe0e Exercice 43.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Le tri \u00e0 bulles est un tri en place qui commence par placer le plus grand \u00e9l\u00e9ment en derni\u00e8re position en parcourant la liste de gauche \u00e0 droite et en \u00e9changeant au passage les \u00e9l\u00e9ments voisins mal ordonn\u00e9s (si la valeur de l\u2019\u00e9l\u00e9ment d\u2019indice i a une valeur strictement sup\u00e9rieure \u00e0 celle de l\u2019indice i + 1 , ils sont \u00e9chang\u00e9s). Le tri place ensuite en avant-derni\u00e8re position le plus grand \u00e9l\u00e9ment de la liste priv\u00e9e de son dernier \u00e9l\u00e9ment en proc\u00e9dant encore \u00e0 des \u00e9changes d\u2019\u00e9l\u00e9ments voisins. Ce principe est r\u00e9p\u00e9t\u00e9 jusqu\u2019\u00e0 placer le minimum en premi\u00e8re position. Exemple : pour trier la liste [7, 9, 4, 3] : premi\u00e8re \u00e9tape : 7 et 9 ne sont pas \u00e9chang\u00e9s, puis 9 et 4 sont \u00e9chang\u00e9s, puis 9 et 3 sont \u00e9chang\u00e9s, la liste est alors [7, 4, 3, 9] deuxi\u00e8me \u00e9tape : 7 et 4 sont \u00e9chang\u00e9s, puis 7 et 3 sont \u00e9chang\u00e9s, la liste est alors [4, 3, 7, 9] troisi\u00e8me \u00e9tape : 4 et 3 sont \u00e9chang\u00e9s, la liste est alors [3, 4, 7, 9] Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tri_bulles ( T ): ''' Renvoie le tableau T tri\u00e9 par ordre croissant ''' n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T Exemples : \ud83d\udc0d Script Python >>> tri_bulles ([]) [] >>> tri_bulles ([ 7 ]) [ 7 ] >>> tri_bulles ([ 9 , 3 , 7 , 2 , 3 , 1 , 6 ]) [ 1 , 2 , 3 , 3 , 6 , 7 , 9 ] >>> tri_bulles ([ 9 , 7 , 4 , 3 ]) [ 3 , 4 , 7 , 9 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tri_bulles ( T ): ''' Renvoie le tableau T tri\u00e9 par ordre croissant ''' n = len ( T ) for i in range ( n - 1 , - 1 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T Markdown La fonction `tri_bulles` prend en param\u00e8tre une liste `T` d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Le tri \u00e0 bulles est un tri en place qui commence par placer le plus grand \u00e9l\u00e9ment en derni\u00e8re position en parcourant la liste de gauche \u00e0 droite et en \u00e9changeant au passage les \u00e9l\u00e9ments voisins mal ordonn\u00e9s (si la valeur de l\u2019\u00e9l\u00e9ment d\u2019indice `i` a une valeur strictement sup\u00e9rieure \u00e0 celle de l\u2019indice `i + 1` , ils sont \u00e9chang\u00e9s). Le tri place ensuite en avant-derni\u00e8re position le plus grand \u00e9l\u00e9ment de la liste priv\u00e9e de son dernier \u00e9l\u00e9ment en proc\u00e9dant encore \u00e0 des \u00e9changes d\u2019\u00e9l\u00e9ments voisins. Ce principe est r\u00e9p\u00e9t\u00e9 jusqu\u2019\u00e0 placer le minimum en premi\u00e8re position. Exemple : pour trier la liste `[7, 9, 4, 3]` : - premi\u00e8re \u00e9tape : 7 et 9 ne sont pas \u00e9chang\u00e9s, puis 9 et 4 sont \u00e9chang\u00e9s, puis 9 et 3 sont \u00e9chang\u00e9s, la liste est alors `[7, 4, 3, 9]` - deuxi\u00e8me \u00e9tape : 7 et 4 sont \u00e9chang\u00e9s, puis 7 et 3 sont \u00e9chang\u00e9s, la liste est alors `[4, 3, 7, 9]` - troisi\u00e8me \u00e9tape : 4 et 3 sont \u00e9chang\u00e9s, la liste est alors `[3, 4, 7, 9]` Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles. ```python linenums='1' def tri_bulles(T): ''' Renvoie le tableau T tri\u00e9 par ordre croissant ''' n = len(T) for i in range(...,...,-1): for j in range(i): if T[j] > T[...]: ... = T[j] T[j] = T[...] T[j+1] = temp return T Exemples : \ud83d\udc0d Script Python >>> tri_bulles ([]) [] >>> tri_bulles ([ 7 ]) [ 7 ] >>> tri_bulles ([ 9 , 3 , 7 , 2 , 3 , 1 , 6 ]) [ 1 , 2 , 3 , 3 , 6 , 7 , 9 ] >>> tri_bulles ([ 9 , 7 , 4 , 3 ]) [ 3 , 4 , 7 , 9 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 44 \u2693\ufe0e Version originale du sujet en pdf. Exercice 44.1 \u2693\ufe0e Exercice 44.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer une fonction renverse , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide mot et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene mot . Exemple : \ud83d\udc0d Script Python >>> renverse ( \"informatique\" ) \"euqitamrofni\" \ud83d\udc0d Script Python 1 2 3 4 5 def renverse ( mot ): sol = '' for lettre in mot : sol = lettre + sol return sol \ud83d\udccb Texte Programmer une fonction `renverse`, prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide `mot` et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene `mot`. Exemple : ```python >>> renverse(\"informatique\") \"euqitamrofni\" ``` R\u00e9digez votre code sur Basthon Exercice 44.2 \u2693\ufe0e Exercice 44.2 \u00c9nonc\u00e9 Correction Sources Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre n fix\u00e9. On consid\u00e8re pour cela un tableau tab de n bool\u00e9ens, initialement tous \u00e9gaux \u00e0 True , sauf tab[0] et tab[1] qui valent False , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice i : si tab[i] vaut True : le nombre i est premier et on donne la valeur False \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de i , \u00e0 partir de 2*i (c\u2019est-\u00e0-dire 2*i , 3*i ...). si tab[i] vaut False : le nombre i n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction crible , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier n strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que n . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( n ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * n tab [ 0 ], tab [ 1 ] = False , False for i in range ( ... , n ): if tab [ i ] == ... : premiers . append ( ... ) for multiple in range ( 2 * i , n , ... ): tab [ multiple ] = ... return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Compl\u00e9ter le code de cette fonction. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( n ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * n tab [ 0 ], tab [ 1 ] = False , False for i in range ( 2 , n ): if tab [ i ] == True : premiers . append ( i ) for multiple in range ( 2 * i , n , i ): tab [ multiple ] = False return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre `n` fix\u00e9. On consid\u00e8re pour cela un tableau `tab` de `n` bool\u00e9ens, initialement tous \u00e9gaux \u00e0 `True` , sauf `tab[0]` et `tab[1]` qui valent `False` , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice `i` : - si `tab[i]` vaut `True` : le nombre `i` est premier et on donne la valeur `False` \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de `i` , \u00e0 partir de `2*i` (c\u2019est-\u00e0-dire `2*i` , `3*i` ...). - si `tab[i]` vaut `False` : le nombre `i` n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction `crible` , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier `n` strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que `n` . ```python linenums='1' def crible(n): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [True] * n tab[0], tab[1] = False, False for i in range(..., n): if tab[i] == ...: premiers.append(...) for multiple in range(2*i, n, ...): tab[multiple] = ... return premiers assert crible(40) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] Compl\u00e9ter le code de cette fonction. ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 45 \u2693\ufe0e Version originale du sujet en pdf. Exercice 45.1 \u2693\ufe0e Exercice 45.1 \u00c9nonc\u00e9 Correction Source Markdown On veut trier par ordre croissant les notes d\u2019une \u00e9valuation qui sont des nombres entiers compris entre 0 et 10 (inclus). Ces notes sont contenues dans une liste notes_eval . \u00c9crire une fonction rangement_valeurs prenant en param\u00e8tre la liste notes_eval et renvoyant une liste de longueur 11 telle que la valeur de cette liste \u00e0 chaque rang est \u00e9gale au nombre de notes valant ce rang. Ainsi le terme de rang 0 indique le nombre de note 0, le terme de rang 1 le nombre de note 1, etc. \u00c9crire ensuite une fonction notes_triees prenant en param\u00e8tre la liste des effectifs des notes et renvoyant une liste contenant la liste, tri\u00e9e dans l\u2019ordre croissant, des notes des \u00e9l\u00e8ves. Exemple : \ud83d\udc0d Script Python >>> notes_eval = [ 2 , 0 , 5 , 9 , 6 , 9 , 10 , 5 , 7 , 9 , 9 , 5 , 0 , 9 , 6 , 5 , 4 ] >>> effectifs_notes = rangement_valeurs ( notes_eval ) >>> effectifs_notes [ 2 , 0 , 1 , 0 , 1 , 4 , 2 , 1 , 0 , 5 , 1 ] >>> notes_triees ( effectifs_notes ) [ 0 , 0 , 2 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 7 , 9 , 9 , 9 , 9 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def rangement_valeurs ( notes_eval ): lst = [ 0 ] * 11 for note in notes_eval : lst [ note ] += 1 return lst def notes_triees ( effectifs_notes ): triees = [] for i in range ( 11 ): if effectifs_notes [ i ] != 0 : for _ in range ( effectifs_notes [ i ]): triees . append ( i ) return triees \ud83d\udccb Texte On veut trier par ordre croissant les notes d\u2019une \u00e9valuation qui sont des nombres entiers compris entre 0 et 10 (inclus). Ces notes sont contenues dans une liste `notes_eval`. \u00c9crire une fonction `rangement_valeurs` prenant en param\u00e8tre la liste `notes_eval` et renvoyant une liste de longueur 11 telle que la valeur de cette liste \u00e0 chaque rang est \u00e9gale au nombre de notes valant ce rang. Ainsi le terme de rang 0 indique le nombre de note 0, le terme de rang 1 le nombre de note 1, etc. \u00c9crire ensuite une fonction `notes_triees` prenant en param\u00e8tre la liste des effectifs des notes et renvoyant une liste contenant la liste, tri\u00e9e dans l\u2019ordre croissant, des notes des \u00e9l\u00e8ves. Exemple : ```python >>> notes_eval = [2, 0, 5, 9, 6, 9, 10, 5, 7, 9, 9, 5, 0, 9, 6, 5, 4] >>> effectifs_notes = rangement_valeurs(notes_eval) >>> effectifs_notes [2, 0, 1, 0, 1, 4, 2, 1, 0, 5, 1] >>> notes_triees(effectifs_notes) [0, 0, 2, 4, 5, 5, 5, 5, 6, 6, 7, 9, 9, 9, 9, 9, 10] ``` R\u00e9digez votre code sur Basthon Exercice 45.2 \u2693\ufe0e Exercice 45.2 \u00c9nonc\u00e9 Correction Sources Markdown L\u2019objectif de cet exercice est d\u2019\u00e9crire deux fonctions r\u00e9cursives dec_to_bin et bin_to_dec assurant respectivement la conversion de l\u2019\u00e9criture d\u00e9cimale d\u2019un nombre entier vers son \u00e9criture en binaire et, r\u00e9ciproquement, la conversion de l\u2019\u00e9criture en binaire d\u2019un nombre vers son \u00e9criture d\u00e9cimale. Dans cet exercice, on s\u2019interdit l\u2019usage des fonctions Python bin et int . On rappelle sur l\u2019exemple ci-dessous une fa\u00e7on d\u2019obtenir l\u2019\u00e9criture en binaire du nombre 25 : \\(25 = 1 + 2 \\times 12\\) \\(\\phantom{25} = 1 + 2 \\times 12\\) \\(\\phantom{25} = 1 + 2 (0 + 2 \\times 6)\\) \\(\\phantom{25} = 1 + 2 (0 + 2 (0 + 2 \\times 3))\\) \\(\\phantom{25} = 1 + 2 (0 + 2 (0 + 2 (1 + 2 \\times 1)))\\) \\(\\phantom{25} = 1 \\times 2^0 + 0 \\times 2^1 + 0 \\times 2^2 + 1 \\times 2^3 + 1 \\times 2^4\\) L'\u00e9criture binaire de 25 est donc 11001 . 0n rappelle \u00e9galement que : a // 2 renvoie le quotient de la division euclidienne de a par 2. a % 2 renvoie le reste dans la division euclidienne de a par 2. On indique enfin qu\u2019en Python si mot = \"informatique\" alors : mot[-1] renvoie 'e' , c\u2019est-\u00e0-dire le dernier caract\u00e8re de la cha\u00eene de caract\u00e8res mot . mot[:-1] renvoie 'informatiqu' , c\u2019est-\u00e0-dire l\u2019ensemble de la cha\u00eene de caract\u00e8res mot priv\u00e9e de son dernier caract\u00e8re. Compl\u00e9ter, puis tester, les codes de deux fonctions ci-dessous. On pr\u00e9cise que la fonction r\u00e9cursive dec_to_bin prend en param\u00e8tre un nombre entier et renvoie une cha\u00eene de caract\u00e8res contenant l\u2019\u00e9criture en binaire du nombre pass\u00e9 en param\u00e8tre. Exemple : \ud83d\udc0d Script Python >>> dec_to_bin ( 25 ) '11001' La fonction r\u00e9cursive bin_to_dec prend en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019\u00e9criture d\u2019un nombre en binaire et renvoie l\u2019\u00e9criture d\u00e9cimale de ce nombre. \ud83d\udc0d Script Python >>> bin_to_dec ( '101010' ) 42 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == ... : return str ( r ) else : return dec_to_bin ( ... ) + ... def bin_to_dec ( nb_bin ): if nb_bin == '0' : return 0 elif ... : return 1 else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : bit_droit = ... return ... * bin_to_dec ( nb_bin [: - 1 ]) + ... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == 0 : return str ( r ) else : return dec_to_bin ( q ) + str ( r ) def bin_to_dec ( nb_bin ): if nb_bin == '0' : return 0 elif nb_bin == '1' : return 1 else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : bit_droit = 1 return 2 * bin_to_dec ( nb_bin [: - 1 ]) + bit_droit Markdown L\u2019objectif de cet exercice est d\u2019\u00e9crire deux fonctions r\u00e9cursives `dec_to_bin` et `bin_to_dec` assurant respectivement la conversion de l\u2019\u00e9criture d\u00e9cimale d\u2019un nombre entier vers son \u00e9criture en binaire et, r\u00e9ciproquement, la conversion de l\u2019\u00e9criture en binaire d\u2019un nombre vers son \u00e9criture d\u00e9cimale. Dans cet exercice, on s\u2019interdit l\u2019usage des fonctions Python `bin` et `int` . On rappelle sur l\u2019exemple ci-dessous une fa\u00e7on d\u2019obtenir l\u2019\u00e9criture en binaire du nombre 25 : $25 = 1 + 2 \\times 12$ $\\phantom{25} = 1 + 2 \\times 12$ $\\phantom{25} = 1 + 2 (0 + 2 \\times 6)$ $\\phantom{25} = 1 + 2 (0 + 2 (0 + 2 \\times 3))$ $\\phantom{25} = 1 + 2 (0 + 2 (0 + 2 (1 + 2 \\times 1)))$ $\\phantom{25} = 1 \\times 2^0 + 0 \\times 2^1 + 0 \\times 2^2 + 1 \\times 2^3 + 1 \\times 2^4$ L'\u00e9criture binaire de 25 est donc ```11001```. 0n rappelle \u00e9galement que : - `a // 2` renvoie le quotient de la division euclidienne de `a` par 2. - ` a % 2` renvoie le reste dans la division euclidienne de `a` par 2. On indique enfin qu\u2019en Python si `mot = \"informatique\"` alors : - `mot[-1]` renvoie `'e'` , c\u2019est-\u00e0-dire le dernier caract\u00e8re de la cha\u00eene de caract\u00e8res `mot` . - `mot[:-1]` renvoie `'informatiqu'` , c\u2019est-\u00e0-dire l\u2019ensemble de la cha\u00eene de caract\u00e8res `mot` priv\u00e9e de son dernier caract\u00e8re. Compl\u00e9ter, puis tester, les codes de deux fonctions ci-dessous. On pr\u00e9cise que la fonction r\u00e9cursive `dec_to_bin` prend en param\u00e8tre un nombre entier et renvoie une cha\u00eene de caract\u00e8res contenant l\u2019\u00e9criture en binaire du nombre pass\u00e9 en param\u00e8tre. Exemple : ```python >>> dec_to_bin(25) '11001' La fonction r\u00e9cursive bin_to_dec prend en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019\u00e9criture d\u2019un nombre en binaire et renvoie l\u2019\u00e9criture d\u00e9cimale de ce nombre. \ud83d\udc0d Script Python >>> bin_to_dec ( '101010' ) 42 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == ... : return str ( r ) else : return dec_to_bin ( ... ) + ... def bin_to_dec ( nb_bin ): if nb_bin == '0' : return 0 elif ... : return 1 else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : bit_droit = ... return ... * bin_to_dec ( nb_bin [: - 1 ]) + ... ``` Compl\u00e9tez le code sur Basthon", "title": "(!!! old !!!) BNS 2023"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#epreuve-pratique-bns-2023", "text": "Les sujets ci-dessous correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 25/01/2023 . T\u00e9l\u00e9chargements Une archive contenant les 45 dossiers (contenant chacun les deux fichiers .pdf et .py ) : BNS_2023.zip (2,9 Mo) Un pdf unique de tous les sujets : BNS_2023_pdf_unique.pdf (3,2 Mo)", "title": "\u00c9preuve Pratique BNS 2023"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-01", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 01"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-011", "text": "Exercice 01.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction verifie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie True si ce tableau est tri\u00e9 dans l\u2019ordre croissant, False sinon. Exemples : \ud83d\udc0d Script Python Exemples : >>> verifie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> verifie ([ 8 , 12 , 4 ]) False >>> verifie ([ - 1 , 4 ]) True >>> verifie ([ 5 ]) True \ud83d\udc0d Script Python 1 2 3 4 5 def verifie ( tab ): for i in range ( 1 , len ( tab )): if tab [ i ] < tab [ i - 1 ]: return False return True \ud83d\udccb Texte Programmer la fonction `verifie` qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques non vide et qui renvoie `True` si ce tableau est tri\u00e9 dans l\u2019ordre croissant, `False` sinon. Exemples : ```python Exemples : >>> verifie([0, 5, 8, 8, 9]) True >>> verifie([8, 12, 4]) False >>> verifie([-1, 4]) True >>> verifie([5]) True ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 01.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-012", "text": "Exercice 01.2 \u00c9nonc\u00e9 Correction Sources Markdown Les r\u00e9sultats d'un vote ayant trois issues possibles 'A', 'B' et 'C' sont stock\u00e9s dans un tableau. Exemple : \ud83d\udc0d Script Python urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } >>> vainqueur ( election ) [ 'B' ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = {} for bulletin in urne : if bulletin in resultat : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : resultat [ bulletin ] = 1 return resultat def vainqueur ( election ): vainqueur = '' #(1) nmax = 0 for candidat in election : if election [ candidat ] > nmax : nmax = election [ candidat ] vainqueur = candidat #(2) liste_finale = [ nom for nom in election if election [ nom ] == nmax ] return liste_finale Il est pourtant tr\u00e8s d\u00e9conseill\u00e9 de nommer une variable avec le m\u00eame nom que la fonction qui la contient... Cette variable vainqueur est inutile, on ne s'en sert pas dans l'\u00e9laboration de la liste finale. Markdown Les r\u00e9sultats d'un vote ayant trois issues possibles 'A', 'B' et 'C' sont stock\u00e9s dans un tableau. Exemple : ```python urne = ['A', 'A', 'A', 'B', 'C', 'B', 'C', 'B', 'C', 'B'] La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des artistes et les valeurs le nombre de votes en leur faveur. La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueur ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] def depouille ( urne ): resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueur ( election ): vainqueur = '' nmax = 0 for candidat in election : if ... > ... : nmax = ... vainqueur = candidat liste_finale = [ nom for nom in election if election [ nom ] == ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> election = depouille ( urne ) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } >>> vainqueur ( election ) [ 'B' ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 01.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-02", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 02"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-021", "text": "Exercice 02.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction indices_maxi qui prend en param\u00e8tre une liste tab , non vide, de nombres entiers et renvoie un couple donnant d\u2019une part le plus grand \u00e9l\u00e9ment de cette liste et d\u2019autre part la liste des indices de la liste tab o\u00f9 appara\u00eet ce plus grand \u00e9l\u00e9ment. Exemple : \ud83d\udc0d Script Python >>> indices_maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , [ 3 , 8 ]) >>> indices_maxi ([ 7 ]) ( 7 , [ 0 ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def indices_maxi ( tab ): val_max = tab [ 0 ] ind_max = [] for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] for i in range ( len ( tab )): if tab [ i ] == val_max : ind_max . append ( i ) return ( val_max , ind_max ) \ud83d\udccb Texte \u00c9crire une fonction `indices_maxi` qui prend en param\u00e8tre une liste `tab`, non vide, de nombres entiers et renvoie un couple donnant d\u2019une part le plus grand \u00e9l\u00e9ment de cette liste et d\u2019autre part la liste des indices de la liste `tab` o\u00f9 appara\u00eet ce plus grand \u00e9l\u00e9ment. Exemple : ```python >>> indices_maxi([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) (9, [3, 8]) >>> indices_maxi([7]) (7, [0]) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 02.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-022", "text": "Exercice 02.2 \u00c9nonc\u00e9 Correction Sources Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type list ). On rappelle que l\u2019expression liste_1 = list(liste) fait une copie de liste ind\u00e9pendante de liste , que l\u2019expression x = liste.pop() enl\u00e8ve le sommet de la pile liste et le place dans la variable x et, enfin, que l\u2019expression liste.append(v) place la valeur v au sommet de la pile liste . Compl\u00e9ter le code Python de la fonction positif ci-dessous qui prend une pile liste de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable liste . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def positif ( pile ): pile_1 = ... ( pile ) pile_2 = ... while pile_1 != []: x = ... if ... >= 0 : pile_2 . append ( ... ) while pile_2 != ... : x = pile_2 . pop () ... return pile_1 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) [ 0 , 5 , 4 , 10 , 9 ] >>> positif ([ - 2 ]) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def positif ( pile ): pile_1 = list ( pile ) pile_2 = [] while pile_1 != []: x = pile_1 . pop () if x >= 0 : pile_2 . append ( x ) while pile_2 != []: x = pile_2 . pop () pile_1 . append ( x ) return pile_1 Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es en Python par des listes (type `list` ). On rappelle que l\u2019expression `liste_1 = list(liste)` fait une copie de `liste ` ind\u00e9pendante de `liste` , que l\u2019expression `x = liste.pop()` enl\u00e8ve le sommet de la pile `liste` et le place dans la variable `x` et, enfin, que l\u2019expression `liste.append(v)` place la valeur `v` au sommet de la pile `liste` . Compl\u00e9ter le code Python de la fonction `positif` ci-dessous qui prend une pile `liste` de nombres entiers en param\u00e8tre et qui renvoie la pile des entiers positifs dans le m\u00eame ordre, sans modifier la variable `liste` . ```python linenums='1' def positif(pile): pile_1 = ...(pile) pile_2 = ... while pile_1 != []: x = ... if ... >= 0: pile_2.append(...) while pile_2 != ...: x = pile_2.pop() ... return pile_1 Exemple : \ud83d\udc0d Script Python >>> positif ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) [ 0 , 5 , 4 , 10 , 9 ] >>> positif ([ - 2 ]) [] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 02.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-03", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 03"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-031", "text": "Exercice 03.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, les nombres sont des entiers ou des flottants. \u00c9crire une fonction moyenne renvoyant la moyenne pond\u00e9r\u00e9e d\u2019une liste non vide, pass\u00e9e en param\u00e8tre, de tuples \u00e0 deux \u00e9l\u00e9ments de la forme ( valeur , coefficient ) o\u00f9 valeur et coefficient sont des nombres positifs ou nuls. Si la somme des coefficients est nulle, la fonction renvoie None , si la somme des coefficients est non nulle, la fonction renvoie, sous forme de flottant, la moyenne des valeurs affect\u00e9es de leur coefficient. Exemple : \ud83d\udc0d Script Python >>> moyenne ([( 8 , 2 ), ( 12 , 0 ), ( 13.5 , 1 ), ( 5 , 0.5 )]) 9.142857142857142 >>> moyenne ([( 3 , 0 ), ( 5 , 0 )]) None Dans le premier exemple la moyenne est calcul\u00e9e par la formule : \\(\\dfrac{8 \\times 2 + 12 \\times 0 + 13,5 \\times 1 + 5 \\times 0,5}{2+0+1+0,5}\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme = 0 coeffs = 0 for couple in tab : somme += couple [ 0 ] * couple [ 1 ] coeffs += couple [ 1 ] if coeffs == 0 : return None return somme / coeffs \ud83d\udccb Texte Dans cet exercice, les nombres sont des entiers ou des flottants. \u00c9crire une fonction `moyenne` renvoyant la moyenne pond\u00e9r\u00e9e d\u2019une liste non vide, pass\u00e9e en param\u00e8tre, de tuples \u00e0 deux \u00e9l\u00e9ments de la forme (`valeur`, `coefficient`) o\u00f9 `valeur` et `coefficient` sont des nombres positifs ou nuls. Si la somme des coefficients est nulle, la fonction renvoie `None`, si la somme des coefficients est non nulle, la fonction renvoie, sous forme de flottant, la moyenne des valeurs affect\u00e9es de leur coefficient. Exemple : ```python >>> moyenne([(8, 2), (12, 0), (13.5, 1), (5, 0.5)]) 9.142857142857142 >>> moyenne([(3, 0), (5, 0)]) None ``` Dans le premier exemple la moyenne est calcul\u00e9e par la formule : $\\dfrac{8 \\times 2 + 12 \\times 0 + 13,5 \\times 1 + 5 \\times 0,5}{2+0+1+0,5}$ R\u00e9digez votre code sur Basthon", "title": "Exercice 03.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-032", "text": "Exercice 03.2 \u00c9nonc\u00e9 Correction Sources Markdown On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction zoomListe prend en argument une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction zoomDessin prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Soit le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( \" *\" , end = \"\" ) else : print ( \" \" , end = \"\" ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range ( k ): ... return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = ... for i in range ( k ): ... . append ( ... ) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], \\ [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], \\ [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], \\ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : for col in ligne : if col == 1 : print ( ' *' , end = '' ) else : print ( ' ' , end = '' ) print () def zoomListe ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = [] for elt in liste_depart : for i in range ( k ): liste_zoom . append ( elt ) return liste_zoom def zoomDessin ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom = [] for elt in grille : liste_zoom = zoomListe ( elt , k ) for i in range ( k ): grille_zoom . append ( liste_zoom ) return grille_zoom Markdown ![ image ]( data2023/03_coeur.png ){: .center width=30%} On travaille sur des dessins en noir et blanc obtenu \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction `affiche` permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction `zoomListe` prend en argument une liste `liste_depart` et un entier `k` . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de `liste_depart` est dupliqu\u00e9 `k` fois. La fonction `zoomDessin` prend en argument la grille `dessin` et renvoie une grille o\u00f9 toutes les lignes de `dessin` sont zoom\u00e9es `k` fois et r\u00e9p\u00e9t\u00e9es `k` fois. Soit le code ci-dessous : ```python linenums='1' coeur = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], \\ [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], \\ [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], \\ [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], \\ [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], \\ [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], \\ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]] def affiche(dessin): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin: for col in ligne: if col == 1: print(\" *\", end=\"\") else: print(\" \", end=\"\") print() def zoomListe(liste_depart,k): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoom = ... for elt in ... : for i in range(k): ... return liste_zoom def zoomDessin(grille,k): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoom=[] for elt in grille: liste_zoom = ... for i in range(k): ... .append(...) return grille_zoom R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> affiche ( coeur ) \ud83d\udc0d Script Python >>> affiche ( zoomDessin ( coeur , 3 )) \ud83d\udccb Texte * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 03.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-04", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 04"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-041", "text": "Exercice 04.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction a_doublon qui prend en param\u00e8tre une liste tri\u00e9e de nombres et renvoie True si la liste contient au moins deux nombres identiques, False sinon. Par exemple : \ud83d\udc0d Script Python >>> a_doublon ([]) False >>> a_doublon ([ 1 ]) False >>> a_doublon ([ 1 , 2 , 4 , 6 , 6 ]) True >>> a_doublon ([ 2 , 5 , 7 , 7 , 7 , 9 ]) True >>> a_doublon ([ 0 , 2 , 3 ]) False \ud83d\udc0d Script Python 1 2 3 4 5 def a_doublon ( lst ): for i in range ( len ( lst ) - 1 ): if lst [ i ] == lst [ i + 1 ]: return True return False \ud83d\udccb Texte \u00c9crire une fonction `a_doublon` qui prend en param\u00e8tre une liste **tri\u00e9e** de nombres et renvoie `True` si la liste contient au moins deux nombres identiques, `False` sinon. Par exemple : ```python >>> a_doublon([]) False >>> a_doublon([1]) False >>> a_doublon([1, 2, 4, 6, 6]) True >>> a_doublon([2, 5, 7, 7, 7, 9]) True >>> a_doublon([0, 2, 3]) False ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 04.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-042", "text": "Exercice 04.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite g\u00e9n\u00e9rer des grilles du jeu de d\u00e9mineur \u00e0 partir de la position des bombes \u00e0 placer. On se limite \u00e0 la g\u00e9n\u00e9ration de grilles carr\u00e9es de taille \\(n \\times n\\) o\u00f9 \\(n\\) est le nombre de bombes du jeu. Dans le jeu du d\u00e9mineur, chaque case de la grille contient soit une bombe, soit une valeur qui correspond aux nombres de bombes situ\u00e9es dans le voisinage direct de la case (au- dessus, en dessous, \u00e0 droite, \u00e0 gauche ou en diagonale : chaque case a donc 8 voisins si elle n'est pas situ\u00e9e au bord de la grille). Voici un exemple de grille \\(5 \\times 5\\) de d\u00e9mineur dans laquelle la bombe est repr\u00e9sent\u00e9e par une \u00e9toile : On utilise une liste de listes pour repr\u00e9senter la grille et on choisit de coder une bombe par la valeur -1. L'exemple ci-contre sera donc cod\u00e9 par la liste : \ud83d\udc0d Script Python [[ 1 , 1 , 1 , 0 , 0 ], [ 1 , - 1 , 1 , 1 , 1 ], [ 2 , 2 , 3 , 2 , - 1 ], [ 1 , - 1 , 2 , - 1 , 3 ], [ 1 , 1 , 2 , 2 , - 1 ]] Compl\u00e9ter le code suivant afin de g\u00e9n\u00e9rer des grilles de d\u00e9mineur, on pourra v\u00e9rifier que l\u2019instruction genere_grille([(1, 1), (2, 4), (3, 1), (3, 3), (4, 4)]) produit bien la liste donn\u00e9e en exemple. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = ... for l , c in voisins : if grille [ l ][ c ] != ... : # si ce n'est pas une bombe ... # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = ... # place la bombe ... # incr\u00e9mente ses voisins return grille \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = voisinage ( len ( grille ), ligne , colonne ) for l , c in voisins : if grille [ l ][ c ] != - 1 : # si ce n'est pas une bombe grille [ l ][ c ] += 1 # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = - 1 # place la bombe incremente_voisins ( grille , ligne , colonne ) # incr\u00e9mente ses voisins return grille Markdown On souhaite g\u00e9n\u00e9rer des grilles du jeu de d\u00e9mineur \u00e0 partir de la position des bombes \u00e0 placer. On se limite \u00e0 la g\u00e9n\u00e9ration de grilles carr\u00e9es de taille $n \\times n$ o\u00f9 $n$ est le nombre de bombes du jeu. Dans le jeu du d\u00e9mineur, chaque case de la grille contient soit une bombe, soit une valeur qui correspond aux nombres de bombes situ\u00e9es dans le voisinage direct de la case (au- dessus, en dessous, \u00e0 droite, \u00e0 gauche ou en diagonale : chaque case a donc 8 voisins si elle n'est pas situ\u00e9e au bord de la grille). Voici un exemple de grille $5 \\times 5$ de d\u00e9mineur dans laquelle la bombe est repr\u00e9sent\u00e9e par une \u00e9toile : ![ image ]( data2023/04grille.png ){: .center} On utilise une liste de listes pour repr\u00e9senter la grille et on choisit de coder une bombe par la valeur -1. L'exemple ci-contre sera donc cod\u00e9 par la liste : ```python [[1, 1, 1, 0, 0], [1, -1, 1, 1, 1], [2, 2, 3, 2, -1], [1, -1, 2, -1, 3], [1, 1, 2, 2, -1]] Compl\u00e9ter le code suivant afin de g\u00e9n\u00e9rer des grilles de d\u00e9mineur, on pourra v\u00e9rifier que l\u2019instruction genere_grille([(1, 1), (2, 4), (3, 1), (3, 3), (4, 4)]) produit bien la liste donn\u00e9e en exemple. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = ... for l , c in voisins : if grille [ l ][ c ] != ... : # si ce n'est pas une bombe ... # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = ... # place la bombe ... # incr\u00e9mente ses voisins return grille ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 04.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-05", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 05"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-051", "text": "Exercice 05.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire en python deux fonctions : lancer de param\u00e8tre n , un entier positif, qui renvoie un tableau de type list de n entiers obtenus al\u00e9atoirement entre 1 et 6 (1 et 6 inclus) ; paire_6 de param\u00e8tre tab , un tableau de type list de n entiers entre 1 et 6 obtenus al\u00e9atoirement, qui renvoie un bool\u00e9en \u00e9gal \u00e0 True si le nombre de 6 est sup\u00e9rieur ou \u00e9gal \u00e0 2, False sinon. On pourra utiliser la fonction randint(a,b) du module random pour laquelle la documentation officielle est la suivante : Renvoie un entier al\u00e9atoire N tel que a <=N <= b. Exemples : \ud83d\udc0d Script Python >>> lancer1 = lancer ( 5 ) [ 5 , 6 , 6 , 2 , 2 ] >>> paire_6 ( lancer1 ) True >>> lancer2 = lancer ( 5 ) [ 6 , 5 , 1 , 6 , 6 ] >>> paire_6 ( lancer2 ) True >>> lancer3 = lancer ( 3 ) [ 2 , 2 , 6 ] >>> paire_6 ( lancer3 ) False >>> lancer4 = lancer ( 0 ) [] >>> paire_6 ( lancer4 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from random import randint def lancer ( n ): return [ randint ( 1 , 6 ) for _ in range ( n )] def paire_6 ( tab ): nb = 0 for elt in tab : if elt == 6 : nb += 1 if nb >= 2 : return True else : return False \ud83d\udccb Texte \u00c9crire en python deux fonctions : - `lancer` de param\u00e8tre `n`, un entier positif, qui renvoie un tableau de type `list` de `n` entiers obtenus al\u00e9atoirement entre 1 et 6 (1 et 6 inclus) ; - `paire_6` de param\u00e8tre `tab`, un tableau de type `list` de `n` entiers entre 1 et 6 obtenus al\u00e9atoirement, qui renvoie un bool\u00e9en \u00e9gal \u00e0 `True` si le nombre de 6 est sup\u00e9rieur ou \u00e9gal \u00e0 2, `False` sinon. On pourra utiliser la fonction `randint(a,b)` du module `random` pour laquelle la documentation officielle est la suivante : `Renvoie un entier al\u00e9atoire N tel que a <=N <= b.` Exemples : ```python >>> lancer1 = lancer(5) [5, 6, 6, 2, 2] >>> paire_6(lancer1) True >>> lancer2 = lancer(5) [6, 5, 1, 6, 6] >>> paire_6(lancer2) True >>> lancer3 = lancer(3) [2, 2, 6] >>> paire_6(lancer3) False >>> lancer4 = lancer(0) [] >>> paire_6(lancer4) False ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 05.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-052", "text": "Exercice 05.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Le n\u00e9gatif d\u2019une image est l\u2019image constitu\u00e9e des pixels x_n tels que x_n + x_i = 255 o\u00f9 x_i est le pixel correspondant de l\u2019image initiale. Compl\u00e9ter le programme suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nbCol ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] for i in range ( nbLig ( image )): for j in range ( ... ): L [ i ][ j ] = ... return L def binaire ( image , seuil ): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] for i in range ( nbLig ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : L [ i ][ j ] = ... else : L [ i ][ j ] = ... return L Exemples : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 237 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , 18 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( img , 120 ) [[ 0 , 0 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 0 , 0 ], [ 1 , 0 , 0 , 1 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def nbLig ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nbCol ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] for i in range ( nbLig ( image )): for j in range ( nbCol ( image )): L [ i ][ j ] = 255 - image [ i ][ j ] return L def binaire ( image , seuil ): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[ 0 for k in range ( nbCol ( image ))] for i in range ( nbLig ( image ))] for i in range ( nbLig ( image )): for j in range ( nbCol ( image )): if image [ i ][ j ] < seuil : L [ i ][ j ] = 0 else : L [ i ][ j ] = 1 return L Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Le n\u00e9gatif d\u2019une image est l\u2019image constitu\u00e9e des pixels `x_n` tels que `x_n + x_i = 255` o\u00f9 `x_i` est le pixel correspondant de l\u2019image initiale. Compl\u00e9ter le programme suivant : ```python linenums='1' def nbLig(image): '''renvoie le nombre de lignes de l'image''' return ... def nbCol(image): '''renvoie la largeur de l'image''' return ... def negatif(image): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] for i in range(nbLig(image)): for j in range(...): L[i][j] = ... return L def binaire(image, seuil): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' # on cree une image de 0 aux memes dimensions que le parametre image L = [[0 for k in range(nbCol(image))] for i in range(nbLig(image))] for i in range(nbLig(image)): for j in range(...): if image[i][j] < ... : L[i][j] = ... else: L[i][j] = ... return L Exemples : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 237 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nbLig ( img ) 4 >>> nbCol ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , 18 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( img , 120 ) [[ 0 , 0 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 0 , 0 ], [ 1 , 0 , 0 , 1 , 1 ]] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 05.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-06", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 06"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-061", "text": "Exercice 06.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction recherche , prenant en param\u00e8tre un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = len ( tab ) for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \ud83d\udccb Texte Programmer la fonction `recherche`, prenant en param\u00e8tre un tableau non vide `tab` (type `list`) d'entiers et un entier `n`, et qui renvoie l'indice de la **derni\u00e8re** occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. Exemples ```python >>> recherche([5, 3],1) 2 >>> recherche([2,4],2) 0 >>> recherche([2,3,5,2,4],2) 3 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 06.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-062", "text": "Exercice 06.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x-x')^2+(y-y')^2}\\] On importe pour cela la fonction racine carr\u00e9e ( sqrt ) du module math de Python. Compl\u00e9ter le code des fonctions distance et plus_courte_distance fournies ci-dessous pour qu\u2019elles r\u00e9pondent \u00e0 leurs sp\u00e9cifications. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from math import sqrt # import de la fonction racine carr\u00e9e def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( ... ) ** 2 + ( ... ) ** 2 ) def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = ... for i in range ( 1 , ... ): if distance ( tab [ i ], depart ) ... : point = ... min_dist = ... return point Exemples : \ud83d\udc0d Script Python >>> distance (( 1 , 0 ), ( 5 , 3 )) 5.0 >>> distance (( 1 , 0 ), ( 0 , 1 )) 1.4142135623730951 >>> plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) ( 2 , 5 ) >>> plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 5 , 2 )) ( 5 , 2 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from math import sqrt def distance ( point1 , point2 ): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt (( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 ) def plus_courte_distance ( tab , depart ): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab [ 0 ] min_dist = distance ( point , depart ) for i in range ( 1 , len ( tab )): if distance ( tab [ i ], depart ) < min_dist : point = tab [ i ] min_dist = distance ( tab [ i ], depart ) return point Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es $(x;y)$ et $(x';y')$ est donn\u00e9e par la formule : $$d=\\sqrt{(x-x')^2+(y-y')^2}$$ On importe pour cela la fonction racine carr\u00e9e ( `sqrt` ) du module `math` de Python. Compl\u00e9ter le code des fonctions `distance` et `plus_courte_distance` fournies ci-dessous pour qu\u2019elles r\u00e9pondent \u00e0 leurs sp\u00e9cifications. ```python linenums='1' from math import sqrt # import de la fonction racine carr\u00e9e def distance(point1, point2): \"\"\" Calcule et renvoie la distance entre deux points. \"\"\" return sqrt((...)**2 + (...)**2) def plus_courte_distance(tab, depart): \"\"\" Renvoie le point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point = tab[0] min_dist = ... for i in range (1, ...): if distance(tab[i], depart)...: point = ... min_dist = ... return point Exemples : \ud83d\udc0d Script Python >>> distance (( 1 , 0 ), ( 5 , 3 )) 5.0 >>> distance (( 1 , 0 ), ( 0 , 1 )) 1.4142135623730951 >>> plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) ( 2 , 5 ) >>> plus_courte_distance ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 5 , 2 )) ( 5 , 2 ) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 06.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-07", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 07"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-071", "text": "Exercice 07.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction fusion prenant en param\u00e8tres deux tableaux non vides tab1 et tab2 (type list ) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de tab1 et tab2 . Exemples : \ud83d\udc0d Script Python >>> fusion ([ 3 , 5 ], [ 2 , 5 ]) [ 2 , 3 , 5 , 5 ] >>> fusion ([ - 2 , 4 ], [ - 3 , 5 , 10 ]) [ - 3 , - 2 , 4 , 5 , 10 ] >>> fusion ([ 4 ], [ 2 , 6 ]) [ 2 , 4 , 6 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fusion ( tab1 , tab2 ): tab_fusion = [] i1 = 0 i2 = 0 while i1 < len ( tab1 ) and i2 < len ( tab2 ): if tab1 [ i1 ] < tab2 [ i2 ]: tab_fusion . append ( tab1 [ i1 ]) i1 += 1 else : tab_fusion . append ( tab2 [ i2 ]) i2 += 1 if i1 == len ( tab1 ): while i2 < len ( tab2 ): tab_fusion . append ( tab2 [ i2 ]) i2 += 1 else : while i1 < len ( tab1 ): tab_fusion . append ( tab1 [ i1 ]) i1 += 1 return tab_fusion \ud83d\udccb Texte Programmer la fonction `fusion` prenant en param\u00e8tres deux tableaux non vides `tab1` et `tab2` (type `list`) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de `tab1` et `tab2`. Exemples : ```python >>> fusion([3, 5], [2, 5]) [2, 3, 5, 5] >>> fusion([-2, 4], [-3, 5, 10]) [-3, -2, 4, 5, 10] >>> fusion([4], [2, 6]) [2, 4, 6] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 07.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-072", "text": "Exercice 07.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de cet exercice est d\u2019\u00e9crire une fonction r\u00e9cursive traduire_romain qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res, non vide, repr\u00e9sentant un nombre \u00e9crit en chiffres romains et qui renvoie son \u00e9criture d\u00e9cimale. Les chiffres romains consid\u00e9r\u00e9s sont : I, V, X, L, C, D et M. Ils repr\u00e9sentent respectivement les nombres 1, 5, 10, 50, 100, 500, et 1000 en base dix. On dispose d\u2019un dictionnaire romains dont les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale : romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000} Le code de la fonction traduire_romain fournie repose sur le principe suivant : la valeur d\u2019un caract\u00e8re est ajout\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur sup\u00e9rieure (ou \u00e9gale) \u00e0 celle du caract\u00e8re qui le suit ; la valeur d\u2019un caract\u00e8re est retranch\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur strictement inf\u00e9rieure \u00e0 celle du caract\u00e8re qui le suit. Ainsi, XIV correspond au nombre 10 + 5 - 1 puisque : la valeur de X (10) est sup\u00e9rieure \u00e0 celle de I (1), on ajoute donc 10 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire IV ; la valeur de I (1) est strictement inf\u00e9rieure \u00e0 celle de V (5), on soustrait donc 1 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire V. On rappelle que pour priver une cha\u00eene de caract\u00e8res de son premier caract\u00e8re, on utilisera l\u2019instruction : nom_de_variable[1:] Par exemple, si la variable mot contient la cha\u00eene \"CDI\" , mot[1:] renvoie \"DI\" . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 romains = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } def traduire_romain ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len ( nombre ) == 1 : return ... elif romains [ nombre [ 0 ]] >= ... return romains [ nombre [ 0 ]] + ... else : return ... Compl\u00e9ter le code de la fonction traduire_romain et le tester. Exemples : \ud83d\udc0d Script Python >>> traduire_romain ( \"XIV\" ) 14 >>> traduire_romain ( \"CXLII\" ) 142 >>> traduire_romain ( \"MMXXIII\" ) 2023 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 romains = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } def traduire_romain ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len ( nombre ) == 1 : return romains [ nombre ] elif romains [ nombre [ 0 ]] >= romains [ nombre [ 1 ]]: return romains [ nombre [ 0 ]] + traduire_romain ( nombre [ 1 :]) else : return traduire_romain ( nombre [ 1 :]) - romains [ nombre [ 0 ]] Markdown Le but de cet exercice est d\u2019\u00e9crire une fonction r\u00e9cursive `traduire_romain` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res, non vide, repr\u00e9sentant un nombre \u00e9crit en chiffres romains et qui renvoie son \u00e9criture d\u00e9cimale. Les chiffres romains consid\u00e9r\u00e9s sont : I, V, X, L, C, D et M. Ils repr\u00e9sentent respectivement les nombres 1, 5, 10, 50, 100, 500, et 1000 en base dix. On dispose d\u2019un dictionnaire `romains` dont les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale : `romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000}` Le code de la fonction `traduire_romain` fournie repose sur le principe suivant : - la valeur d\u2019un caract\u00e8re est ajout\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur sup\u00e9rieure (ou \u00e9gale) \u00e0 celle du caract\u00e8re qui le suit ; - la valeur d\u2019un caract\u00e8re est retranch\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur strictement inf\u00e9rieure \u00e0 celle du caract\u00e8re qui le suit. Ainsi, XIV correspond au nombre 10 + 5 - 1 puisque : - la valeur de X (10) est sup\u00e9rieure \u00e0 celle de I (1), on ajoute donc 10 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire IV ; - la valeur de I (1) est strictement inf\u00e9rieure \u00e0 celle de V (5), on soustrait donc 1 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire V. On rappelle que pour priver une cha\u00eene de caract\u00e8res de son premier caract\u00e8re, on utilisera l\u2019instruction : `nom_de_variable[1:]` Par exemple, si la variable `mot` contient la cha\u00eene `\"CDI\"` , `mot[1:]` renvoie `\"DI\"` . ```python linenums='1' romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000} def traduire_romain(nombre): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len(nombre) == 1: return ... elif romains[nombre[0]] >= ... return romains[nombre[0]] + ... else: return ... Compl\u00e9ter le code de la fonction traduire_romain et le tester. Exemples : \ud83d\udc0d Script Python >>> traduire_romain ( \"XIV\" ) 14 >>> traduire_romain ( \"CXLII\" ) 142 >>> traduire_romain ( \"MMXXIII\" ) 2023 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 07.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-08", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 08"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-081", "text": "Exercice 08.1 \u00c9nonc\u00e9 Correction Source Markdown Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : \ud83d\udc0d Script Python >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def max_dico ( dico ): cle_max = '' val_max = 0 for cle in dico : if dico [ cle ] > val_max : val_max = dico [ cle ] cle_max = cle return ( cle_max , val_max ) \ud83d\udccb Texte Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : `{'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}` \u00c9crire une fonction `max_dico` qui : - Prend en param\u00e8tre un dictionnaire `dico` non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; - Renvoie un tuple dont : - La premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; - La seconde valeur est la premi\u00e8re valeur maximale pr\u00e9sente dans le dictionnaire. Exemples : ```python >>> max_dico({'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}) ('Ada', 201) >>> max_dico({'Alan': 222, 'Ada': 201, 'Eve': 220, 'Tim': 50}) ('Alan', 222) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 08.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-082", "text": "Exercice 08.2 \u00c9nonc\u00e9 Correction Sources Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = p . depiler () + ... else : resultat = ... p . empiler ( ... ) return ... Exemple : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for element in tab : if element != '+' and element != '*' : p . empiler ( element ) else : if element == '+' : resultat = p . depiler () + p . depiler () else : resultat = p . depiler () * p . depiler () p . empiler ( resultat ) return p . depiler () Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*']. Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+']. D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : - Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; - Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. - \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe `Pile` qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction `eval_expression` qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. ```python linenums='1' class Pile: \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ (self): self.contenu = [] def est_vide(self): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self.contenu == [] def empiler(self, v): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self.contenu.append(v) def depiler(self): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self.est_vide(): return self.contenu.pop() def eval_expression(tab): p = Pile() for ... in tab: if element != '+' ... element != '*': p.empiler(...) else: if element == ...: resultat = p.depiler() + ... else: resultat = ... p.empiler(...) return ... Exemple : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 08.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-09", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 09"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-091", "text": "Exercice 09.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : ```python >>> multiplication(3,5) 15 >>> multiplication(-4,-8) 32 >>> multiplication(-2,6) -12 >>> multiplication(-2,0) 0 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 09.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-092", "text": "Exercice 09.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit tab un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher ci-dessous doit renvoyer un indice o\u00f9 la valeur n appara\u00eet dans tab si cette valeur y figure et None sinon. Les param\u00e8tres de la fonction sont : tab , le tableau dans lequel s'effectue la recherche ; n , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. L\u2019algorithme demand\u00e9 est une recherche dichotomique r\u00e9cursive. Recopier et compl\u00e9ter le code de la fonction chercher suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def chercher ( tab , n , i , j ): if i < 0 or j > len ( tab ) : return None if i > j : return None m = ( i + j ) // ... if ... < n : return chercher ( tab , n , ... , ... ) elif ... > n : return chercher ( tab , n , ... , ... ) else : return ... L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def chercher ( tab , n , i , j ): if i < 0 or j > len ( tab ) : return None if i > j : return None m = ( i + j ) // 2 if tab [ m ] < n : return chercher ( tab , n , m + 1 , j ) elif tab [ m ] > n : return chercher ( tab , n , i , m - 1 ) else : return m Markdown Soit `tab` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher` ci-dessous doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet dans `tab` si cette valeur y figure et `None` sinon. Les param\u00e8tres de la fonction sont : - `tab` , le tableau dans lequel s'effectue la recherche ; - `n` , l'entier \u00e0 chercher dans le tableau ; - `i` , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j` , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. L\u2019algorithme demand\u00e9 est une recherche dichotomique r\u00e9cursive. Recopier et compl\u00e9ter le code de la fonction `chercher` suivante : ```python linenums='1' def chercher(tab, n, i, j): if i < 0 or j > len(tab) : return None if i > j : return None m = (i + j) // ... if ... < n : return chercher(tab, n, ... , ...) elif ... > n : return chercher(tab, n, ... , ... ) else : return ... L'ex\u00e9cution du code doit donner : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 09.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-10", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 10"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-101", "text": "Exercice 10.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire la fonction maxliste , prenant en param\u00e8tre un tableau non vide de nombres tab (de type list ) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : \ud83d\udc0d Script Python >>> maxliste ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maxliste ([ - 27 , 24 , - 3 , 15 ]) 24 \ud83d\udc0d Script Python 1 2 3 4 5 6 def maxliste ( tab ): maximum = tab [ 0 ] for element in tab : if element > maximum : maximum = element return maximum \ud83d\udccb Texte \u00c9crire la fonction `maxliste`, prenant en param\u00e8tre un tableau non vide de nombres `tab` (de type `list`) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : ```python >>> maxliste([98, 12, 104, 23, 131, 9]) 131 >>> maxliste([-27, 24, -3, 15]) 24 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 10.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-102", "text": "Exercice 10.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, ((()())(())) est un parenth\u00e9sage correct. Les parenth\u00e9sages ())(() et (())(() sont, eux, incorrects. On dispose du code de la classe Pile suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self ): self . valeurs = [] def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res ch form\u00e9e de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () Compl\u00e9ter le code de la fonction parenthesage . Exemples : \ud83d\udc0d Script Python >>> parenthesage ( \"((()())(()))\" ) True >>> parenthesage ( \"())(()\" ) False >>> parenthesage ( \"(())(()\" ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Pile : \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ ( self ): self . valeurs = [] def est_vide ( self ): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self . valeurs == [] def empiler ( self , c ): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self . valeurs . append ( c ) def depiler ( self ): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self . est_vide () == False : self . valeurs . pop () def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == '(' : p . empiler ( c ) elif c == ')' : if p . est_vide (): return False else : p . depiler () return p . est_vide () Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : - le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. - en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, `((()())(()))` est un parenth\u00e9sage correct. Les parenth\u00e9sages `())(()` et `(())(()` sont, eux, incorrects. On dispose du code de la classe `Pile` suivant : ```python linenums='1' class Pile: \"\"\" Classe d\u00e9finissant une pile \"\"\" def __init__ (self): self.valeurs = [] def est_vide(self): \"\"\"Renvoie True si la pile est vide, False sinon\"\"\" return self.valeurs == [] def empiler(self, c): \"\"\"Place l\u2019\u00e9l\u00e9ment c au sommet de la pile\"\"\" self.valeurs.append(c) def depiler(self): \"\"\"Supprime l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, \u00e0 condition qu\u2019elle soit non vide\"\"\" if self.est_vide() == False: self.valeurs.pop() On souhaite programmer une fonction parenthesage qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res ch form\u00e9e de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def parenthesage ( ch ): \"\"\"Renvoie True si la cha\u00eene ch est bien parenth\u00e9s\u00e9e et False sinon\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): return ... else : ... return p . est_vide () Compl\u00e9ter le code de la fonction parenthesage . Exemples : \ud83d\udc0d Script Python >>> parenthesage ( \"((()())(()))\" ) True >>> parenthesage ( \"())(()\" ) False >>> parenthesage ( \"(())(()\" ) False ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 10.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-11", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 11"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-111", "text": "Exercice 11.1 \u00c9nonc\u00e9 Correction Source Markdown On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau [1, 0, 1, 0, 0, 1, 1] repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est 2**6 + 2**4 + 2**1 + 2**0 = 83 . \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction convertir r\u00e9pondant aux sp\u00e9cifications suivantes : \ud83d\udc0d Script Python def convertir ( tab ): \"\"\" tab est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau tab \"\"\" Exemple : \ud83d\udc0d Script Python >>> convertir ([ 1 , 0 , 1 , 0 , 0 , 1 , 1 ]) 83 >>> convertir ([ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def convertir ( tab ): puissance = 0 total = 0 for i in range ( len ( tab ) - 1 , - 1 , - 1 ): total += tab [ i ] * ( 2 ** puissance ) puissance += 1 return total \ud83d\udccb Texte On mod\u00e9lise la repr\u00e9sentation binaire d'un entier non sign\u00e9 par un tableau d'entiers dont les \u00e9l\u00e9ments sont 0 ou 1. Par exemple, le tableau `[1, 0, 1, 0, 0, 1, 1]` repr\u00e9sente l'\u00e9criture binaire de l'entier dont l'\u00e9criture d\u00e9cimale est `2**6 + 2**4 + 2**1 + 2**0 = 83`. \u00c0 l'aide d'un parcours s\u00e9quentiel, \u00e9crire la fonction `convertir` r\u00e9pondant aux sp\u00e9cifications suivantes : ```python def convertir(tab): \"\"\" tab est un tableau d'entiers, dont les \u00e9l\u00e9ments sont 0 ou 1 et repr\u00e9sentant un entier \u00e9crit en binaire. Renvoie l'\u00e9criture d\u00e9cimale de l'entier positif dont la repr\u00e9sentation binaire est donn\u00e9e par le tableau tab \"\"\" ``` Exemple : ```python >>> convertir([1, 0, 1, 0, 0, 1, 1]) 83 >>> convertir([1, 0, 0, 0, 0, 0, 1, 0]) 130 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 11.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-112", "text": "Exercice 11.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_insertion suivante prend en argument une liste tab et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. On rappelle le principe du tri par insertion : on consid\u00e8re les \u00e9l\u00e9ments \u00e0 trier un par un, le premier \u00e9l\u00e9ment constituant, \u00e0 lui tout seul, une liste tri\u00e9e de longueur 1. On range ensuite le second \u00e9l\u00e9ment pour constituer une liste tri\u00e9e de longueur 2, puis on range le troisi\u00e8me \u00e9l\u00e9ment pour avoir une liste tri\u00e9e de longueur 3 et ainsi de suite\u2026 A chaque \u00e9tape, le premier \u00e9l\u00e9ment de la sous-liste non tri\u00e9e est plac\u00e9 dans la sous-liste des \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s de sorte que cette sous-liste demeure tri\u00e9e. Le principe du tri par insertion est donc d'ins\u00e9rer \u00e0 la n-i\u00e8me it\u00e9ration, le n-i\u00e8me \u00e9l\u00e9ment \u00e0 la bonne place. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tri_insertion ( tab ): n = len ( tab ) for i in range ( 1 , n ): valeur_insertion = tab [ ... ] # la variable j sert \u00e0 d\u00e9terminer o\u00f9 placer la valeur \u00e0 ranger j = ... # tant qu'on a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer # on d\u00e9cale les valeurs du tableau vers la droite while j > ... and valeur_insertion < tab [ ... ]: tab [ j ] = tab [ j - 1 ] j = ... tab [ j ] = ... Exemples : \ud83d\udc0d Script Python >>> liste = [ 9 , 5 , 8 , 4 , 0 , 2 , 7 , 1 , 10 , 3 , 6 ] >>> tri_insertion ( liste ) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tri_insertion ( tab ): n = len ( tab ) for i in range ( 1 , n ): valeur_insertion = tab [ i ] # la variable j sert \u00e0 d\u00e9terminer o\u00f9 placer la valeur \u00e0 ranger j = i # tant qu'on a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer # on d\u00e9cale les valeurs du tableau vers la droite while j > 0 and valeur_insertion < tab [ j - 1 ]: tab [ j ] = tab [ j - 1 ] j = j - 1 tab [ j ] = valeur_insertion Markdown La fonction `tri_insertion` suivante prend en argument une liste `tab` et trie cette liste en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. On rappelle le principe du tri par insertion : on consid\u00e8re les \u00e9l\u00e9ments \u00e0 trier un par un, le premier \u00e9l\u00e9ment constituant, \u00e0 lui tout seul, une liste tri\u00e9e de longueur 1. On range ensuite le second \u00e9l\u00e9ment pour constituer une liste tri\u00e9e de longueur 2, puis on range le troisi\u00e8me \u00e9l\u00e9ment pour avoir une liste tri\u00e9e de longueur 3 et ainsi de suite\u2026 A chaque \u00e9tape, le premier \u00e9l\u00e9ment de la sous-liste non tri\u00e9e est plac\u00e9 dans la sous-liste des \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s de sorte que cette sous-liste demeure tri\u00e9e. Le principe du tri par insertion est donc d'ins\u00e9rer \u00e0 la n-i\u00e8me it\u00e9ration, le n-i\u00e8me \u00e9l\u00e9ment \u00e0 la bonne place. ```python linenums='1' def tri_insertion(tab): n = len(tab) for i in range(1, n): valeur_insertion = tab[...] # la variable j sert \u00e0 d\u00e9terminer o\u00f9 placer la valeur \u00e0 ranger j = ... # tant qu'on a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer # on d\u00e9cale les valeurs du tableau vers la droite while j > ... and valeur_insertion < tab[...]: tab[j] = tab[j-1] j = ... tab[j] = ... Exemples : \ud83d\udc0d Script Python >>> liste = [ 9 , 5 , 8 , 4 , 0 , 2 , 7 , 1 , 10 , 3 , 6 ] >>> tri_insertion ( liste ) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 11.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-12", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 12"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-121", "text": "Exercice 12.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re la classe ABR , dont le constructeur est le suivant : \ud83d\udc0d Script Python class ABR : def __init__ ( self , g0 , v0 , d0 ): self . gauche = g0 self . cle = v0 self . droit = d0 def __repr__ ( self ): if self is None : return '' else : return '(' + ( self . gauche ) . __repr__ () + ',' + str ( self . cle ) + ',' + ( self . droit ) . __repr__ () + ')' Ainsi, l\u2019arbre binaire de recherche abr1 ci- contre est cr\u00e9\u00e9 par le code python ci- dessous \ud83d\udc0d Script Python n0 = ABR ( None , 0 , None ) n3 = ABR ( None , 3 , None ) n2 = ABR ( None , 2 , n3 ) n3 = ABR ( n0 , 1 , n2 ) Dans tout le code, None correspondra \u00e0 un arbre vide. La classe ABR dispose aussi d\u2019une m\u00e9thode de repr\u00e9sentation ( __repr__ ), qui affiche entre parenth\u00e8ses le contenu du sous arbre gauche, puis la cl\u00e9 de l\u2019arbre, et enfin le contenu du sous arbre droit. Elle s\u2019utilise en console de la mani\u00e8re suivante : \ud83d\udc0d Script Python >>> abr1 (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) \u00c9crire une fonction r\u00e9cursive ajoute(cle, a) qui prend en param\u00e8tres une cl\u00e9 cle et un arbre binaire de recherche a , et qui renvoie un arbre binaire de recherche dans lequel cle a \u00e9t\u00e9 ins\u00e9r\u00e9e. Dans le cas o\u00f9 cle est d\u00e9j\u00e0 pr\u00e9sente dans a , la fonction renvoie l\u2019arbre a inchang\u00e9. R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> a = ajoute ( 4 , abr1 ) >>> a (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 ,( None , 4 , None )))) >>> ajoute ( - 5 , abr1 ) ((( None , - 5 , None ), 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) >>> ajoute ( 2 , abr1 ) (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def ajoute ( cle , a ): if a is None : a = ABR ( None , cle , None ) elif cle > a . cle : a . droit = ajoute ( cle , a . droit ) elif cle < a . cle : a . gauche = ajoute ( cle , a . gauche ) return a \ud83d\udccb Texte On consid\u00e8re la classe `ABR`, dont le constructeur est le suivant : ```python class ABR: def __init__(self, g0, v0, d0): self.gauche = g0 self.cle = v0 self.droit = d0 def __repr__(self): if self is None: return '' else: return '(' + (self.gauche).__repr__() + ',' + str(self.cle) + ',' +(self.droit).__repr__() + ')' ``` ![image](data2023/12_arbre.png){: .center width=30%} Ainsi, l\u2019arbre binaire de recherche `abr1` ci- contre est cr\u00e9\u00e9 par le code python ci- dessous ```python n0 = ABR(None, 0, None) n3 = ABR(None, 3, None) n2 = ABR(None, 2, n3) n3 = ABR(n0, 1, n2) ``` Dans tout le code, `None` correspondra \u00e0 un arbre vide. La classe `ABR` dispose aussi d\u2019une m\u00e9thode de repr\u00e9sentation (```__repr__``` ), qui affiche entre parenth\u00e8ses le contenu du sous arbre gauche, puis la cl\u00e9 de l\u2019arbre, et enfin le contenu du sous arbre droit. Elle s\u2019utilise en console de la mani\u00e8re suivante : ```python >>> abr1 ((None,0,None),1,(None,2,(None,3,None))) ``` \u00c9crire une fonction r\u00e9cursive `ajoute(cle, a)` qui prend en param\u00e8tres une cl\u00e9 `cle` et un arbre binaire de recherche ```a``` , et qui renvoie un arbre binaire de recherche dans lequel `cle` a \u00e9t\u00e9 ins\u00e9r\u00e9e. Dans le cas o\u00f9 `cle` est d\u00e9j\u00e0 pr\u00e9sente dans `a`, la fonction renvoie l\u2019arbre `a` inchang\u00e9. R\u00e9sultats \u00e0 obtenir : ```python >>> a = ajoute(4, abr1) >>> a ((None,0,None),1,(None,2,(None,3,(None,4,None)))) >>> ajoute(-5, abr1) (((None,-5,None),0,None),1,(None,2,(None,3,None))) >>> ajoute(2, abr1) ((None,0,None),1,(None,2,(None,3,None))) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 12.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-122", "text": "Exercice 12.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019un ensemble d\u2019objets dont on conna\u00eet, pour chacun, la masse. On souhaite ranger l\u2019ensemble de ces objets dans des boites identiques de telle mani\u00e8re que la somme des masses des objets contenus dans une bo\u00eete ne d\u00e9passe pas la capacit\u00e9 c de la bo\u00eete. On souhaite utiliser le moins de bo\u00eetes possibles pour ranger cet ensemble d\u2019objets. Pour r\u00e9soudre ce probl\u00e8me, on utilisera un algorithme glouton consistant \u00e0 placer chacun des objets dans la premi\u00e8re bo\u00eete o\u00f9 cela est possible. Par exemple, pour ranger dans des bo\u00eetes de capacit\u00e9 c = 5 un ensemble de trois objets dont les masses sont repr\u00e9sent\u00e9es en Python par la liste [1, 5, 2] , on proc\u00e8de de la fa\u00e7on suivante : Le premier objet, de masse 1, va dans une premi\u00e8re boite. Le deuxi\u00e8me objet, de masse 5, ne peut pas aller dans la m\u00eame boite que le premier objet car cela d\u00e9passerait la capacit\u00e9 de la boite. On place donc cet objet dans une deuxi\u00e8me bo\u00eete. Le troisi\u00e8me objet, de masse 2, va dans la premi\u00e8re bo\u00eete. On a donc utilis\u00e9 deux bo\u00eetes de capacit\u00e9 c = 5 pour ranger les 3 objets. Compl\u00e9ter la fonction Python empaqueter(liste_masses, c) suivante pour qu\u2019elle renvoie le nombre de bo\u00eetes de capacit\u00e9 c n\u00e9cessaires pour empaqueter un ensemble d\u2019objets dont les masses sont contenues dans la liste liste_masses . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def empaqueter ( liste_masses , c ): n = len ( liste_masses ) nb_boites = 0 boites = [ 0 ] * n for masse in ... : i = 0 while i <= nb_boites and boites [ i ] + ... > C : i = i + 1 if i == nb_boites + 1 : ... boites [ i ] = ... return ... Tester ensuite votre fonction : \ud83d\udc0d Script Python >>> empaqueter ([ 7 , 6 , 3 , 4 , 8 , 5 , 9 , 2 ], 11 ) 5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def empaqueterR ( liste_masses , c ): n = len ( liste_masses ) nb_boites = 0 boites = [ 0 ] * n for masse in liste_masses : i = 0 while i <= nb_boites and boites [ i ] + masse > c : i = i + 1 if i == nb_boites + 1 : nb_boites = nb_boites + 1 boites [ i ] = boites [ i ] + masse return nb_boites + 1 Markdown On dispose d\u2019un ensemble d\u2019objets dont on conna\u00eet, pour chacun, la masse. On souhaite ranger l\u2019ensemble de ces objets dans des boites identiques de telle mani\u00e8re que la somme des masses des objets contenus dans une bo\u00eete ne d\u00e9passe pas la capacit\u00e9 `c` de la bo\u00eete. On souhaite utiliser le moins de bo\u00eetes possibles pour ranger cet ensemble d\u2019objets. Pour r\u00e9soudre ce probl\u00e8me, on utilisera un algorithme glouton consistant \u00e0 placer chacun des objets dans la premi\u00e8re bo\u00eete o\u00f9 cela est possible. Par exemple, pour ranger dans des bo\u00eetes de capacit\u00e9 `c = 5` un ensemble de trois objets dont les masses sont repr\u00e9sent\u00e9es en Python par la liste `[1, 5, 2]` , on proc\u00e8de de la fa\u00e7on suivante : - Le premier objet, de masse 1, va dans une premi\u00e8re boite. - Le deuxi\u00e8me objet, de masse 5, ne peut pas aller dans la m\u00eame boite que le premier objet car cela d\u00e9passerait la capacit\u00e9 de la boite. On place donc cet objet dans une deuxi\u00e8me bo\u00eete. - Le troisi\u00e8me objet, de masse 2, va dans la premi\u00e8re bo\u00eete. On a donc utilis\u00e9 deux bo\u00eetes de capacit\u00e9 `c = 5` pour ranger les 3 objets. Compl\u00e9ter la fonction Python `empaqueter(liste_masses, c)` suivante pour qu\u2019elle renvoie le nombre de bo\u00eetes de capacit\u00e9 c n\u00e9cessaires pour empaqueter un ensemble d\u2019objets dont les masses sont contenues dans la liste `liste_masses` . ```python linenums='1' def empaqueter(liste_masses, c): n = len(liste_masses) nb_boites = 0 boites = [0]*n for masse in ... : i = 0 while i <= nb_boites and boites[i] + ... > C: i = i + 1 if i == nb_boites + 1: ... boites[i] = ... return ... Tester ensuite votre fonction : \ud83d\udc0d Script Python >>> empaqueter ([ 7 , 6 , 3 , 4 , 8 , 5 , 9 , 2 ], 11 ) 5 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 12.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-13", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 13"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-131", "text": "Exercice 13.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire en langage Python une fonction recherche prenant comme param\u00e8tres une variable a de type num\u00e9rique ( float ou int ) et un tableau tab (type list ) et qui renvoie le nombre d'occurrences de a dans tab . Exemples : \ud83d\udc0d Script Python >>> recherche ( 5 , []) 0 >>> recherche ( 5 , [ - 2 , 3 , 4 , 8 ]) 0 >>> recherche ( 5 , [ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> recherche ( 5 , [ - 2 , 5 , 3 , 5 , 4 , 5 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( a , tab ): nb = 0 for element in tab : if element == a : nb += 1 return nb \ud83d\udccb Texte \u00c9crire en langage Python une fonction `recherche` prenant comme param\u00e8tres une variable `a` de type num\u00e9rique (`float` ou `int`) et un tableau `tab` (type `list`) et qui renvoie le nombre d'occurrences de `a` dans `tab`. Exemples : ```python >>> recherche(5, []) 0 >>> recherche(5, [-2, 3, 4, 8]) 0 >>> recherche(5, [-2, 3, 1, 5, 3, 7, 4]) 1 >>> recherche(5, [-2, 5, 3, 5, 4, 5]) 3 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 13.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-132", "text": "Exercice 13.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction rendu_monnaie prend en param\u00e8tres deux nombres entiers positifs somme_due et somme_versee et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence somme_versee \u2013 somme_due pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme glouton qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. Par la suite, on assimilera les billets \u00e0 des pi\u00e8ces. La fonction rendu_monnaie renvoie un tableau de type list contenant les pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en euros. Les valeurs possibles pour les pi\u00e8ces sont donc [1, 2, 5, 10, 20, 50, 100, 200] . Ainsi, l\u2019instruction rendu_monnaie(452, 500) renvoie le tableau [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 euros soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction rendu_monnaie est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie ( somme_due , somme_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : if pieces [ i ] <= a_rendre : rendu . append ( ... ) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code et le tester : \ud83d\udc0d Script Python >>> rendu_monnaie ( 700 , 700 ) [] >>> rendu_monnaie ( 102 , 500 ) [ 200 , 100 , 50 , 20 , 20 , 5 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie ( somme_due , somme_versee ): pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] rendu = [] a_rendre = somme_versee - somme_due i = len ( pieces ) - 1 while a_rendre > 0 : if pieces [ i ] <= a_rendre : rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] else : i = i - 1 return rendu Markdown La fonction `rendu_monnaie` prend en param\u00e8tres deux nombres entiers positifs `somme_due` et `somme_versee` et elle permet de proc\u00e9der au rendu de monnaie de la diff\u00e9rence `somme_versee \u2013 somme_due` pour des achats effectu\u00e9s avec le syst\u00e8me de pi\u00e8ces de la zone Euro. On utilise pour cela un algorithme glouton qui commence par rendre le maximum de pi\u00e8ces de plus grandes valeurs et ainsi de suite. Par la suite, on assimilera les billets \u00e0 des pi\u00e8ces. La fonction `rendu_monnaie` renvoie un tableau de type `list` contenant les pi\u00e8ces qui composent le rendu. Toutes les sommes sont exprim\u00e9es en euros. Les valeurs possibles pour les pi\u00e8ces sont donc `[1, 2, 5, 10, 20, 50, 100, 200]` . Ainsi, l\u2019instruction `rendu_monnaie(452, 500)` renvoie le tableau `[20, 20, 5, 2, 1]` . En effet, la somme \u00e0 rendre est de `48` euros soit `20 + 20 + 5 + 2 + 1` . Le code de la fonction `rendu_monnaie` est donn\u00e9 ci-dessous : ```python linenums='1' def rendu_monnaie(somme_due, somme_versee): pieces = [1, 2, 5, 10, 20, 50, 100, 200] rendu = ... a_rendre = ... i = len(pieces) - 1 while a_rendre > ... : if pieces[i] <= a_rendre : rendu.append(...) a_rendre = ... else : i = ... return rendu Compl\u00e9ter ce code et le tester : \ud83d\udc0d Script Python >>> rendu_monnaie ( 700 , 700 ) [] >>> rendu_monnaie ( 102 , 500 ) [ 200 , 100 , 50 , 20 , 20 , 5 , 2 , 1 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 13.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-14", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 14"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-141", "text": "Exercice 14.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def recherche ( elt , tab ): ''' renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. ''' assert tab != [], \"le tableau est vide\" for i in range ( len ( tab )): if tab [ i ] == elt : return i return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 14.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-142", "text": "Exercice 14.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et un tableau tab d'entiers tri\u00e9s par ordre croissant. Cette fonction cr\u00e9e et renvoie un nouveau tableau \u00e0 partir de celui fourni en param\u00e8tre en y ins\u00e9rant la valeur a de sorte que le tableau renvoy\u00e9 soit encore tri\u00e9 par ordre croissant. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes Python. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( a , tab ): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = ... while a < ... and i >= 0 : l [ i + 1 ] = ... l [ i ] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 , [ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 30 , [ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 12 , 14 , 25 , 30 ] >>> insere ( 1 , [ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] >>> insere ( 1 , []) [ 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( a , tab ): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" l = list ( tab ) #l contient les m\u00eames \u00e9l\u00e9ments que tab l . append ( a ) i = len ( l ) - 2 while a < l [ i ] and i >= 0 : l [ i + 1 ] = l [ i ] l [ i ] = a i = i - 1 return l Markdown On consid\u00e8re la fonction `insere` ci-dessous qui prend en argument un entier `a` et un tableau `tab` d'entiers tri\u00e9s par ordre croissant. Cette fonction cr\u00e9e et renvoie un nouveau tableau \u00e0 partir de celui fourni en param\u00e8tre en y ins\u00e9rant la valeur `a` de sorte que le tableau renvoy\u00e9 soit encore tri\u00e9 par ordre croissant. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes Python. ```python linenums='1' def insere(a, tab): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" l = list(tab) #l contient les m\u00eames \u00e9l\u00e9ments que tab l.append(a) i = ... while a < ... and i >= 0: l[i+1] = ... l[i] = a i = ... return l Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ( 3 , [ 1 , 2 , 4 , 5 ]) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ( 30 , [ 1 , 2 , 7 , 12 , 14 , 25 ]) [ 1 , 2 , 7 , 12 , 14 , 25 , 30 ] >>> insere ( 1 , [ 2 , 3 , 4 ]) [ 1 , 2 , 3 , 4 ] >>> insere ( 1 , []) [ 1 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 14.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-15", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 15"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-151", "text": "Exercice 15.1 \u00c9nonc\u00e9 Correction Source Markdown On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction mini qui prend en param\u00e8tres un tableau releve des relev\u00e9s et un tableau date des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. On suppose que la temp\u00e9rature minimale est atteinte une seule fois. Exemple : \ud83d\udc0d Script Python >>> mini ( t_moy , annees ) ( 12.5 , 2016 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def mini ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \ud83d\udccb Texte On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux listes : l\u2019une pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : ```python t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7] annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019] ``` \u00c9crire la fonction `mini` qui prend en param\u00e8tres un tableau `releve` des relev\u00e9s et un tableau `date` des dates et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. On suppose que la temp\u00e9rature minimale est atteinte une seule fois. Exemple : ```python >>> mini(t_moy, annees) (12.5, 2016) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 15.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-152", "text": "Exercice 15.2 \u00c9nonc\u00e9 Correction Sources Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : bob , radar , et non sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction est_nbre_palindrome s\u2019appuiera sur la fonction est_palindrome qui elle-m\u00eame s\u2019appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res chaine et renvoie la cha\u00eene invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbre_palindrome teste si un nombre nbre est un palindrome. Elle renvoie True si c\u2019est le cas et False sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = ... for caractere in chaine : result = ... return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def inverse_chaine ( chaine ): result = '' for caractere in chaine : result = caractere + result return result def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): chaine = str ( nbre ) return est_palindrome ( chaine ) Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : *bob* , *radar* , et *non* sont des mots palindromes. De m\u00eame certains nombres sont eux aussi des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous sachant que la fonction `est_nbre_palindrome` s\u2019appuiera sur la fonction `est_palindrome` qui elle-m\u00eame s\u2019appuiera sur la fonction `inverse_chaine` . La fonction `inverse_chaine` inverse l'ordre des caract\u00e8res d'une cha\u00eene de caract\u00e8res `chaine` et renvoie la cha\u00eene invers\u00e9e. La fonction `est_palindrome` teste si une chaine de caract\u00e8res `chaine` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. La fonction `est_nbre_palindrome` teste si un nombre `nbre` est un palindrome. Elle renvoie `True` si c\u2019est le cas et `False` sinon. Cette fonction s\u2019appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. ```python linenums='1' def inverse_chaine(chaine): result = ... for caractere in chaine: result = ... return result def est_palindrome(chaine): inverse = inverse_chaine(chaine) return ... def est_nbre_palindrome(nbre): chaine = ... return est_palindrome(chaine) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 15.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-16", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 16"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-161", "text": "Exercice 16.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_indices_classement qui prend en param\u00e8tres un entier elt et une liste d\u2019entiers tab , et qui renvoie trois listes : la premi\u00e8re liste contient les indices des valeurs de la liste tab strictement inf\u00e9rieures \u00e0 elt ; la deuxi\u00e8me liste contient les indices des valeurs de la liste tab \u00e9gales \u00e0 elt ; la troisi\u00e8me liste contient les indices des valeurs de la liste tab strictement sup\u00e9rieures \u00e0 elt . Exemples : \ud83d\udc0d Script Python >>> recherche_indices_classement ( 3 , [ 1 , 3 , 4 , 2 , 4 , 6 , 3 , 0 ]) ([ 0 , 3 , 7 ], [ 1 , 6 ], [ 2 , 4 , 5 ]) >>> recherche_indices_classement ( 3 , [ 1 , 4 , 2 , 4 , 6 , 0 ]) ([ 0 , 2 , 5 ], [], [ 1 , 3 , 4 ]) >>> recherche_indices_classement ( 3 , [ 1 , 1 , 1 , 1 ]) ([ 0 , 1 , 2 , 3 ], [], []) >>> recherche_indices_classement ( 3 , []) ([], [], []) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche_indices_classement ( elt , tab ): ind_inf = [] ind_egal = [] ind_sup = [] for i in range ( len ( tab )): if tab [ i ] < elt : ind_inf . append ( i ) elif tab [ i ] > elt : ind_sup . append ( i ) else : ind_egal . append ( i ) return ( ind_inf , ind_egal , ind_sup ) \ud83d\udccb Texte \u00c9crire une fonction `recherche_indices_classement` qui prend en param\u00e8tres un entier `elt` et une liste d\u2019entiers `tab`, et qui renvoie trois listes : - la premi\u00e8re liste contient les indices des valeurs de la liste `tab` strictement inf\u00e9rieures \u00e0 `elt` ; - la deuxi\u00e8me liste contient les indices des valeurs de la liste `tab` \u00e9gales \u00e0 `elt` ; - la troisi\u00e8me liste contient les indices des valeurs de la liste `tab` strictement sup\u00e9rieures \u00e0 `elt`. Exemples : ```python >>> recherche_indices_classement(3, [1, 3, 4, 2, 4, 6, 3, 0]) ([0, 3, 7], [1, 6], [2, 4, 5]) >>> recherche_indices_classement(3, [1, 4, 2, 4, 6, 0]) ([0, 2, 5], [], [1, 3, 4]) >>>recherche_indices_classement(3, [1, 1, 1, 1]) ([0, 1, 2, 3], [], []) >>> recherche_indices_classement(3, []) ([], [], []) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 16.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-162", "text": "Exercice 16.2 \u00c9nonc\u00e9 Correction Sources Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves sous forme de cha\u00eene de caract\u00e8res et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients dans une liste. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' : { 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ] }, 'Durand' : { 'DS1' : [ 6 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 8 , 4 ], 'DS4' :[ 15 , 4 ] } } L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ses \u00e9l\u00e8ves et renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom , dico_result ): if nom in ... : notes = dico_result [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom , dico_result ): if nom in dico_result : notes = dico_result [ nom ] total_points = 0. total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return - 1 Markdown Un professeur de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : - les clefs sont les noms des \u00e9l\u00e8ves ; - les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves sous forme de cha\u00eene de caract\u00e8res et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients dans une liste. Avec : ```python resultats = {'Dupont': { 'DS1': [15.5, 4], 'DM1': [14.5, 1], 'DS2': [13, 4], 'PROJET1': [16, 3], 'DS3': [14, 4] }, 'Durand': { 'DS1': [6 , 4], 'DM1': [14.5, 1], 'DS2': [8, 4], 'PROJET1': [9, 3], 'IE1': [7, 2], 'DS3': [8, 4], 'DS4':[15, 4] } } L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ses \u00e9l\u00e8ves et renvoie sa moyenne arrondie au dixi\u00e8me. Compl\u00e9ter le code du professeur ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( nom , dico_result ): if nom in ... : notes = dico_result [ nom ] total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient total_coefficients = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return - 1 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 16.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-17", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 17"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-171", "text": "Exercice 17.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne(liste_notes) qui renvoie la moyenne pond\u00e9r\u00e9e des r\u00e9sultats contenus dans la liste liste_notes , non vide, donn\u00e9e en param\u00e8tre. Cette liste contient des couples (note, coefficient) dans lesquels : note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier strictement positif. Ainsi l\u2019expression moyenne([(15,2),(9,1),(12,3)]) devra renvoyer 12.5 . \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( liste_notes ): somme_notes = 0 somme_coeffs = 0 for devoir in liste_notes : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \ud83d\udccb Texte \u00c9crire une fonction `moyenne(liste_notes)` qui renvoie la moyenne pond\u00e9r\u00e9e des r\u00e9sultats contenus dans la liste `liste_notes`, non vide, donn\u00e9e en param\u00e8tre. Cette liste contient des couples `(note, coefficient)` dans lesquels : - `note` est un nombre de type flottant (`float`) compris entre 0 et 20 ; - `coefficient` est un nombre entier strictement positif. Ainsi l\u2019expression `moyenne([(15,2),(9,1),(12,3)])` devra renvoyer `12.5`. $\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5$ R\u00e9digez votre code sur Basthon", "title": "Exercice 17.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-172", "text": "Exercice 17.2 \u00c9nonc\u00e9 Correction Sources Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal (Figure 1). Dans le triangle de Pascal, chaque ligne commence et se termine par le nombre 1. Comme l\u2019illustre la Figure 2, on additionne deux valeurs successives d\u2019une ligne pour obtenir la valeur qui se situe sous la deuxi\u00e8me valeur. Compl\u00e9ter la fonction pascal ci-apr\u00e8s prenant en param\u00e8tre un entier n sup\u00e9rieur ou \u00e9gal \u00e0 2. Cette fonction doit renvoyer une liste correspondant au triangle de Pascal de la ligne 0 \u00e0 la ligne n . Le tableau repr\u00e9sentant le triangle de Pascal sera contenu dans la variable triangle . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): triangle = [[ 1 ]] for k in range ( 1 , ... ): ligne_k = [ ... ] for i in range ( 1 , k ): ligne_k . append ( triangle [ ... ][ i - 1 ] + triangle [ ... ][ ... ]) ligne_k . append ( ... ) triangle . append ( ligne_k ) return triangle Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def pascal ( n ): triangle = [[ 1 ]] for k in range ( 1 , n + 1 ): ligne_k = [ 1 ] for i in range ( 1 , k ): ligne_k . append ( triangle [ k - 1 ][ i - 1 ] + triangle [ k - 1 ][ i ]) ligne_k . append ( 1 ) triangle . append ( ligne_k ) return triangle Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal (Figure 1). Dans le triangle de Pascal, chaque ligne commence et se termine par le nombre 1. Comme l\u2019illustre la Figure 2, on additionne deux valeurs successives d\u2019une ligne pour obtenir la valeur qui se situe sous la deuxi\u00e8me valeur. ![ image ]( data2023/17_triangle.png ){: .center width=60%} Compl\u00e9ter la fonction `pascal` ci-apr\u00e8s prenant en param\u00e8tre un entier `n` sup\u00e9rieur ou \u00e9gal \u00e0 2. Cette fonction doit renvoyer une liste correspondant au triangle de Pascal de la ligne 0 \u00e0 la ligne `n` . Le tableau repr\u00e9sentant le triangle de Pascal sera contenu dans la variable `triangle` . ```python linenums='1' def pascal(n): triangle = [[1]] for k in range(1,...): ligne_k = [...] for i in range(1,k): ligne_k.append(triangle[...][i-1]+triangle[...][...]) ligne_k.append(...) triangle.append(ligne_k) return triangle Pour n = 4 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 4 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ]] Pour n = 5 , voici ce qu'on devra obtenir : \ud83d\udc0d Script Python >>> pascal ( 5 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ], [ 1 , 4 , 6 , 4 , 1 ], [ 1 , 5 , 10 , 10 , 5 , 1 ]] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 17.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-18", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 18"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-181", "text": "Exercice 18.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction max_et_indice qui prend en param\u00e8tre une liste non vide tab de nombres entiers et qui renvoie la valeur du plus grand \u00e9l\u00e9ment de cette liste ainsi que l\u2019indice de sa premi\u00e8re apparition dans cette liste. L\u2019utilisation de la fonction native max n\u2019est pas autoris\u00e9e. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : \ud83d\udc0d Script Python >>> max_et_indice ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) >>> max_et_indice ([ - 2 ]) ( - 2 , 0 ) >>> max_et_indice ([ - 1 , - 1 , 3 , 3 , 3 ]) ( 3 , 2 ) >>> max_et_indice ([ 1 , 1 , 1 , 1 ]) ( 1 , 0 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def max_et_indice ( tab ): ''' renvoie la valeur du plus grand \u00e9l\u00e9ment de cette liste ainsi que l\u2019indice de sa premi\u00e8re apparition dans cette liste. ''' assert tab != [], 'le tableau est vide' val_max = tab [ 0 ] ind_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] ind_max = i return ( val_max , ind_max ) \ud83d\udccb Texte \u00c9crire une fonction `max_et_indice` qui prend en param\u00e8tre une liste non vide `tab` de nombres entiers et qui renvoie la valeur du plus grand \u00e9l\u00e9ment de cette liste ainsi que l\u2019indice de sa premi\u00e8re apparition dans cette liste. L\u2019utilisation de la fonction native `max` n\u2019est pas autoris\u00e9e. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : ```python >>> max_et_indice([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) (9, 3) >>> max_et_indice([-2]) (-2, 0) >>> max_et_indice([-1, -1, 3, 3, 3]) (3, 2) >>> max_et_indice([1, 1, 1, 1]) (1, 0) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 18.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-182", "text": "Exercice 18.2 \u00c9nonc\u00e9 Correction Sources Markdown L\u2019ordre des g\u00e8nes sur un chromosome est repr\u00e9sent\u00e9 par un tableau ordre de n cases d\u2019entiers distincts deux \u00e0 deux et compris entre 1 et n . Par exemple, ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9] dans le cas n = 9 . On dit qu\u2019il y a un point de rupture dans ordre dans chacune des situations suivantes : la premi\u00e8re valeur de ordre n\u2019est pas 1 ; l\u2019\u00e9cart entre deux g\u00e8nes cons\u00e9cutifs n\u2019est pas \u00e9gal \u00e0 1 ; la derni\u00e8re valeur de ordre n\u2019est pas n. Par exemple, si ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9] avec n = 9 , on a un point de rupture au d\u00e9but car 5 est diff\u00e9rent de 1 un point de rupture entre 3 et 6 (l\u2019\u00e9cart est de 3) un point de rupture entre 7 et 2 (l\u2019\u00e9cart est de 5) un point de rupture entre 1 et 8 (l\u2019\u00e9cart est de 7) Il y a donc 4 points de rupture. Compl\u00e9ter les fonctions Python est_un_ordre et nombre_points_rupture propos\u00e9es \u00e0 la page suivante pour que : la fonction est_un_ordre renvoie True si le tableau pass\u00e9 en param\u00e8tre repr\u00e9sente bien un ordre de g\u00e8nes de chromosome et False sinon ; la fonction nombre_points_rupture renvoie le nombre de points de rupture d\u2019un tableau pass\u00e9 en param\u00e8tre repr\u00e9sentant l\u2019ordre de g\u00e8nes d\u2019un chromosome. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def est_un_ordre ( tab ): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' for i in range ( 1 , ... ): if ... : return False return True def nombre_points_rupture ( ordre ): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' assert ... # ordre n'est pas un ordre de g\u00e8nes n = len ( ordre ) nb = 0 if ordre [ ... ] != 1 : # le premier n'est pas 1 nb = nb + 1 i = 0 while i < ... : if ... not in [ - 1 , 1 ]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre [ ... ] != n : # le dernier n'est pas n nb = nb + 1 return nb Exemples : \ud83d\udc0d Script Python >>> est_un_ordre ([ 1 , 6 , 2 , 8 , 3 , 7 ]) False >>> est_un_ordre ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) True >>> nombre_points_rupture ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) 4 >>> nombre_points_rupture ([ 1 , 2 , 3 , 4 , 5 ]) 0 >>> nombre_points_rupture ([ 1 , 6 , 2 , 8 , 3 , 7 , 4 , 5 ]) 7 >>> nombre_points_rupture ([ 2 , 1 , 3 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def est_un_ordre ( tab ): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' for i in range ( 1 , len ( tab ) + 1 ): if i not in tab : return False return True def nombre_points_rupture ( ordre ): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' assert est_un_ordre ( ordre ) # ordre n'est pas un ordre de g\u00e8nes n = len ( ordre ) nb = 0 if ordre [ 0 ] != 1 : # le premier n'est pas 1 nb = nb + 1 i = 0 while i < n - 1 : if ordre [ i + 1 ] - ordre [ i ] not in [ - 1 , 1 ]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre [ n - 1 ] != n : # le dernier n'est pas n nb = nb + 1 return nb Markdown L\u2019ordre des g\u00e8nes sur un chromosome est repr\u00e9sent\u00e9 par un tableau `ordre` de `n` cases d\u2019entiers distincts deux \u00e0 deux et compris entre 1 et `n` . Par exemple, `ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9]` dans le cas `n = 9` . On dit qu\u2019il y a un point de rupture dans `ordre` dans chacune des situations suivantes : - la premi\u00e8re valeur de `ordre` n\u2019est pas 1 ; - l\u2019\u00e9cart entre deux g\u00e8nes cons\u00e9cutifs n\u2019est pas \u00e9gal \u00e0 1 ; - la derni\u00e8re valeur de `ordre` n\u2019est pas n. Par exemple, si `ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9]` avec `n = 9` , on a - un point de rupture au d\u00e9but car 5 est diff\u00e9rent de 1 - un point de rupture entre 3 et 6 (l\u2019\u00e9cart est de 3) - un point de rupture entre 7 et 2 (l\u2019\u00e9cart est de 5) - un point de rupture entre 1 et 8 (l\u2019\u00e9cart est de 7) Il y a donc 4 points de rupture. Compl\u00e9ter les fonctions Python `est_un_ordre` et `nombre_points_rupture` propos\u00e9es \u00e0 la page suivante pour que : - la fonction `est_un_ordre` renvoie `True` si le tableau pass\u00e9 en param\u00e8tre repr\u00e9sente bien un ordre de g\u00e8nes de chromosome et `False` sinon ; - la fonction `nombre_points_rupture` renvoie le nombre de points de rupture d\u2019un tableau pass\u00e9 en param\u00e8tre repr\u00e9sentant l\u2019ordre de g\u00e8nes d\u2019un chromosome. ```python linenums='1' def est_un_ordre(tab): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' for i in range(1,...): if ...: return False return True def nombre_points_rupture(ordre): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' assert ... # ordre n'est pas un ordre de g\u00e8nes n = len(ordre) nb = 0 if ordre[...] != 1: # le premier n'est pas 1 nb = nb + 1 i = 0 while i < ...: if ... not in [-1, 1]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre[...] != n: # le dernier n'est pas n nb = nb + 1 return nb Exemples : \ud83d\udc0d Script Python >>> est_un_ordre ([ 1 , 6 , 2 , 8 , 3 , 7 ]) False >>> est_un_ordre ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) True >>> nombre_points_rupture ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) 4 >>> nombre_points_rupture ([ 1 , 2 , 3 , 4 , 5 ]) 0 >>> nombre_points_rupture ([ 1 , 6 , 2 , 8 , 3 , 7 , 4 , 5 ]) 7 >>> nombre_points_rupture ([ 2 , 1 , 3 , 4 ]) 2 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 18.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-19", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 19"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-191", "text": "Exercice 19.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) - 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres un tableau `tab` de nombres entiers tri\u00e9s par ordre croissant et un nombre entier `n`, et qui effectue une recherche dichotomique du nombre entier `n` dans le tableau non vide `tab`. Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, `-1` sinon. Exemples : ```python >>> recherche([2, 3, 4, 5, 6], 5) 3 >>> recherche([2, 3, 4, 6, 7], 5) -1 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 19.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-192", "text": "Exercice 19.2 \u00c9nonc\u00e9 Correction Sources Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019 ...) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res ALPHABET s\u2019il s\u2019y trouve. La fonction cesar prend en param\u00e8tre une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ord ( lettre ) - ord ( 'A' ) def cesar ( message , decalage ): resultat = '' for ... in message : if 'A' <= c and c <= 'Z' : indice = ( ... ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): return ord ( lettre ) - ord ( 'A' ) def cesar ( message , decalage ): resultat = '' for c in message : if 'A' <= c and c <= 'Z' : indice = ( position_alphabet ( c ) + decalage ) % 26 resultat = resultat + ALPHABET [ indice ] else : resultat = resultat + c return resultat Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019 ...) ne sont pas cod\u00e9s. La fonction `position_alphabet` ci-dessous prend en param\u00e8tre un caract\u00e8re `lettre` et renvoie la position de `lettre` dans la cha\u00eene de caract\u00e8res `ALPHABET` s\u2019il s\u2019y trouve. La fonction `cesar` prend en param\u00e8tre une cha\u00eene de caract\u00e8res `message` et un nombre entier `decalage` et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage `decalage` . ```python linenums='1' ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet(lettre): return ord(lettre) - ord('A') def cesar(message, decalage): resultat = '' for ... in message: if 'A' <= c and c <= 'Z': indice = ( ... ) % 26 resultat = resultat + ALPHABET[indice] else: resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 19.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-20", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 20"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-201", "text": "Exercice 20.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction ajoute_dictionnaires qui prend en param\u00e8tres deux dictionnaires d1 et d2 dont les cl\u00e9s sont des nombres et renvoie le dictionnaire d d\u00e9fini de la fa\u00e7on suivante : Les cl\u00e9s de d sont celles de d1 et celles de d2 r\u00e9unies. Si une cl\u00e9 est pr\u00e9sente dans les deux dictionnaires d1 et d2 , sa valeur associ\u00e9e dans le dictionnaire d est la somme de ses valeurs dans les dictionnaires d1 et d2 . Si une cl\u00e9 n\u2019est pr\u00e9sente que dans un des deux dictionnaires, sa valeur associ\u00e9e dans le dictionnaire d est la m\u00eame que sa valeur dans le dictionnaire o\u00f9 elle est pr\u00e9sente. Exemples : \ud83d\udc0d Script Python >>> ajoute_dictionnaires ({ 1 : 5 , 2 : 7 }, { 2 : 9 , 3 : 11 }) { 1 : 5 , 2 : 16 , 3 : 11 } >>> ajoute_dictionnaires ({}, { 2 : 9 , 3 : 11 }) { 2 : 9 , 3 : 11 } >>> ajoute_dictionnaires ({ 1 : 5 , 2 : 7 }, {}) { 1 : 5 , 2 : 7 } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def ajoute_dictionnaires ( d1 , d2 ): for cle in d2 : if cle in d1 : d1 [ cle ] += d2 [ cle ] else : d1 [ cle ] = d2 [ cle ] return d1 \ud83d\udccb Texte \u00c9crire une fonction `ajoute_dictionnaires` qui prend en param\u00e8tres deux dictionnaires `d1` et `d2` dont les cl\u00e9s sont des nombres et renvoie le dictionnaire `d` d\u00e9fini de la fa\u00e7on suivante : - Les cl\u00e9s de `d` sont celles de `d1` et celles de `d2` r\u00e9unies. - Si une cl\u00e9 est pr\u00e9sente dans les deux dictionnaires `d1` et `d2`, sa valeur associ\u00e9e dans le dictionnaire d est la somme de ses valeurs dans les dictionnaires `d1` et `d2`. - Si une cl\u00e9 n\u2019est pr\u00e9sente que dans un des deux dictionnaires, sa valeur associ\u00e9e dans le dictionnaire `d` est la m\u00eame que sa valeur dans le dictionnaire o\u00f9 elle est pr\u00e9sente. Exemples : ```python >>> ajoute_dictionnaires({1: 5, 2: 7}, {2: 9, 3: 11}) {1: 5, 2: 16, 3: 11} >>> ajoute_dictionnaires({}, {2: 9, 3: 11}) {2: 9, 3: 11} >>> ajoute_dictionnaires({1: 5, 2: 7}, {}) {1: 5, 2: 7} ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 20.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-202", "text": "Exercice 20.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une piste carr\u00e9e qui contient 4 cases par c\u00f4t\u00e9. Les cases sont num\u00e9rot\u00e9es de 0 inclus \u00e0 12 exclu comme ci-dessous : L\u2019objectif de l\u2019exercice est d\u2019impl\u00e9menter le jeu suivant : Au d\u00e9part, le joueur place son pion sur la case 0. A chaque coup, il lance un d\u00e9 \u00e9quilibr\u00e9 \u00e0 six faces et avance son pion d\u2019autant de cases que le nombre indiqu\u00e9 par le d\u00e9 (entre 1 et 6 inclus) dans le sens des aiguilles d\u2019une montre. Par exemple, s\u2019il obtient 2 au premier lancer, il pose son pion sur la case 2 puis s\u2019il obtient 6 au deuxi\u00e8me lancer, il le pose sur la case 8, puis s\u2019il obtient \u00e0 nouveau 6, il pose le pion sur la case 2. Le jeu se termine lorsque le joueur a pos\u00e9 son pion sur toutes les cases de la piste. Compl\u00e9ter la fonction nbre_coups ci-dessous de sorte qu\u2019elle renvoie le nombre de lancers al\u00e9atoires n\u00e9cessaires pour terminer le jeu. Proposer ensuite quelques tests pour en v\u00e9rifier le fonctionnement. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from random import randint def nbre_coups (): n = ... cases_vues = [ 0 ] case_en_cours = 0 nbre_cases = 12 while ... < ... : x = randint ( 1 , 6 ) case_en_cours = ( case_en_cours + ... ) % ... if ... : cases_vues . append ( case_en_cours ) n = ... return n \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from random import randint def nbre_coups (): n = 0 cases_vues = [ 0 ] case_en_cours = 0 nbre_cases = 12 while len ( cases_vues ) < nbre_cases : x = randint ( 1 , 6 ) case_en_cours = ( case_en_cours + x ) % nbre_cases if case_en_cours not in cases_vues : cases_vues . append ( case_en_cours ) n = n + 1 return n Markdown On consid\u00e8re une piste carr\u00e9e qui contient 4 cases par c\u00f4t\u00e9. Les cases sont num\u00e9rot\u00e9es de 0 inclus \u00e0 12 exclu comme ci-dessous : ![ image ]( data2023/20_carre.png ){: .center width=20%} L\u2019objectif de l\u2019exercice est d\u2019impl\u00e9menter le jeu suivant : Au d\u00e9part, le joueur place son pion sur la case 0. A chaque coup, il lance un d\u00e9 \u00e9quilibr\u00e9 \u00e0 six faces et avance son pion d\u2019autant de cases que le nombre indiqu\u00e9 par le d\u00e9 (entre 1 et 6 inclus) dans le sens des aiguilles d\u2019une montre. Par exemple, s\u2019il obtient 2 au premier lancer, il pose son pion sur la case 2 puis s\u2019il obtient 6 au deuxi\u00e8me lancer, il le pose sur la case 8, puis s\u2019il obtient \u00e0 nouveau 6, il pose le pion sur la case 2. Le jeu se termine lorsque le joueur a pos\u00e9 son pion sur **toutes les cases** de la piste. Compl\u00e9ter la fonction `nbre_coups` ci-dessous de sorte qu\u2019elle renvoie le nombre de lancers al\u00e9atoires n\u00e9cessaires pour terminer le jeu. Proposer ensuite quelques tests pour en v\u00e9rifier le fonctionnement. ```python linenums='1' from random import randint def nbre_coups(): n = ... cases_vues = [0] case_en_cours = 0 nbre_cases = 12 while ... < ...: x = randint(1, 6) case_en_cours = (case_en_cours + ...) % ... if ...: cases_vues.append(case_en_cours) n = ... return n ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 20.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-21", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 21"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-211", "text": "Exercice 21.1 \u00c9nonc\u00e9 Correction Source Markdown Le codage par diff\u00e9rence ( delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es plus petit, n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta(liste) qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : \ud83d\udc0d Script Python >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] \ud83d\udc0d Script Python 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff \ud83d\udccb Texte Le codage par diff\u00e9rence (*delta encoding* en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es plus petit, n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction `delta(liste)` qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : ```python >>> delta([1000, 800, 802, 1000, 1003]) [1000, -200, 2, 198, 3] >>> delta([42]) [42] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 21.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-212", "text": "Exercice 21.2 \u00c9nonc\u00e9 Correction Sources Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212, \u00d7, \u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[(3 \\times (8 + 7)) \u2212 (2 + 1)\\] La classe Noeud ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_infixe qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : \ud83d\udc0d Script Python >>> e = Noeud ( Noeud ( Noeud ( None , 3 , None ), '*' , Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None ))), '-' , Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None ))) >>> expression_infixe ( e ) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Noeud : ''' classe impl\u00e9mentant un noeud d'arbre binaire ''' def __init__ ( self , g , v , d ): ''' un objet Noeud poss\u00e8de 3 attributs : - gauche : le sous-arbre gauche, - valeur : la valeur de l'\u00e9tiquette, - droit : le sous-arbre droit. ''' self . gauche = g self . valeur = v self . droit = d def __str__ ( self ): ''' renvoie la repr\u00e9sentation du noeud en chaine de caract\u00e8res ''' return str ( self . valeur ) def est_une_feuille ( self ): ''' renvoie True si et seulement si le noeud est une feuille ''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Noeud : ''' classe impl\u00e9mentant un noeud d'arbre binaire ''' def __init__ ( self , g , v , d ): ''' un objet Noeud poss\u00e8de 3 attributs : - gauche : le sous-arbre gauche, - valeur : la valeur de l'\u00e9tiquette, - droit : le sous-arbre droit. ''' self . gauche = g self . valeur = v self . droit = d def __str__ ( self ): ''' renvoie la repr\u00e9sentation du noeud en chaine de caract\u00e8res ''' return str ( self . valeur ) def est_une_feuille ( self ): ''' renvoie True si et seulement si le noeud est une feuille ''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = '' if e . gauche is not None : s = '(' + s + expression_infixe ( e . gauche ) s = s + str ( e . valeur ) if e . droit is not None : s = s + expression_infixe ( e . droit ) + ')' return s Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212, \u00d7, \u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. ![ image ]( data2023/21_arbre.png ){: .center width=30%} En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : $$(3 \\times (8 + 7)) \u2212 (2 + 1)$$ La classe `Noeud` ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive `expression_infixe` qui prend en param\u00e8tre un objet de la classe `Noeud` et qui renvoie l\u2019expression arithm\u00e9tique repr\u00e9sent\u00e9e par l\u2019arbre binaire pass\u00e9 en param\u00e8tre, sous forme d\u2019une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses. R\u00e9sultat attendu avec l\u2019arbre ci-dessus : ```python >>> e = Noeud(Noeud(Noeud(None, 3, None), '*', Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))), '-', Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))) >>> expression_infixe(e) '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Noeud : ''' classe impl\u00e9mentant un noeud d'arbre binaire ''' def __init__ ( self , g , v , d ): ''' un objet Noeud poss\u00e8de 3 attributs : - gauche : le sous-arbre gauche, - valeur : la valeur de l'\u00e9tiquette, - droit : le sous-arbre droit. ''' self . gauche = g self . valeur = v self . droit = d def __str__ ( self ): ''' renvoie la repr\u00e9sentation du noeud en chaine de caract\u00e8res ''' return str ( self . valeur ) def est_une_feuille ( self ): ''' renvoie True si et seulement si le noeud est une feuille ''' return self . gauche is None and self . droit is None def expression_infixe ( e ): s = ... if e . gauche is not None : s = '(' + s + expression_infixe ( ... ) s = s + ... if ... is not None : s = s + ... + ... return s ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 21.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-22", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 22"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-221", "text": "Exercice 22.1 \u00c9nonc\u00e9 Correction Source Markdown On rappelle que : le nombre \\(a^n\\) est le nombre \\(a \\times a \\times a \\times \\dots \\times a\\) , o\u00f9 le facteur \\(a\\) appara\u00eet \\(n\\) fois, en langage Python, l\u2019instruction t[-1] permet d\u2019acc\u00e9der au dernier \u00e9l\u00e9ment du tableau t . Dans cet exercice, l\u2019op\u00e9rateur ** et la fonction pow ne sont pas autoris\u00e9s. Programmer en langage Python une fonction liste_puissances qui prend en argument un nombre entier a , un entier strictement positif n et qui renvoie la liste de ses puissances \\(\\rm{[a^1, a^2, ..., a^n]}\\) . Programmer \u00e9galement une fonction liste_puisssances_borne qui prend en argument un nombre entier a sup\u00e9rieur ou \u00e9gal \u00e0 2 et un entier borne , et qui renvoie la liste de ses puissances, \u00e0 l\u2019exclusion de \\(\\rm{a^0}\\) , strictement inf\u00e9rieures \u00e0 borne . Exemples : \ud83d\udc0d Script Python >>> liste_puissances ( 3 , 5 ) [ 3 , 9 , 27 , 81 , 243 ] >>> liste_puissances ( - 2 , 4 ) [ - 2 , 4 , - 8 , 16 ] >>> liste_puissances_borne ( 2 , 16 ) [ 2 , 4 , 8 ] >>> liste_puissances_borne ( 2 , 17 ) [ 2 , 4 , 8 , 16 ] >>> liste_puissances_borne ( 5 , 5 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def liste_puissances ( a , n ): puissances = [ a ] for i in range ( n - 1 ): puissances . append ( puissances [ - 1 ] * a ) return puissances def liste_puissances_borne ( a , borne ): lst = [] val = a while val < borne : lst . append ( val ) val = val * a return lst \ud83d\udccb Texte On rappelle que : - le nombre $a^n$ est le nombre $a \\times a \\times a \\times \\dots \\times a$, o\u00f9 le facteur $a$ appara\u00eet $n$ fois, - en langage Python, l\u2019instruction `t[-1]` permet d\u2019acc\u00e9der au dernier \u00e9l\u00e9ment du tableau `t`. Dans cet exercice, l\u2019op\u00e9rateur ```**``` et la fonction `pow` ne sont pas autoris\u00e9s. Programmer en langage Python une fonction `liste_puissances` qui prend en argument un nombre entier `a`, un entier strictement positif `n` et qui renvoie la liste de ses puissances $\\rm{[a^1, a^2, ..., a^n]}$. Programmer \u00e9galement une fonction `liste_puisssances_borne` qui prend en argument un nombre entier `a` sup\u00e9rieur ou \u00e9gal \u00e0 2 et un entier `borne`, et qui renvoie la liste de ses puissances, \u00e0 l\u2019exclusion de $\\rm{a^0}$, strictement inf\u00e9rieures \u00e0 `borne`. Exemples : ```python >>> liste_puissances(3, 5) [3, 9, 27, 81, 243] >>> liste_puissances(-2, 4) [-2, 4, -8, 16] >>> liste_puissances_borne(2, 16) [2, 4, 8] >>> liste_puissances_borne(2, 17) [2, 4, 8, 16] >>> liste_puissances_borne(5, 5) [] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 22.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-222", "text": "Exercice 22.2 \u00c9nonc\u00e9 Correction Sources Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M 1 2 3 4 5 6 7 8 9 10 11 12 13 N O P Q R S T U V W X Y Z 14 15 16 17 18 19 20 21 22 23 24 25 26 Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu\u2019un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ): # mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_concatene = \"\" code_additionne = ... for c in mot : code_concatene = code_concatene + ... code_additionne = ... code_concatene = int ( code_concatene ) if ... : mot_est_parfait = True else : mot_est_parfait = False return code_additionne , code_concatene , mot_est_parfait Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) ( 50 , 1612112 , False ) >>> est_parfait ( \"ALAIN\" ) ( 37 , 1121914 , True ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def est_parfait ( mot ): # mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_concatene = \"\" code_additionne = 0 for c in mot : code_concatene = code_concatene + str ( dico [ c ]) code_additionne = code_additionne + dico [ c ] code_concatene = int ( code_concatene ) if code_concatene % code_additionne == 0 : mot_est_parfait = True else : mot_est_parfait = False return code_additionne , code_concatene , mot_est_parfait Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : | A | B | C | D | E | F | G | H | I | J | K | L | M | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son *code alphab\u00e9tique concat\u00e9n\u00e9* , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, *son code additionn\u00e9*, qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab *parfait* \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : - Pour le mot `\"PAUL\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1612112'` , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot `\"PAUL\"` n\u2019est pas parfait. - Pour le mot `\"ALAIN\"` , le code concat\u00e9n\u00e9 est la cha\u00eene `'1121914'` , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot `\"ALAIN\"` est parfait. Compl\u00e9ter la fonction `est_parfait` ci-dessous qui prend comme argument une cha\u00eene de caract\u00e8res `mot` (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de `mot` , ainsi qu\u2019un bool\u00e9en qui indique si `mot` est parfait ou pas. ```python linenums='1' dico = {\"A\": 1, \"B\": 2, \"C\": 3, \"D\": 4, \"E\": 5, \"F\": 6, \"G\": 7, \"H\": 8, \"I\": 9, \"J\": 10, \"K\": 11, \"L\": 12, \"M\": 13, \"N\": 14, \"O\": 15, \"P\": 16, \"Q\": 17, \"R\": 18, \"S\": 19, \"T\": 20, \"U\": 21, \"V\": 22, \"W\": 23, \"X\": 24, \"Y\": 25, \"Z\": 26} def est_parfait(mot): # mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_concatene = \"\" code_additionne = ... for c in mot: code_concatene = code_concatene + ... code_additionne = ... code_concatene = int(code_concatene) if ... : mot_est_parfait = True else: mot_est_parfait = False return code_additionne, code_concatene, mot_est_parfait Exemples : \ud83d\udc0d Script Python >>> est_parfait ( \"PAUL\" ) ( 50 , 1612112 , False ) >>> est_parfait ( \"ALAIN\" ) ( 37 , 1121914 , True ) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 22.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-23", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 23"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-231", "text": "Exercice 23.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont 'nom' , 'espece' , 'age' , 'enclos' . Voici un exemple d'une telle table : \ud83d\udc0d Script Python animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] Programmer une fonction selection_enclos qui : prend en param\u00e8tres : une table table_animaux contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), un num\u00e9ro d'enclos num_enclos ; renvoie une table contenant les enregistrements de table_animaux dont l'attribut 'enclos' est num_enclos . Exemples avec la table animaux ci-dessus : \ud83d\udc0d Script Python >>> selection_enclos ( animaux , 5 ) [{ 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] >>> selection_enclos ( animaux , 2 ) [{ 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }] >>> selection_enclos ( animaux , 7 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def selection_enclos ( table_animaux , num_enclos ): table = [] for animal in table_animaux : if animal [ 'enclos' ] == num_enclos : table . append ( animal ) return table \ud83d\udccb Texte On consid\u00e8re des tables (des tableaux de dictionnaires) qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont `'nom'`, `'espece'`, `'age'`, `'enclos'`. Voici un exemple d'une telle table : ```python animaux = [ {'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}, {'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Tom', 'espece':'chat', 'age':7, 'enclos':4}, {'nom':'Belle', 'espece':'chien', 'age':6, 'enclos':3}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] ``` Programmer une fonction `selection_enclos` qui : - prend en param\u00e8tres : - une table `table_animaux` contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), - un num\u00e9ro d'enclos `num_enclos` ; - renvoie une table contenant les enregistrements de `table_animaux` dont l'attribut `'enclos'` est `num_enclos`. Exemples avec la table `animaux` ci-dessus : ```python >>> selection_enclos(animaux, 5) [{'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] >>> selection_enclos(animaux, 2) [{'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}] >>> selection_enclos(animaux, 7) [] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 23.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-232", "text": "Exercice 23.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois \u00e0 la suite, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : \ud83d\udc0d Script Python tab_a = [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] #l'intrus est 7 tab_b = [ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ] #l'intrus est 8 tab_c = [ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Par exemple, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 12, on voit les valeurs 2 et 4 qui sont diff\u00e9rentes : l\u2019intrus est donc \u00e0 gauche de l\u2019indice 12 (indice 12 compris) En revanche, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 3, on voit les valeurs 9 et 9 qui sont identiques : l\u2019intrus est donc \u00e0 droite des indices 3-4-5, donc \u00e0 partir de l\u2019indice 6. Compl\u00e9ter la fonction r\u00e9cursive trouver_intrus propos\u00e9e page suivante qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return tab [ g ] else : nombre_de_triplets = ( d - g ) // 3 indice = g + 3 * ( nombre_de_triplets // 2 ) if tab [ indice ] != tab [ indice + 1 ] : return trouver_intrus ( tab , g , indice ) else : return trouver_intrus ( tab , indice + 3 , d ) Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois \u00e0 la suite, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : ```python tab_a = [3, 3, 3, 9, 9, 9, 1, 1, 1, 7, 2, 2, 2, 4, 4, 4, 8, 8, 8, 5, 5, 5] #l'intrus est 7 tab_b = [8, 5, 5, 5, 9, 9, 9, 18, 18, 18, 3, 3, 3] #l'intrus est 8 tab_c = [5, 5, 5, 1, 1, 1, 0, 0, 0, 6, 6, 6, 3, 8, 8, 8] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme celles ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Par exemple, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 12, on voit les valeurs 2 et 4 qui sont diff\u00e9rentes : l\u2019intrus est donc \u00e0 gauche de l\u2019indice 12 (indice 12 compris) En revanche, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 3, on voit les valeurs 9 et 9 qui sont identiques : l\u2019intrus est donc \u00e0 droite des indices 3-4-5, donc \u00e0 partir de l\u2019indice 6. Compl\u00e9ter la fonction r\u00e9cursive trouver_intrus propos\u00e9e page suivante qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 23.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-24", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 24"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-241", "text": "Exercice 24.1 \u00c9nonc\u00e9 Correction Source Markdown Le nombre d\u2019occurrences d\u2019un caract\u00e8re dans une cha\u00eene de caract\u00e8re est le nombre d\u2019apparitions de ce caract\u00e8re dans la cha\u00eene. Exemples : le nombre d\u2019occurrences du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; le nombre d\u2019occurrences du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; le nombre d\u2019occurrences du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; le nombre d\u2019occurrences du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} L\u2019ordre des clefs n\u2019a pas d\u2019importance. \u00c9crire une fonction nbr_occurrences prenant comme param\u00e8tre une cha\u00eene de caract\u00e8res chaine et renvoyant le dictionnaire des nombres d\u2019occurrences des caract\u00e8res de cette cha\u00eene. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def nbr_occurrences ( chaine ): nb_occ = {} for caractere in chaine : if caractere in nb_occ : nb_occ [ caractere ] += 1 else : nb_occ [ caractere ] = 1 return nb_occ \ud83d\udccb Texte Le nombre d\u2019occurrences d\u2019un caract\u00e8re dans une cha\u00eene de caract\u00e8re est le nombre d\u2019apparitions de ce caract\u00e8re dans la cha\u00eene. Exemples : - le nombre d\u2019occurrences du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; - le nombre d\u2019occurrences du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - le nombre d\u2019occurrences du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; - le nombre d\u2019occurrences du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs l\u2019occurrence de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : `{'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1}` *L\u2019ordre des clefs n\u2019a pas d\u2019importance.* \u00c9crire une fonction `nbr_occurrences` prenant comme param\u00e8tre une cha\u00eene de caract\u00e8res `chaine` et renvoyant le dictionnaire des nombres d\u2019occurrences des caract\u00e8res de cette cha\u00eene. R\u00e9digez votre code sur Basthon", "title": "Exercice 24.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-242", "text": "Exercice 24.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction fusion prend deux listes lst1 , lst2 d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e lst12 qu\u2019elle renvoie. Le code Python de la fonction fusion est \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( lst1 , lst2 ): n1 = len ( lst1 ) n2 = len ( lst2 ) lst12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if lst1 [ i1 ] < lst2 [ i2 ]: lst12 [ i ] = ... i1 = ... else : lst12 [ i ] = lst2 [ i2 ] i2 = ... i += 1 while i1 < n1 : lst12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : lst12 [ i ] = ... i2 = i2 + 1 i = ... return lst12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( lst1 , lst2 ): n1 = len ( lst1 ) n2 = len ( lst2 ) lst12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if lst1 [ i1 ] < lst2 [ i2 ]: lst12 [ i ] = lst1 [ i1 ] i1 = i1 + 1 else : lst12 [ i ] = lst2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : lst12 [ i ] = lst1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : lst12 [ i ] = lst2 [ i2 ] i2 = i2 + 1 i = i + 1 return lst12 Markdown La fonction `fusion` prend deux listes `lst1` , `lst2` d\u2019entiers tri\u00e9es par ordre croissant et les fusionne en une liste tri\u00e9e `lst12` qu\u2019elle renvoie. Le code Python de la fonction `fusion` est ```python linenums='1' def fusion(lst1,lst2): n1 = len(lst1) n2 = len(lst2) lst12 = [0] * (n1 + n2) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if lst1[i1] < lst2[i2]: lst12[i] = ... i1 = ... else: lst12[i] = lst2[i2] i2 = ... i += 1 while i1 < n1: lst12[i] = ... i1 = i1 + 1 i = ... while i2 < n2: lst12[i] = ... i2 = i2 + 1 i = ... return lst12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 24.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-25", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 25"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-251", "text": "Exercice 25.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction enumere qui prend en param\u00e8tre une liste L et renvoie un dictionnaire d dont les cl\u00e9s sont les \u00e9l\u00e9ments de L avec pour valeur associ\u00e9e la liste des indices de l\u2019\u00e9l\u00e9ment dans la liste L . Exemple : \ud83d\udc0d Script Python >>> enumere ([ 1 , 1 , 2 , 3 , 2 , 1 ]) { 1 : [ 0 , 1 , 5 ], 2 : [ 2 , 4 ], 3 : [ 3 ]} \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def enumere ( L ): d = {} for i in range ( len ( L )): if L [ i ] in d : d [ L [ i ]] . append ( i ) else : d [ L [ i ]] = [ i ] return d \ud83d\udccb Texte \u00c9crire une fonction `enumere` qui prend en param\u00e8tre une liste `L` et renvoie un dictionnaire `d` dont les cl\u00e9s sont les \u00e9l\u00e9ments de `L` avec pour valeur associ\u00e9e la liste des indices de l\u2019\u00e9l\u00e9ment dans la liste `L`. Exemple : ```python >>> enumere([1, 1, 2, 3, 2, 1]) {1: [0, 1, 5], 2: [2, 4], 3: [3]} ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 25.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-252", "text": "Exercice 25.2 \u00c9nonc\u00e9 Correction Sources Markdown Un arbre binaire est impl\u00e9ment\u00e9 par la classe Arbre donn\u00e9e ci-dessous. Les attributs fg et fd prennent pour valeurs des instances de la classe Arbre ou None . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 class Arbre : def __init__ ( self , etiquette ): self . v = etiquette self . fg = None self . fd = None def parcours ( arbre , liste ): if arbre != None : parcours ( arbre . fg , liste ) liste . append ( arbre . v ) parcours ( arbre . fd , liste ) return liste La fonction r\u00e9cursive parcours renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre impl\u00e9ment\u00e9 par l\u2019instance arbre dans l\u2019ordre du parcours en profondeur infixe \u00e0 partir d\u2019une liste vide pass\u00e9e en argument. Compl\u00e9ter le code de la fonction insere qui ins\u00e8re un n\u0153ud d\u2019\u00e9tiquette cle en feuille de l\u2019arbre impl\u00e9ment\u00e9 par l\u2019instance arbre selon la sp\u00e9cification indiqu\u00e9e et de fa\u00e7on que l\u2019arbre ainsi compl\u00e9t\u00e9 soit encore un arbre binaire de recherche. Tester ensuite ce code en utilisant la fonction parcours et en ins\u00e9rant successivement des n\u0153uds d\u2019\u00e9tiquette 1, 4, 6 et 8 dans l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci- dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( arbre , cle ): \"\"\" arbre est une instance de la classe Arbre qui impl\u00e9mente un arbre binaire de recherche. \"\"\" if ... : if ... : insere ( arbre . fg , cle ) else : arbre . fg = Arbre ( cle ) else : if ... : insere ( arbre . fd , cle ) else : arbre . fd = Arbre ( cle ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( arbre , cle ): \"\"\" arbre est une instance de la classe Arbre qui impl\u00e9mente un arbre binaire de recherche. \"\"\" if cle < arbre . v : if arbre . fg is not None : insere ( arbre . fg , cle ) else : arbre . fg = Arbre ( cle ) else : if arbre . fd is not None : insere ( arbre . fd , cle ) else : arbre . fd = Arbre ( cle ) Tests : \ud83d\udc0d Script Python >>> a = Arbre ( 5 ) >>> insere ( a , 2 ) >>> insere ( a , 7 ) >>> insere ( a , 3 ) >>> parcours ( a , []) [ 2 , 3 , 5 , 7 ] >>> insere ( a , 1 ) >>> insere ( a , 4 ) >>> insere ( a , 6 ) >>> insere ( a , 8 ) >>> parcours ( a , []) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] Markdown Un arbre binaire est impl\u00e9ment\u00e9 par la classe `Arbre` donn\u00e9e ci-dessous. Les attributs `fg` et `fd` prennent pour valeurs des instances de la classe `Arbre` ou `None` . ```python linenums='1' class Arbre: def __init__ (self, etiquette): self.v = etiquette self.fg = None self.fd = None def parcours(arbre, liste): if arbre != None: parcours(arbre.fg, liste) liste.append(arbre.v) parcours(arbre.fd, liste) return liste La fonction r\u00e9cursive parcours renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre impl\u00e9ment\u00e9 par l\u2019instance arbre dans l\u2019ordre du parcours en profondeur infixe \u00e0 partir d\u2019une liste vide pass\u00e9e en argument. Compl\u00e9ter le code de la fonction insere qui ins\u00e8re un n\u0153ud d\u2019\u00e9tiquette cle en feuille de l\u2019arbre impl\u00e9ment\u00e9 par l\u2019instance arbre selon la sp\u00e9cification indiqu\u00e9e et de fa\u00e7on que l\u2019arbre ainsi compl\u00e9t\u00e9 soit encore un arbre binaire de recherche. Tester ensuite ce code en utilisant la fonction parcours et en ins\u00e9rant successivement des n\u0153uds d\u2019\u00e9tiquette 1, 4, 6 et 8 dans l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci- dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( arbre , cle ): \"\"\" arbre est une instance de la classe Arbre qui impl\u00e9mente un arbre binaire de recherche. \"\"\" if ... : if ... : insere ( arbre . fg , cle ) else : arbre . fg = Arbre ( cle ) else : if ... : insere ( arbre . fd , cle ) else : arbre . fd = Arbre ( cle ) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 25.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-26", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 26"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-261", "text": "Exercice 26.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def multiplication ( n1 , n2 ): # on se ram\u00e8ne d'abord au cas o\u00f9 n1 et n2 sont tous les deux positifs : if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. ```python >>> multiplication(3, 5) 15 >>> multiplication(-4, -8) 32 >>> multiplication(-2, 6) -12 >>> multiplication(-2, 0) 0 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 26.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-262", "text": "Exercice 26.2 \u00c9nonc\u00e9 Correction Sources Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Markdown Recopier et compl\u00e9ter sous Python la fonction suivante en respectant la sp\u00e9cification. On ne recopiera pas les commentaires. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 26.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-27", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 27"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-271", "text": "Exercice 27.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_min qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> recherche_min ([ 5 ]) 0 >>> recherche_min ([ 2 , 4 , 1 ]) 2 >>> recherche_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \ud83d\udccb Texte \u00c9crire une fonction `recherche_min` qui prend en param\u00e8tre un tableau de nombres non tri\u00e9 `tab`, et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> recherche_min([5]) 0 >>> recherche_min([2, 4, 1]) 2 >>> recherche_min([5, 3, 2, 2, 4]) 2 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 27.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-272", "text": "Exercice 27.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): gauche = 0 droite = ... while gauche < droite : if tab [ gauche ] == 0 : gauche = ... else : tab [ gauche ], tab [ droite ] = ... droite = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Description d\u2019\u00e9tapes effectu\u00e9es par la fonction separe sur le tableau ci-dessous : tab = [1, 0, 1, 0, 1, 0, 1, 0] Etape 1 : on regarde la premi\u00e8re case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec la derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus la derni\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 2 : on regarde \u00e0 nouveau la premi\u00e8re case, qui contient maintenant un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la premi\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 3 : on regarde la seconde case, qui contient un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la seconde case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 4 : on regarde la troisi\u00e8me case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec l\u2019avant-derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus l\u2019avant-derni\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Et ainsi de suite... tab = [0, 0, 0, 0, 1, 1, 1, 1] Compl\u00e9ter la fonction separe pr\u00e9sent\u00e9e \u00e0 la page pr\u00e9c\u00e9dente \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def separe ( tab ): gauche = 0 droite = len ( tab ) - 1 while gauche < droite : if tab [ gauche ] == 0 : gauche = gauche + 1 else : tab [ gauche ], tab [ droite ] = tab [ droite ], tab [ gauche ] droite = droite - 1 return tab Markdown On consid\u00e8re la fonction `separe` ci-dessous qui prend en argument un tableau `tab` dont les \u00e9l\u00e9ments sont des `0` et des `1` et qui s\u00e9pare les `0` des `1` en pla\u00e7ant les `0` en d\u00e9but de tableau et les `1` \u00e0 la suite. ```python linenums='1' def separe(tab): gauche = 0 droite = ... while gauche < droite : if tab[gauche] == 0 : gauche = ... else : tab[gauche], tab[droite] = ... droite = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Description d\u2019\u00e9tapes effectu\u00e9es par la fonction separe sur le tableau ci-dessous : tab = [1, 0, 1, 0, 1, 0, 1, 0] Etape 1 : on regarde la premi\u00e8re case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec la derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus la derni\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 2 : on regarde \u00e0 nouveau la premi\u00e8re case, qui contient maintenant un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la premi\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 3 : on regarde la seconde case, qui contient un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la seconde case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Etape 4 : on regarde la troisi\u00e8me case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec l\u2019avant-derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus l\u2019avant-derni\u00e8re case en compte. tab = [0, 0, 1, 0, 1, 0, 1, 1] Et ainsi de suite... tab = [0, 0, 0, 0, 1, 1, 1, 1] Compl\u00e9ter la fonction separe pr\u00e9sent\u00e9e \u00e0 la page pr\u00e9c\u00e9dente ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 27.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-28", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 28"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-281", "text": "Exercice 28.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. \ud83d\udc0d Script Python def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne ([ 1 ]) == 1 assert moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]) == 4 assert moyenne ([ 1 , 2 ]) == 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def moyenne ( tab ): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction qui prend en param\u00e8tre un tableau d'entiers non vide et qui renvoie la moyenne de ces entiers. La fonction est sp\u00e9cifi\u00e9e ci-apr\u00e8s et doit passer les assertions fournies. ```python def moyenne (tab): ''' moyenne(list) -> float Entr\u00e9e : un tableau non vide d'entiers Sortie : nombre de type float Correspondant \u00e0 la moyenne des valeurs pr\u00e9sentes dans le tableau ''' assert moyenne([1]) == 1 assert moyenne([1, 2, 3, 4, 5, 6, 7]) == 4 assert moyenne([1, 2]) == 1.5 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 28.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-282", "text": "Exercice 28.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide et il est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient False en renvoyant False, 1 , False, 2 et False, 3 . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ... : return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ... : return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def dichotomie ( tab , x ): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if tab == []: return False , 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if ( x < tab [ 0 ]) or ( x > tab [ - 1 ]): return False , 2 debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False , 3 Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. L'algorithme traite le cas du tableau vide et il est \u00e9crit pour que la recherche dichotomique ne se fasse que dans le cas o\u00f9 la valeur est comprise entre les valeurs extr\u00eames du tableau. On distingue les trois cas qui renvoient `False` en renvoyant `False, 1` , `False, 2` et `False, 3` . Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" # cas du tableau vide if ...: return False, 1 # cas o\u00f9 x n'est pas compris entre les valeurs extr\u00eames if (x < tab[0]) or ...: return False, 2 debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) ( False , 3 ) >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) ( False , 2 ) >>> dichotomie ([], 28 ) ( False , 1 ) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 28.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-29", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 29"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-291", "text": "Exercice 29.1 \u00c9nonc\u00e9 Correction Source Markdown Un arbre binaire est impl\u00e9ment\u00e9 par la classe Arbre donn\u00e9e ci-dessous. Les attributs fg et fd prennent pour valeurs des instances de la classe Arbre ou None . \ud83d\udc0d Script Python class Arbre : def __init__ ( self , etiquette ): self . v = etiquette self . fg = None self . fd = None L\u2019arbre ci-dessus sera donc impl\u00e9ment\u00e9 de la mani\u00e8re suivante : \ud83d\udc0d Script Python a = Arbre ( 1 ) a . fg = Arbre ( 4 ) a . fd = Arbre ( 0 ) a . fd . fd = Arbre ( 7 ) \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tre une instance a de la classe Arbre et qui renvoie la taille de l\u2019arbre que cette instance impl\u00e9mente. \u00c9crire de m\u00eame une fonction r\u00e9cursive hauteur prenant en param\u00e8tre une instance a de la classe Arbre et qui renvoie la hauteur de l\u2019arbre que cette instance impl\u00e9mente. Si un arbre a un seul n\u0153ud, sa taille et sa hauteur sont \u00e9gales \u00e0 1. S\u2019il est vide, sa taille et sa hauteur sont \u00e9gales \u00e0 0. Tester les deux fonctions sur l\u2019arbre repr\u00e9sent\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def taille ( a ): if a is None : return 0 else : return 1 + taille ( a . fg ) + taille ( a . fd ) def hauteur ( a ): if a is None : return 0 else : return 1 + max ( hauteur ( a . fg ), hauteur ( a . fd )) Tests : \ud83d\udc0d Script Python a = Arbre ( 0 ) a . fg = Arbre ( 1 ) a . fd = Arbre ( 2 ) a . fg . fg = Arbre ( 3 ) a . fd . fg = Arbre ( 4 ) a . fd . fd = Arbre ( 5 ) a . fd . fg . fd = Arbre ( 6 ) \ud83d\udc0d Script Python >>> taille ( a ) 7 >>> hauteur ( a ) 4 \ud83d\udccb Texte Un arbre binaire est impl\u00e9ment\u00e9 par la classe `Arbre` donn\u00e9e ci-dessous. Les attributs `fg` et `fd` prennent pour valeurs des instances de la classe `Arbre` ou `None`. ```python class Arbre: def __init__(self, etiquette): self.v = etiquette self.fg = None self.fd = None ``` ![image](data2023/29_arbre1.png){: .center} L\u2019arbre ci-dessus sera donc impl\u00e9ment\u00e9 de la mani\u00e8re suivante : ```python a = Arbre(1) a.fg = Arbre(4) a.fd = Arbre(0) a.fd.fd = Arbre(7) ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tre une instance `a` de la classe `Arbre` et qui renvoie la taille de l\u2019arbre que cette instance impl\u00e9mente. \u00c9crire de m\u00eame une fonction r\u00e9cursive `hauteur` prenant en param\u00e8tre une instance `a` de la classe `Arbre` et qui renvoie la hauteur de l\u2019arbre que cette instance impl\u00e9mente. Si un arbre a un seul n\u0153ud, sa taille et sa hauteur sont \u00e9gales \u00e0 1. S\u2019il est vide, sa taille et sa hauteur sont \u00e9gales \u00e0 0. Tester les deux fonctions sur l\u2019arbre repr\u00e9sent\u00e9 ci-dessous : ![image](data2023/29_arbre2.png){: .center} R\u00e9digez votre code sur Basthon", "title": "Exercice 29.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-292", "text": "Exercice 29.2 \u00c9nonc\u00e9 Correction Sources Markdown La m\u00e9thode insert de la classe list permet d\u2019ins\u00e9rer un \u00e9l\u00e9ment dans une liste \u00e0 un indice donn\u00e9. Le but de cet exercice est, sans utiliser cette m\u00e9thode , d\u2019\u00e9crire une fonction ajoute r\u00e9alisant cette insertion en produisant une nouvelle liste. Cette fonction ajoute prend en param\u00e8tres trois variables indice , element et liste et renvoie une liste L dans laquelle les \u00e9l\u00e9ments sont ceux de la liste liste avec, en plus, l\u2019\u00e9l\u00e9ment element \u00e0 l\u2019indice indice . On consid\u00e8re que les variables indice et element sont des entiers positifs et que les \u00e9l\u00e9ments de liste sont \u00e9galement des entiers positifs. Les \u00e9l\u00e9ments de la liste liste , dont les indices sont sup\u00e9rieurs ou \u00e9gaux \u00e0 indice apparaissent d\u00e9cal\u00e9s vers la droite dans la liste L . Si indice est sup\u00e9rieur ou \u00e9gal au nombre d\u2019\u00e9l\u00e9ments de la liste liste , l\u2019\u00e9l\u00e9ment element est ajout\u00e9 dans L apr\u00e8s tous les \u00e9l\u00e9ments de la liste liste . Exemple : \ud83d\udc0d Script Python >>> ajoute ( 1 , 4 , [ 7 , 8 , 9 ]) [ 7 , 4 , 8 , 9 ] >>> ajoute ( 3 , 4 , [ 7 , 8 , 9 ]) [ 7 , 8 , 9 , 4 ] >>> ajoute ( 4 , 4 , [ 7 , 8 , 9 ]) [ 7 , 8 , 9 , 4 ] Compl\u00e9ter et tester le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def ajoute ( indice , element , liste ): nbre_elts = len ( liste ) L = [ 0 for i in range ( nbre_elts + 1 )] if ... : for i in range ( indice ): L [ i ] = ... L [ ... ] = ... for i in range ( indice + 1 , nbre_elts + 1 ): L [ i ] = ... else : for i in range ( nbre_elts ): L [ i ] = ... L [ ... ] = ... return L \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def ajoute ( indice , element , liste ): nbre_elts = len ( liste ) L = [ 0 for i in range ( nbre_elts + 1 )] if indice < nbre_elts : for i in range ( indice ): L [ i ] = liste [ i ] L [ indice ] = element for i in range ( indice + 1 , nbre_elts + 1 ): L [ i ] = liste [ i - 1 ] else : for i in range ( nbre_elts ): L [ i ] = liste [ i ] L [ nbre_elts ] = element return L Markdown La m\u00e9thode `insert` de la classe `list` permet d\u2019ins\u00e9rer un \u00e9l\u00e9ment dans une liste \u00e0 un `indice` donn\u00e9. Le but de cet exercice est, *sans utiliser cette m\u00e9thode* , d\u2019\u00e9crire une fonction `ajoute` r\u00e9alisant cette insertion en produisant une nouvelle liste. Cette fonction `ajoute` prend en param\u00e8tres trois variables `indice` , `element` et `liste` et renvoie une liste `L` dans laquelle les \u00e9l\u00e9ments sont ceux de la liste `liste` avec, en plus, l\u2019\u00e9l\u00e9ment `element` \u00e0 l\u2019indice `indice` . On consid\u00e8re que les variables `indice` et `element` sont des entiers positifs et que les \u00e9l\u00e9ments de `liste` sont \u00e9galement des entiers positifs. Les \u00e9l\u00e9ments de la liste `liste` , dont les indices sont sup\u00e9rieurs ou \u00e9gaux \u00e0 `indice` apparaissent d\u00e9cal\u00e9s vers la droite dans la liste `L` . Si `indice` est sup\u00e9rieur ou \u00e9gal au nombre d\u2019\u00e9l\u00e9ments de la liste `liste` , l\u2019\u00e9l\u00e9ment element est ajout\u00e9 dans `L` apr\u00e8s tous les \u00e9l\u00e9ments de la liste `liste` . Exemple : ```python >>> ajoute(1, 4, [7, 8, 9]) [7, 4, 8, 9] >>> ajoute(3, 4, [7, 8, 9]) [7, 8, 9, 4] >>> ajoute(4, 4, [7, 8, 9]) [7, 8, 9, 4] Compl\u00e9ter et tester le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def ajoute ( indice , element , liste ): nbre_elts = len ( liste ) L = [ 0 for i in range ( nbre_elts + 1 )] if ... : for i in range ( indice ): L [ i ] = ... L [ ... ] = ... for i in range ( indice + 1 , nbre_elts + 1 ): L [ i ] = ... else : for i in range ( nbre_elts ): L [ i ] = ... L [ ... ] = ... return L ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 29.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-30", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 30"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-301", "text": "Exercice 30.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> moyenne([1.0]) 1.0 >>> moyenne([1.0, 2.0, 4.0]) 2.3333333333333335 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 30.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-302", "text": "Exercice 30.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction binaire ci-dessous qui prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. L\u2019algorithme utilise la m\u00e9thode des divisions euclidiennes successives comme l\u2019illustre l\u2019exemple ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter le code de la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 83 ) '1010011' >>> binaire ( 127 ) '1111111' >>> binaire ( 0 ) '0' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown On consid\u00e8re la fonction `binaire` ci-dessous qui prend en param\u00e8tre un entier positif `a` en \u00e9criture d\u00e9cimale et qui renvoie son \u00e9criture binaire sous la forme d'une chaine de caract\u00e8res. L\u2019algorithme utilise la m\u00e9thode des divisions euclidiennes successives comme l\u2019illustre l\u2019exemple ci-apr\u00e8s. ![ image ]( data2023/30_divisions.png ){: .center} ```python linenums='1' def binaire(a): bin_a = ... a = a // 2 while a ... : bin_a = ... + bin_a a = ... return bin_a Compl\u00e9ter le code de la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 83 ) '1010011' >>> binaire ( 127 ) '1111111' >>> binaire ( 0 ) '0' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 30.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-31", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 31"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-311", "text": "Exercice 31.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction Python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et une liste tab et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 , [ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' , [ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 , [ 1 , '!' , 7 , 21 , 36 , 44 ]) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \ud83d\udccb Texte \u00c9crire une fonction Python appel\u00e9e `nb_repetitions` qui prend en param\u00e8tres un \u00e9l\u00e9ment `elt` et une liste `tab` et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans la liste. Exemples : ```python >>> nb_repetitions(5, [2, 5, 3, 5, 6, 9, 5]) 3 >>> nb_repetitions('A', ['B', 'A', 'B', 'A', 'R']) 2 >>> nb_repetitions(12, [1, '!', 7, 21, 36, 44]) 0 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 31.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-312", "text": "Exercice 31.2 \u00c9nonc\u00e9 Correction Sources Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( ... ) a = a // 2 while a ... : bin_a = ... ( a % 2 ) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def binaire ( a ): bin_a = str ( a % 2 ) a = a // 2 while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : ![ image ]( data2023/31_divisions.png ){: .center} Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : ```python linenums='1' def binaire(a): bin_a = str(...) a = a // 2 while a ... : bin_a = ...(a%2) + ... a = ... return bin_a Compl\u00e9ter la fonction binaire . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 31.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-32", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 32"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-321", "text": "Exercice 32.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction min_et_max qui prend en param\u00e8tre un tableau de nombres tab non vide, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s min et max . Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. L\u2019utilisation des fonctions natives min , max et sorted , ainsi que la m\u00e9thode sort n\u2019est pas autoris\u00e9e. Exemples : \ud83d\udc0d Script Python >>> min_et_max ([ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ]) { 'min' : - 2 , 'max' : 9 } >>> min_et_max ([ 0 , 1 , 2 , 3 ]) { 'min' : 0 , 'max' : 3 } >>> min_et_max ([ 3 ]) { 'min' : 3 , 'max' : 3 } >>> min_et_max ([ 1 , 3 , 2 , 1 , 3 ]) { 'min' : 1 , 'max' : 3 } >>> min_et_max ([ - 1 , - 1 , - 1 , - 1 , - 1 ]) { 'min' : - 1 , 'max' : - 1 } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def min_et_max ( tab ): d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \ud83d\udccb Texte \u00c9crire une fonction `min_et_max` qui prend en param\u00e8tre un tableau de nombres `tab` non vide, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s `min` et `max`. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. L\u2019utilisation des fonctions natives `min`, `max` et `sorted`, ainsi que la m\u00e9thode `sort` n\u2019est pas autoris\u00e9e. Exemples : ```python >>> min_et_max([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) {'min': -2, 'max': 9} >>> min_et_max([0, 1, 2, 3]) {'min': 0, 'max': 3} >>> min_et_max([3]) {'min': 3, 'max': 3} >>> min_et_max([1, 3, 2, 1, 3]) {'min': 1, 'max': 3} >>> min_et_max([-1, -1, -1, -1, -1]) {'min': -1, 'max': -1} ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 32.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-322", "text": "Exercice 32.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019une classe Carte permettant de cr\u00e9er des objets mod\u00e9lisant des cartes \u00e0 jouer. Compl\u00e9ter la classe Paquet_de_cartes suivante en respectant les sp\u00e9cifications donn\u00e9es dans les cha\u00eenes de documentation. Ajouter une assertion dans la m\u00e9thode get_carte afin de v\u00e9rifier que le param\u00e8tre pos est correct. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Carte : def __init__ ( self , c , v ): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def get_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def get_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" # A compl\u00e9ter def get_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" # A compl\u00e9ter Exemple : \ud83d\udc0d Script Python Exemple : >>> jeu = Paquet_de_cartes () >>> carte1 = jeu . get_carte ( 20 ) >>> print ( carte1 . get_valeur () + \" de \" + carte1 . get_couleur ()) 8 de coeur >>> carte2 = jeu . get_carte ( 0 ) >>> print ( carte2 . get_valeur () + \" de \" + carte2 . get_couleur ()) As de pique >>> carte3 = jeu . get_carte ( 52 ) AssertionError : param\u00e8tre pos invalide \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Carte : def __init__ ( self , c , v ): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def get_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def get_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" self . contenu = [ Carte ( c , v ) for c in range ( 1 , 5 ) for v in range ( 1 , 14 )] def get_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" assert 0 <= pos <= 51 , 'param\u00e8tre pos invalide' return self . contenu [ pos ] Markdown On dispose d\u2019une classe `Carte` permettant de cr\u00e9er des objets mod\u00e9lisant des cartes \u00e0 jouer. Compl\u00e9ter la classe `Paquet_de_cartes` suivante en respectant les sp\u00e9cifications donn\u00e9es dans les cha\u00eenes de documentation. Ajouter une assertion dans la m\u00e9thode `get_carte` afin de v\u00e9rifier que le param\u00e8tre `pos` est correct. ```python linenums='1' class Carte: def __init__ (self, c, v): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self.couleur = c self.valeur = v def get_valeur(self): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = ['As','2', '3', '4', '5', '6', '7', '8', '9', '10', 'Valet', 'Dame', 'Roi'] return valeurs[self.valeur - 1] def get_couleur(self): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = ['pique', 'coeur', 'carreau', 'tr\u00e8fle'] return couleurs[self.couleur - 1] class Paquet_de_cartes: def __init__ (self): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" # A compl\u00e9ter def get_carte(self, pos): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" # A compl\u00e9ter Exemple : \ud83d\udc0d Script Python Exemple : >>> jeu = Paquet_de_cartes () >>> carte1 = jeu . get_carte ( 20 ) >>> print ( carte1 . get_valeur () + \" de \" + carte1 . get_couleur ()) 8 de coeur >>> carte2 = jeu . get_carte ( 0 ) >>> print ( carte2 . get_valeur () + \" de \" + carte2 . get_couleur ()) As de pique >>> carte3 = jeu . get_carte ( 52 ) AssertionError : param\u00e8tre pos invalide ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 32.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-33", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 33"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-331", "text": "Exercice 33.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153uds. On observe que, par exemple, arbre[lettre][0] , respectivement arbre[lettre][1] , permet d\u2019atteindre la cl\u00e9 du sous-arbre gauche, respectivement droit, de l\u2019arbre arbre de sommet lettre . Exemple : \ud83d\udc0d Script Python >>> taille ( a , \u2019 F \u2019 ) 9 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): fils_gauche = arbre [ lettre ][ 0 ] fils_droit = arbre [ lettre ][ 1 ] if fils_gauche != '' and fils_droit != '' : return 1 + taille ( arbre , fils_gauche ) + taille ( arbre , fils_droit ) if fils_gauche != '' and fils_droit == '' : return 1 + taille ( arbre , fils_gauche ) if fils_gauche == '' and fils_droit != '' : return 1 + taille ( arbre , fils_droit ) else : return 1 ou plus simplement : \ud83d\udc0d Script Python 1 2 3 4 def taille ( arbre , lettre ): if lettre == '' : return 0 return 1 + taille ( arbre , arbre [ lettre ][ 0 ]) + taille ( arbre , arbre [ lettre ][ 1 ]) \ud83d\udccb Texte Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. Par exemple, l\u2019arbre ![image](data2023/33_arbre.png){: .center} est stock\u00e9 dans ```python a = {'F':['B','G'], 'B':['A','D'], 'A':['',''], 'D':['C','E'], \\ 'C':['',''], 'E':['',''], 'G':['','I'], 'I':['','H'], \\ 'H':['','']} ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tres un arbre binaire `arbre` sous la forme d\u2019un dictionnaire et un caract\u00e8re `lettre` qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153uds. On observe que, par exemple, `arbre[lettre][0]`, respectivement `arbre[lettre][1]`, permet d\u2019atteindre la cl\u00e9 du sous-arbre gauche, respectivement droit, de l\u2019arbre `arbre` de sommet `lettre`. Exemple : ```python >>> taille(a, \u2019F\u2019) 9 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 33.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-332", "text": "Exercice 33.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt le sous- tableau des \u00e9l\u00e9ments non rang\u00e9s et on place le plus petit \u00e9l\u00e9ment en premi\u00e8re position de ce sous-tableau. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus petit \u00e9l\u00e9ment avec le premier. Le tableau devient t = [6, 55, 21, 18, 12, 41, 25] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le premier, on permute le plus petit \u00e9l\u00e9ment trouv\u00e9 avec le second. Le tableau devient : t = [6, 12, 21, 18, 55, 41, 25] Et ainsi de suite. La code de la fonction tri_selection qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): N = len ( tab ) for k in range ( ... ): imin = ... for i in range ( ... , N ): if tab [ i ] < ... : imin = i ... , tab [ imin ] = tab [ imin ] , ... Compl\u00e9ter le code de cette fonction de fa\u00e7on \u00e0 obtenir : \ud83d\udc0d Script Python >>> liste = [ 41 , 55 , 21 , 18 , 12 , 6 , 25 ] >>> tri_selection ( liste ) >>> liste [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et de b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): N = len ( tab ) for k in range ( N ): imin = k for i in range ( k + 1 , N ): if tab [ i ] < tab [ imin ] : imin = i tab [ k ] , tab [ imin ] = tab [ imin ] , tab [ k ] Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt le sous- tableau des \u00e9l\u00e9ments non rang\u00e9s et on place le plus petit \u00e9l\u00e9ment en premi\u00e8re position de ce sous-tableau. Exemple avec le tableau : ```t = [41, 55, 21, 18, 12, 6, 25]``` - \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus petit \u00e9l\u00e9ment avec le premier. Le tableau devient `t = [6, 55, 21, 18, 12, 41, 25]` - \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le premier, on permute le plus petit \u00e9l\u00e9ment trouv\u00e9 avec le second. Le tableau devient : ```t = [6, 12, 21, 18, 55, 41, 25]``` Et ainsi de suite. La code de la fonction `tri_selection` qui impl\u00e9mente cet algorithme est donn\u00e9 ci- dessous. ```python linenums='1' def tri_selection(tab): N = len(tab) for k in range(...): imin = ... for i in range(... , N): if tab[i] < ... : imin = i ... , tab[imin] = tab[imin] , ... Compl\u00e9ter le code de cette fonction de fa\u00e7on \u00e0 obtenir : \ud83d\udc0d Script Python >>> liste = [ 41 , 55 , 21 , 18 , 12 , 6 , 25 ] >>> tri_selection ( liste ) >>> liste [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] On rappelle que l'instruction a, b = b, a \u00e9change les contenus de a et de b . ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 33.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-34", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 34"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-341", "text": "Exercice 34.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (de type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide. Proposer une fa\u00e7on de traiter le cas o\u00f9 le tableau pass\u00e9 en param\u00e8tre est vide. Dans cet exercice, on s\u2019interdira d\u2019utiliser la fonction Python sum . Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) # Comportement diff\u00e9rent suivant le traitement propos\u00e9. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'Le tableau donn\u00e9 est vide' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte Programmer la fonction ```moyenne``` prenant en param\u00e8tre un tableau d'entiers ```tab``` (de type `list`) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide. Proposer une fa\u00e7on de traiter le cas o\u00f9 le tableau pass\u00e9 en param\u00e8tre est vide. Dans cet exercice, on s\u2019interdira d\u2019utiliser la fonction Python `sum`. Exemples : ```python >>> moyenne([5,3,8]) 5.333333333333333 >>> moyenne([1,2,3,4,5,6,7,8,9,10]) 5.5 >>> moyenne([]) # Comportement diff\u00e9rent suivant le traitement propos\u00e9. ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 34.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-342", "text": "Exercice 34.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau d'entiers tab (de type list ) dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tri ( tab ): # i est le premier indice de la zone non tri\u00e9e, # j est le dernier indice de cette zone non tri\u00e9e. # Au d\u00e9but, la zone non tri\u00e9e est le tableau complet. i = ... j = ... while i != j : if tab [ i ] == 0 : i = ... else : valeur = tab [ j ] tab [ j ] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tri ( tab ): # i est le premier indice de la zone non tri\u00e9e, # j est le dernier indice de cette zone non tri\u00e9e. # Au d\u00e9but, la zone non tri\u00e9e est le tableau complet. i = 0 j = len ( tab ) - 1 while i != j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 return tab Markdown On consid\u00e8re un tableau d'entiers `tab` (de type `list` ) dont les \u00e9l\u00e9ments sont des `0` ou des `1` ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des `0` , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des `1` . <table> <tr> <td>Zone de 0</td><td>Zone non tri\u00e9e</td><td>Zone de 1</td> </tr> </table> Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : - si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; - si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Recopier sous Python en la compl\u00e9tant la fonction `tri` suivante : ```python linenums='1' def tri(tab): # i est le premier indice de la zone non tri\u00e9e, # j est le dernier indice de cette zone non tri\u00e9e. # Au d\u00e9but, la zone non tri\u00e9e est le tableau complet. i = ... j = ... while i != j: if tab[i]== 0: i = ... else: valeur = tab[j] tab[j] = ... ... j = ... ... Exemple : \ud83d\udc0d Script Python >>> tri ([ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 34.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-35", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 35"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-351", "text": "Exercice 35.1 \u00c9nonc\u00e9 Correction Source Markdown L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents. Il est symbolis\u00e9 par le caract\u00e8re \u2295. Ainsi : 0 \u2295 0 = 0 0 \u2295 1 = 1 1 \u2295 0 = 1 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : \ud83d\udc0d Script Python a = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ] b = [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] c = [ 1 , 1 , 0 , 1 ] d = [ 0 , 0 , 1 , 1 ] \u00c9crire la fonction ou_exclusif qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction donne : \ud83d\udc0d Script Python >>> ou_exclusif ( a , b ) [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ] >>> ou_exclusif ( c , d ) [ 1 , 1 , 1 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 def ou_exclusif ( tab1 , tab2 ): resultat = [] taille = len ( tab1 ) for i in range ( taille ): resultat . append ( tab1 [ i ] ^ tab2 [ i ]) return resultat Si on ne connait pas la fonction native ^ qui fait le \u00abou exclusif\u00bb de deux entiers en Python, on peut la recoder : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def ou_exc ( a , b ): if a == 0 and b == 0 : return 0 if a == 0 and b == 1 : return 1 if a == 1 and b == 0 : return 1 if a == 1 and b == 1 : return 0 Le code devient alors : \ud83d\udc0d Script Python 1 2 3 4 5 6 def ou_exclusif ( tab1 , tab2 ): resultat = [] taille = len ( tab1 ) for i in range ( taille ): resultat . append ( ou_exc ( tab1 [ i ], tab2 [ i ])) return resultat \ud83d\udccb Texte L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents. Il est symbolis\u00e9 par le caract\u00e8re \u2295. Ainsi : - 0 \u2295 0 = 0 - 0 \u2295 1 = 1 - 1 \u2295 0 = 1 - 1 \u2295 1 = 0 On repr\u00e9sente ici une suite de bits par un tableau contenant des 0 et des 1. Exemples : ```python a = [1, 0, 1, 0, 1, 1, 0, 1] b = [0, 1, 1, 1, 0, 1, 0, 0] c = [1, 1, 0, 1] d = [0, 0, 1, 1] ``` \u00c9crire la fonction ```ou_exclusif``` qui prend en param\u00e8tres deux tableaux de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position `i` est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position `i` des tableaux pass\u00e9s en param\u00e8tres. En consid\u00e9rant les quatre exemples ci-dessus, cette fonction donne : ```python >>> ou_exclusif(a, b) [1, 1, 0, 1, 1, 0, 0, 1] >>> ou_exclusif(c, d) [1, 1, 1, 0] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 35.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-352", "text": "Exercice 35.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit semimagique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne sont \u00e9gales. Ainsi c2 et c3 sont semimagiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 8 pour c2 et 12 pour c3. Le carre c3bis n'est pas semimagique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 15 alors que celle de la deuxi\u00e8me ligne est \u00e9gale \u00e0 10. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. La m\u00e9thode constructeur cr\u00e9e un carr\u00e9 sous forme d\u2019un tableau \u00e0 deux dimensions \u00e0 partir d\u2019une liste d\u2019entiers, et d\u2019un ordre. La m\u00e9thode affiche permet d\u2019afficher le carr\u00e9 cr\u00e9\u00e9. Exemple : \ud83d\udc0d Script Python >>> liste = ( 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ) >>> c3 = Carre ( liste , 3 ) >>> c3 . affiche () [ 3 , 4 , 5 ] [ 4 , 4 , 4 ] [ 5 , 4 , 3 ] Compl\u00e9ter la m\u00e9thode est_semimagique qui renvoie True si le carr\u00e9 est semimagique, False sinon. Puis tester la fonction est_semimagique sur les carr\u00e9s c2, c3 et c3bis. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... ): if ... != s : return ... #test de la somme de chaque colonne for j in range ( ... ): if ... != s : return ... return ... Listes permettant de g\u00e9n\u00e9rer les carr\u00e9s c2, c3 et c3bis : \ud83d\udc0d Script Python 1 2 3 lst_c2 = [ 1 , 7 , 7 , 1 ] lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] lst_c3bis = [ 2 , 9 , 4 , 7 , 0 , 3 , 6 , 1 , 8 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( self . ordre ): if self . somme_ligne ( i ) != s : return False #test de la somme de chaque colonne for j in range ( self . ordre ): if self . somme_col ( j ) != s : return False return True Tests avec : \ud83d\udc0d Script Python 1 2 3 lst_c2 = [ 1 , 7 , 7 , 1 ] lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] lst_c3bis = [ 2 , 9 , 4 , 7 , 0 , 3 , 6 , 1 , 8 ] \ud83d\udc0d Script Python >>> c2 = Carre ( lst_c2 , 2 ) >>> c2 . est_semimagique () True >>> c3 = Carre ( lst_c3 , 3 ) >>> c3 . est_semimagique () True >>> c3bis = Carre ( lst_c3bis , 2 ) >>> c3bis . est_semimagique () False Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre $n$ un tableau de $n$ lignes et $n$ colonnes dont chaque case contient un entier naturel. Exemples : ![ image ]( data2023/35_carre.png ){: .center} Un carr\u00e9 est dit semimagique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne sont \u00e9gales. - Ainsi c2 et c3 sont semimagiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 8 pour c2 et 12 pour c3. - Le carre c3bis n'est pas semimagique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 15 alors que celle de la deuxi\u00e8me ligne est \u00e9gale \u00e0 10. La classe `Carre` ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. - La m\u00e9thode constructeur cr\u00e9e un carr\u00e9 sous forme d\u2019un tableau \u00e0 deux dimensions \u00e0 partir d\u2019une liste d\u2019entiers, et d\u2019un ordre. - La m\u00e9thode `affiche` permet d\u2019afficher le carr\u00e9 cr\u00e9\u00e9. Exemple : ```python >>> liste = (3, 4, 5, 4, 4, 4, 5, 4, 3) >>> c3 = Carre(liste, 3) >>> c3.affiche() [3, 4, 5] [4, 4, 4] [5, 4, 3] Compl\u00e9ter la m\u00e9thode est_semimagique qui renvoie True si le carr\u00e9 est semimagique, False sinon. Puis tester la fonction est_semimagique sur les carr\u00e9s c2, c3 et c3bis. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... ): if ... != s : return ... #test de la somme de chaque colonne for j in range ( ... ): if ... != s : return ... return ... Listes permettant de g\u00e9n\u00e9rer les carr\u00e9s c2, c3 et c3bis : \ud83d\udc0d Script Python 1 2 3 lst_c2 = [ 1 , 7 , 7 , 1 ] lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] lst_c3bis = [ 2 , 9 , 4 , 7 , 0 , 3 , 6 , 1 , 8 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 35.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-36", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 36"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-361", "text": "Exercice 36.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction couples_consecutifs qui prend en param\u00e8tre une liste de nombres entiers tab non vide, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> couples_consecutifs ([ 1 , 4 , 3 , 5 ]) [] >>> couples_consecutifs ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> couples_consecutifs ([ 1 , 1 , 2 , 4 ]) [( 1 , 2 )] >>> couples_consecutifs ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> couples_consecutifs ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] \ud83d\udc0d Script Python 1 2 3 4 5 6 def couples_consecutifs ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \ud83d\udccb Texte \u00c9crire une fonction `couples_consecutifs` qui prend en param\u00e8tre une liste de nombres entiers `tab` non vide, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans `tab`. Exemples : ```python >>> couples_consecutifs([1, 4, 3, 5]) [] >>> couples_consecutifs([1, 4, 5, 3]) [(4, 5)] >>> couples_consecutifs([1, 1, 2, 4]) [(1, 2)] >>> couples_consecutifs([7, 1, 2, 5, 3, 4]) [(1, 2), (3, 4)] >>> couples_consecutifs([5, 1, 2, 3, 8, -5, -4, 7]) [(1, 2), (2, 3), (-5, -4)] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 36.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-362", "text": "Exercice 36.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image M (repr\u00e9sent\u00e9e par une liste de listes), deux entiers i et j et unevaleur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien s\u2019il vaut 0 . Par exemple, propager(M, 2, 1, 3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction propager donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def propager ( M , i , j , val ): if M [ i ][ j ] == ... : M [ i ][ j ] = val # l'element en haut fait partie de la composante if i - 1 >= 0 and M [ i - 1 ][ j ] == ... : propager ( M , i - 1 , j , val ) # l'element en bas fait partie de la composante if ... < len ( M ) and M [ i + 1 ][ j ] == 1 : propager ( M , ... , j , val ) # l'element \u00e0 gauche fait partie de la composante if ... and M [ i ][ j - 1 ] == 1 : propager ( M , ... , ... , val ) # l'element \u00e0 droite fait partie de la composante if ... and ... : propager ( ... , ... , ... , ... ) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def propager ( M , i , j , val ): if M [ i ][ j ] == 1 : M [ i ][ j ] = val # l'element en haut fait partie de la composante if i - 1 >= 0 and M [ i - 1 ][ j ] == 1 : propager ( M , i - 1 , j , val ) # l'element en bas fait partie de la composante if i + 1 < len ( M ) and M [ i + 1 ][ j ] == 1 : propager ( M , i + 1 , j , val ) # l'element \u00e0 gauche fait partie de la composante if j - 1 >= 0 and M [ i ][ j - 1 ] == 1 : propager ( M , i , j - 1 , val ) # l'element \u00e0 droite fait partie de la composante if j + 1 < len ( M [ i ]) and M [ i ][ j + 1 ] == 1 : propager ( M , i , j + 1 , val ) ce code va d\u00e9clencher la propagation m\u00eame si la cellule i,j n'est pas \u00e0 1. C'est sans doute une erreur d'\u00e9nonc\u00e9. Il faudrait plut\u00f4t \u00e9crire ceci : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def propager ( M , i , j , val ): if M [ i ][ j ] == 1 : M [ i ][ j ] = val # l'element en haut fait partie de la composante if i - 1 >= 0 and M [ i - 1 ][ j ] == 1 : propager ( M , i - 1 , j , val ) # l'element en bas fait partie de la composante if i + 1 < len ( M ) and M [ i + 1 ][ j ] == 1 : propager ( M , i + 1 , j , val ) # l'element \u00e0 gauche fait partie de la composante if j - 1 >= 0 and M [ i ][ j - 1 ] == 1 : propager ( M , i , j - 1 , val ) # l'element \u00e0 droite fait partie de la composante if j + 1 < len ( M [ i ]) and M [ i ][ j + 1 ] == 1 : propager ( M , i , j + 1 , val ) Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments `M[i][j]` , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 `0` soit \u00e0 `1` . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de `1` et de `0` qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de ![ image ]( data2023/36_carre1.png ){: .center} sont ![ image ]( data2023/36_carre2.png ){: .center width=30%} On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 `1` dans une image `M` , donner la valeur `val` \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction `propager` prend pour param\u00e8tre une image `M` (repr\u00e9sent\u00e9e par une liste de listes), deux entiers `i` et `j` et unevaleur enti\u00e8re `val` . Elle met \u00e0 la valeur `val` tous les pixels de la composante du pixel `M[i][j]` s\u2019il vaut `1` et ne fait rien s\u2019il vaut `0` . Par exemple, `propager(M, 2, 1, 3)` donne ![ image ]( data2023/36_carre3.png ){: .center width=30%} Compl\u00e9ter le code r\u00e9cursif de la fonction `propager` donn\u00e9 ci-dessous : ```python linenums='1' def propager(M, i, j, val): if M[i][j] == ...: M[i][j] = val # l'element en haut fait partie de la composante if i-1 >= 0 and M[i-1][j] == ...: propager(M, i-1, j, val) # l'element en bas fait partie de la composante if ... < len(M) and M[i+1][j] == 1: propager(M, ..., j, val) # l'element \u00e0 gauche fait partie de la composante if ... and M[i][j-1] == 1: propager(M, ..., ..., val) # l'element \u00e0 droite fait partie de la composante if ... and ...: propager(..., ..., ..., ...) Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 0 ]] >>> propager ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 36.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-37", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 37"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-371", "text": "Exercice 37.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers, et qui renvoie l\u2019indice de la derni\u00e8re occurrence de elt dans tab si elt est dans tab et -1 sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) - 1 >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 1 , [ 1 , 0 , 42 , 7 ]) 0 >>> recherche ( 1 , [ 1 , 50 , 1 ]) 2 >>> recherche ( 1 , [ 8 , 1 , 10 , 1 , 7 , 1 , 8 ]) 5 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab ) - 1 , - 1 , - 1 ): if tab [ i ] == elt : return i return - 1 \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers, et qui renvoie l\u2019indice de la derni\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `-1` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) -1 >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(1, [1, 0, 42, 7]) 0 >>> recherche(1, [1, 50, 1]) 2 >>> recherche(1, [8, 1, 10, 1, 7, 1, 8]) 5 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 37.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-372", "text": "Exercice 37.2 \u00c9nonc\u00e9 Correction Sources Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254 : octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) else : return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octet ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return self . liste_octet ()[ 3 ] == 0 or self . liste_octet ()[ 3 ] == 255 def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if self . liste_octet ()[ 3 ] < 254 : octet_nouveau = self . liste_octet ()[ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) else : return False adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de `192.168.0.0` \u00e0 `192.168.0.255` . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP `192.168.0.0` et `192.168.0.255` sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe `AdresseIP` . ```python linenums='1' class AdresseIP: def __init__ (self, adresse): self.adresse = ... def liste_octet(self): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" return ... or ... def adresse_suivante(self): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l\u2019adresse self si elle existe et False sinon\"\"\" if ... < 254: octet_nouveau = ... + ... return AdresseIP('192.168.0.' + ...) else: return False Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse '192.168.0.3' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 37.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-38", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 38"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-381", "text": "Exercice 38.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res * . Par exemple INFO*MA*IQUE , ***I***E** et *S* sont des mots \u00e0 trous. Programmer une fonction correspond qui : prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res mot et mot_a_trous o\u00f9 mot_a_trous est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, renvoie : True si on peut obtenir mot en rempla\u00e7ant convenablement les caract\u00e8res '*' de mot_a_trous . False sinon. Exemple : \ud83d\udc0d Script Python >>> correspond ( 'INFORMATIQUE' , 'INFO*MA*IQUE' ) True >>> correspond ( 'AUTOMATIQUE' , 'INFO*MA*IQUE' ) False >>> correspond ( 'STOP' , 'S*' ) False >>> correspond ( 'AUTO' , '*UT*' ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def correspond ( mot , mot_a_trous ): if len ( mot ) != len ( mot_a_trous ): return False for i in range ( len ( mot )): if mot [ i ] != mot_a_trous [ i ] and mot_a_trous [ i ] != '*' : return False return True \ud83d\udccb Texte On consid\u00e8re des mots \u00e0 trous : ce sont des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des caract\u00e8res `*`. Par exemple `INFO*MA*IQUE`, `***I***E**` et `*S*` sont des mots \u00e0 trous. Programmer une fonction `correspond` qui : - prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res `mot` et `mot_a_trous` o\u00f9 `mot_a_trous` est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, - renvoie : - `True` si on peut obtenir `mot` en rempla\u00e7ant convenablement les caract\u00e8res `'*'` de `mot_a_trous`. - `False` sinon. Exemple : ```python >>> correspond('INFORMATIQUE', 'INFO*MA*IQUE') True >>> correspond('AUTOMATIQUE', 'INFO*MA*IQUE') False >>> correspond('STOP', 'S*') False >>> correspond('AUTO', '*UT*') True ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 38.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-382", "text": "Exercice 38.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : chaque personne ne peut envoyer des messages qu'\u00e0 une seule personne (\u00e9ventuellement elle-m\u00eame), chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : A envoie ses messages \u00e0 E E envoie ses messages \u00e0 B B envoie ses messages \u00e0 F F envoie ses messages \u00e0 A C envoie ses messages \u00e0 D D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'} Un cycle est une suite de personnes dans laquelle la derni\u00e8re est la m\u00eame que la premi\u00e8re. Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'} comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle , on dit que le plan d\u2019envoi est cyclique . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : on part d\u2019un exp\u00e9diteur (ici A) et on inspecte son destinataire dans le plan d'envoi, chaque destinataire devient \u00e0 son tour exp\u00e9diteur, selon le plan d\u2019envoi, tant qu\u2019on ne \u00ab retombe \u00bb pas sur l\u2019exp\u00e9diteur initial, le plan d\u2019envoi est cyclique si on l\u2019a parcouru en entier. Compl\u00e9ter la fonction est_cyclique en respectant la sp\u00e9cification. Remarque : la fonction python len permet d'obtenir la longueur d'un dictionnaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' expediteur = 'A' destinataire = plan [ ... ] nb_destinaires = 1 while destinataire != ... : destinataire = plan [ ... ] nb_destinaires += ... return nb_destinaires == ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def est_cyclique ( plan ): ''' Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' expediteur = 'A' destinataire = plan [ expediteur ] nb_destinaires = 1 while destinataire != expediteur : destinataire = plan [ destinataire ] nb_destinaires += 1 return nb_destinaires == len ( plan ) #tests print ( est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' })) print ( est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' })) Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : - chaque personne ne peut envoyer des messages qu'\u00e0 une seule personne (\u00e9ventuellement elle-m\u00eame), - chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : - A envoie ses messages \u00e0 E - E envoie ses messages \u00e0 B - B envoie ses messages \u00e0 F - F envoie ses messages \u00e0 A - C envoie ses messages \u00e0 D - D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : `plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'}` Un cycle est une suite de personnes dans laquelle la derni\u00e8re est la m\u00eame que la premi\u00e8re. Sur le plan d'envoi `plan_a` des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi `plan_b` ci-dessous : `plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'}` comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un *unique cycle* , on dit que le plan d\u2019envoi est *cyclique* . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : - on part d\u2019un exp\u00e9diteur (ici A) et on inspecte son destinataire dans le plan d'envoi, - chaque destinataire devient \u00e0 son tour exp\u00e9diteur, selon le plan d\u2019envoi, tant qu\u2019on ne \u00ab retombe \u00bb pas sur l\u2019exp\u00e9diteur initial, - le plan d\u2019envoi est cyclique si on l\u2019a parcouru en entier. Compl\u00e9ter la fonction `est_cyclique` en respectant la sp\u00e9cification. *Remarque :* la fonction python `len` permet d'obtenir la longueur d'un dictionnaire. ```python linenums='1' def est_cyclique(plan): ''' Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon. ''' expediteur = 'A' destinataire = plan[ ... ] nb_destinaires = 1 while destinataire != ...: destinataire = plan[ ... ] nb_destinaires += ... return nb_destinaires == ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 38.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-39", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 39"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-391", "text": "Exercice 39.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par : les deux premiers termes sont \u00e9gaux \u00e0 1, ensuite, chaque terme est obtenu en faisant la somme des deux termes qui le pr\u00e9c\u00e8dent. En math\u00e9matiques, on le formule ainsi : \\(U_1 = 1\\) , \\(U_2 = 1\\) et, pour tout entier naturel non nul \\(n\\) , par \\(U_{n+2} = U_{n+1} + U_n\\) . Cette suite est connue sous le nom de suite de Fibonacci. \u00c9crire en Python une fonction fibonacci qui prend en param\u00e8tre un entier n suppos\u00e9 strictement positif et qui renvoie le terme d\u2019indice n de cette suite. Exemples : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 >>> fibonacci ( 45 ) 1134903170 Version r\u00e9cursive : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonacci ( n ): if n == 1 : return 1 elif n == 1 : return 1 else : return fibonacci ( n - 1 ) + fibonacci ( n - 2 ) Version imp\u00e9rative : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def fibonacci ( n ): a = 1 b = 1 for k in range ( n - 2 ): t = b b = a + b a = t return b Version programmation dynamique : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonacci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] On peut constater que la version r\u00e9cursive \u00e9choue \u00e0 calculer fibonacci(45) , alors que les deux autres versions le font quasi-imm\u00e9diatement. \ud83d\udccb Texte On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par : - les deux premiers termes sont \u00e9gaux \u00e0 1, - ensuite, chaque terme est obtenu en faisant la somme des deux termes qui le pr\u00e9c\u00e8dent. En math\u00e9matiques, on le formule ainsi : $U_1 = 1$, $U_2 = 1$ et, pour tout entier naturel non nul $n$, par $U_{n+2} = U_{n+1} + U_n$. Cette suite est connue sous le nom de suite de Fibonacci. \u00c9crire en Python une fonction `fibonacci` qui prend en param\u00e8tre un entier `n` suppos\u00e9 strictement positif et qui renvoie le terme d\u2019indice `n` de cette suite. Exemples : ```python >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(25) 75025 >>> fibonacci(45) 1134903170 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 39.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-392", "text": "Exercice 39.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction pantheon prenant en param\u00e8tres eleves et notes deux tableaux de m\u00eame longueur, le premier contenant le nom des \u00e9l\u00e8ves et le second, des entiers positifs d\u00e9signant leur note \u00e0 un contr\u00f4le de sorte que eleves[i] a obtenu la note notes[i] . Cette fonction renvoie le couple constitu\u00e9 de la note maximale attribu\u00e9e et des noms des \u00e9l\u00e8ves ayant obtenu cette note regroup\u00e9s dans un tableau. Ainsi, l\u2019instruction pantheon(['a', 'b', 'c', 'd'], [15, 18, 12, 18]) renvoie le couple (18, ['b', 'd']) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def pantheon ( eleves , notes ): note_maxi = 0 meilleurs_eleves = ... for i in range ( ... ) : if notes [ i ] == ... : meilleurs_eleves . append ( ... ) elif notes [ i ] > note_maxi : note_maxi = ... meilleurs_eleves = [ ... ] return ( note_maxi , meilleurs_eleves ) Compl\u00e9ter ce code. Exemples : \ud83d\udc0d Script Python >>> eleves_nsi = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] >>> notes_nsi = [ 30 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] >>> pantheon ( eleves_nsi , notes_nsi ) ( 80 , [ 'c' , 'f' , 'h' ]) >>> pantheon ([],[]) ( 0 , []) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def pantheon ( eleves , notes ): note_maxi = 0 meilleurs_eleves = [] for i in range ( len ( eleves )) : if notes [ i ] == note_maxi : meilleurs_eleves . append ( eleves [ i ]) elif notes [ i ] > note_maxi : note_maxi = notes [ i ] meilleurs_eleves = [ eleves [ i ]] return ( note_maxi , meilleurs_eleves ) Markdown On consid\u00e8re la fonction `pantheon` prenant en param\u00e8tres `eleves` et `notes` deux tableaux de m\u00eame longueur, le premier contenant le nom des \u00e9l\u00e8ves et le second, des entiers positifs d\u00e9signant leur note \u00e0 un contr\u00f4le de sorte que `eleves[i]` a obtenu la note `notes[i]` . Cette fonction renvoie le couple constitu\u00e9 de la note maximale attribu\u00e9e et des noms des \u00e9l\u00e8ves ayant obtenu cette note regroup\u00e9s dans un tableau. Ainsi, l\u2019instruction `pantheon(['a', 'b', 'c', 'd'], [15, 18, 12, 18])` renvoie le couple `(18, ['b', 'd'])` . ```python linenums='1' def pantheon(eleves, notes): note_maxi = 0 meilleurs_eleves = ... for i in range(...) : if notes[i] == ... : meilleurs_eleves.append(...) elif notes[i] > note_maxi: note_maxi = ... meilleurs_eleves = [...] return (note_maxi,meilleurs_eleves) Compl\u00e9ter ce code. Exemples : \ud83d\udc0d Script Python >>> eleves_nsi = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] >>> notes_nsi = [ 30 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] >>> pantheon ( eleves_nsi , notes_nsi ) ( 80 , [ 'c' , 'f' , 'h' ]) >>> pantheon ([],[]) ( 0 , []) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 39.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-40", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 40"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-401", "text": "Exercice 40.1 \u00c9nonc\u00e9 Correction Source Markdown Pour cet exercice : On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace ' ' , se finissant : soit par un point '.' qui est alors coll\u00e9 au dernier mot, soit par un point d'exclamation '!' ou d'interrogation '?' qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace ' ' . Exemples : 'Cet exercice est simple.' 'Le point d exclamation est separe !' Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction nombre_de_mots qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. \ud83d\udc0d Script Python >>> nombre_de_mots ( 'Le point d exclamation est separe !' ) 6 >>> nombre_de_mots ( 'Il y a un seul espace entre les mots !' ) 9 >>> nombre_de_mots ( 'Combien de mots y a t il dans cette phrase ?' ) 10 >>> nombre_de_mots ( 'Fin.' ) 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nombre_de_mots ( phrase ): nb_mots = 0 for caractere in phrase : if caractere == ' ' or caractere == '.' : nb_mots += 1 return nb_mots \ud83d\udccb Texte Pour cet exercice : - On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, - On appelle \u00ab phrase \u00bb une cha\u00eene de caract\u00e8res : - compos\u00e9e avec un ou plusieurs \u00ab mots \u00bb s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace `' '`, - se finissant : - soit par un point `'.'` qui est alors coll\u00e9 au dernier mot, - soit par un point d'exclamation `'!'` ou d'interrogation `'?'` qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace `' '`. *Exemples :* - 'Cet exercice est simple.' - 'Le point d exclamation est separe !' Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction `nombre_de_mots` qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. ```python >>> nombre_de_mots('Le point d exclamation est separe !') 6 >>> nombre_de_mots('Il y a un seul espace entre les mots !') 9 >>> nombre_de_mots('Combien de mots y a t il dans cette phrase ?') 10 >>> nombre_de_mots('Fin.') 1 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 40.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-402", "text": "Exercice 40.2 \u00c9nonc\u00e9 Correction Sources Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Noeud : def __init__ ( self , valeur ): '''M\u00e9thode constructeur pour la classe Noeud. Param\u00e8tre d'entr\u00e9e : valeur (str)''' self . valeur = valeur self . gauche = None self . droit = None def getValeur ( self ): '''M\u00e9thode accesseur pour obtenir la valeur du noeud Aucun param\u00e8tre en entr\u00e9e''' return self . valeur def droitExiste ( self ): '''M\u00e9thode renvoyant True si l'enfant droit existe Aucun param\u00e8tre en entr\u00e9e''' return ( self . droit is not None ) def gaucheExiste ( self ): '''M\u00e9thode renvoyant True si l'enfant gauche existe Aucun param\u00e8tre en entr\u00e9e''' return ( self . gauche is not None ) def inserer ( self , cle ): '''M\u00e9thode d'insertion de cl\u00e9 dans un arbre binaire de recherche Param\u00e8tre d'entr\u00e9e : cle (int)''' if cle < ... : # on ins\u00e8re \u00e0 gauche if self . gaucheExiste (): # on descend \u00e0 gauche et on retente l'insertion de la cl\u00e9 ... else : # on cr\u00e9e un fils gauche self . gauche = ... elif cle > ... : # on ins\u00e8re \u00e0 droite if ... : # on descend \u00e0 droite et on retente l'insertion de la cl\u00e9 ... else : # on cr\u00e9e un fils droit ... = Noeud ( cle ) Compl\u00e9ter la fonction r\u00e9cursive inserer afin qu'elle permette d\u2019ins\u00e9rer un n\u0153ud dans l\u2019arbre binaire de recherche propos\u00e9, \u00e0 l\u2019aide de sa cl\u00e9. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> arbre = Noeud ( 7 ) >>> for cle in ( 3 , 9 , 1 , 6 ): arbre . inserer ( cle ) >>> arbre . gauche . getValeur () 3 >>> arbre . droit . getValeur () 9 >>> arbre . gauche . gauche . getValeur () 1 >>> arbre . gauche . droit . getValeur () 6 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Noeud : def __init__ ( self , valeur ): '''M\u00e9thode constructeur pour la classe Noeud. Param\u00e8tre d'entr\u00e9e : valeur (str)''' self . valeur = valeur self . gauche = None self . droit = None def getValeur ( self ): '''M\u00e9thode accesseur pour obtenir la valeur du noeud Aucun param\u00e8tre en entr\u00e9e''' return self . valeur def droitExiste ( self ): '''M\u00e9thode renvoyant True si l'enfant droit existe Aucun param\u00e8tre en entr\u00e9e''' return ( self . droit is not None ) def gaucheExiste ( self ): '''M\u00e9thode renvoyant True si l'enfant gauche existe Aucun param\u00e8tre en entr\u00e9e''' return ( self . gauche is not None ) def inserer ( self , cle ): '''M\u00e9thode d'insertion de cl\u00e9 dans un arbre binaire de recherche Param\u00e8tre d'entr\u00e9e : cle (int)''' if cle < self . valeur : # on ins\u00e8re \u00e0 gauche if self . gaucheExiste (): # on descend \u00e0 gauche et on retente l'insertion de la cl\u00e9 self . gauche . inserer ( cle ) else : # on cr\u00e9e un fils gauche self . gauche = Noeud ( cle ) elif cle > self . valeur : # on ins\u00e8re \u00e0 droite if self . droitExiste (): # on descend \u00e0 droite et on retente l'insertion de la cl\u00e9 self . droit . inserer ( cle ) else : # on cr\u00e9e un fils droit self . droit = Noeud ( cle ) Markdown La classe ABR ci-dessous permet d'impl\u00e9menter une structure d'arbre binaire de recherche. ```python linenums='1' class Noeud: def __init__ (self, valeur): '''M\u00e9thode constructeur pour la classe Noeud. Param\u00e8tre d'entr\u00e9e : valeur (str)''' self.valeur = valeur self.gauche = None self.droit = None def getValeur(self): '''M\u00e9thode accesseur pour obtenir la valeur du noeud Aucun param\u00e8tre en entr\u00e9e''' return self.valeur def droitExiste(self): '''M\u00e9thode renvoyant True si l'enfant droit existe Aucun param\u00e8tre en entr\u00e9e''' return (self.droit is not None) def gaucheExiste(self): '''M\u00e9thode renvoyant True si l'enfant gauche existe Aucun param\u00e8tre en entr\u00e9e''' return (self.gauche is not None) def inserer(self, cle): '''M\u00e9thode d'insertion de cl\u00e9 dans un arbre binaire de recherche Param\u00e8tre d'entr\u00e9e : cle (int)''' if cle < ...: # on ins\u00e8re \u00e0 gauche if self.gaucheExiste(): # on descend \u00e0 gauche et on retente l'insertion de la cl\u00e9 ... else: # on cr\u00e9e un fils gauche self.gauche = ... elif cle > ... : # on ins\u00e8re \u00e0 droite if ... : # on descend \u00e0 droite et on retente l'insertion de la cl\u00e9 ... else: # on cr\u00e9e un fils droit ... = Noeud(cle) Compl\u00e9ter la fonction r\u00e9cursive inserer afin qu'elle permette d\u2019ins\u00e9rer un n\u0153ud dans l\u2019arbre binaire de recherche propos\u00e9, \u00e0 l\u2019aide de sa cl\u00e9. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> arbre = Noeud ( 7 ) >>> for cle in ( 3 , 9 , 1 , 6 ): arbre . inserer ( cle ) >>> arbre . gauche . getValeur () 3 >>> arbre . droit . getValeur () 9 >>> arbre . gauche . gauche . getValeur () 1 >>> arbre . gauche . droit . getValeur () 6 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 40.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-41", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 41"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-411", "text": "Exercice 41.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche(caractere, chaine) qui prend en param\u00e8tres caractere , un unique caract\u00e8re (c\u2019est-\u00e0-dire une cha\u00eene de caract\u00e8re de longueur 1), et chaine , une cha\u00eene de caract\u00e8res. Cette fonction renvoie le nombre d\u2019occurrences de caractere dans chaine , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans chaine. Exemples : \ud83d\udc0d Script Python >>> recherche ( 'e' , \"sciences\" ) 2 >>> recherche ( 'i' , \"mississippi\" ) 4 >>> recherche ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( caractere , chaine ): somme = 0 for lettre in chaine : if lettre == caractere : somme += 1 return somme \ud83d\udccb Texte \u00c9crire une fonction `recherche(caractere, chaine)` qui prend en param\u00e8tres `caractere`, un unique caract\u00e8re (c\u2019est-\u00e0-dire une cha\u00eene de caract\u00e8re de longueur 1), et `chaine`, une cha\u00eene de caract\u00e8res. Cette fonction renvoie le nombre d\u2019occurrences de `caractere` dans `chaine`, c\u2019est-\u00e0-dire le nombre de fois o\u00f9 `caractere` appara\u00eet dans chaine. Exemples : ```python >>> recherche('e', \"sciences\") 2 >>> recherche('i',\"mississippi\") 4 >>> recherche('a',\"mississippi\") 0 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 41.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-412", "text": "Exercice 41.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste valeurs = [100, 50, 20, 10, 5, 2, 1] . On suppose que les pi\u00e8ces et billets sont disponibles sans limitation. On cherche \u00e0 donner la liste des valeurs \u00e0 rendre pour une somme donn\u00e9e en argument. L\u2019algorithme utilis\u00e9 est de type glouton. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 valeurs = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( a_rendre , rang ): if a_rendre == 0 : return ... v = valeurs [ rang ] if v <= ... : return ... + rendu_glouton ( a_rendre - v , rang ) else : return rendu_glouton ( a_rendre , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 67 , 0 ) [ 50 , 10 , 5 , 2 ] >>> rendu_glouton ( 291 , 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] >>> rendu_glouton ( 291 , 1 ) # si on ne dispose pas de billets de 100 [ 50 , 50 , 50 , 50 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 valeurs = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( a_rendre , rang ): if a_rendre == 0 : return [] v = valeurs [ rang ] if v <= a_rendre : return [ v ] + rendu_glouton ( a_rendre - v , rang ) else : return rendu_glouton ( a_rendre , rang + 1 ) Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste `valeurs = [100, 50, 20, 10, 5, 2, 1]`. On suppose que les pi\u00e8ces et billets sont disponibles sans limitation. On cherche \u00e0 donner la liste des valeurs \u00e0 rendre pour une somme donn\u00e9e en argument. L\u2019algorithme utilis\u00e9 est de type glouton. Compl\u00e9ter le code Python ci-dessous de la fonction `rendu_glouton` qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. ```python linenums='1' valeurs = [100, 50, 20, 10, 5, 2, 1] def rendu_glouton(a_rendre, rang): if a_rendre == 0: return ... v = valeurs[rang] if v <= ... : return ... + rendu_glouton(a_rendre - v, rang) else : return rendu_glouton(a_rendre, ...) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 67 , 0 ) [ 50 , 10 , 5 , 2 ] >>> rendu_glouton ( 291 , 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] >>> rendu_glouton ( 291 , 1 ) # si on ne dispose pas de billets de 100 [ 50 , 50 , 50 , 50 , 50 , 20 , 20 , 1 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 41.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-42", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 42"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-421", "text": "Exercice 42.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction tri_selection qui prend en param\u00e8tre une liste tab de nombres entiers et qui renvoie la liste tri\u00e9e par ordre croissant. Il est demand\u00e9 de ne pas cr\u00e9er de nouvelle liste mais de modifier celle fournie. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment de la liste, en la parcourant du rang 0 au dernier rang, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; on recherche ensuite le plus petit \u00e9l\u00e9ment de la liste restreinte du rang 1 au dernier rang, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; on continue de cette fa\u00e7on jusqu'\u00e0 ce que la liste soit enti\u00e8rement tri\u00e9e. Exemple : \ud83d\udc0d Script Python >>> tri_selection ([ 1 , 52 , 6 , - 9 , 12 ]) [ - 9 , 1 , 6 , 12 , 52 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \ud83d\udccb Texte \u00c9crire une fonction `tri_selection` qui prend en param\u00e8tre une liste `tab` de nombres entiers et qui renvoie la liste tri\u00e9e par ordre croissant. Il est demand\u00e9 de ne pas cr\u00e9er de nouvelle liste mais de modifier celle fournie. On utilisera l\u2019algorithme suivant : - on recherche le plus petit \u00e9l\u00e9ment de la liste, en la parcourant du rang 0 au dernier rang, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 0 ; - on recherche ensuite le plus petit \u00e9l\u00e9ment de la liste restreinte du rang 1 au dernier rang, et on l'\u00e9change avec l'\u00e9l\u00e9ment d'indice 1 ; - on continue de cette fa\u00e7on jusqu'\u00e0 ce que la liste soit enti\u00e8rement tri\u00e9e. Exemple : ```python >>> tri_selection([1, 52, 6, -9, 12]) [-9, 1, 6, 12, 52] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 42.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-422", "text": "Exercice 42.2 \u00c9nonc\u00e9 Correction Sources Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers tels que a <= b , randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 99 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 1 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Un \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : - le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; - si la proposition de l\u2019utilisateur est plus petite que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si la proposition de l\u2019utilisateur est plus grande que le nombre cherch\u00e9, l\u2019utilisateur en est averti. Il peut alors en tester un autre ; - si l\u2019utilisateur trouve le bon nombre en 10 essais ou moins, il gagne ; - si l\u2019utilisateur a fait plus de 10 essais sans trouver le bon nombre, il perd. La fonction `randint` est utilis\u00e9e. Si a et b sont des entiers tels que `a <= b` , `randint(a,b)` renvoie un nombre entier compris entre `a` et `b` . Compl\u00e9ter le code ci-dessous et le tester : ```python linenums='1' from random import randint def plus_ou_moins(): nb_mystere = randint(1,...) nb_test = int(input(\"Proposez un nombre entre 1 et 99 : \")) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test: nb_test = int(input(\"Trop petit ! Testez encore : \")) else: nb_test = int(input(\"Trop grand ! Testez encore : \")) if nb_mystere == nb_test: print (\"Bravo ! Le nombre \u00e9tait \",...) print(\"Nombre d'essais: \",...) else: print (\"Perdu ! Le nombre \u00e9tait \",...) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 42.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-43", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 43"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-431", "text": "Exercice 43.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction ecriture_binaire_entier_positif qui prend en param\u00e8tre un entier positif n et renvoie une liste d'entiers correspondant \u00e0 l\u2018\u00e9criture binaire de n . Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : \ud83d\udc0d Script Python >>> ecriture_binaire_entier_positif ( 0 ) [ 0 ] >>> ecriture_binaire_entier_positif ( 2 ) [ 1 , 0 ] >>> ecriture_binaire_entier_positif ( 105 ) [ 1 , 1 , 0 , 1 , 0 , 0 , 1 ] Aide : l'op\u00e9rateur // donne le quotient de la division euclidienne : 5//2 donne 2 ; l'op\u00e9rateur % donne le reste de la division euclidienne : 5%2 donne 1 ; append est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit T=[5,2,4] , alors T.append(10) ajoute 10 \u00e0 la liste T . Ainsi, T devient [5,2,4,10] . reverse est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit T=[5,2,4,10] . Apr\u00e8s T.reverse() , la liste devient [10,4,2,5] . On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier n en partant de la gauche en appliquant successivement les instructions : b = n%2 n = n//2 r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def ecriture_binaire_entier_positif ( n ): # cas particulier pour n = 0 if n == 0 : return [ 0 ] # cas g\u00e9n\u00e9ral b = [] while n != 0 : b . append ( n % 2 ) n = n // 2 b . reverse () return b \ud83d\udccb Texte \u00c9crire une fonction `ecriture_binaire_entier_positif` qui prend en param\u00e8tre un entier positif `n` et renvoie une liste d'entiers correspondant \u00e0 l\u2018\u00e9criture binaire de `n`. Ne pas oublier d\u2019ajouter au corps de la fonction une documentation et une ou plusieurs assertions pour v\u00e9rifier les pr\u00e9-conditions. Exemples : ```python >>> ecriture_binaire_entier_positif(0) [0] >>> ecriture_binaire_entier_positif(2) [1, 0] >>> ecriture_binaire_entier_positif(105) [1, 1, 0, 1, 0, 0, 1] ``` Aide : - l'op\u00e9rateur `//` donne le quotient de la division euclidienne : `5//2` donne `2` ; - l'op\u00e9rateur `%` donne le reste de la division euclidienne :` 5%2` donne `1` ; - `append` est une m\u00e9thode qui ajoute un \u00e9l\u00e9ment \u00e0 une liste existante : Soit `T=[5,2,4]`, alors `T.append(10)` ajoute `10` \u00e0 la liste `T`. Ainsi, `T` devient `[5,2,4,10]`. - `reverse` est une m\u00e9thode qui renverse les \u00e9l\u00e9ments d'une liste. Soit `T=[5,2,4,10]`. Apr\u00e8s `T.reverse()`, la liste devient `[10,4,2,5]`. On remarquera qu\u2019on r\u00e9cup\u00e8re la repr\u00e9sentation binaire d\u2019un entier `n` en partant de la gauche en appliquant successivement les instructions : `b = n%2` `n = n//2` r\u00e9p\u00e9t\u00e9es autant que n\u00e9cessaire. R\u00e9digez votre code sur Basthon", "title": "Exercice 43.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-432", "text": "Exercice 43.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_bulles prend en param\u00e8tre une liste T d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Le tri \u00e0 bulles est un tri en place qui commence par placer le plus grand \u00e9l\u00e9ment en derni\u00e8re position en parcourant la liste de gauche \u00e0 droite et en \u00e9changeant au passage les \u00e9l\u00e9ments voisins mal ordonn\u00e9s (si la valeur de l\u2019\u00e9l\u00e9ment d\u2019indice i a une valeur strictement sup\u00e9rieure \u00e0 celle de l\u2019indice i + 1 , ils sont \u00e9chang\u00e9s). Le tri place ensuite en avant-derni\u00e8re position le plus grand \u00e9l\u00e9ment de la liste priv\u00e9e de son dernier \u00e9l\u00e9ment en proc\u00e9dant encore \u00e0 des \u00e9changes d\u2019\u00e9l\u00e9ments voisins. Ce principe est r\u00e9p\u00e9t\u00e9 jusqu\u2019\u00e0 placer le minimum en premi\u00e8re position. Exemple : pour trier la liste [7, 9, 4, 3] : premi\u00e8re \u00e9tape : 7 et 9 ne sont pas \u00e9chang\u00e9s, puis 9 et 4 sont \u00e9chang\u00e9s, puis 9 et 3 sont \u00e9chang\u00e9s, la liste est alors [7, 4, 3, 9] deuxi\u00e8me \u00e9tape : 7 et 4 sont \u00e9chang\u00e9s, puis 7 et 3 sont \u00e9chang\u00e9s, la liste est alors [4, 3, 7, 9] troisi\u00e8me \u00e9tape : 4 et 3 sont \u00e9chang\u00e9s, la liste est alors [3, 4, 7, 9] Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tri_bulles ( T ): ''' Renvoie le tableau T tri\u00e9 par ordre croissant ''' n = len ( T ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if T [ j ] > T [ ... ]: ... = T [ j ] T [ j ] = T [ ... ] T [ j + 1 ] = temp return T Exemples : \ud83d\udc0d Script Python >>> tri_bulles ([]) [] >>> tri_bulles ([ 7 ]) [ 7 ] >>> tri_bulles ([ 9 , 3 , 7 , 2 , 3 , 1 , 6 ]) [ 1 , 2 , 3 , 3 , 6 , 7 , 9 ] >>> tri_bulles ([ 9 , 7 , 4 , 3 ]) [ 3 , 4 , 7 , 9 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def tri_bulles ( T ): ''' Renvoie le tableau T tri\u00e9 par ordre croissant ''' n = len ( T ) for i in range ( n - 1 , - 1 , - 1 ): for j in range ( i ): if T [ j ] > T [ j + 1 ]: temp = T [ j ] T [ j ] = T [ j + 1 ] T [ j + 1 ] = temp return T Markdown La fonction `tri_bulles` prend en param\u00e8tre une liste `T` d\u2019entiers non tri\u00e9s et renvoie la liste tri\u00e9e par ordre croissant. Le tri \u00e0 bulles est un tri en place qui commence par placer le plus grand \u00e9l\u00e9ment en derni\u00e8re position en parcourant la liste de gauche \u00e0 droite et en \u00e9changeant au passage les \u00e9l\u00e9ments voisins mal ordonn\u00e9s (si la valeur de l\u2019\u00e9l\u00e9ment d\u2019indice `i` a une valeur strictement sup\u00e9rieure \u00e0 celle de l\u2019indice `i + 1` , ils sont \u00e9chang\u00e9s). Le tri place ensuite en avant-derni\u00e8re position le plus grand \u00e9l\u00e9ment de la liste priv\u00e9e de son dernier \u00e9l\u00e9ment en proc\u00e9dant encore \u00e0 des \u00e9changes d\u2019\u00e9l\u00e9ments voisins. Ce principe est r\u00e9p\u00e9t\u00e9 jusqu\u2019\u00e0 placer le minimum en premi\u00e8re position. Exemple : pour trier la liste `[7, 9, 4, 3]` : - premi\u00e8re \u00e9tape : 7 et 9 ne sont pas \u00e9chang\u00e9s, puis 9 et 4 sont \u00e9chang\u00e9s, puis 9 et 3 sont \u00e9chang\u00e9s, la liste est alors `[7, 4, 3, 9]` - deuxi\u00e8me \u00e9tape : 7 et 4 sont \u00e9chang\u00e9s, puis 7 et 3 sont \u00e9chang\u00e9s, la liste est alors `[4, 3, 7, 9]` - troisi\u00e8me \u00e9tape : 4 et 3 sont \u00e9chang\u00e9s, la liste est alors `[3, 4, 7, 9]` Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles. ```python linenums='1' def tri_bulles(T): ''' Renvoie le tableau T tri\u00e9 par ordre croissant ''' n = len(T) for i in range(...,...,-1): for j in range(i): if T[j] > T[...]: ... = T[j] T[j] = T[...] T[j+1] = temp return T Exemples : \ud83d\udc0d Script Python >>> tri_bulles ([]) [] >>> tri_bulles ([ 7 ]) [ 7 ] >>> tri_bulles ([ 9 , 3 , 7 , 2 , 3 , 1 , 6 ]) [ 1 , 2 , 3 , 3 , 6 , 7 , 9 ] >>> tri_bulles ([ 9 , 7 , 4 , 3 ]) [ 3 , 4 , 7 , 9 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 43.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-44", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 44"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-441", "text": "Exercice 44.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer une fonction renverse , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide mot et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene mot . Exemple : \ud83d\udc0d Script Python >>> renverse ( \"informatique\" ) \"euqitamrofni\" \ud83d\udc0d Script Python 1 2 3 4 5 def renverse ( mot ): sol = '' for lettre in mot : sol = lettre + sol return sol \ud83d\udccb Texte Programmer une fonction `renverse`, prenant en param\u00e8tre une cha\u00eene de caract\u00e8res non vide `mot` et renvoie une cha\u00eene de caract\u00e8res en inversant ceux de la cha\u00eene `mot`. Exemple : ```python >>> renverse(\"informatique\") \"euqitamrofni\" ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 44.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-442", "text": "Exercice 44.2 \u00c9nonc\u00e9 Correction Sources Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre n fix\u00e9. On consid\u00e8re pour cela un tableau tab de n bool\u00e9ens, initialement tous \u00e9gaux \u00e0 True , sauf tab[0] et tab[1] qui valent False , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice i : si tab[i] vaut True : le nombre i est premier et on donne la valeur False \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de i , \u00e0 partir de 2*i (c\u2019est-\u00e0-dire 2*i , 3*i ...). si tab[i] vaut False : le nombre i n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction crible , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier n strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que n . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( n ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * n tab [ 0 ], tab [ 1 ] = False , False for i in range ( ... , n ): if tab [ i ] == ... : premiers . append ( ... ) for multiple in range ( 2 * i , n , ... ): tab [ multiple ] = ... return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Compl\u00e9ter le code de cette fonction. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def crible ( n ): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [ True ] * n tab [ 0 ], tab [ 1 ] = False , False for i in range ( 2 , n ): if tab [ i ] == True : premiers . append ( i ) for multiple in range ( 2 * i , n , i ): tab [ multiple ] = False return premiers assert crible ( 40 ) == [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre `n` fix\u00e9. On consid\u00e8re pour cela un tableau `tab` de `n` bool\u00e9ens, initialement tous \u00e9gaux \u00e0 `True` , sauf `tab[0]` et `tab[1]` qui valent `False` , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice `i` : - si `tab[i]` vaut `True` : le nombre `i` est premier et on donne la valeur `False` \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de `i` , \u00e0 partir de `2*i` (c\u2019est-\u00e0-dire `2*i` , `3*i` ...). - si `tab[i]` vaut `False` : le nombre `i` n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction `crible` , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier `n` strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que `n` . ```python linenums='1' def crible(n): \"\"\" Renvoie un tableau contenant tous les nombres premiers plus petits que N \"\"\" premiers = [] tab = [True] * n tab[0], tab[1] = False, False for i in range(..., n): if tab[i] == ...: premiers.append(...) for multiple in range(2*i, n, ...): tab[multiple] = ... return premiers assert crible(40) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] Compl\u00e9ter le code de cette fonction. ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 44.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#sujet-45", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 45"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-451", "text": "Exercice 45.1 \u00c9nonc\u00e9 Correction Source Markdown On veut trier par ordre croissant les notes d\u2019une \u00e9valuation qui sont des nombres entiers compris entre 0 et 10 (inclus). Ces notes sont contenues dans une liste notes_eval . \u00c9crire une fonction rangement_valeurs prenant en param\u00e8tre la liste notes_eval et renvoyant une liste de longueur 11 telle que la valeur de cette liste \u00e0 chaque rang est \u00e9gale au nombre de notes valant ce rang. Ainsi le terme de rang 0 indique le nombre de note 0, le terme de rang 1 le nombre de note 1, etc. \u00c9crire ensuite une fonction notes_triees prenant en param\u00e8tre la liste des effectifs des notes et renvoyant une liste contenant la liste, tri\u00e9e dans l\u2019ordre croissant, des notes des \u00e9l\u00e8ves. Exemple : \ud83d\udc0d Script Python >>> notes_eval = [ 2 , 0 , 5 , 9 , 6 , 9 , 10 , 5 , 7 , 9 , 9 , 5 , 0 , 9 , 6 , 5 , 4 ] >>> effectifs_notes = rangement_valeurs ( notes_eval ) >>> effectifs_notes [ 2 , 0 , 1 , 0 , 1 , 4 , 2 , 1 , 0 , 5 , 1 ] >>> notes_triees ( effectifs_notes ) [ 0 , 0 , 2 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 7 , 9 , 9 , 9 , 9 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def rangement_valeurs ( notes_eval ): lst = [ 0 ] * 11 for note in notes_eval : lst [ note ] += 1 return lst def notes_triees ( effectifs_notes ): triees = [] for i in range ( 11 ): if effectifs_notes [ i ] != 0 : for _ in range ( effectifs_notes [ i ]): triees . append ( i ) return triees \ud83d\udccb Texte On veut trier par ordre croissant les notes d\u2019une \u00e9valuation qui sont des nombres entiers compris entre 0 et 10 (inclus). Ces notes sont contenues dans une liste `notes_eval`. \u00c9crire une fonction `rangement_valeurs` prenant en param\u00e8tre la liste `notes_eval` et renvoyant une liste de longueur 11 telle que la valeur de cette liste \u00e0 chaque rang est \u00e9gale au nombre de notes valant ce rang. Ainsi le terme de rang 0 indique le nombre de note 0, le terme de rang 1 le nombre de note 1, etc. \u00c9crire ensuite une fonction `notes_triees` prenant en param\u00e8tre la liste des effectifs des notes et renvoyant une liste contenant la liste, tri\u00e9e dans l\u2019ordre croissant, des notes des \u00e9l\u00e8ves. Exemple : ```python >>> notes_eval = [2, 0, 5, 9, 6, 9, 10, 5, 7, 9, 9, 5, 0, 9, 6, 5, 4] >>> effectifs_notes = rangement_valeurs(notes_eval) >>> effectifs_notes [2, 0, 1, 0, 1, 4, 2, 1, 0, 5, 1] >>> notes_triees(effectifs_notes) [0, 0, 2, 4, 5, 5, 5, 5, 6, 6, 7, 9, 9, 9, 9, 9, 10] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 45.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2023/#exercice-452", "text": "Exercice 45.2 \u00c9nonc\u00e9 Correction Sources Markdown L\u2019objectif de cet exercice est d\u2019\u00e9crire deux fonctions r\u00e9cursives dec_to_bin et bin_to_dec assurant respectivement la conversion de l\u2019\u00e9criture d\u00e9cimale d\u2019un nombre entier vers son \u00e9criture en binaire et, r\u00e9ciproquement, la conversion de l\u2019\u00e9criture en binaire d\u2019un nombre vers son \u00e9criture d\u00e9cimale. Dans cet exercice, on s\u2019interdit l\u2019usage des fonctions Python bin et int . On rappelle sur l\u2019exemple ci-dessous une fa\u00e7on d\u2019obtenir l\u2019\u00e9criture en binaire du nombre 25 : \\(25 = 1 + 2 \\times 12\\) \\(\\phantom{25} = 1 + 2 \\times 12\\) \\(\\phantom{25} = 1 + 2 (0 + 2 \\times 6)\\) \\(\\phantom{25} = 1 + 2 (0 + 2 (0 + 2 \\times 3))\\) \\(\\phantom{25} = 1 + 2 (0 + 2 (0 + 2 (1 + 2 \\times 1)))\\) \\(\\phantom{25} = 1 \\times 2^0 + 0 \\times 2^1 + 0 \\times 2^2 + 1 \\times 2^3 + 1 \\times 2^4\\) L'\u00e9criture binaire de 25 est donc 11001 . 0n rappelle \u00e9galement que : a // 2 renvoie le quotient de la division euclidienne de a par 2. a % 2 renvoie le reste dans la division euclidienne de a par 2. On indique enfin qu\u2019en Python si mot = \"informatique\" alors : mot[-1] renvoie 'e' , c\u2019est-\u00e0-dire le dernier caract\u00e8re de la cha\u00eene de caract\u00e8res mot . mot[:-1] renvoie 'informatiqu' , c\u2019est-\u00e0-dire l\u2019ensemble de la cha\u00eene de caract\u00e8res mot priv\u00e9e de son dernier caract\u00e8re. Compl\u00e9ter, puis tester, les codes de deux fonctions ci-dessous. On pr\u00e9cise que la fonction r\u00e9cursive dec_to_bin prend en param\u00e8tre un nombre entier et renvoie une cha\u00eene de caract\u00e8res contenant l\u2019\u00e9criture en binaire du nombre pass\u00e9 en param\u00e8tre. Exemple : \ud83d\udc0d Script Python >>> dec_to_bin ( 25 ) '11001' La fonction r\u00e9cursive bin_to_dec prend en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019\u00e9criture d\u2019un nombre en binaire et renvoie l\u2019\u00e9criture d\u00e9cimale de ce nombre. \ud83d\udc0d Script Python >>> bin_to_dec ( '101010' ) 42 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == ... : return str ( r ) else : return dec_to_bin ( ... ) + ... def bin_to_dec ( nb_bin ): if nb_bin == '0' : return 0 elif ... : return 1 else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : bit_droit = ... return ... * bin_to_dec ( nb_bin [: - 1 ]) + ... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == 0 : return str ( r ) else : return dec_to_bin ( q ) + str ( r ) def bin_to_dec ( nb_bin ): if nb_bin == '0' : return 0 elif nb_bin == '1' : return 1 else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : bit_droit = 1 return 2 * bin_to_dec ( nb_bin [: - 1 ]) + bit_droit Markdown L\u2019objectif de cet exercice est d\u2019\u00e9crire deux fonctions r\u00e9cursives `dec_to_bin` et `bin_to_dec` assurant respectivement la conversion de l\u2019\u00e9criture d\u00e9cimale d\u2019un nombre entier vers son \u00e9criture en binaire et, r\u00e9ciproquement, la conversion de l\u2019\u00e9criture en binaire d\u2019un nombre vers son \u00e9criture d\u00e9cimale. Dans cet exercice, on s\u2019interdit l\u2019usage des fonctions Python `bin` et `int` . On rappelle sur l\u2019exemple ci-dessous une fa\u00e7on d\u2019obtenir l\u2019\u00e9criture en binaire du nombre 25 : $25 = 1 + 2 \\times 12$ $\\phantom{25} = 1 + 2 \\times 12$ $\\phantom{25} = 1 + 2 (0 + 2 \\times 6)$ $\\phantom{25} = 1 + 2 (0 + 2 (0 + 2 \\times 3))$ $\\phantom{25} = 1 + 2 (0 + 2 (0 + 2 (1 + 2 \\times 1)))$ $\\phantom{25} = 1 \\times 2^0 + 0 \\times 2^1 + 0 \\times 2^2 + 1 \\times 2^3 + 1 \\times 2^4$ L'\u00e9criture binaire de 25 est donc ```11001```. 0n rappelle \u00e9galement que : - `a // 2` renvoie le quotient de la division euclidienne de `a` par 2. - ` a % 2` renvoie le reste dans la division euclidienne de `a` par 2. On indique enfin qu\u2019en Python si `mot = \"informatique\"` alors : - `mot[-1]` renvoie `'e'` , c\u2019est-\u00e0-dire le dernier caract\u00e8re de la cha\u00eene de caract\u00e8res `mot` . - `mot[:-1]` renvoie `'informatiqu'` , c\u2019est-\u00e0-dire l\u2019ensemble de la cha\u00eene de caract\u00e8res `mot` priv\u00e9e de son dernier caract\u00e8re. Compl\u00e9ter, puis tester, les codes de deux fonctions ci-dessous. On pr\u00e9cise que la fonction r\u00e9cursive `dec_to_bin` prend en param\u00e8tre un nombre entier et renvoie une cha\u00eene de caract\u00e8res contenant l\u2019\u00e9criture en binaire du nombre pass\u00e9 en param\u00e8tre. Exemple : ```python >>> dec_to_bin(25) '11001' La fonction r\u00e9cursive bin_to_dec prend en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019\u00e9criture d\u2019un nombre en binaire et renvoie l\u2019\u00e9criture d\u00e9cimale de ce nombre. \ud83d\udc0d Script Python >>> bin_to_dec ( '101010' ) 42 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == ... : return str ( r ) else : return dec_to_bin ( ... ) + ... def bin_to_dec ( nb_bin ): if nb_bin == '0' : return 0 elif ... : return 1 else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : bit_droit = ... return ... * bin_to_dec ( nb_bin [: - 1 ]) + ... ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 45.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/", "text": "\u00c9preuve Pratique BNS 2024 \u2693\ufe0e Les sujets ci-dessous correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 21/03/2024 . T\u00e9l\u00e9chargements Une archive contenant les 48 dossiers (contenant chacun le sujet en .pdf et le script en .py ) : BNS_2024.zip (1,6 Mo) Un pdf unique de tous les sujets : BNS_2024_pdf_unique.pdf (2,1 Mo) \u25b6 Sujet 01 \u2693\ufe0e Version originale du sujet en pdf. Exercice 01.1 \u2693\ufe0e Exercice 01.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. On utilise la valeur '' pour repr\u00e9senter un fils vide. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre non vide sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153uds. On observe que, par exemple, arbre[lettre][0] , respectivement arbre[lettre][1] , permet d\u2019atteindre la cl\u00e9 du sous-arbre gauche, respectivement droit, de l\u2019arbre arbre de sommet lettre . Exemple : \ud83d\udc0d Script Python >>> taille ( a , 'F' ) 9 >>> taille ( a , 'B' ) 5 >>> taille ( a , 'I' ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): if lettre == '' : return 0 return 1 + taille ( arbre , arbre [ lettre ][ 0 ]) + taille ( arbre , arbre [ lettre ][ 1 ]) \ud83d\udccb Texte Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. On utilise la valeur `''` pour repr\u00e9senter un fils vide. Par exemple, l\u2019arbre ![image](data2023/33_arbre.png){: .center} est stock\u00e9 dans ```python a = {'F':['B','G'], 'B':['A','D'], 'A':['',''], 'D':['C','E'], \\ 'C':['',''], 'E':['',''], 'G':['','I'], 'I':['','H'], \\ 'H':['','']} ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tres un arbre binaire `arbre` non vide sous la forme d\u2019un dictionnaire et un caract\u00e8re `lettre` qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153uds. On observe que, par exemple, `arbre[lettre][0]`, respectivement `arbre[lettre][1]`, permet d\u2019atteindre la cl\u00e9 du sous-arbre gauche, respectivement droit, de l\u2019arbre `arbre` de sommet `lettre`. Exemple : ```python >>> taille(a, 'F') 9 >>> taille(a, 'B') 5 >>> taille(a, 'I') 2 ``` R\u00e9digez votre code sur Basthon Exercice 01.2 \u2693\ufe0e Exercice 01.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt le sous- tableau des \u00e9l\u00e9ments non rang\u00e9s et on place le plus petit \u00e9l\u00e9ment en premi\u00e8re position de ce sous-tableau. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus petit \u00e9l\u00e9ment avec le premier. Le tableau devient t = [6, 55, 21, 18, 12, 41, 25] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le premier , on permute le plus petit \u00e9l\u00e9ment trouv\u00e9 avec le second. Le tableau devient : t = [6, 12, 21, 18, 55, 41, 25] Et ainsi de suite. Le programme ci-dessous impl\u00e9mente cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def echange ( tab , i , j ): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = ... tab [ i ] = ... tab [ j ] = ... def tri_selection ( tab ): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri par s\u00e9lection.''' N = len ( tab ) for k in range ( ... ): imin = ... for i in range ( ... , N ): if tab [ i ] < ... : imin = i echange ( tab , ... , ... ) Compl\u00e9ter le code de cette fonction de fa\u00e7on \u00e0 obtenir : \ud83d\udc0d Script Python >>> liste = [ 41 , 55 , 21 , 18 , 12 , 6 , 25 ] >>> tri_selection ( liste ) >>> liste [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def echange ( tab , i , j ): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = tab [ i ] tab [ i ] = tab [ j ] tab [ j ] = temp def tri_selection ( tab ): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri par s\u00e9lection.''' N = len ( tab ) for k in range ( N ): imin = k for i in range ( k + 1 , N ): if tab [ i ] < tab [ imin ]: imin = i echange ( tab , k , imin ) Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt le sous- tableau des \u00e9l\u00e9ments non rang\u00e9s et on place le plus petit \u00e9l\u00e9ment en premi\u00e8re position de ce sous-tableau. Exemple avec le tableau : ```t = [41, 55, 21, 18, 12, 6, 25]``` - \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus petit \u00e9l\u00e9ment avec le premier. Le tableau devient `t = [6, 55, 21, 18, 12, 41, 25]` - \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments **sauf le premier** , on permute le plus petit \u00e9l\u00e9ment trouv\u00e9 avec le second. Le tableau devient : ```t = [6, 12, 21, 18, 55, 41, 25]``` Et ainsi de suite. Le programme ci-dessous impl\u00e9mente cet algorithme. ```python linenums='1' def echange(tab, i, j): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = ... tab[i] = ... tab[j] = ... def tri_selection(tab): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri par s\u00e9lection.''' N = len(tab) for k in range(...): imin = ... for i in range(..., N): if tab[i] < ...: imin = i echange(tab, ..., ...) Compl\u00e9ter le code de cette fonction de fa\u00e7on \u00e0 obtenir : \ud83d\udc0d Script Python >>> liste = [ 41 , 55 , 21 , 18 , 12 , 6 , 25 ] >>> tri_selection ( liste ) >>> liste [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 02 \u2693\ufe0e Version originale du sujet en pdf. Exercice 02.1 \u2693\ufe0e Exercice 02.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des carac- t\u00e8res * appel\u00e9es mots \u00e0 trous . Par exemple INFO*MA*IQUE , ***I***E** et *S* sont des mots \u00e0 trous. Programmer une fonction correspond qui : prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res mot et mot_a_trous o\u00f9 mot_a_trous est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, renvoie : True si on peut obtenir mot en rempla\u00e7ant convenablement les caract\u00e8res '*' de mot_a_trous . False sinon. Exemple : \ud83d\udc0d Script Python >>> correspond ( 'INFORMATIQUE' , 'INFO*MA*IQUE' ) True >>> correspond ( 'AUTOMATIQUE' , 'INFO*MA*IQUE' ) False >>> correspond ( 'STOP' , 'S*' ) False >>> correspond ( 'AUTO' , '*UT*' ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def correspond ( mot , mot_a_trous ): if len ( mot ) != len ( mot_a_trous ): return False for i in range ( len ( mot )): if mot [ i ] != mot_a_trous [ i ] and mot_a_trous [ i ] != '*' : return False return True \ud83d\udccb Texte On consid\u00e8re des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des carac- t\u00e8res `*` appel\u00e9es *mots \u00e0 trous*. Par exemple `INFO*MA*IQUE`, `***I***E**` et `*S*` sont des mots \u00e0 trous. Programmer une fonction `correspond` qui : - prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res `mot` et `mot_a_trous` o\u00f9 `mot_a_trous` est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, - renvoie : - `True` si on peut obtenir `mot` en rempla\u00e7ant convenablement les caract\u00e8res `'*'` de `mot_a_trous`. - `False` sinon. Exemple : ```python >>> correspond('INFORMATIQUE', 'INFO*MA*IQUE') True >>> correspond('AUTOMATIQUE', 'INFO*MA*IQUE') False >>> correspond('STOP', 'S*') False >>> correspond('AUTO', '*UT*') True ``` R\u00e9digez votre code sur Basthon Exercice 02.2 \u2693\ufe0e Exercice 02.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : chaque personne ne peut envoyer des messages qu'\u00e0 une seule personne (\u00e9ventuellement elle-m\u00eame), chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : A envoie ses messages \u00e0 E E envoie ses messages \u00e0 B B envoie ses messages \u00e0 F F envoie ses messages \u00e0 A C envoie ses messages \u00e0 D D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'} Un cycle est une suite de personnes dans laquelle la derni\u00e8re est la m\u00eame que la premi\u00e8re. Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'} comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle , on dit que le plan d\u2019envoi est cyclique . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : on part d\u2019un exp\u00e9diteur (ici A) et on inspecte son destinataire dans le plan d'envoi, chaque destinataire devient \u00e0 son tour exp\u00e9diteur, selon le plan d\u2019envoi, tant qu\u2019on ne \u00ab retombe \u00bb pas sur l\u2019exp\u00e9diteur initial, le plan d\u2019envoi est cyclique si on l\u2019a parcouru en entier. Compl\u00e9ter la fonction est_cyclique en respectant la sp\u00e9cification. On rappelle que la fonction Python len permet d'obtenir la longueur d'un dictionnaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def est_cyclique ( plan ): '''Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon.''' expediteur = 'A' destinataire = plan [ ... ] nb_destinataires = 1 while destinataire != expediteur : destinataire = ... nb_destinataires = ... return nb_destinataires == ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def est_cyclique ( plan ): '''Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon.''' expediteur = 'A' destinataire = plan [ expediteur ] nb_destinaires = 1 while destinataire != expediteur : destinataire = plan [ destinataire ] nb_destinaires += 1 return nb_destinaires == len ( plan ) #tests print ( est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' })) print ( est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' })) Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : - chaque personne ne peut envoyer des messages qu'\u00e0 une seule personne (\u00e9ventuellement elle-m\u00eame), - chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : - A envoie ses messages \u00e0 E - E envoie ses messages \u00e0 B - B envoie ses messages \u00e0 F - F envoie ses messages \u00e0 A - C envoie ses messages \u00e0 D - D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : `plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'}` Un cycle est une suite de personnes dans laquelle la derni\u00e8re est la m\u00eame que la premi\u00e8re. Sur le plan d'envoi `plan_a` des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi `plan_b` ci-dessous : `plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'}` comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un *unique cycle* , on dit que le plan d\u2019envoi est *cyclique* . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : - on part d\u2019un exp\u00e9diteur (ici A) et on inspecte son destinataire dans le plan d'envoi, - chaque destinataire devient \u00e0 son tour exp\u00e9diteur, selon le plan d\u2019envoi, tant qu\u2019on ne \u00ab retombe \u00bb pas sur l\u2019exp\u00e9diteur initial, - le plan d\u2019envoi est cyclique si on l\u2019a parcouru en entier. Compl\u00e9ter la fonction `est_cyclique` en respectant la sp\u00e9cification. On rappelle que la fonction Python `len` permet d'obtenir la longueur d'un dictionnaire. ```python linenums='1' def est_cyclique(plan): '''Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon.''' expediteur = 'A' destinataire = plan[...] nb_destinataires = 1 while destinataire != expediteur: destinataire = ... nb_destinataires = ... return nb_destinataires == ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 03 \u2693\ufe0e Version originale du sujet en pdf. Exercice 03.1 \u2693\ufe0e Exercice 03.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire la fonction maximum_tableau , prenant en param\u00e8tre un tableau non vide de nombres tab (de type list ) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : \ud83d\udc0d Script Python >>> maximum_tableau ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maximum_tableau ([ - 27 , 24 , - 3 , 15 ]) 24 \ud83d\udc0d Script Python 1 2 3 4 5 6 def maximum_tableau ( tab ): maximum = tab [ 0 ] for element in tab : if element > maximum : maximum = element return maximum \ud83d\udccb Texte \u00c9crire la fonction `maximum_tableau`, prenant en param\u00e8tre un tableau non vide de nombres `tab` (de type `list`) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : ```python >>> maximum_tableau([98, 12, 104, 23, 131, 9]) 131 >>> maximum_tableau([-27, 24, -3, 15]) 24 ``` R\u00e9digez votre code sur Basthon Exercice 03.2 \u2693\ufe0e Exercice 03.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, ((()())(())) est un parenth\u00e9sage correct. Les parenth\u00e9sages ())(() et (())(() sont, eux, incorrects. On dispose du code de la classe Pile suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie un bool\u00e9en indiquant si la pile est vide.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l'\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self . est_vide () return self . contenu . pop () On souhaite programmer une fonction bon_parenthesage qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res ch form\u00e9e de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. Compl\u00e9ter le code de la fonction bon_parenthesage ci-dessous: \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def bon_parenthesage ( ch ): \"\"\"Renvoie un bool\u00e9en indiquant si la cha\u00eene ch est bien parenth\u00e9s\u00e9e\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): ... else : ... return ... Exemples : \ud83d\udc0d Script Python >>> bon_parenthesage ( \"((()())(()))\" ) True >>> bon_parenthesage ( \"())(()\" ) False >>> bon_parenthesage ( \"(())(()\" ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie un bool\u00e9en indiquant si la pile est vide.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l'\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self . est_vide () return self . contenu . pop () def bon_parenthesage ( ch ): \"\"\"Renvoie un bool\u00e9en indiquant si la cha\u00eene ch est bien parenth\u00e9s\u00e9e\"\"\" p = Pile () for c in ch : if c == '(' : p . empiler ( c ) elif c == ')' : if p . est_vide (): return False else : p . depiler () return p . est_vide () Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : - le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. - en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, `((()())(()))` est un parenth\u00e9sage correct. Les parenth\u00e9sages `())(()` et `(())(()` sont, eux, incorrects. On dispose du code de la classe `Pile` suivant : ```python linenums='1' class Pile: \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ (self): self.contenu = [] def est_vide(self): \"\"\"Renvoie un bool\u00e9en indiquant si la pile est vide.\"\"\" return self.contenu == [] def empiler(self, v): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self.contenu.append(v) def depiler(self): \"\"\" Retire et renvoie l'\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self.est_vide() return self.contenu.pop() On souhaite programmer une fonction bon_parenthesage qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res ch form\u00e9e de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. Compl\u00e9ter le code de la fonction bon_parenthesage ci-dessous: \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def bon_parenthesage ( ch ): \"\"\"Renvoie un bool\u00e9en indiquant si la cha\u00eene ch est bien parenth\u00e9s\u00e9e\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): ... else : ... return ... Exemples : \ud83d\udc0d Script Python >>> bon_parenthesage ( \"((()())(()))\" ) True >>> bon_parenthesage ( \"())(()\" ) False >>> bon_parenthesage ( \"(())(()\" ) False ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 04 \u2693\ufe0e Version originale du sujet en pdf. Exercice 04.1 \u2693\ufe0e Exercice 04.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction recherche , prenant en param\u00e8tres un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie None . Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) # renvoie None 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = None for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \ud83d\udccb Texte Programmer la fonction `recherche`, prenant en param\u00e8tres un tableau non vide `tab` (type `list`) d'entiers et un entier `n`, et qui renvoie l'indice de la **derni\u00e8re** occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie `None`. Exemples ```python >>> recherche([5, 3], 1) # renvoie None 2 >>> recherche([2, 4], 2) 0 >>> recherche([2, 3, 5, 2, 4], 2) 3 ``` R\u00e9digez votre code sur Basthon Exercice 04.2 \u2693\ufe0e Exercice 04.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) v\u00e9rifie la formule : \\[d^2=(x-x')^2+(y-y')^2\\] Compl\u00e9ter le code des fonctions distance_carre et point_le_plus_proche fournies ci-dessous pour qu\u2019elles r\u00e9pondent \u00e0 leurs sp\u00e9cifications. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def distance_carre ( point1 , point2 ): \"\"\" Calcule et renvoie la distance au carre entre deux points.\"\"\" return ( ... ) ** 2 + ( ... ) ** 2 def point_le_plus_proche ( depart , tab ): \"\"\" Renvoie les coordonn\u00e9es du premier point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" min_point = tab [ 0 ] min_dist = ... for i in range ( 1 , len ( tab )): if distance_carre ( tab [ i ], depart ) < ... : min_point = ... min_dist = ... return min_point Exemples : \ud83d\udc0d Script Python >>> distance_carre (( 1 , 0 ), ( 5 , 3 )) 25 >>> distance_carre (( 1 , 0 ), ( 0 , 1 )) 2 >>> point_le_plus_proche (( 0 , 0 ), [( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )]) ( 2 , 5 ) >>> point_le_plus_proche (( 5 , 2 ), [( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )]) ( 5 , 2 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def distance_carre ( point1 , point2 ): \"\"\" Calcule et renvoie la distance au carre entre deux points.\"\"\" return ( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 def point_le_plus_proche ( depart , tab ): \"\"\" Renvoie les coordonn\u00e9es du premier point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" min_point = tab [ 0 ] min_dist = distance_carre ( min_point , depart ) for i in range ( 1 , len ( tab )): if distance_carre ( tab [ i ], depart ) < min_dist : min_point = tab [ i ] min_dist = distance_carre ( tab [ i ], depart ) return min_point Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es $(x;y)$ et $(x';y')$ v\u00e9rifie la formule : $$d^2=(x-x')^2+(y-y')^2$$ Compl\u00e9ter le code des fonctions `distance_carre` et `point_le_plus_proche` fournies ci-dessous pour qu\u2019elles r\u00e9pondent \u00e0 leurs sp\u00e9cifications. ```python linenums='1' def distance_carre(point1, point2): \"\"\" Calcule et renvoie la distance au carre entre deux points.\"\"\" return (...)**2 + (...)**2 def point_le_plus_proche(depart, tab): \"\"\" Renvoie les coordonn\u00e9es du premier point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" min_point = tab[0] min_dist = ... for i in range(1, len(tab)): if distance_carre(tab[i], depart) < ...: min_point = ... min_dist = ... return min_point Exemples : \ud83d\udc0d Script Python >>> distance_carre (( 1 , 0 ), ( 5 , 3 )) 25 >>> distance_carre (( 1 , 0 ), ( 0 , 1 )) 2 >>> point_le_plus_proche (( 0 , 0 ), [( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )]) ( 2 , 5 ) >>> point_le_plus_proche (( 5 , 2 ), [( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )]) ( 5 , 2 ) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 05 \u2693\ufe0e Version originale du sujet en pdf. Exercice 05.1 \u2693\ufe0e Exercice 05.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction max_et_indice qui prend en param\u00e8tre un tableau non vide tab de nombres entiers et qui renvoie la valeur du plus grand \u00e9l\u00e9ment de ce tableau ainsi que l\u2019indice de sa premi\u00e8re apparition dans ce tableau. L\u2019utilisation de la fonction native max n\u2019est pas autoris\u00e9e. Exemples : \ud83d\udc0d Script Python >>> max_et_indice ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) >>> max_et_indice ([ - 2 ]) ( - 2 , 0 ) >>> max_et_indice ([ - 1 , - 1 , 3 , 3 , 3 ]) ( 3 , 2 ) >>> max_et_indice ([ 1 , 1 , 1 , 1 ]) ( 1 , 0 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def max_et_indice ( tab ): ''' renvoie la valeur du plus grand \u00e9l\u00e9ment de ce tableau ainsi que l\u2019indice de sa premi\u00e8re apparition dans ce tableau. ''' val_max = tab [ 0 ] ind_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] ind_max = i return ( val_max , ind_max ) \ud83d\udccb Texte \u00c9crire une fonction `max_et_indice` qui prend en param\u00e8tre un tableau non vide `tab` de nombres entiers et qui renvoie la valeur du plus grand \u00e9l\u00e9ment de ce tableau ainsi que l\u2019indice de sa premi\u00e8re apparition dans ce tableau. L\u2019utilisation de la fonction native `max` n\u2019est pas autoris\u00e9e. Exemples : ```python >>> max_et_indice([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) (9, 3) >>> max_et_indice([-2]) (-2, 0) >>> max_et_indice([-1, -1, 3, 3, 3]) (3, 2) >>> max_et_indice([1, 1, 1, 1]) (1, 0) ``` R\u00e9digez votre code sur Basthon Exercice 05.2 \u2693\ufe0e Exercice 05.2 \u00c9nonc\u00e9 Correction Sources Markdown L\u2019ordre des g\u00e8nes sur un chromosome est repr\u00e9sent\u00e9 par un tableau ordre de n cases d\u2019entiers distincts deux \u00e0 deux et compris entre 1 et n . Par exemple, ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9] dans le cas n = 9 . On dit qu\u2019il y a un point de rupture dans ordre dans chacune des situations suivantes : la premi\u00e8re valeur de ordre n\u2019est pas 1 ; l\u2019\u00e9cart entre deux g\u00e8nes cons\u00e9cutifs n\u2019est pas \u00e9gal \u00e0 1 ; la derni\u00e8re valeur de ordre n\u2019est pas n. Par exemple, si ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9] avec n = 9 , on a un point de rupture au d\u00e9but car 5 est diff\u00e9rent de 1 un point de rupture entre 3 et 6 (l\u2019\u00e9cart est de 3) un point de rupture entre 7 et 2 (l\u2019\u00e9cart est de 5) un point de rupture entre 1 et 8 (l\u2019\u00e9cart est de 7) Il y a donc 4 points de rupture. Compl\u00e9ter les fonctions Python est_un_ordre et nombre_points_rupture propos\u00e9es \u00e0 la page suivante pour que : la fonction est_un_ordre renvoie True si le tableau pass\u00e9 en param\u00e8tre repr\u00e9sente bien un ordre de g\u00e8nes de chromosome et False sinon ; la fonction nombre_points_rupture renvoie le nombre de points de rupture d\u2019un tableau pass\u00e9 en param\u00e8tre repr\u00e9sentant l\u2019ordre de g\u00e8nes d\u2019un chromosome. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def est_un_ordre ( tab ): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' n = len ( tab ) # les entiers vus lors du parcours vus = ... for x in tab : if x < ... or x >... or ... : return False ... . append ( ... ) return True def nombre_points_rupture ( ordre ): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' # on v\u00e9rifie que ordre est un ordre de g\u00e8nes assert ... n = len ( ordre ) nb = 0 if ordre [ ... ] != 1 : # le premier n'est pas 1 nb = nb + 1 i = 0 while i < ... : if ... not in [ - 1 , 1 ]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre [ i ] != ... : # le dernier n'est pas n nb = nb + 1 return nb Exemples : \ud83d\udc0d Script Python >>> est_un_ordre ([ 1 , 6 , 2 , 8 , 3 , 7 ]) False >>> est_un_ordre ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) True >>> nombre_points_rupture ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) 4 >>> nombre_points_rupture ([ 1 , 2 , 3 , 4 , 5 ]) 0 >>> nombre_points_rupture ([ 1 , 6 , 2 , 8 , 3 , 7 , 4 , 5 ]) 7 >>> nombre_points_rupture ([ 2 , 1 , 3 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def est_un_ordre ( tab ): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' n = len ( tab ) # les entiers vus lors du parcours vus = [] for x in tab : if x < 1 or x > n or x in vus : return False vus . append ( x ) return True def nombre_points_rupture ( ordre ): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' # on v\u00e9rifie que ordre est un ordre de g\u00e8nes assert est_un_ordre ( ordre ) n = len ( ordre ) nb = 0 if ordre [ 0 ] != 1 : # le premier n'est pas 1 nb = nb + 1 i = 0 while i < n - 1 : if ordre [ i + 1 ] - ordre [ i ] not in [ - 1 , 1 ]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre [ i ] != n : # le dernier n'est pas n nb = nb + 1 return nb Markdown L\u2019ordre des g\u00e8nes sur un chromosome est repr\u00e9sent\u00e9 par un tableau `ordre` de `n` cases d\u2019entiers distincts deux \u00e0 deux et compris entre 1 et `n` . Par exemple, `ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9]` dans le cas `n = 9` . On dit qu\u2019il y a un point de rupture dans `ordre` dans chacune des situations suivantes : - la premi\u00e8re valeur de `ordre` n\u2019est pas 1 ; - l\u2019\u00e9cart entre deux g\u00e8nes cons\u00e9cutifs n\u2019est pas \u00e9gal \u00e0 1 ; - la derni\u00e8re valeur de `ordre` n\u2019est pas n. Par exemple, si `ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9]` avec `n = 9` , on a - un point de rupture au d\u00e9but car 5 est diff\u00e9rent de 1 - un point de rupture entre 3 et 6 (l\u2019\u00e9cart est de 3) - un point de rupture entre 7 et 2 (l\u2019\u00e9cart est de 5) - un point de rupture entre 1 et 8 (l\u2019\u00e9cart est de 7) Il y a donc 4 points de rupture. Compl\u00e9ter les fonctions Python `est_un_ordre` et `nombre_points_rupture` propos\u00e9es \u00e0 la page suivante pour que : - la fonction `est_un_ordre` renvoie `True` si le tableau pass\u00e9 en param\u00e8tre repr\u00e9sente bien un ordre de g\u00e8nes de chromosome et `False` sinon ; - la fonction `nombre_points_rupture` renvoie le nombre de points de rupture d\u2019un tableau pass\u00e9 en param\u00e8tre repr\u00e9sentant l\u2019ordre de g\u00e8nes d\u2019un chromosome. ```python linenums='1' def est_un_ordre(tab): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' n = len(tab) # les entiers vus lors du parcours vus = ... for x in tab: if x < ... or x >... or ...: return False ... .append(...) return True def nombre_points_rupture(ordre): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' # on v\u00e9rifie que ordre est un ordre de g\u00e8nes assert ... n = len(ordre) nb = 0 if ordre[...] != 1: # le premier n'est pas 1 nb = nb + 1 i = 0 while i < ...: if ... not in [-1, 1]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre[i] != ...: # le dernier n'est pas n nb = nb + 1 return nb Exemples : \ud83d\udc0d Script Python >>> est_un_ordre ([ 1 , 6 , 2 , 8 , 3 , 7 ]) False >>> est_un_ordre ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) True >>> nombre_points_rupture ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) 4 >>> nombre_points_rupture ([ 1 , 2 , 3 , 4 , 5 ]) 0 >>> nombre_points_rupture ([ 1 , 6 , 2 , 8 , 3 , 7 , 4 , 5 ]) 7 >>> nombre_points_rupture ([ 2 , 1 , 3 , 4 ]) 2 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 06 \u2693\ufe0e Version originale du sujet en pdf. Exercice 06.1 \u2693\ufe0e Exercice 06.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction verifie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques et qui renvoie True si ce tableau est tri\u00e9 dans l\u2019ordre croissant, False sinon. Un tableau vide est consid\u00e9r\u00e9 comme tri\u00e9. Exemples : \ud83d\udc0d Script Python Exemples : >>> verifie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> verifie ([ 8 , 12 , 4 ]) False >>> verifie ([ - 1 , 4 ]) True >>> verifie ([]) True >>> verifie ([ 5 ]) True \ud83d\udc0d Script Python 1 2 3 4 5 def verifie ( tab ): for i in range ( 1 , len ( tab )): if tab [ i ] < tab [ i - 1 ]: return False return True \ud83d\udccb Texte \u00c9crire une fonction `verifie` qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques et qui renvoie `True` si ce tableau est tri\u00e9 dans l\u2019ordre croissant, `False` sinon. Un tableau vide est consid\u00e9r\u00e9 comme tri\u00e9. Exemples : ```python Exemples : >>> verifie([0, 5, 8, 8, 9]) True >>> verifie([8, 12, 4]) False >>> verifie([-1, 4]) True >>> verifie([]) True >>> verifie([5]) True ``` R\u00e9digez votre code sur Basthon Exercice 06.2 \u2693\ufe0e Exercice 06.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re dans cet exercice l\u2019\u00e9lection d\u2019un vainqueur \u00e0 l\u2019issue d\u2019un vote. Les r\u00e9sultats du vote sont stock\u00e9s dans un tableau : chaque vote exprim\u00e9 est le nom d\u2019un ou d\u2019une candidate. Par exemple, les r\u00e9sultats pourraient correspondre au tableau : \ud83d\udc0d Script Python urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] indiquant que 3 candidats ont obtenu au moins un vote chacun : A, B et C. On cherche \u00e0 d\u00e9terminer le ou les candidats ayant obtenu le plus de suffrages. Pour cela, on propose d\u2019\u00e9crire deux fonctions : La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des issues et les valeurs le nombre de votes en leur faveur. La fonction vainqueurs doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire non vide dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueurs ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def depouille ( urne ): '''prend en param\u00e8tre une liste de suffrages et renvoie un dictionnaire avec le nombre de voix pour chaque candidat''' resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueurs ( election ): '''prend en param\u00e8tre un dictionnaire non vide avec le nombre de voix pour chaque candidat et renvoie la liste des vainqueurs''' nmax = 0 for candidat in election : if ... > ... : nmax = ... liste_finale = [ nom for nom in election if ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> depouille ([ 'A' , 'B' , 'A' ]) { 'A' : 2 , 'B' : 1 } >>> depouille ([]) {} >>> election = depouille ([ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ]) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } >>> vainqueurs ( election ) [ 'B' ] >>> vainqueurs ({ 'A' : 2 , 'B' : 2 , 'C' : 1 }) [ 'A' , 'B' ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def depouille ( urne ): '''prend en param\u00e8tre une liste de suffrages et renvoie un dictionnaire avec le nombre de voix pour chaque candidat''' resultat = {} for bulletin in urne : if bulletin in resultat : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : resultat [ bulletin ] = 1 return resultat def vainqueurs ( election ): '''prend en param\u00e8tre un dictionnaire non vide avec le nombre de voix pour chaque candidat et renvoie la liste des vainqueurs''' nmax = 0 for candidat in election : if election [ candidat ] > nmax : nmax = election [ candidat ] liste_finale = [ nom for nom in election if election [ nom ] == nmax ] return liste_finale Markdown On consid\u00e8re dans cet exercice l\u2019\u00e9lection d\u2019un vainqueur \u00e0 l\u2019issue d\u2019un vote. Les r\u00e9sultats du vote sont stock\u00e9s dans un tableau : chaque vote exprim\u00e9 est le nom d\u2019un ou d\u2019une candidate. Par exemple, les r\u00e9sultats pourraient correspondre au tableau : ```python urne = ['A', 'A', 'A', 'B', 'C', 'B', 'C', 'B', 'C', 'B'] indiquant que 3 candidats ont obtenu au moins un vote chacun : A, B et C. On cherche \u00e0 d\u00e9terminer le ou les candidats ayant obtenu le plus de suffrages. Pour cela, on propose d\u2019\u00e9crire deux fonctions : La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des issues et les valeurs le nombre de votes en leur faveur. La fonction vainqueurs doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire non vide dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueurs ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def depouille ( urne ): '''prend en param\u00e8tre une liste de suffrages et renvoie un dictionnaire avec le nombre de voix pour chaque candidat''' resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueurs ( election ): '''prend en param\u00e8tre un dictionnaire non vide avec le nombre de voix pour chaque candidat et renvoie la liste des vainqueurs''' nmax = 0 for candidat in election : if ... > ... : nmax = ... liste_finale = [ nom for nom in election if ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> depouille ([ 'A' , 'B' , 'A' ]) { 'A' : 2 , 'B' : 1 } >>> depouille ([]) {} >>> election = depouille ([ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ]) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } >>> vainqueurs ( election ) [ 'B' ] >>> vainqueurs ({ 'A' : 2 , 'B' : 2 , 'C' : 1 }) [ 'A' , 'B' ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 07 \u2693\ufe0e Version originale du sujet en pdf. Exercice 07.1 \u2693\ufe0e Exercice 07.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re dans cet exercice une repr\u00e9sentation binaire d\u2019un entier non sign\u00e9 en tant que tableau de bool\u00e9ens. Si \ud83d\udc0d Script Python tab = [ True , False , True , False , False , True , True ] est un tel tableau, alors l\u2019entier qu\u2019il repr\u00e9sente est \\(2^6 +2^4 + 2^1 + 2^0 = 83\\) . Cette repr\u00e9sentation consistant \u00e0 placer en premier le bool\u00e9en indiquant la puissance la plus \u00e9lev\u00e9e de 2 est dite big-endian ou grand-boutiste. \u00c9crire une fonction gb_vers_entier qui prend en param\u00e8tre un tel tableau et renvoie l\u2019entier qu\u2019il repr\u00e9sente. Exemple : \ud83d\udc0d Script Python >>> gb_vers_entier ([]) 0 >>> gb_vers_entier ([ True ]) 1 >>> gb_vers_entier ([ True , False , True , False , False , True , True ]) 83 >>> gb_vers_entier ([ True , False , False , False , False , False , True , False ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 def gb_vers_entier ( tab ): somme = 0 for i in range ( len ( tab )): if tab [ i ]: somme += 2 ** ( len ( tab ) - 1 - i ) return somme \ud83d\udccb Texte On consid\u00e8re dans cet exercice une repr\u00e9sentation binaire d\u2019un entier non sign\u00e9 en tant que tableau de bool\u00e9ens. Si ```python tab = [True, False, True, False, False, True, True] ``` est un tel tableau, alors l\u2019entier qu\u2019il repr\u00e9sente est $2^6 +2^4 + 2^1 + 2^0 = 83$. Cette repr\u00e9sentation consistant \u00e0 placer en premier le bool\u00e9en indiquant la puissance la plus \u00e9lev\u00e9e de 2 est dite *big-endian* ou grand-boutiste. \u00c9crire une fonction `gb_vers_entier` qui prend en param\u00e8tre un tel tableau et renvoie l\u2019entier qu\u2019il repr\u00e9sente. Exemple : ```python >>> gb_vers_entier([]) 0 >>> gb_vers_entier([True]) 1 >>> gb_vers_entier([True, False, True, False, False, True, True]) 83 >>> gb_vers_entier([True, False, False, False, False, False, True, False]) 130 ``` R\u00e9digez votre code sur Basthon Exercice 07.2 \u2693\ufe0e Exercice 07.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_insertion suivante prend en argument un tableau tab et trie ce tableau en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. On rappelle le principe du tri par insertion : on consid\u00e8re les \u00e9l\u00e9ments \u00e0 trier un par un, le premier \u00e9l\u00e9ment constituant, \u00e0 lui tout seul, un tableau tri\u00e9 de longueur 1. On range ensuite le second \u00e9l\u00e9ment pour constituer un tableau tri\u00e9 de longueur 2, puis on range le troisi\u00e8me \u00e9l\u00e9ment pour avoir un tableau tri\u00e9 de longueur 3 et ainsi de suite... A chaque \u00e9tape, le premier \u00e9l\u00e9ment du sous-tableau non tri\u00e9 est plac\u00e9 dans le sous-tableau des \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s de sorte que ce sous-tableau demeure tri\u00e9. Le principe du tri par insertion est donc d'ins\u00e9rer \u00e0 la n-i\u00e8me it\u00e9ration, le n-i\u00e8me \u00e9l\u00e9ment \u00e0 la bonne place. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tri_insertion ( tab ): '''Trie le tableau tab par ordre croissant en appliquant l'algorithme de tri par insertion''' n = len ( tab ) for i in range ( 1 , n ): valeur_insertion = ... # la variable j sert \u00e0 d\u00e9terminer # o\u00f9 placer la valeur \u00e0 ranger j = ... # tant qu'on n'a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 # ins\u00e9rer on d\u00e9cale les valeurs du tableau vers la droite while j > ... and valeur_insertion < tab [ ... ]: tab [ j ] = tab [ j - 1 ] j = ... tab [ j ] = ... Exemples : \ud83d\udc0d Script Python >>> tab = [ 98 , 12 , 104 , 23 , 131 , 9 ] >>> tri_insertion ( tab ) >>> tab [ 9 , 12 , 23 , 98 , 104 , 131 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tri_insertion ( tab ): '''Trie le tableau tab par ordre croissant en appliquant l'algorithme de tri par insertion''' n = len ( tab ) for i in range ( 1 , n ): valeur_insertion = tab [ i ] # la variable j sert \u00e0 d\u00e9terminer # o\u00f9 placer la valeur \u00e0 ranger j = i # tant qu'on n'a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 # ins\u00e9rer on d\u00e9cale les valeurs du tableau vers la droite while j > 0 and valeur_insertion < tab [ j - 1 ]: tab [ j ] = tab [ j - 1 ] j = j - 1 tab [ j ] = valeur_insertion Markdown La fonction `tri_insertion` suivante prend en argument un tableau `tab` et trie ce tableau en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. On rappelle le principe du tri par insertion : on consid\u00e8re les \u00e9l\u00e9ments \u00e0 trier un par un, le premier \u00e9l\u00e9ment constituant, \u00e0 lui tout seul, un tableau tri\u00e9 de longueur 1. On range ensuite le second \u00e9l\u00e9ment pour constituer un tableau tri\u00e9 de longueur 2, puis on range le troisi\u00e8me \u00e9l\u00e9ment pour avoir un tableau tri\u00e9 de longueur 3 et ainsi de suite... A chaque \u00e9tape, le premier \u00e9l\u00e9ment du sous-tableau non tri\u00e9 est plac\u00e9 dans le sous-tableau des \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s de sorte que ce sous-tableau demeure tri\u00e9. Le principe du tri par insertion est donc d'ins\u00e9rer \u00e0 la n-i\u00e8me it\u00e9ration, le n-i\u00e8me \u00e9l\u00e9ment \u00e0 la bonne place. ```python linenums='1' def tri_insertion(tab): '''Trie le tableau tab par ordre croissant en appliquant l'algorithme de tri par insertion''' n = len(tab) for i in range(1, n): valeur_insertion = ... # la variable j sert \u00e0 d\u00e9terminer # o\u00f9 placer la valeur \u00e0 ranger j = ... # tant qu'on n'a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 # ins\u00e9rer on d\u00e9cale les valeurs du tableau vers la droite while j > ... and valeur_insertion < tab[...]: tab[j] = tab[j-1] j = ... tab[j] = ... Exemples : \ud83d\udc0d Script Python >>> tab = [ 98 , 12 , 104 , 23 , 131 , 9 ] >>> tri_insertion ( tab ) >>> tab [ 9 , 12 , 23 , 98 , 104 , 131 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 08 \u2693\ufe0e Version originale du sujet en pdf. Exercice 08.1 \u2693\ufe0e Exercice 08.1 \u00c9nonc\u00e9 Correction Source Markdown Le codage par diff\u00e9rence ( delta encoding en anglais) permet de compresser un tableau d\u2019entiers dont les valeurs sont proches les unes des autres. Le principe est de stocker la premi\u00e8re donn\u00e9e en indiquant pour chaque autre donn\u00e9e sa diff\u00e9rence avec la pr\u00e9c\u00e9dente plut\u00f4t que la donn\u00e9e elle-m\u00eame. On se retrouve alors avec un tableau de donn\u00e9es plus petit, n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta(liste) qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : \ud83d\udc0d Script Python >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] \ud83d\udc0d Script Python 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff \ud83d\udccb Texte Le codage par diff\u00e9rence (*delta encoding* en anglais) permet de compresser un tableau d\u2019entiers dont les valeurs sont proches les unes des autres. Le principe est de stocker la premi\u00e8re donn\u00e9e en indiquant pour chaque autre donn\u00e9e sa diff\u00e9rence avec la pr\u00e9c\u00e9dente plut\u00f4t que la donn\u00e9e elle-m\u00eame. On se retrouve alors avec un tableau de donn\u00e9es plus petit, n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction `delta(liste)` qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : ```python >>> delta([1000, 800, 802, 1000, 1003]) [1000, -200, 2, 198, 3] >>> delta([42]) [42] ``` R\u00e9digez votre code sur Basthon Exercice 08.2 \u2693\ufe0e Exercice 08.2 \u00c9nonc\u00e9 Correction Sources Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212, \u00d7, \u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[(3 \\times (8 + 7)) \u2212 (2 + 1)\\] La classe Expr ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire pour repr\u00e9senter de telles expressions. Compl\u00e9ter la m\u00e9thode r\u00e9cursive infixe qui renvoie une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses repr\u00e9sentant l\u2019expression arithm\u00e9tique sur laquelle on l\u2019applique. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Expr : \"\"\"Classe impl\u00e9mentant un arbre d'expression.\"\"\" def __init__ ( self , g , v , d ): \"\"\"un objet Expr poss\u00e8de 3 attributs : - gauche : la sous-expression gauche ; - valeur : la valeur de l'\u00e9tiquette, op\u00e9rande ou nombre ; - droite : la sous-expression droite.\"\"\" self . gauche = g self . valeur = v self . droite = d def est_une_feuille ( self ): \"\"\"renvoie True si et seulement si le noeud est une feuille\"\"\" return self . gauche is None and self . droite is None def infixe ( self ): \"\"\"renvoie la repr\u00e9sentation infixe de l'expression en chaine de caract\u00e8res\"\"\" s = ... if self . gauche is not None : s = '(' + s + ... . infixe () s = s + ... if ... is not None : s = s + ... + ... return s Exemples : \ud83d\udc0d Script Python >>> a = Expr ( Expr ( None , 1 , None ), '+' , Expr ( None , 2 , None )) >>> a . infixe () '(1+2)' >>> b = Expr ( Expr ( Expr ( None , 1 , None ), '+' , Expr ( None , 2 , None )), '*' , Expr ( Expr ( None , 3 , None ), '+' , Expr ( None , 4 , None ))) >>> b . infixe () '((1+2)*(3+4))' >>> e = Expr ( Expr ( Expr ( None , 3 , None ), '*' , Expr ( Expr ( None , 8 , None ), '+' , Expr ( None , 7 , None ))), '-' , Expr ( Expr ( None , 2 , None ), '+' , Expr ( None , 1 , None ))) >>> e . infixe () '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Expr : \"\"\"Classe impl\u00e9mentant un arbre d'expression.\"\"\" def __init__ ( self , g , v , d ): \"\"\"un objet Expr poss\u00e8de 3 attributs : - gauche : la sous-expression gauche ; - valeur : la valeur de l'\u00e9tiquette, op\u00e9rande ou nombre ; - droite : la sous-expression droite.\"\"\" self . gauche = g self . valeur = v self . droite = d def est_une_feuille ( self ): \"\"\"renvoie True si et seulement si le noeud est une feuille\"\"\" return self . gauche is None and self . droite is None def infixe ( self ): \"\"\"renvoie la repr\u00e9sentation infixe de l'expression en chaine de caract\u00e8res\"\"\" s = '' if self . gauche is not None : s = '(' + s + self . gauche . infixe () s = s + str ( self . valeur ) if self . droite is not None : s = s + self . droite . infixe () + ')' return s Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212, \u00d7, \u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. ![ image ]( data2023/21_arbre.png ){: .center width=30%} En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : $$(3 \\times (8 + 7)) \u2212 (2 + 1)$$ La classe `Expr` ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire pour repr\u00e9senter de telles expressions. Compl\u00e9ter la m\u00e9thode r\u00e9cursive `infixe` qui renvoie une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses repr\u00e9sentant l\u2019expression arithm\u00e9tique sur laquelle on l\u2019applique. ```python linenums='1' class Expr: \"\"\"Classe impl\u00e9mentant un arbre d'expression.\"\"\" def __init__ (self, g, v, d): \"\"\"un objet Expr poss\u00e8de 3 attributs : - gauche : la sous-expression gauche ; - valeur : la valeur de l'\u00e9tiquette, op\u00e9rande ou nombre ; - droite : la sous-expression droite.\"\"\" self.gauche = g self.valeur = v self.droite = d def est_une_feuille(self): \"\"\"renvoie True si et seulement si le noeud est une feuille\"\"\" return self.gauche is None and self.droite is None def infixe(self): \"\"\"renvoie la repr\u00e9sentation infixe de l'expression en chaine de caract\u00e8res\"\"\" s = ... if self.gauche is not None: s = '(' + s + ... .infixe() s = s + ... if ... is not None: s = s + ... + ... return s Exemples : \ud83d\udc0d Script Python >>> a = Expr ( Expr ( None , 1 , None ), '+' , Expr ( None , 2 , None )) >>> a . infixe () '(1+2)' >>> b = Expr ( Expr ( Expr ( None , 1 , None ), '+' , Expr ( None , 2 , None )), '*' , Expr ( Expr ( None , 3 , None ), '+' , Expr ( None , 4 , None ))) >>> b . infixe () '((1+2)*(3+4))' >>> e = Expr ( Expr ( Expr ( None , 3 , None ), '*' , Expr ( Expr ( None , 8 , None ), '+' , Expr ( None , 7 , None ))), '-' , Expr ( Expr ( None , 2 , None ), '+' , Expr ( None , 1 , None ))) >>> e . infixe () '((3*(8+7))-(2+1))' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 09 \u2693\ufe0e Version originale du sujet en pdf. Exercice 09.1 \u2693\ufe0e Exercice 09.1 \u00c9nonc\u00e9 Correction Source Markdown On veut trier par ordre croissant les notes d\u2019une \u00e9valuation qui sont des nombres entiers compris entre 0 et 10 (inclus). Ces notes sont contenues dans un tableau notes_eval (type list ) \u00c9crire une fonction effectif_notes prenant en param\u00e8tre le tableau notes_eval et renvoyant un tableau de longueur 11 tel que la valeur d\u2019indice i soit le nombre de notes valant i dans le tableau notes_eval . \u00c9crire ensuite une fonction notes_triees prenant en param\u00e8tre le tableau des effectifs des notes et renvoyant un tableau contenant les m\u00eames valeurs que notes_eval mais tri\u00e9es dans l\u2019ordre croissant. Exemple : \ud83d\udc0d Script Python >>> notes_eval = [ 2 , 0 , 5 , 9 , 6 , 9 , 10 , 5 , 7 , 9 , 9 , 5 , 0 , 9 , 6 , 5 , 4 ] >>> eff = effectif_notes ( notes_eval ) >>> eff [ 2 , 0 , 1 , 0 , 1 , 4 , 2 , 1 , 0 , 5 , 1 ] >>> notes_triees ( eff ) [ 0 , 0 , 2 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 7 , 9 , 9 , 9 , 9 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def effectif_notes ( notes_eval ): tab = [ 0 ] * 11 for note in notes_eval : tab [ note ] += 1 return tab def notes_triees ( eff ): triees = [] for i in range ( 11 ): if eff [ i ] != 0 : #(1) for _ in range ( eff [ i ]): triees . append ( i ) return triees On peut ne pas effectuer ce test, car si eff[i] vaut 0, on ne rentrera pas dans la boucle for _ in range(0) et donc on ne touchera pas \u00e0 la liste triees . \ud83d\udccb Texte On veut trier par ordre croissant les notes d\u2019une \u00e9valuation qui sont des nombres entiers compris entre 0 et 10 (inclus). Ces notes sont contenues dans un tableau `notes_eval` (type `list`) \u00c9crire une fonction `effectif_notes` prenant en param\u00e8tre le tableau `notes_eval` et renvoyant un tableau de longueur 11 tel que la valeur d\u2019indice `i` soit le nombre de notes valant `i` dans le tableau `notes_eval`. \u00c9crire ensuite une fonction `notes_triees` prenant en param\u00e8tre le tableau des effectifs des notes et renvoyant un tableau contenant les m\u00eames valeurs que `notes_eval` mais tri\u00e9es dans l\u2019ordre croissant. Exemple : ```python >>> notes_eval = [2, 0, 5, 9, 6, 9, 10, 5, 7, 9, 9, 5, 0, 9, 6, 5, 4] >>> eff = effectif_notes(notes_eval) >>> eff [2, 0, 1, 0, 1, 4, 2, 1, 0, 5, 1] >>> notes_triees(eff) [0, 0, 2, 4, 5, 5, 5, 5, 6, 6, 7, 9, 9, 9, 9, 9, 10] ``` R\u00e9digez votre code sur Basthon Exercice 09.2 \u2693\ufe0e Exercice 09.2 \u00c9nonc\u00e9 Correction Sources Markdown L\u2019objectif de cet exercice est d\u2019\u00e9crire deux fonctions r\u00e9cursives dec_to_bin et bin_to_dec assurant respectivement la conversion de l\u2019\u00e9criture d\u00e9cimale d\u2019un nombre entier vers son \u00e9criture en binaire et, r\u00e9ciproquement, la conversion de l\u2019\u00e9criture en binaire d\u2019un nombre vers son \u00e9criture d\u00e9cimale. Dans cet exercice, on s\u2019interdit l\u2019usage des fonctions Python bin et int . L'exemple suivant montre comment obtenir l\u2019\u00e9criture en binaire du nombre 25 : \\(25 = 2 \\times 12 + 1\\) \\(\\phantom{25} = 2 \\times (2 \\times 6 + 0) + 1\\) \\(\\phantom{25} = 2 \\times (2 \\times (2 \\times 3 + 0) + 0) + 1\\) \\(\\phantom{25} = 2 \\times (2 \\times (2 \\times (2 \\times 1+1) + 0) + 0) + 1\\) \\(\\phantom{25} = 2 \\times (2 \\times (2 \\times (2 \\times (2 \\times 0 + 1)+1) + 0) + 0) + 1\\) \\(\\phantom{25} = 1 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) L'\u00e9criture binaire de 25 est donc 11001 . 0n rappelle \u00e9galement que : a // 2 renvoie le quotient de la division euclidienne de a par 2. a % 2 renvoie le reste dans la division euclidienne de a par 2. On indique enfin qu\u2019en Python si mot = \"informatique\" alors : mot[-1] renvoie 'e' , c\u2019est-\u00e0-dire le dernier caract\u00e8re de la cha\u00eene de caract\u00e8res mot . mot[:-1] renvoie 'informatiqu' , c\u2019est-\u00e0-dire l\u2019ensemble de la cha\u00eene de caract\u00e8res mot priv\u00e9e de son dernier caract\u00e8re. Compl\u00e9ter, puis tester, les codes de deux fonctions ci-dessous. On pr\u00e9cise que la fonction r\u00e9cursive dec_to_bin prend en param\u00e8tre un nombre entier et renvoie une cha\u00eene de caract\u00e8res contenant l\u2019\u00e9criture en binaire du nombre pass\u00e9 en param\u00e8tre. Exemple : \ud83d\udc0d Script Python >>> dec_to_bin ( 25 ) '11001' La fonction r\u00e9cursive bin_to_dec prend en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019\u00e9criture d\u2019un nombre en binaire et renvoie l\u2019\u00e9criture d\u00e9cimale de ce nombre. \ud83d\udc0d Script Python >>> bin_to_dec ( '101010' ) 42 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == ... : return ... else : return dec_to_bin ( ... ) + ... def bin_to_dec ( nb_bin ): if len ( nb_bin ) == 1 : if ... == '0' : return 0 else : return ... else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : ... return ... * bin_to_dec ( nb_bin [: - 1 ]) + ... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == 0 : return str ( r ) else : return dec_to_bin ( q ) + str ( r ) def bin_to_dec ( nb_bin ): if len ( nb_bin ) == 1 : if nb_bin == '0' : return 0 else : return 1 else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : bit_droit = 1 return 2 * bin_to_dec ( nb_bin [: - 1 ]) + bit_droit Markdown L\u2019objectif de cet exercice est d\u2019\u00e9crire deux fonctions r\u00e9cursives `dec_to_bin` et `bin_to_dec` assurant respectivement la conversion de l\u2019\u00e9criture d\u00e9cimale d\u2019un nombre entier vers son \u00e9criture en binaire et, r\u00e9ciproquement, la conversion de l\u2019\u00e9criture en binaire d\u2019un nombre vers son \u00e9criture d\u00e9cimale. Dans cet exercice, on s\u2019interdit l\u2019usage des fonctions Python `bin` et `int` . L'exemple suivant montre comment obtenir l\u2019\u00e9criture en binaire du nombre 25 : $25 = 2 \\times 12 + 1$ $\\phantom{25} = 2 \\times (2 \\times 6 + 0) + 1$ $\\phantom{25} = 2 \\times (2 \\times (2 \\times 3 + 0) + 0) + 1$ $\\phantom{25} = 2 \\times (2 \\times (2 \\times (2 \\times 1+1) + 0) + 0) + 1$ $\\phantom{25} = 2 \\times (2 \\times (2 \\times (2 \\times (2 \\times 0 + 1)+1) + 0) + 0) + 1$ $\\phantom{25} = 1 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0$ L'\u00e9criture binaire de 25 est donc ```11001```. 0n rappelle \u00e9galement que : - `a // 2` renvoie le quotient de la division euclidienne de `a` par 2. - ` a % 2` renvoie le reste dans la division euclidienne de `a` par 2. On indique enfin qu\u2019en Python si `mot = \"informatique\"` alors : - `mot[-1]` renvoie `'e'` , c\u2019est-\u00e0-dire le dernier caract\u00e8re de la cha\u00eene de caract\u00e8res `mot` . - `mot[:-1]` renvoie `'informatiqu'` , c\u2019est-\u00e0-dire l\u2019ensemble de la cha\u00eene de caract\u00e8res `mot` priv\u00e9e de son dernier caract\u00e8re. Compl\u00e9ter, puis tester, les codes de deux fonctions ci-dessous. On pr\u00e9cise que la fonction r\u00e9cursive `dec_to_bin` prend en param\u00e8tre un nombre entier et renvoie une cha\u00eene de caract\u00e8res contenant l\u2019\u00e9criture en binaire du nombre pass\u00e9 en param\u00e8tre. Exemple : ```python >>> dec_to_bin(25) '11001' La fonction r\u00e9cursive bin_to_dec prend en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019\u00e9criture d\u2019un nombre en binaire et renvoie l\u2019\u00e9criture d\u00e9cimale de ce nombre. \ud83d\udc0d Script Python >>> bin_to_dec ( '101010' ) 42 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == ... : return ... else : return dec_to_bin ( ... ) + ... def bin_to_dec ( nb_bin ): if len ( nb_bin ) == 1 : if ... == '0' : return 0 else : return ... else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : ... return ... * bin_to_dec ( nb_bin [: - 1 ]) + ... ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 10 \u2693\ufe0e Version originale du sujet en pdf. Exercice 10.1 \u2693\ufe0e Exercice 10.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice on cherche \u00e0 calculer la moyenne pond\u00e9r\u00e9e d\u2019un \u00e9l\u00e8ve dans une mati\u00e8re donn\u00e9e. Chaque note est associ\u00e9e \u00e0 un coefficient qui la pond\u00e8re. Par exemple, si ses notes sont : 14 avec coefficient 3, 12 avec coefficient 1 et 16 avec coeffi- cient 2, sa moyenne pond\u00e9r\u00e9e sera donn\u00e9e par \\[\\dfrac{14 \\times 3 + 12 \\times 1 + 16 \\times 2}{3+1+2}=14,333... \\] \u00c9crire une fonction moyenne : qui prend en param\u00e8tre une liste notes non vide de tuples \u00e0 deux \u00e9l\u00e9ments entiers de la forme (note, coefficient) ( int ou float ) positifs ou nuls ; et qui renvoie la moyenne pond\u00e9r\u00e9e des notes de la liste sous forme de flottant si la somme des coefficients est non nulle, None sinon. Exemple : \ud83d\udc0d Script Python >>> moyenne ([( 8 , 2 ), ( 12 , 0 ), ( 13.5 , 1 ), ( 5 , 0.5 )]) 9.142857142857142 >>> moyenne ([( 3 , 0 ), ( 5 , 0 )]) None \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme = 0 coeffs = 0 for couple in tab : somme += couple [ 0 ] * couple [ 1 ] coeffs += couple [ 1 ] if coeffs == 0 : return None return somme / coeffs \ud83d\udccb Texte Dans cet exercice on cherche \u00e0 calculer la moyenne pond\u00e9r\u00e9e d\u2019un \u00e9l\u00e8ve dans une mati\u00e8re donn\u00e9e. Chaque note est associ\u00e9e \u00e0 un coefficient qui la pond\u00e8re. Par exemple, si ses notes sont : 14 avec coefficient 3, 12 avec coefficient 1 et 16 avec coeffi- cient 2, sa moyenne pond\u00e9r\u00e9e sera donn\u00e9e par $$\\dfrac{14 \\times 3 + 12 \\times 1 + 16 \\times 2}{3+1+2}=14,333... $$ \u00c9crire une fonction `moyenne` : - qui prend en param\u00e8tre une liste notes non vide de tuples \u00e0 deux \u00e9l\u00e9ments entiers de la forme `(note, coefficient)` (`int` ou `float`) positifs ou nuls ; - et qui renvoie la moyenne pond\u00e9r\u00e9e des notes de la liste sous forme de flottant si la somme des coefficients est non nulle, `None` sinon. Exemple : ```python >>> moyenne([(8, 2), (12, 0), (13.5, 1), (5, 0.5)]) 9.142857142857142 >>> moyenne([(3, 0), (5, 0)]) None ``` R\u00e9digez votre code sur Basthon Exercice 10.2 \u2693\ufe0e Exercice 10.2 \u00c9nonc\u00e9 Correction Sources Markdown On travaille sur des dessins en noir et blanc obtenus \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction liste_zoom prend en arguments une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction dessin_zoom prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Compl\u00e9ter les fonctions liste_zoom et dessin_zoom du code suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \"*\" , les 0 par un espace \" \" ''' for ligne in dessin : affichage = '' for col in ligne : if col == 1 : affichage = affichage + \"*\" else : affichage = affichage + \" \" print ( affichage ) def liste_zoom ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoomee = ... for elt in ... : for i in range ( k ): ... return liste_zoomee def dessin_zoom ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoomee = [] for ligne in grille : ligne_zoomee = ... for i in range ( k ): ... . append ( ... ) return grille_zoomee Exemples : \ud83d\udc0d Script Python >>> coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] >>> affiche ( coeur ) * * * * * * * * * * * * * * * * * * * * * * * * >>> affiche ( dessin_zoom ( coeur , 2 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * >>> liste_zoom ([ 1 , 2 , 3 ], 3 ) [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : affichage = '' for col in ligne : if col == 1 : affichage = affichage + \"*\" else : affichage = affichage + \" \" print ( affichage ) def liste_zoom ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoomee = [] for elt in liste_depart : for i in range ( k ): liste_zoomee . append ( elt ) return liste_zoomee def dessin_zoom ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoomee = [] for ligne in grille : liste_zoomee = liste_zoom ( ligne , k ) for i in range ( k ): grille_zoomee . append ( liste_zoomee ) return grille_zoomee Markdown ![ image ]( data2023/03_coeur.png ){: .center width=30%} On travaille sur des dessins en noir et blanc obtenus \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction `affiche` permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction `liste_zoom` prend en arguments une liste `liste_depart` et un entier `k` . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de `liste_depart` est dupliqu\u00e9 `k` fois. La fonction `dessin_zoom` prend en argument la grille `dessin` et renvoie une grille o\u00f9 toutes les lignes de `dessin` sont zoom\u00e9es `k` fois et r\u00e9p\u00e9t\u00e9es `k` fois. Compl\u00e9ter les fonctions `liste_zoom` et `dessin_zoom` du code suivant : ```python linenums='1' def affiche(dessin): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \"*\" , les 0 par un espace \" \" ''' for ligne in dessin: affichage = '' for col in ligne: if col == 1: affichage = affichage + \"*\" else: affichage = affichage + \" \" print(affichage) def liste_zoom(liste_depart,k): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoomee = ... for elt in ... : for i in range(k): ... return liste_zoomee def dessin_zoom(grille,k): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoomee=[] for ligne in grille: ligne_zoomee = ... for i in range(k): ... .append(...) return grille_zoomee Exemples : \ud83d\udc0d Script Python >>> coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] >>> affiche ( coeur ) * * * * * * * * * * * * * * * * * * * * * * * * >>> affiche ( dessin_zoom ( coeur , 2 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * >>> liste_zoom ([ 1 , 2 , 3 ], 3 ) [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 11 \u2693\ufe0e Version originale du sujet en pdf. Exercice 11.1 \u2693\ufe0e Exercice 11.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, on consid\u00e8re des phrases compos\u00e9es de mots. On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, On appelle phrase une cha\u00eene de caract\u00e8res : compos\u00e9e avec un ou plusieurs mots s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace ' ' , se finissant : soit par un point '.' qui est alors coll\u00e9 au dernier mot, soit par un point d'exclamation '!' ou d'interrogation '?' qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace ' ' . Voici deux exemples de phrases : 'Cet exercice est simple.' 'Le point d exclamation est separe !' Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction nombre_de_mots qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. \ud83d\udc0d Script Python >>> nombre_de_mots ( 'Cet exercice est simple.' ) 4 >>> nombre_de_mots ( 'Le point d exclamation est s\u00e9par\u00e9 !' ) 6 >>> nombre_de_mots ( 'Combien de mots y a t il dans cette phrase ?' ) 10 >>> nombre_de_mots ( 'Fin.' ) 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nombre_de_mots ( phrase ): nb_mots = 0 for caractere in phrase : if caractere == ' ' or caractere == '.' : nb_mots += 1 return nb_mots \ud83d\udccb Texte Dans cet exercice, on consid\u00e8re des phrases compos\u00e9es de mots. - On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, - On appelle *phrase* une cha\u00eene de caract\u00e8res : - compos\u00e9e avec un ou plusieurs *mots* s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace `' '`, - se finissant : - soit par un point `'.'` qui est alors coll\u00e9 au dernier mot, - soit par un point d'exclamation `'!'` ou d'interrogation `'?'` qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace `' '`. Voici deux exemples de phrases : - 'Cet exercice est simple.' - 'Le point d exclamation est separe !' Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction `nombre_de_mots` qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. ```python >>> nombre_de_mots('Cet exercice est simple.') 4 >>> nombre_de_mots('Le point d exclamation est s\u00e9par\u00e9 !') 6 >>> nombre_de_mots('Combien de mots y a t il dans cette phrase ?') 10 >>> nombre_de_mots('Fin.') 1 ``` R\u00e9digez votre code sur Basthon Exercice 11.2 \u2693\ufe0e Exercice 11.2 \u00c9nonc\u00e9 Correction Sources Markdown Un arbre binaire de recherche est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None, soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe Noeud donn\u00e9e ci-dessous. On consid\u00e8re ici que les \u00e9tiquettes des n\u0153uds sont des entiers et que les arbres binaires de recherche consid\u00e9r\u00e9s ne contiennent pas de doublons. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Noeud : def __init__ ( self , etiquette ): '''M\u00e9thode constructeur pour la classe Noeud. Cr\u00e9e une feuille d'\u00e9tiquette donn\u00e9e.''' self . etiquette = etiquette self . gauche = None self . droit = None def inserer ( self , cle ): '''Ins\u00e8re la cl\u00e9 dans l'arbre binaire de recherche en pr\u00e9servant sa structure.''' if cle < self . etiquette : if self . gauche != None : ... else : self . gauche = ... else : ... ... else : ... = Noeud ( cle ) Compl\u00e9ter la m\u00e9thode r\u00e9cursive inserer afin qu\u2019elle permette d\u2019ins\u00e9rer une cl\u00e9 dans l\u2019arbre binaire de recherche non vide sur lequel on l\u2019appelle. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> arbre = Noeud ( 7 ) >>> for cle in ( 3 , 9 , 1 , 6 ): arbre . inserer ( cle ) >>> arbre . gauche . etiquette 3 >>> arbre . droit . etiquette 9 >>> arbre . gauche . gauche . etiquette 1 >>> arbre . gauche . droit . etiquette 6 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Noeud : def __init__ ( self , etiquette ): '''M\u00e9thode constructeur pour la classe Noeud. Cr\u00e9e une feuille d'\u00e9tiquette donn\u00e9e.''' self . etiquette = etiquette self . gauche = None self . droit = None def inserer ( self , cle ): '''Ins\u00e8re la cl\u00e9 dans l'arbre binaire de recherche en pr\u00e9servant sa structure.''' if cle < self . etiquette : if self . gauche != None : self . gauche . inserer ( cle ) else : self . gauche = Noeud ( cle ) else : if self . droit != None : self . droit . inserer ( cle ) else : self . droit = Noeud ( cle ) Markdown Un arbre binaire de recherche est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None, soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe Noeud donn\u00e9e ci-dessous. On consid\u00e8re ici que les \u00e9tiquettes des n\u0153uds sont des entiers et que les arbres binaires de recherche consid\u00e9r\u00e9s ne contiennent pas de doublons. ```python linenums='1' class Noeud: def __init__ (self, etiquette): '''M\u00e9thode constructeur pour la classe Noeud. Cr\u00e9e une feuille d'\u00e9tiquette donn\u00e9e.''' self.etiquette = etiquette self.gauche = None self.droit = None def inserer(self, cle): '''Ins\u00e8re la cl\u00e9 dans l'arbre binaire de recherche en pr\u00e9servant sa structure.''' if cle < self.etiquette: if self.gauche != None: ... else: self.gauche = ... else: ... ... else: ... = Noeud(cle) Compl\u00e9ter la m\u00e9thode r\u00e9cursive inserer afin qu\u2019elle permette d\u2019ins\u00e9rer une cl\u00e9 dans l\u2019arbre binaire de recherche non vide sur lequel on l\u2019appelle. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> arbre = Noeud ( 7 ) >>> for cle in ( 3 , 9 , 1 , 6 ): arbre . inserer ( cle ) >>> arbre . gauche . etiquette 3 >>> arbre . droit . etiquette 9 >>> arbre . gauche . gauche . etiquette 1 >>> arbre . gauche . droit . etiquette 6 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 12 \u2693\ufe0e Version originale du sujet en pdf. Exercice 12.1 \u2693\ufe0e Exercice 12.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction tri_selection qui prend en param\u00e8tre un tableau tab de nombres entiers (type list ) et qui le modifie afin qu\u2019il soit tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, en le parcourant du rang 0 au dernier rang, et on l\u2019\u00e9change avec l\u2019\u00e9l\u00e9ment d\u2019indice 0 ; on recherche ensuite le plus petit \u00e9l\u00e9ment du tableau restreint du rang 1 au dernier rang, et on l\u2019\u00e9change avec l\u2019\u00e9l\u00e9ment d\u2019indice 1 ; on continue de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : \ud83d\udc0d Script Python >>> tab = [ 1 , 52 , 6 , - 9 , 12 ] >>> tri_selection ( tab ) >>> tab [ - 9 , 1 , 6 , 12 , 52 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \ud83d\udccb Texte \u00c9crire une fonction `tri_selection` qui prend en param\u00e8tre un tableau `tab` de nombres entiers (type `list`) et qui le modifie afin qu\u2019il soit tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : - on recherche le plus petit \u00e9l\u00e9ment du tableau, en le parcourant du rang 0 au dernier rang, et on l\u2019\u00e9change avec l\u2019\u00e9l\u00e9ment d\u2019indice 0 ; - on recherche ensuite le plus petit \u00e9l\u00e9ment du tableau restreint du rang 1 au dernier rang, et on l\u2019\u00e9change avec l\u2019\u00e9l\u00e9ment d\u2019indice 1 ; - on continue de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : ```python >>> tab = [1, 52, 6, -9, 12] >>> tri_selection(tab) >>> tab [-9, 1, 6, 12, 52] ``` R\u00e9digez votre code sur Basthon Exercice 12.2 \u2693\ufe0e Exercice 12.2 \u00c9nonc\u00e9 Correction Sources Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Une \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisatrice est plus petite que le nombre cherch\u00e9, l\u2019utilisatrice en est avertie. Elle peut alors en tester un autre ; si la proposition de l\u2019utilisatrice est plus grande que le nombre cherch\u00e9, l\u2019utilisatrice en est avertie. Elle peut alors en tester un autre ; si l\u2019utilisatrice trouve le bon nombre en 10 essais ou moins, elle gagne ; si l\u2019utilisatrice a fait plus de 10 essais sans trouver le bon nombre, elle perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers tels que a <= b , randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 99 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 1 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Une \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : - le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; - si la proposition de l\u2019utilisatrice est plus petite que le nombre cherch\u00e9, l\u2019utilisatrice en est avertie. Elle peut alors en tester un autre ; - si la proposition de l\u2019utilisatrice est plus grande que le nombre cherch\u00e9, l\u2019utilisatrice en est avertie. Elle peut alors en tester un autre ; - si l\u2019utilisatrice trouve le bon nombre en 10 essais ou moins, elle gagne ; - si l\u2019utilisatrice a fait plus de 10 essais sans trouver le bon nombre, elle perd. La fonction `randint` est utilis\u00e9e. Si a et b sont des entiers tels que `a <= b` , `randint(a,b)` renvoie un nombre entier compris entre `a` et `b` . Compl\u00e9ter le code ci-dessous et le tester : ```python linenums='1' from random import randint def plus_ou_moins(): nb_mystere = randint(1,...) nb_test = int(input(\"Proposez un nombre entre 1 et 99 : \")) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test: nb_test = int(input(\"Trop petit ! Testez encore : \")) else: nb_test = int(input(\"Trop grand ! Testez encore : \")) if nb_mystere == nb_test: print (\"Bravo ! Le nombre \u00e9tait \",...) print(\"Nombre d'essais: \",...) else: print (\"Perdu ! Le nombre \u00e9tait \",...) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 13 \u2693\ufe0e Version originale du sujet en pdf. Exercice 13.1 \u2693\ufe0e Exercice 13.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers (type list ), et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et None sinon. L\u2019objectif de cet exercice est de parcourir un tableau, il est interdit d\u2019utiliser la m\u00e9thode index des listes Python. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) # renvoie None >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return None \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers (type `list`), et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `None` sinon. L\u2019objectif de cet exercice est de parcourir un tableau, il est interdit d\u2019utiliser la m\u00e9thode `index` des listes Python. Exemples : ```python >>> recherche(1, [2, 3, 4]) # renvoie None >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ``` R\u00e9digez votre code sur Basthon Exercice 13.2 \u2693\ufe0e Exercice 13.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction insere ci-dessous qui prend en argument un tableau tab d\u2019en- tiers tri\u00e9s par ordre croissant et un entier a . Cette fonction cr\u00e9e et renvoie un nouveau tableau \u00e0 partir de celui fourni en param\u00e8tre en y ins\u00e9rant la valeur a de sorte que le tableau renvoy\u00e9 soit encore tri\u00e9 par ordre croissant. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes Python. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( tab , a ): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" tab_a = [ a ] + tab # nouveau tableau contenant a # suivi des \u00e9l\u00e9ments de tab i = 0 while i < ... and a > ... : tab_a [ i ] = ... tab_a [ i + 1 ] = a i = ... return tab_a Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ([ 1 , 2 , 4 , 5 ], 3 ) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ([ 1 , 2 , 7 , 12 , 14 , 25 ], 30 ) [ 1 , 2 , 7 , 12 , 14 , 25 , 30 ] >>> insere ([ 2 , 3 , 4 ], 1 ) [ 1 , 2 , 3 , 4 ] >>> insere ([], 1 ) [ 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( tab , a ): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" tab_a = [ a ] + tab # nouveau tableau contenant a # suivi des \u00e9l\u00e9ments de tab i = 0 while i < len ( tab_a ) - 1 and a > tab_a [ i + 1 ]: tab_a [ i ] = tab_a [ i + 1 ] tab_a [ i + 1 ] = a i = i + 1 return tab_a Markdown On consid\u00e8re la fonction `insere` ci-dessous qui prend en argument un tableau `tab` d\u2019en- tiers tri\u00e9s par ordre croissant et un entier `a` . Cette fonction cr\u00e9e et renvoie un nouveau tableau \u00e0 partir de celui fourni en param\u00e8tre en y ins\u00e9rant la valeur `a` de sorte que le tableau renvoy\u00e9 soit encore tri\u00e9 par ordre croissant. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes Python. ```python linenums='1' def insere(tab, a): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" tab_a = [ a ] + tab # nouveau tableau contenant a # suivi des \u00e9l\u00e9ments de tab i = 0 while i < ... and a > ...: tab_a[i] = ... tab_a[i+1] = a i = ... return tab_a Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ([ 1 , 2 , 4 , 5 ], 3 ) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ([ 1 , 2 , 7 , 12 , 14 , 25 ], 30 ) [ 1 , 2 , 7 , 12 , 14 , 25 , 30 ] >>> insere ([ 2 , 3 , 4 ], 1 ) [ 1 , 2 , 3 , 4 ] >>> insere ([], 1 ) [ 1 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 14 \u2693\ufe0e Version originale du sujet en pdf. Exercice 14.1 \u2693\ufe0e Exercice 14.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction min_et_max qui prend en param\u00e8tre un tableau de nombres tab non vide, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s min et max . Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. L\u2019utilisation des fonctions natives min , max et sorted , ainsi que la m\u00e9thode sort n\u2019est pas autoris\u00e9e. Exemples : \ud83d\udc0d Script Python >>> min_et_max ([ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ]) { 'min' : - 2 , 'max' : 9 } >>> min_et_max ([ 0 , 1 , 2 , 3 ]) { 'min' : 0 , 'max' : 3 } >>> min_et_max ([ 3 ]) { 'min' : 3 , 'max' : 3 } >>> min_et_max ([ 1 , 3 , 2 , 1 , 3 ]) { 'min' : 1 , 'max' : 3 } >>> min_et_max ([ - 1 , - 1 , - 1 , - 1 , - 1 ]) { 'min' : - 1 , 'max' : - 1 } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def min_et_max ( tab ): d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \ud83d\udccb Texte \u00c9crire une fonction `min_et_max` qui prend en param\u00e8tre un tableau de nombres `tab` non vide, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s `min` et `max`. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. L\u2019utilisation des fonctions natives `min`, `max` et `sorted`, ainsi que la m\u00e9thode `sort` n\u2019est pas autoris\u00e9e. Exemples : ```python >>> min_et_max([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) {'min': -2, 'max': 9} >>> min_et_max([0, 1, 2, 3]) {'min': 0, 'max': 3} >>> min_et_max([3]) {'min': 3, 'max': 3} >>> min_et_max([1, 3, 2, 1, 3]) {'min': 1, 'max': 3} >>> min_et_max([-1, -1, -1, -1, -1]) {'min': -1, 'max': -1} ``` R\u00e9digez votre code sur Basthon Exercice 14.2 \u2693\ufe0e Exercice 14.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019une classe Carte permettant de cr\u00e9er des objets mod\u00e9lisant des cartes \u00e0 jouer. Compl\u00e9ter la classe Paquet_de_cartes suivante en respectant les sp\u00e9cifications donn\u00e9es dans les cha\u00eenes de documentation. Ajouter une assertion dans la m\u00e9thode recuperer_carte afin de v\u00e9rifier que le param\u00e8tre pos est correct. On rappelle que l\u2019instruction \ud83d\udc0d Script Python assert condition , message permet de v\u00e9rifier que la condition est vraie. Si ce n\u2019est pas le cas, le programme s\u2019arr\u00eate et affiche le message d\u2019erreur fourni. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Carte : def __init__ ( self , c , v ): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def recuperer_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def recuperer_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" ... ... ... ... def recuperer_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" ... ... Exemple : \ud83d\udc0d Script Python >>> jeu = Paquet_de_cartes () >>> carte1 = jeu . recuperer_carte ( 20 ) >>> carte1 . recuperer_valeur () + \" de \" + carte1 . recuperer_couleur () \"8 de coeur\" >>> carte2 = jeu . recuperer_carte ( 0 ) >>> carte2 . recuperer_valeur () + \" de \" + carte2 . recuperer_couleur () \"As de pique\" >>> carte3 = jeu . recuperer_carte ( 52 ) AssertionError : param\u00e8tre pos invalide \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Carte : def __init__ ( self , c , v ): \"\"\"Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def recuperer_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def recuperer_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis c\u0153ur, carreau et tr\u00e8fle. \"\"\" self . contenu = [] for c in range ( 1 , 5 ): for v in range ( 1 , 14 ): self . contenu . append ( Carte ( c , v )) def recuperer_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" assert 0 <= pos <= 51 , 'param\u00e8tre pos invalide' return self . contenu [ pos ] Markdown On dispose d\u2019une classe `Carte` permettant de cr\u00e9er des objets mod\u00e9lisant des cartes \u00e0 jouer. Compl\u00e9ter la classe `Paquet_de_cartes` suivante en respectant les sp\u00e9cifications donn\u00e9es dans les cha\u00eenes de documentation. Ajouter une assertion dans la m\u00e9thode `recuperer_carte` afin de v\u00e9rifier que le param\u00e8tre `pos` est correct. On rappelle que l\u2019instruction ```python assert condition, message permet de v\u00e9rifier que la condition est vraie. Si ce n\u2019est pas le cas, le programme s\u2019arr\u00eate et affiche le message d\u2019erreur fourni. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Carte : def __init__ ( self , c , v ): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def recuperer_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def recuperer_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" ... ... ... ... def recuperer_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" ... ... Exemple : \ud83d\udc0d Script Python >>> jeu = Paquet_de_cartes () >>> carte1 = jeu . recuperer_carte ( 20 ) >>> carte1 . recuperer_valeur () + \" de \" + carte1 . recuperer_couleur () \"8 de coeur\" >>> carte2 = jeu . recuperer_carte ( 0 ) >>> carte2 . recuperer_valeur () + \" de \" + carte2 . recuperer_couleur () \"As de pique\" >>> carte3 = jeu . recuperer_carte ( 52 ) AssertionError : param\u00e8tre pos invalide ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 15 \u2693\ufe0e Version originale du sujet en pdf. Exercice 15.1 \u2693\ufe0e Exercice 15.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> moyenne([1.0]) 1.0 >>> moyenne([1.0, 2.0, 4.0]) 2.3333333333333335 ``` R\u00e9digez votre code sur Basthon Exercice 15.2 \u2693\ufe0e Exercice 15.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction binaire . Cette fonction prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et renvoie son \u00e9criture binaire sous la forme d\u2019une chaine de caract\u00e8res. L\u2019algorithme utilise la m\u00e9thode des divisions euclidiennes successives comme l\u2019illustre l\u2019exemple ci-apr\u00e8s. Compl\u00e9ter le code de la fonction binaire . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def binaire ( a ): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0 : return ... bin_a = ... while ... : bin_a = ... + bin_a a = ... return bin_a Exemples : \ud83d\udc0d Script Python >>> binaire ( 83 ) '1010011' >>> binaire ( 127 ) '1111111' >>> binaire ( 0 ) '0' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def binaire ( a ): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0 : return '0' bin_a = '' while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown On consid\u00e8re la fonction `binaire` . Cette fonction prend en param\u00e8tre un entier positif `a` en \u00e9criture d\u00e9cimale et renvoie son \u00e9criture binaire sous la forme d\u2019une chaine de caract\u00e8res. L\u2019algorithme utilise la m\u00e9thode des divisions euclidiennes successives comme l\u2019illustre l\u2019exemple ci-apr\u00e8s. ![ image ]( data2023/30_divisions.png ){: .center} Compl\u00e9ter le code de la fonction `binaire` . ```python linenums='1' def binaire(a): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0: return ... bin_a = ... while ... : bin_a = ... + bin_a a = ... return bin_a Exemples : \ud83d\udc0d Script Python >>> binaire ( 83 ) '1010011' >>> binaire ( 127 ) '1111111' >>> binaire ( 0 ) '0' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 16 \u2693\ufe0e Version originale du sujet en pdf. Exercice 16.1 \u2693\ufe0e Exercice 16.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction ecriture_binaire_entier_positif qui prend en param\u00e8tre un entier positif n et renvoie une une chaine de caract\u00e8re correspondant \u00e0 l\u2018\u00e9criture binaire de n . On rappelle que : l\u2019\u00e9criture binaire de 25 est 11001 car \\(25 = 1 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) ; n % 2 vaut 0 ou 1 selon que n est pair ou impair ; n // 2 donne le quotient de la division euclidienne de n par 2. Il est interdit dans cet exercice d\u2019utiliser la fonction bin de Python. Exemples : \ud83d\udc0d Script Python >>> 5 % 2 1 >>> 5 // 2 2 >>> ecriture_binaire_entier_positif ( 0 ) '0' >>> ecriture_binaire_entier_positif ( 2 ) '10' >>> ecriture_binaire_entier_positif ( 105 ) '1101001' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def ecriture_binaire_entier_positif ( n ): if n == 0 : return '0' bin_n = '' while n != 0 : bin_n = str ( n % 2 ) + bin_n n = n // 2 return bin_n \ud83d\udccb Texte \u00c9crire une fonction `ecriture_binaire_entier_positif` qui prend en param\u00e8tre un entier positif `n` et renvoie une une chaine de caract\u00e8re correspondant \u00e0 l\u2018\u00e9criture binaire de `n`. On rappelle que : - l\u2019\u00e9criture binaire de 25 est 11001 car $25 = 1 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0$ ; - `n % 2` vaut 0 ou 1 selon que `n` est pair ou impair ; - `n // 2` donne le quotient de la division euclidienne de `n` par 2. Il est interdit dans cet exercice d\u2019utiliser la fonction `bin` de Python. Exemples : ```python >>> 5 % 2 1 >>> 5 // 2 2 >>> ecriture_binaire_entier_positif(0) '0' >>> ecriture_binaire_entier_positif(2) '10' >>> ecriture_binaire_entier_positif(105) '1101001' ``` R\u00e9digez votre code sur Basthon Exercice 16.2 \u2693\ufe0e Exercice 16.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_bulles prend en param\u00e8tre une liste tab d\u2019entiers (type list ) et le modifie pour le trier par ordre croissant. Le tri \u00e0 bulles est un tri en place qui commence par placer le plus grand \u00e9l\u00e9ment en derni\u00e8re position en parcourant le tableau de gauche \u00e0 droite et en \u00e9changeant au passage les \u00e9l\u00e9ments voisins mal ordonn\u00e9s (si la valeur de l\u2019\u00e9l\u00e9ment d\u2019indice i a une valeur strictement sup\u00e9rieure \u00e0 celle de l\u2019indice i + 1 , ils sont \u00e9chang\u00e9s). Le tri place ensuite en avant-derni\u00e8re position le plus grand \u00e9l\u00e9ment du tableau priv\u00e9 de son dernier \u00e9l\u00e9ment en proc\u00e9dant encore \u00e0 des \u00e9changes d\u2019\u00e9l\u00e9ments voisins. Ce principe est r\u00e9p\u00e9t\u00e9 jusqu\u2019\u00e0 placer le minimum en premi\u00e8re position. Exemple : pour trier le tableau [7, 9, 4, 3] : premi\u00e8re \u00e9tape : 7 et 9 ne sont pas \u00e9chang\u00e9s, puis 9 et 4 sont \u00e9chang\u00e9s, puis 9 et 3 sont \u00e9chang\u00e9s, le tableau est alors [7, 4, 3, 9] deuxi\u00e8me \u00e9tape : 7 et 4 sont \u00e9chang\u00e9s, puis 7 et 3 sont \u00e9chang\u00e9s, le tableau est alors [4, 3, 7, 9] troisi\u00e8me \u00e9tape : 4 et 3 sont \u00e9chang\u00e9s, le tableau est alors [3, 4, 7, 9] Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def echange ( tab , i , j ): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = ... tab [ i ] = ... tab [ j ] = ... def tri_bulles ( tab ): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri \u00e0 bulles.''' n = len ( tab ) for i in range ( ... ): for j in range ( ... ): if ... > ... : echange ( tab , j , ... ) Exemples : \ud83d\udc0d Script Python >>> tab = [] >>> tri_bulles ( tab ) >>> tab [] >>> tab2 = [ 9 , 3 , 7 , 2 , 3 , 1 , 6 ] >>> tri_bulles ( tab2 ) >>> tab2 [ 1 , 2 , 3 , 3 , 6 , 7 , 9 ] >>> tab3 = [ 9 , 7 , 4 , 3 ] >>> tri_bulles ( tab3 ) >>> tab3 [ 3 , 4 , 7 , 9 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def echange ( tab , i , j ): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = tab [ i ] tab [ i ] = tab [ j ] tab [ j ] = temp def tri_bulles ( tab ): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri \u00e0 bulles.''' n = len ( tab ) for i in range ( n - 1 , - 1 , - 1 ): for j in range ( i ): if tab [ j ] > tab [ j + 1 ]: echange ( tab , j , j + 1 ) Markdown La fonction `tri_bulles` prend en param\u00e8tre une liste `tab` d\u2019entiers (type `list` ) et le modifie pour le trier par ordre croissant. Le tri \u00e0 bulles est un tri en place qui commence par placer le plus grand \u00e9l\u00e9ment en derni\u00e8re position en parcourant le tableau de gauche \u00e0 droite et en \u00e9changeant au passage les \u00e9l\u00e9ments voisins mal ordonn\u00e9s (si la valeur de l\u2019\u00e9l\u00e9ment d\u2019indice `i` a une valeur strictement sup\u00e9rieure \u00e0 celle de l\u2019indice `i + 1` , ils sont \u00e9chang\u00e9s). Le tri place ensuite en avant-derni\u00e8re position le plus grand \u00e9l\u00e9ment du tableau priv\u00e9 de son dernier \u00e9l\u00e9ment en proc\u00e9dant encore \u00e0 des \u00e9changes d\u2019\u00e9l\u00e9ments voisins. Ce principe est r\u00e9p\u00e9t\u00e9 jusqu\u2019\u00e0 placer le minimum en premi\u00e8re position. Exemple : pour trier le tableau `[7, 9, 4, 3]` : - premi\u00e8re \u00e9tape : 7 et 9 ne sont pas \u00e9chang\u00e9s, puis 9 et 4 sont \u00e9chang\u00e9s, puis 9 et 3 sont \u00e9chang\u00e9s, le tableau est alors `[7, 4, 3, 9]` - deuxi\u00e8me \u00e9tape : 7 et 4 sont \u00e9chang\u00e9s, puis 7 et 3 sont \u00e9chang\u00e9s, le tableau est alors `[4, 3, 7, 9]` - troisi\u00e8me \u00e9tape : 4 et 3 sont \u00e9chang\u00e9s, le tableau est alors `[3, 4, 7, 9]` Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles. ```python linenums='1' def echange(tab, i, j): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = ... tab[i] = ... tab[j] = ... def tri_bulles(tab): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri \u00e0 bulles.''' n = len(tab) for i in range(...): for j in range(...): if ... > ...: echange(tab, j, ...) Exemples : \ud83d\udc0d Script Python >>> tab = [] >>> tri_bulles ( tab ) >>> tab [] >>> tab2 = [ 9 , 3 , 7 , 2 , 3 , 1 , 6 ] >>> tri_bulles ( tab2 ) >>> tab2 [ 1 , 2 , 3 , 3 , 6 , 7 , 9 ] >>> tab3 = [ 9 , 7 , 4 , 3 ] >>> tri_bulles ( tab3 ) >>> tab3 [ 3 , 4 , 7 , 9 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 17 \u2693\ufe0e Version originale du sujet en pdf. Exercice 17.1 \u2693\ufe0e Exercice 17.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction Python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et un tableau tab (type list ) et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans le tableau. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 , [ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' , [ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 , [ 1 , 3 , 7 , 21 , 36 , 44 ]) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \ud83d\udccb Texte \u00c9crire une fonction Python appel\u00e9e `nb_repetitions` qui prend en param\u00e8tres un \u00e9l\u00e9ment `elt` et un tableau `tab` (type `list`) et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans le tableau. Exemples : ```python >>> nb_repetitions(5, [2, 5, 3, 5, 6, 9, 5]) 3 >>> nb_repetitions('A', ['B', 'A', 'B', 'A', 'R']) 2 >>> nb_repetitions(12, [1, 3, 7, 21, 36, 44]) 0 ``` R\u00e9digez votre code sur Basthon Exercice 17.2 \u2693\ufe0e Exercice 17.2 \u00c9nonc\u00e9 Correction Sources Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : Compl\u00e9ter la fonction binaire \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def binaire ( a ): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0 : return '0' bin_a = ... while ... : bin_a = ... + bin_a a = ... return bin_a . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def binaire ( a ): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0 : return '0' bin_a = '' while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : ![ image ]( data2023/31_divisions.png ){: .center} Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : Compl\u00e9ter la fonction ```binaire``` ```python linenums='1' def binaire(a): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0: return '0' bin_a = ... while ...: bin_a = ... + bin_a a = ... return bin_a . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 18 \u2693\ufe0e Version originale du sujet en pdf. Exercice 18.1 \u2693\ufe0e Exercice 18.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers relatifs n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations arithm\u00e9tiques autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers relatifs `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations arithm\u00e9tiques autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : ```python >>> multiplication(3,5) 15 >>> multiplication(-4,-8) 32 >>> multiplication(-2,6) -12 >>> multiplication(-2,0) 0 ``` R\u00e9digez votre code sur Basthon Exercice 18.2 \u2693\ufe0e Exercice 18.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit tab un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher ci-dessous doit renvoyer un indice o\u00f9 la valeur n appara\u00eet dans tab si cette valeur y figure et None sinon. Les param\u00e8tres de la fonction sont : tab , le tableau dans lequel s'effectue la recherche ; x , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. L\u2019algorithme demand\u00e9 est une recherche dichotomique r\u00e9cursive. Recopier et compl\u00e9ter le code de la fonction chercher suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( tab , x , i , j ): '''Renvoie l'indice de x dans tab, si x est dans tab, None sinon. On suppose que tab est tri\u00e9 dans l'ordre croissant.''' if i > j : return None m = ( i + j ) // ... if ... < x : return chercher ( tab , x , ... , ... ) elif tab [ m ] > x : return chercher ( tab , x , ... , ... ) else : return ... Exemples : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( tab , x , i , j ): '''Renvoie l'indice de x dans tab, si x est dans tab, None sinon. On suppose que tab est tri\u00e9 dans l'ordre croissant.''' if i > j : return None m = ( i + j ) // 2 if tab [ m ] < x : return chercher ( tab , x , m + 1 , j ) elif tab [ m ] > x : return chercher ( tab , x , i , m - 1 ) else : return m Markdown Soit `tab` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher` ci-dessous doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet dans `tab` si cette valeur y figure et `None` sinon. Les param\u00e8tres de la fonction sont : - `tab` , le tableau dans lequel s'effectue la recherche ; - `x` , l'entier \u00e0 chercher dans le tableau ; - `i` , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j` , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. L\u2019algorithme demand\u00e9 est une recherche dichotomique r\u00e9cursive. Recopier et compl\u00e9ter le code de la fonction `chercher` suivante : ```python linenums='1' def chercher(tab, x, i, j): '''Renvoie l'indice de x dans tab, si x est dans tab, None sinon. On suppose que tab est tri\u00e9 dans l'ordre croissant.''' if i > j: return None m = (i + j) // ... if ... < x: return chercher(tab, x, ... , ...) elif tab[m] > x: return chercher(tab, x, ... , ...) else: return ... Exemples : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 19 \u2693\ufe0e Version originale du sujet en pdf. Exercice 19.1 \u2693\ufe0e Exercice 19.1 \u00c9nonc\u00e9 Correction Source Markdown On rappelle que : le nombre \\(a^n\\) est le nombre \\(a \\times a \\times a \\times \\dots \\times a\\) , o\u00f9 le facteur \\(a\\) appara\u00eet \\(n\\) fois, en langage Python, l\u2019instruction t[-1] permet d\u2019acc\u00e9der au dernier \u00e9l\u00e9ment du tableau t . Dans cet exercice, l\u2019op\u00e9rateur ** et la fonction pow ne sont pas autoris\u00e9s. Programmer en langage Python une fonction liste_puissances qui prend en arguments un nombre entier a , un entier strictement positif n et qui renvoie la liste de ses puissances \\(\\rm{[a^1, a^2, ..., a^n]}\\) . Programmer \u00e9galement une fonction liste_puisssances_borne qui prend en arguments un nombre entier a sup\u00e9rieur ou \u00e9gal \u00e0 2 et un entier borne , et qui renvoie la liste de ses puissances, \u00e0 l\u2019exclusion de \\(\\rm{a^0}\\) , strictement inf\u00e9rieures \u00e0 borne . Exemples : \ud83d\udc0d Script Python >>> liste_puissances ( 3 , 5 ) [ 3 , 9 , 27 , 81 , 243 ] >>> liste_puissances ( - 2 , 4 ) [ - 2 , 4 , - 8 , 16 ] >>> liste_puissances_borne ( 2 , 16 ) [ 2 , 4 , 8 ] >>> liste_puissances_borne ( 2 , 17 ) [ 2 , 4 , 8 , 16 ] >>> liste_puissances_borne ( 5 , 5 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def liste_puissances ( a , n ): puissances = [ a ] for i in range ( n - 1 ): puissances . append ( puissances [ - 1 ] * a ) return puissances def liste_puissances_borne ( a , borne ): lst = [] val = a while val < borne : lst . append ( val ) val = val * a return lst \ud83d\udccb Texte On rappelle que : - le nombre $a^n$ est le nombre $a \\times a \\times a \\times \\dots \\times a$, o\u00f9 le facteur $a$ appara\u00eet $n$ fois, - en langage Python, l\u2019instruction `t[-1]` permet d\u2019acc\u00e9der au dernier \u00e9l\u00e9ment du tableau `t`. Dans cet exercice, l\u2019op\u00e9rateur ```**``` et la fonction `pow` ne sont pas autoris\u00e9s. Programmer en langage Python une fonction `liste_puissances` qui prend en arguments un nombre entier `a`, un entier strictement positif `n` et qui renvoie la liste de ses puissances $\\rm{[a^1, a^2, ..., a^n]}$. Programmer \u00e9galement une fonction `liste_puisssances_borne` qui prend en arguments un nombre entier `a` sup\u00e9rieur ou \u00e9gal \u00e0 2 et un entier `borne`, et qui renvoie la liste de ses puissances, \u00e0 l\u2019exclusion de $\\rm{a^0}$, strictement inf\u00e9rieures \u00e0 `borne`. Exemples : ```python >>> liste_puissances(3, 5) [3, 9, 27, 81, 243] >>> liste_puissances(-2, 4) [-2, 4, -8, 16] >>> liste_puissances_borne(2, 16) [2, 4, 8] >>> liste_puissances_borne(2, 17) [2, 4, 8, 16] >>> liste_puissances_borne(5, 5) [] ``` R\u00e9digez votre code sur Basthon Exercice 19.2 \u2693\ufe0e Exercice 19.2 \u00c9nonc\u00e9 Correction Sources Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M 1 2 3 4 5 6 7 8 9 10 11 12 13 N O P Q R S T U V W X Y Z 14 15 16 17 18 19 20 21 22 23 24 25 26 Cette table de correspondance est stock\u00e9e dans un dictionnaire dico o\u00f9 les cl\u00e9s sont les lettres de l\u2019alphabet et les valeurs les codes correspondants. \ud83d\udc0d Script Python dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction codes_parfait situ\u00e9e \u00e0 la page suivante et qui prend en param\u00e8tre un mot en majuscule et renvoie un triplet constitu\u00e9 du code additionn\u00e9, du code concat\u00e9n\u00e9 et d\u2019un bool\u00e9en indiquant si le mot est parfait ou non. On rappelle que pour tester si un entier a divise un entier b , on utilise l\u2019op\u00e9rateur modulo b % a qui renvoie le reste de la division euclidienne de b par a . Si b % a vaut 0 , alors a divise b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def codes_parfait ( mot ): \"\"\"Renvoie un triplet (code_additionne, code_concatene, mot_est_parfait) o\u00f9 : - code_additionne est la somme des codes des lettres du mot ; - code_concatene est le code des lettres du mot concat\u00e9n\u00e9es ; - mot_est_parfait est un bool\u00e9en indiquant si le mot est parfait.\"\"\" code_concatene = \"\" code_additionne = ... for c in mot : code_concatene = code_concatene + ... code_additionne = code_additionne + ... code_concatene = int ( code_concatene ) mot_est_parfait = ... return code_additionne , code_concatene , mot_est_parfait Exemples : \ud83d\udc0d Script Python >>> codes_parfait ( \"PAUL\" ) ( 50 , 1612112 , False ) >>> codes_parfait ( \"ALAIN\" ) ( 37 , 1121914 , True ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def codes_parfait ( mot ): # mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_concatene = \"\" code_additionne = 0 for c in mot : code_concatene = code_concatene + str ( dico [ c ]) code_additionne = code_additionne + dico [ c ] code_concatene = int ( code_concatene ) mot_est_parfait = code_concatene % code_additionne == 0 return code_additionne , code_concatene , mot_est_parfait Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : | A | B | C | D | E | F | G | H | I | J | K | L | M | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | Cette table de correspondance est stock\u00e9e dans un dictionnaire `dico` o\u00f9 les cl\u00e9s sont les lettres de l\u2019alphabet et les valeurs les codes correspondants. ```python dico = {\"A\": 1, \"B\": 2, \"C\": 3, \"D\": 4, \"E\": 5, \"F\": 6, \"G\": 7, \"H\": 8, \"I\": 9, \"J\": 10, \"K\": 11, \"L\": 12, \"M\": 13, \"N\": 14, \"O\": 15, \"P\": 16, \"Q\": 17, \"R\": 18, \"S\": 19, \"T\": 20, \"U\": 21, \"V\": 22, \"W\": 23, \"X\": 24, \"Y\": 25, \"Z\": 26} Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction codes_parfait situ\u00e9e \u00e0 la page suivante et qui prend en param\u00e8tre un mot en majuscule et renvoie un triplet constitu\u00e9 du code additionn\u00e9, du code concat\u00e9n\u00e9 et d\u2019un bool\u00e9en indiquant si le mot est parfait ou non. On rappelle que pour tester si un entier a divise un entier b , on utilise l\u2019op\u00e9rateur modulo b % a qui renvoie le reste de la division euclidienne de b par a . Si b % a vaut 0 , alors a divise b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def codes_parfait ( mot ): \"\"\"Renvoie un triplet (code_additionne, code_concatene, mot_est_parfait) o\u00f9 : - code_additionne est la somme des codes des lettres du mot ; - code_concatene est le code des lettres du mot concat\u00e9n\u00e9es ; - mot_est_parfait est un bool\u00e9en indiquant si le mot est parfait.\"\"\" code_concatene = \"\" code_additionne = ... for c in mot : code_concatene = code_concatene + ... code_additionne = code_additionne + ... code_concatene = int ( code_concatene ) mot_est_parfait = ... return code_additionne , code_concatene , mot_est_parfait Exemples : \ud83d\udc0d Script Python >>> codes_parfait ( \"PAUL\" ) ( 50 , 1612112 , False ) >>> codes_parfait ( \"ALAIN\" ) ( 37 , 1121914 , True ) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 20 \u2693\ufe0e Version originale du sujet en pdf. Exercice 20.1 \u2693\ufe0e Exercice 20.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice les tableaux sont repr\u00e9sent\u00e9s par des listes Python (type list ). \u00c9crire en python deux fonctions : lancer de param\u00e8tre n , un entier positif, qui renvoie un tableau de n entiers obtenus al\u00e9atoirement entre 1 et 6 (1 et 6 inclus) ; paire_6 de param\u00e8tre tab , un tableau de n entiers compris entre 1 et 6 et qui renvoie un bool\u00e9en \u00e9gal \u00e0 True si le nombre de 6 est sup\u00e9rieur ou \u00e9gal \u00e0 2, False sinon. On pourra utiliser la fonction randint(a,b) du module random pour laquelle la documentation officielle est la suivante : random.randint(a, b) Renvoie un entier al\u00e9atoire N tel que a <=N <= b. Exemples : \ud83d\udc0d Script Python >>> lancer1 = lancer ( 5 ) [ 5 , 6 , 6 , 2 , 2 ] >>> paire_6 ( lancer1 ) True >>> lancer2 = lancer ( 5 ) [ 6 , 5 , 1 , 6 , 6 ] >>> paire_6 ( lancer2 ) True >>> lancer3 = lancer ( 3 ) [ 2 , 2 , 6 ] >>> paire_6 ( lancer3 ) False >>> lancer4 = lancer ( 0 ) [] >>> paire_6 ( lancer4 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from random import randint def lancer ( n ): return [ randint ( 1 , 6 ) for _ in range ( n )] def paire_6 ( tab ): nb = 0 for elt in tab : if elt == 6 : nb += 1 if nb >= 2 : return True else : return False \ud83d\udccb Texte Dans cet exercice les tableaux sont repr\u00e9sent\u00e9s par des listes Python (type `list`). \u00c9crire en python deux fonctions : - `lancer` de param\u00e8tre `n`, un entier positif, qui renvoie un tableau de `n` entiers obtenus al\u00e9atoirement entre 1 et 6 (1 et 6 inclus) ; - `paire_6` de param\u00e8tre `tab`, un tableau de n entiers compris entre 1 et 6 et qui renvoie un bool\u00e9en \u00e9gal \u00e0 `True` si le nombre de 6 est sup\u00e9rieur ou \u00e9gal \u00e0 2, `False` sinon. On pourra utiliser la fonction `randint(a,b)` du module `random` pour laquelle la documentation officielle est la suivante : `random.randint(a, b)` ` Renvoie un entier al\u00e9atoire N tel que a <=N <= b.` Exemples : ```python >>> lancer1 = lancer(5) [5, 6, 6, 2, 2] >>> paire_6(lancer1) True >>> lancer2 = lancer(5) [6, 5, 1, 6, 6] >>> paire_6(lancer2) True >>> lancer3 = lancer(3) [2, 2, 6] >>> paire_6(lancer3) False >>> lancer4 = lancer(0) [] >>> paire_6(lancer4) False ``` R\u00e9digez votre code sur Basthon Exercice 20.2 \u2693\ufe0e Exercice 20.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Le n\u00e9gatif d\u2019une image est l\u2019image constitu\u00e9e des pixels x_n tels que x_n + x_i = 255 o\u00f9 x_i est le pixel correspondant de l\u2019image initiale. Compl\u00e9ter le programme suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def nombre_lignes ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nombre_colonnes ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions # que le parametre image nouvelle_image = [[ 0 for k in range ( nombre_colonnes ( image ))] for i in range ( nombre_lignes ( image ))] for i in range ( nombre_lignes ( image )): for j in range ( ... ): nouvelle_image [ i ][ j ] = ... return nouvelle_image def binaire ( image , seuil ): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' nouvelle_image = [[ 0 ] * nombre_colonnes ( image ) for i in range ( nombre_lignes ( image ))] for i in range ( nombre_lignes ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : nouvelle_image [ i ][ j ] = ... else : nouvelle_image [ i ][ j ] = ... return nouvelle_image Exemples : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 237 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nombre_lignes ( img ) 4 >>> nombre_colonnes ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , 18 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( img , 120 ) [[ 0 , 0 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 1 , 0 ],[ 1 , 1 , 1 , 0 , 0 ],[ 1 , 0 , 0 , 1 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def nombre_lignes ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nombre_colonnes ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions # que le parametre image nouvelle_image = [[ 0 for k in range ( nombre_colonnes ( image ))] for i in range ( nombre_lignes ( image ))] for i in range ( nombre_lignes ( image )): for j in range ( nombre_colonnes ( image )): nouvelle_image [ i ][ j ] = 255 - image [ i ][ j ] return nouvelle_image def binaire ( image , seuil ): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' nouvelle_image = [[ 0 ] * nombre_colonnes ( image ) for i in range ( nombre_lignes ( image ))] for i in range ( nombre_lignes ( image )): for j in range ( nombre_colonnes ( image )): if image [ i ][ j ] < seuil : nouvelle_image [ i ][ j ] = 0 else : nouvelle_image [ i ][ j ] = 1 return nouvelle_image Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Le n\u00e9gatif d\u2019une image est l\u2019image constitu\u00e9e des pixels `x_n` tels que `x_n + x_i = 255` o\u00f9 `x_i` est le pixel correspondant de l\u2019image initiale. Compl\u00e9ter le programme suivant : ```python linenums='1' def nombre_lignes(image): '''renvoie le nombre de lignes de l'image''' return ... def nombre_colonnes(image): '''renvoie la largeur de l'image''' return ... def negatif(image): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions # que le parametre image nouvelle_image = [[0 for k in range(nombre_colonnes(image))] for i in range(nombre_lignes(image))] for i in range(nombre_lignes(image)): for j in range(...): nouvelle_image[i][j] = ... return nouvelle_image def binaire(image, seuil): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' nouvelle_image = [[0] * nombre_colonnes(image) for i in range(nombre_lignes(image))] for i in range(nombre_lignes(image)): for j in range(...): if image[i][j] < ... : nouvelle_image[i][j] = ... else: nouvelle_image[i][j] = ... return nouvelle_image Exemples : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 237 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nombre_lignes ( img ) 4 >>> nombre_colonnes ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , 18 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( img , 120 ) [[ 0 , 0 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 1 , 0 ],[ 1 , 1 , 1 , 0 , 0 ],[ 1 , 0 , 0 , 1 , 1 ]] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 21 \u2693\ufe0e Version originale du sujet en pdf. Exercice 21.1 \u2693\ufe0e Exercice 21.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_motif qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res motif non vide et une cha\u00eene de caract\u00e8res texte et qui renvoie la liste des positions de motif dans texte . Si motif n\u2019appara\u00eet pas, la fonction renvoie une liste vide. Exemples: \ud83d\udc0d Script Python >>> recherche_motif ( \"ab\" , \"\" ) [] >>> recherche_motif ( \"ab\" , \"cdcdcdcd\" ) [] >>> recherche_motif ( \"ab\" , \"abracadabra\" ) [ 0 , 7 ] >>> recherche_motif ( \"ab\" , \"abracadabraab\" ) [ 0 , 7 , 11 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def recherche_motif ( motif , texte ): sol = [] i = 0 while i <= len ( texte ) - len ( motif ): j = 0 while j < len ( motif ) and motif [ j ] == texte [ j + i ]: j += 1 if j == len ( motif ): sol . append ( i ) i += 1 return sol \ud83d\udccb Texte \u00c9crire une fonction `recherche_motif` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res `motif` non vide et une cha\u00eene de caract\u00e8res `texte` et qui renvoie la liste des positions de `motif` dans `texte`. Si `motif` n\u2019appara\u00eet pas, la fonction renvoie une liste vide. Exemples: ```python >>> recherche_motif(\"ab\", \"\") [] >>> recherche_motif(\"ab\", \"cdcdcdcd\") [] >>> recherche_motif(\"ab\", \"abracadabra\") [0, 7] >>> recherche_motif(\"ab\", \"abracadabraab\") [0, 7, 11] ``` R\u00e9digez votre code sur Basthon Exercice 21.2 \u2693\ufe0e Exercice 21.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on consid\u00e8re un graphe non orient\u00e9 repr\u00e9sent\u00e9 sous forme de listes d\u2019adjacence. On suppose que les sommets sont num\u00e9rot\u00e9s de 0 \u00e0 n-1. Ainsi, le graphe suivant: sera repr\u00e9sent\u00e9 par la liste d\u2019adjacence suivante: adj = [[1, 2], [0, 3], [0], [1], [5], [4]] On souhaite d\u00e9terminer les sommets accessibles depuis un sommet donn\u00e9 dans le graphe. Pour cela, on va proc\u00e9der \u00e0 un parcours en profondeur du graphe. Compl\u00e9ter la fonction suivante. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def parcours ( adj , x , acc ): '''R\u00e9alise un parcours en profondeur r\u00e9cursif du graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x en accumulant les sommets rencontr\u00e9s dans acc''' if x ... : acc . append ( x ) for y in ... : parcours ( adj , ... ) def accessibles ( adj , x ): '''Renvoie la liste des sommets accessibles dans le graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x.''' acc = [] parcours ( adj , ... ) return acc Exemples : \ud83d\udc0d Script Python >>> accessibles ([[ 1 , 2 ], [ 0 ], [ 0 , 3 ], [ 1 ], [ 5 ], [ 4 ]], 0 ) [ 0 , 1 , 2 , 3 ] >>> accessibles ([[ 1 , 2 ], [ 0 ], [ 0 , 3 ], [ 1 ], [ 5 ], [ 4 ]], 4 ) [ 4 , 5 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 adj = [[ 1 , 2 ], [ 0 , 3 ], [ 0 ], [ 1 ], [ 5 ], [ 4 ]] def parcours ( adj , x , acc ): '''R\u00e9alise un parcours en profondeur r\u00e9cursif du graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x en accumulant les sommets rencontr\u00e9s dans acc''' if x not in acc : acc . append ( x ) for y in adj [ x ]: parcours ( adj , y , acc ) def accessibles ( adj , x ): '''Renvoie la liste des sommets accessibles dans le graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x.''' acc = [] parcours ( adj , x , acc ) return acc Markdown Dans cet exercice, on consid\u00e8re un graphe non orient\u00e9 repr\u00e9sent\u00e9 sous forme de listes d\u2019adjacence. On suppose que les sommets sont num\u00e9rot\u00e9s de 0 \u00e0 n-1. Ainsi, le graphe suivant: ![ image ]( data2024/graph1.png ){: .center} sera repr\u00e9sent\u00e9 par la liste d\u2019adjacence suivante: `adj = [[1, 2], [0, 3], [0], [1], [5], [4]]` On souhaite d\u00e9terminer les sommets accessibles depuis un sommet donn\u00e9 dans le graphe. Pour cela, on va proc\u00e9der \u00e0 un parcours en profondeur du graphe. Compl\u00e9ter la fonction suivante. ```python linenums='1' def parcours(adj, x, acc): '''R\u00e9alise un parcours en profondeur r\u00e9cursif du graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x en accumulant les sommets rencontr\u00e9s dans acc''' if x ...: acc.append(x) for y in ...: parcours(adj, ...) def accessibles(adj, x): '''Renvoie la liste des sommets accessibles dans le graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x.''' acc = [] parcours(adj, ...) return acc Exemples : \ud83d\udc0d Script Python >>> accessibles ([[ 1 , 2 ], [ 0 ], [ 0 , 3 ], [ 1 ], [ 5 ], [ 4 ]], 0 ) [ 0 , 1 , 2 , 3 ] >>> accessibles ([[ 1 , 2 ], [ 0 ], [ 0 , 3 ], [ 1 ], [ 5 ], [ 4 ]], 4 ) [ 4 , 5 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 22 \u2693\ufe0e Version originale du sujet en pdf. Exercice 22.1 \u2693\ufe0e Exercice 22.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_indices_classement qui prend en param\u00e8tres un entier elt et un tableau d\u2019entiers tab , et qui renvoie trois listes : la premi\u00e8re liste contient les indices des valeurs du tableau tab strictement inf\u00e9rieures \u00e0 elt ; la deuxi\u00e8me liste contient les indices des valeurs du tableau tab \u00e9gales \u00e0 elt ; la troisi\u00e8me liste contient les indices des valeurs du tableau tab strictement sup\u00e9rieures \u00e0 elt . Exemples : \ud83d\udc0d Script Python >>> recherche_indices_classement ( 3 , [ 1 , 3 , 4 , 2 , 4 , 6 , 3 , 0 ]) ([ 0 , 3 , 7 ], [ 1 , 6 ], [ 2 , 4 , 5 ]) >>> recherche_indices_classement ( 3 , [ 1 , 4 , 2 , 4 , 6 , 0 ]) ([ 0 , 2 , 5 ], [], [ 1 , 3 , 4 ]) >>> recherche_indices_classement ( 3 , [ 1 , 1 , 1 , 1 ]) ([ 0 , 1 , 2 , 3 ], [], []) >>> recherche_indices_classement ( 3 , []) ([], [], []) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche_indices_classement ( elt , tab ): ind_inf = [] ind_egal = [] ind_sup = [] for i in range ( len ( tab )): if tab [ i ] < elt : ind_inf . append ( i ) elif tab [ i ] > elt : ind_sup . append ( i ) else : ind_egal . append ( i ) return ( ind_inf , ind_egal , ind_sup ) \ud83d\udccb Texte \u00c9crire une fonction `recherche_indices_classement` qui prend en param\u00e8tres un entier `elt` et un tableau d\u2019entiers `tab`, et qui renvoie trois listes : - la premi\u00e8re liste contient les indices des valeurs du tableau `tab` strictement inf\u00e9rieures \u00e0 `elt` ; - la deuxi\u00e8me liste contient les indices des valeurs du tableau `tab` \u00e9gales \u00e0 `elt` ; - la troisi\u00e8me liste contient les indices des valeurs du tableau `tab` strictement sup\u00e9rieures \u00e0 `elt`. Exemples : ```python >>> recherche_indices_classement(3, [1, 3, 4, 2, 4, 6, 3, 0]) ([0, 3, 7], [1, 6], [2, 4, 5]) >>> recherche_indices_classement(3, [1, 4, 2, 4, 6, 0]) ([0, 2, 5], [], [1, 3, 4]) >>>recherche_indices_classement(3, [1, 1, 1, 1]) ([0, 1, 2, 3], [], []) >>> recherche_indices_classement(3, []) ([], [], []) ``` R\u00e9digez votre code sur Basthon Exercice 22.2 \u2693\ufe0e Exercice 22.2 \u00c9nonc\u00e9 Correction Sources Markdown Une professeure de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves sous forme de cha\u00eene de caract\u00e8res et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients dans une liste. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' : { 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ] }, 'Durand' : { 'DS1' : [ 6 , 4 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 12 , 4 ] } } L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ses \u00e9l\u00e8ves et renvoie sa moyenne arrondie au dixi\u00e8me. Si l\u2019\u00e9l\u00e8ve n\u2019a pas de notes, on consid\u00e8re que sa moyenne est nulle. Si le nom donn\u00e9 n\u2019est pas dans les r\u00e9sultats, la fonction renvoie None . Compl\u00e9ter le code de la professeure ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def moyenne ( nom , resultats ): '''Renvoie la moyenne de l'\u00e9l\u00e8ve nom, selon le dictionnaire resultats. Si nom n'est pas dans le dictionnaire, la fonction renvoie None.''' if nom in ... : notes = resultats [ nom ] if ... : # pas de notes return 0 total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient ... = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return None Exemples : \ud83d\udc0d Script Python >>> moyenne ( \"Dupont\" , resultats ) 14.5 >>> moyenne ( \"Durand\" , resultats ) 8.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def moyenne ( nom , resultats ): '''Renvoie la moyenne de l'\u00e9l\u00e8ve nom, selon le dictionnaire resultats. Si nom n'est pas dans le dictionnaire, la fonction renvoie None.''' if nom in resultats : notes = resultats [ nom ] if notes == {}: # pas de notes return 0 total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return None Markdown Une professeure de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : - les clefs sont les noms des \u00e9l\u00e8ves ; - les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves sous forme de cha\u00eene de caract\u00e8res et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients dans une liste. Avec : ```python resultats = {'Dupont': { 'DS1': [15.5, 4], 'DM1': [14.5, 1], 'DS2': [13, 4], 'PROJET1': [16, 3], 'DS3': [14, 4] }, 'Durand': { 'DS1': [6 , 4], 'DS2': [8, 4], 'PROJET1': [9, 3], 'IE1': [7, 2], 'DS3': [12, 4] } } L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ses \u00e9l\u00e8ves et renvoie sa moyenne arrondie au dixi\u00e8me. Si l\u2019\u00e9l\u00e8ve n\u2019a pas de notes, on consid\u00e8re que sa moyenne est nulle. Si le nom donn\u00e9 n\u2019est pas dans les r\u00e9sultats, la fonction renvoie None . Compl\u00e9ter le code de la professeure ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def moyenne ( nom , resultats ): '''Renvoie la moyenne de l'\u00e9l\u00e8ve nom, selon le dictionnaire resultats. Si nom n'est pas dans le dictionnaire, la fonction renvoie None.''' if nom in ... : notes = resultats [ nom ] if ... : # pas de notes return 0 total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient ... = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return None Exemples : \ud83d\udc0d Script Python >>> moyenne ( \"Dupont\" , resultats ) 14.5 >>> moyenne ( \"Durand\" , resultats ) 8.5 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 23 \u2693\ufe0e Version originale du sujet en pdf. Exercice 23.1 \u2693\ufe0e Exercice 23.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, on consid\u00e8re des arbres binaires de recherche qui sont : soit l\u2019arbre vide identifi\u00e9 par None ; soit un n\u0153ud, contenant une cl\u00e9 et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par un triplet (g, v, d) o\u00f9 g et d sont les sous-arbres gauche et droit et v la cl\u00e9. Ainsi, l\u2019arbre binaire de recherche abr1 ci- contre est cr\u00e9\u00e9 par le code python ci- dessous \ud83d\udc0d Script Python n0 = ( None , 0 , None ) n3 = ( None , 3 , None ) n2 = ( None , 2 , n3 ) abr1 = ( n0 , 1 , n2 ) \u00c9crire une fonction r\u00e9cursive insertion_abr(a, cle) qui prend en param\u00e8tres une cl\u00e9 cle et un arbre binaire de recherche a , et qui renvoie un arbre binaire de recherche dans lequel cle a \u00e9t\u00e9 ins\u00e9r\u00e9e. Dans le cas o\u00f9 cle est d\u00e9j\u00e0 pr\u00e9sente dans a , la fonction renvoie l\u2019arbre a inchang\u00e9. R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> insertion_abr ( abr1 , 4 ) (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 ,( None , 4 , None )))) >>> insertion_abr ( abr1 , - 5 ) ((( None , - 5 , None ), 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) >>> insertion_abr ( abr1 , 2 ) (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def insertion_abr ( a , cle ): if a is None : return ( None , cle , None ) elif cle > a [ 1 ]: return ( a [ 0 ], a [ 1 ], insertion_abr ( a [ 2 ], cle )) elif cle < a [ 1 ]: return ( insertion_abr ( a [ 0 ], cle ), a [ 1 ], a [ 2 ]) return a \ud83d\udccb Texte Dans cet exercice, on consid\u00e8re des arbres binaires de recherche qui sont : - soit l\u2019arbre vide identifi\u00e9 par `None` ; - soit un n\u0153ud, contenant une cl\u00e9 et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par un triplet `(g, v, d)` o\u00f9 `g` et `d` sont les sous-arbres gauche et droit et `v` la cl\u00e9. ![image](data2023/12_arbre.png){: .center width=30%} Ainsi, l\u2019arbre binaire de recherche `abr1` ci- contre est cr\u00e9\u00e9 par le code python ci- dessous ```python n0 = (None, 0, None) n3 = (None, 3, None) n2 = (None, 2, n3) abr1 = (n0, 1, n2) ``` \u00c9crire une fonction r\u00e9cursive `insertion_abr(a, cle)` qui prend en param\u00e8tres une cl\u00e9 `cle` et un arbre binaire de recherche `a`, et qui renvoie un arbre binaire de recherche dans lequel `cle` a \u00e9t\u00e9 ins\u00e9r\u00e9e. Dans le cas o\u00f9 `cle` est d\u00e9j\u00e0 pr\u00e9sente dans `a`, la fonction renvoie l\u2019arbre a inchang\u00e9. R\u00e9sultats \u00e0 obtenir : ```python >>> insertion_abr(abr1, 4) ((None,0,None),1,(None,2,(None,3,(None,4,None)))) >>> insertion_abr(abr1, -5) (((None,-5,None),0,None),1,(None,2,(None,3,None))) >>> insertion_abr(abr1, 2) ((None,0,None),1,(None,2,(None,3,None))) ``` R\u00e9digez votre code sur Basthon Exercice 23.2 \u2693\ufe0e Exercice 23.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019un ensemble d\u2019objets dont on conna\u00eet, pour chacun, la masse. On souhaite ranger l\u2019ensemble de ces objets dans des boites identiques de telle mani\u00e8re que la somme des masses des objets contenus dans une bo\u00eete ne d\u00e9passe pas la capacit\u00e9 c de la bo\u00eete. On souhaite utiliser le moins de bo\u00eetes possibles pour ranger cet ensemble d\u2019objets. Pour r\u00e9soudre ce probl\u00e8me, on utilisera un algorithme glouton consistant \u00e0 placer chacun des objets dans la premi\u00e8re bo\u00eete o\u00f9 cela est possible. Par exemple, pour ranger dans des bo\u00eetes de capacit\u00e9 c = 5 un ensemble de trois objets dont les masses sont repr\u00e9sent\u00e9es en Python par la liste [1, 5, 2] , on proc\u00e8de de la fa\u00e7on suivante : Le premier objet, de masse 1, va dans une premi\u00e8re boite. Le deuxi\u00e8me objet, de masse 5, ne peut pas aller dans la m\u00eame boite que le premier objet car cela d\u00e9passerait la capacit\u00e9 de la boite. On place donc cet objet dans une deuxi\u00e8me bo\u00eete. Le troisi\u00e8me objet, de masse 2, va dans la premi\u00e8re bo\u00eete. On a donc utilis\u00e9 deux bo\u00eetes de capacit\u00e9 c = 5 pour ranger les 3 objets. Compl\u00e9ter la fonction Python empaqueter(liste_masses, c) suivante pour qu\u2019elle renvoie le nombre de bo\u00eetes de capacit\u00e9 c n\u00e9cessaires pour empaqueter un ensemble d\u2019objets dont les masses sont contenues dans la liste liste_masses . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def empaqueter ( liste_masses , c ): \"\"\"Renvoie le nombre minimal de bo\u00eetes n\u00e9cessaires pour empaqueter les objets de la liste liste_masses, sachant que chaque bo\u00eete peut contenir au maximum c kilogrammes\"\"\" n = len ( liste_masses ) nb_boites = 0 boites = [ 0 for _ in range ( n ) ] for masse in ... : i = 0 while i < nb_boites and boites [ i ] + ... > c : i = i + 1 if i == nb_boites : ... boites [ i ] = ... return ... Exemples : \ud83d\udc0d Script Python >>> empaqueter ([ 1 , 2 , 3 , 4 , 5 ], 10 ) 2 >>> empaqueter ([ 1 , 2 , 3 , 4 , 5 ], 5 ) 4 >>> empaqueter ([ 7 , 6 , 3 , 4 , 8 , 5 , 9 , 2 ], 11 ) 5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def empaqueter ( liste_masses , c ): \"\"\"Renvoie le nombre minimal de bo\u00eetes n\u00e9cessaires pour empaqueter les objets de la liste liste_masses, sachant que chaque bo\u00eete peut contenir au maximum c kilogrammes\"\"\" n = len ( liste_masses ) nb_boites = 0 boites = [ 0 for _ in range ( n ) ] for masse in liste_masses : i = 0 while i < nb_boites and boites [ i ] + masse > c : i = i + 1 if i == nb_boites : nb_boites = nb_boites + 1 boites [ i ] = boites [ i ] + masse return nb_boites Markdown On dispose d\u2019un ensemble d\u2019objets dont on conna\u00eet, pour chacun, la masse. On souhaite ranger l\u2019ensemble de ces objets dans des boites identiques de telle mani\u00e8re que la somme des masses des objets contenus dans une bo\u00eete ne d\u00e9passe pas la capacit\u00e9 `c` de la bo\u00eete. On souhaite utiliser le moins de bo\u00eetes possibles pour ranger cet ensemble d\u2019objets. Pour r\u00e9soudre ce probl\u00e8me, on utilisera un algorithme glouton consistant \u00e0 placer chacun des objets dans la premi\u00e8re bo\u00eete o\u00f9 cela est possible. Par exemple, pour ranger dans des bo\u00eetes de capacit\u00e9 `c = 5` un ensemble de trois objets dont les masses sont repr\u00e9sent\u00e9es en Python par la liste `[1, 5, 2]` , on proc\u00e8de de la fa\u00e7on suivante : - Le premier objet, de masse 1, va dans une premi\u00e8re boite. - Le deuxi\u00e8me objet, de masse 5, ne peut pas aller dans la m\u00eame boite que le premier objet car cela d\u00e9passerait la capacit\u00e9 de la boite. On place donc cet objet dans une deuxi\u00e8me bo\u00eete. - Le troisi\u00e8me objet, de masse 2, va dans la premi\u00e8re bo\u00eete. On a donc utilis\u00e9 deux bo\u00eetes de capacit\u00e9 `c = 5` pour ranger les 3 objets. Compl\u00e9ter la fonction Python `empaqueter(liste_masses, c)` suivante pour qu\u2019elle renvoie le nombre de bo\u00eetes de capacit\u00e9 `c` n\u00e9cessaires pour empaqueter un ensemble d\u2019objets dont les masses sont contenues dans la liste `liste_masses` . ```python linenums='1' def empaqueter(liste_masses, c): \"\"\"Renvoie le nombre minimal de bo\u00eetes n\u00e9cessaires pour empaqueter les objets de la liste liste_masses, sachant que chaque bo\u00eete peut contenir au maximum c kilogrammes\"\"\" n = len(liste_masses) nb_boites = 0 boites = [ 0 for _ in range(n) ] for masse in ...: i = 0 while i < nb_boites and boites[i] + ... > c: i = i + 1 if i == nb_boites: ... boites[i] = ... return ... Exemples : \ud83d\udc0d Script Python >>> empaqueter ([ 1 , 2 , 3 , 4 , 5 ], 10 ) 2 >>> empaqueter ([ 1 , 2 , 3 , 4 , 5 ], 5 ) 4 >>> empaqueter ([ 7 , 6 , 3 , 4 , 8 , 5 , 9 , 2 ], 11 ) 5 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 24 \u2693\ufe0e Version originale du sujet en pdf. Exercice 24.1 \u2693\ufe0e Exercice 24.1 \u00c9nonc\u00e9 Correction Source Markdown Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None , soit un n\u0153ud repr\u00e9sent\u00e9 par un triplet (g, x, d) o\u00f9 x est l\u2019\u00e9tiquette du n\u0153ud et g et d sont les sous-arbres gauche et droit. On souhaite \u00e9crire une fonction parcours_largeur qui prend en param\u00e8tre un arbre binaire et qui renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre parcourus en largeur. Exemples : \ud83d\udc0d Script Python >>> arbre = ( ( ( None , 1 , None ), 2 , ( None , 3 , None ) ), 4 , ( ( None , 5 , None ), 6 , ( None , 7 , None ) ) ) >>> parcours_largeur ( arbre ) [ 4 , 2 , 6 , 1 , 3 , 5 , 7 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def parcours_largeur ( arbre ): parcours = [] file = [ arbre ] while file != []: a = file . pop ( 0 ) parcours . append ( a [ 1 ]) if a [ 0 ] != None : file . append ( a [ 0 ]) if a [ 2 ] != None : file . append ( a [ 2 ]) return parcours \ud83d\udccb Texte Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur `None`, soit un n\u0153ud repr\u00e9sent\u00e9 par un triplet `(g, x, d)` o\u00f9 `x` est l\u2019\u00e9tiquette du n\u0153ud et `g` et `d` sont les sous-arbres gauche et droit. On souhaite \u00e9crire une fonction `parcours_largeur` qui prend en param\u00e8tre un arbre binaire et qui renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre parcourus en largeur. Exemples : ```python >>> arbre = ( ( (None, 1, None), 2, (None, 3, None) ), 4, ( (None, 5, None), 6, (None, 7, None) ) ) >>> parcours_largeur(arbre) [4, 2, 6, 1, 3, 5, 7] ``` R\u00e9digez votre code sur Basthon Exercice 24.2 \u2693\ufe0e Exercice 24.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau non vide de nombre entiers, positifs ou n\u00e9gatifs, et on souhaite d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs. Par exemple, dans le tableau [1, -2, 3, 10, -4, 7, 2, -5] , la plus grande somme est 18 obtenue en additionnant les \u00e9l\u00e9ments 3, 10, -4, 7, 2. Pour cela, on va r\u00e9soudre le probl\u00e8me par programmation dynamique. Si on note tab le tableau consid\u00e9r\u00e9 et i un indice dans ce tableau, on se ram\u00e8ne \u00e0 un probl\u00e8me plus simple : d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice i . Si on connait la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice i-1 , on peut d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice i : soit on obtient une plus grande somme en ajoutant tab[i] \u00e0 cette somme pr\u00e9c\u00e9dente ; soit on commence une nouvelle somme \u00e0 partir de tab[i] . Remarque : les sommes consid\u00e9r\u00e9es contiennent toujours au moins un terme. Compl\u00e9ter la fonction somme_max ci-dessous qui r\u00e9alise cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def somme_max ( tab ): n = len ( tab ) sommes_max = [ 0 ] * n sommes_max [ 0 ] = tab [ 0 ] # on calcule la plus grande somme se terminant en i for i in range ( 1 , n ): if ... + ... > ... : sommes_max [ i ] = ... else : sommes_max [ i ] = ... # on en d\u00e9duit la plus grande somme de celles-ci maximum = 0 for i in range ( 1 , n ): if ... > ... : maximum = i return sommes_max [ ... ] Exemples : \ud83d\udc0d Script Python >>> somme_max ([ 1 , 2 , 3 , 4 , 5 ]) 15 >> somme_max ([ 1 , 2 , - 3 , 4 , 5 ]) 9 >>> somme_max ([ 1 , 2 , - 2 , 4 , 5 ]) 10 >>> somme_max ([ 1 , - 2 , 3 , 10 , - 4 , 7 , 2 , - 5 ]) 18 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def somme_max ( tab ): n = len ( tab ) sommes_max = [ 0 ] * n sommes_max [ 0 ] = tab [ 0 ] # on calcule la plus grande somme se terminant en i for i in range ( 1 , n ): if sommes_max [ i - 1 ] + tab [ i ] > tab [ i ]: sommes_max [ i ] = sommes_max [ i - 1 ] + tab [ i ] else : sommes_max [ i ] = tab [ i ] # on en d\u00e9duit la plus grande somme de celles-ci maximum = 0 for i in range ( 1 , n ): if sommes_max [ i ] > sommes_max [ maximum ]: maximum = i return sommes_max [ maximum ] Merci \u00e0 N. Maier pour la correction Markdown On consid\u00e8re un tableau non vide de nombre entiers, positifs ou n\u00e9gatifs, et on souhaite d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs. Par exemple, dans le tableau `[1, -2, 3, 10, -4, 7, 2, -5]` , la plus grande somme est 18 obtenue en additionnant les \u00e9l\u00e9ments 3, 10, -4, 7, 2. Pour cela, on va r\u00e9soudre le probl\u00e8me par programmation dynamique. Si on note `tab` le tableau consid\u00e9r\u00e9 et `i` un indice dans ce tableau, on se ram\u00e8ne \u00e0 un probl\u00e8me plus simple : d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice `i` . Si on connait la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice `i-1` , on peut d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice `i` : - soit on obtient une plus grande somme en ajoutant `tab[i]` \u00e0 cette somme pr\u00e9c\u00e9dente ; - soit on commence une nouvelle somme \u00e0 partir de `tab[i]` . *Remarque :* les sommes consid\u00e9r\u00e9es contiennent toujours au moins un terme. Compl\u00e9ter la fonction `somme_max` ci-dessous qui r\u00e9alise cet algorithme. ```python linenums='1' def somme_max(tab): n = len(tab) sommes_max = [0]*n sommes_max[0] = tab[0] # on calcule la plus grande somme se terminant en i for i in range(1,n): if ... + ... > ...: sommes_max[i] = ... else: sommes_max[i] = ... # on en d\u00e9duit la plus grande somme de celles-ci maximum = 0 for i in range(1, n): if ... > ...: maximum = i return sommes_max[...] Exemples : \ud83d\udc0d Script Python >>> somme_max ([ 1 , 2 , 3 , 4 , 5 ]) 15 >> somme_max ([ 1 , 2 , - 3 , 4 , 5 ]) 9 >>> somme_max ([ 1 , 2 , - 2 , 4 , 5 ]) 10 >>> somme_max ([ 1 , - 2 , 3 , 10 , - 4 , 7 , 2 , - 5 ]) 18 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 25 \u2693\ufe0e Version originale du sujet en pdf. Exercice 25.1 \u2693\ufe0e Exercice 25.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_min qui prend en param\u00e8tre un tableau de nombres tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> recherche_min ([ 5 ]) 0 >>> recherche_min ([ 2 , 4 , 1 ]) 2 >>> recherche_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 >>> recherche_min ([ - 1 , - 2 , - 3 , - 3 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \ud83d\udccb Texte \u00c9crire une fonction `recherche_min` qui prend en param\u00e8tre un tableau de nombres `tab`, et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> recherche_min([5]) 0 >>> recherche_min([2, 4, 1]) 2 >>> recherche_min([5, 3, 2, 2, 4]) 2 >>> recherche_min([-1, -2, -3, -3]) 2 ``` R\u00e9digez votre code sur Basthon Exercice 25.2 \u2693\ufe0e Exercice 25.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def separe ( tab ): '''Separe les 0 et les 1 dans le tableau tab''' gauche = 0 droite = ... while gauche < droite : if tab [ gauche ] == 0 : gauche = ... else : tab [ gauche ] = ... tab [ droite ] = ... droite = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Description d\u2019\u00e9tapes effectu\u00e9es par la fonction separe sur le tableau ci-dessous, les caract\u00e8res ^ indiquent les cases point\u00e9es par les indices gauche et droite : \ud83d\udc0d Script Python tab = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ^ ^ Etape 1 : on regarde la premi\u00e8re case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec la derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus la derni\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 2 : on regarde \u00e0 nouveau la premi\u00e8re case, qui contient maintenant un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la premi\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 3 : on regarde la seconde case, qui contient un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la seconde case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 4 : on regarde la troisi\u00e8me case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec l\u2019avant-derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus l\u2019avant-derni\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Et ainsi de suite... tab = [0, 0, 0, 0, 1, 1, 1, 1] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def separe ( tab ): '''Separe les 0 et les 1 dans le tableau tab''' gauche = 0 droite = len ( tab ) - 1 while gauche < droite : if tab [ gauche ] == 0 : gauche = gauche + 1 else : tab [ gauche ] = tab [ droite ] tab [ droite ] = 1 droite = droite - 1 return tab Markdown On consid\u00e8re la fonction `separe` ci-dessous qui prend en argument un tableau `tab` dont les \u00e9l\u00e9ments sont des `0` et des `1` et qui s\u00e9pare les `0` des `1` en pla\u00e7ant les `0` en d\u00e9but de tableau et les `1` \u00e0 la suite. ```python linenums='1' def separe(tab): '''Separe les 0 et les 1 dans le tableau tab''' gauche = 0 droite = ... while gauche < droite: if tab[gauche] == 0 : gauche = ... else : tab[gauche] = ... tab[droite] = ... droite = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Description d\u2019\u00e9tapes effectu\u00e9es par la fonction separe sur le tableau ci-dessous, les caract\u00e8res ^ indiquent les cases point\u00e9es par les indices gauche et droite : \ud83d\udc0d Script Python tab = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ^ ^ Etape 1 : on regarde la premi\u00e8re case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec la derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus la derni\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 2 : on regarde \u00e0 nouveau la premi\u00e8re case, qui contient maintenant un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la premi\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 3 : on regarde la seconde case, qui contient un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la seconde case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 4 : on regarde la troisi\u00e8me case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec l\u2019avant-derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus l\u2019avant-derni\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Et ainsi de suite... tab = [0, 0, 0, 0, 1, 1, 1, 1] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 26 \u2693\ufe0e Version originale du sujet en pdf. Exercice 26.1 \u2693\ufe0e Exercice 26.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction ajoute_dictionnaires qui prend en param\u00e8tres deux dictionnaires d1 et d2 dont les cl\u00e9s sont des nombres et renvoie le dictionnaire d d\u00e9fini de la fa\u00e7on suivante : Les cl\u00e9s de d sont celles de d1 et celles de d2 r\u00e9unies. Si une cl\u00e9 est pr\u00e9sente dans les deux dictionnaires d1 et d2 , sa valeur associ\u00e9e dans le dictionnaire d est la somme de ses valeurs dans les dictionnaires d1 et d2 . Si une cl\u00e9 n\u2019est pr\u00e9sente que dans un des deux dictionnaires, sa valeur associ\u00e9e dans le dictionnaire d est la m\u00eame que sa valeur dans le dictionnaire o\u00f9 elle est pr\u00e9sente. Exemples : \ud83d\udc0d Script Python >>> ajoute_dictionnaires ({ 1 : 5 , 2 : 7 }, { 2 : 9 , 3 : 11 }) { 1 : 5 , 2 : 16 , 3 : 11 } >>> ajoute_dictionnaires ({}, { 2 : 9 , 3 : 11 }) { 2 : 9 , 3 : 11 } >>> ajoute_dictionnaires ({ 1 : 5 , 2 : 7 }, {}) { 1 : 5 , 2 : 7 } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def ajoute_dictionnaires ( d1 , d2 ): d = {} for cle in d1 : d [ cle ] = d1 [ cle ] for cle in d2 : if cle in d : d [ cle ] += d2 [ cle ] else : d [ cle ] = d2 [ cle ] return d \ud83d\udccb Texte \u00c9crire une fonction `ajoute_dictionnaires` qui prend en param\u00e8tres deux dictionnaires `d1` et `d2` dont les cl\u00e9s sont des nombres et renvoie le dictionnaire `d` d\u00e9fini de la fa\u00e7on suivante : - Les cl\u00e9s de `d` sont celles de `d1` et celles de `d2` r\u00e9unies. - Si une cl\u00e9 est pr\u00e9sente dans les deux dictionnaires `d1` et `d2`, sa valeur associ\u00e9e dans le dictionnaire `d` est la somme de ses valeurs dans les dictionnaires `d1` et `d2`. - Si une cl\u00e9 n\u2019est pr\u00e9sente que dans un des deux dictionnaires, sa valeur associ\u00e9e dans le dictionnaire `d` est la m\u00eame que sa valeur dans le dictionnaire o\u00f9 elle est pr\u00e9sente. Exemples : ```python >>> ajoute_dictionnaires({1: 5, 2: 7}, {2: 9, 3: 11}) {1: 5, 2: 16, 3: 11} >>> ajoute_dictionnaires({}, {2: 9, 3: 11}) {2: 9, 3: 11} >>> ajoute_dictionnaires({1: 5, 2: 7}, {}) {1: 5, 2: 7} ``` R\u00e9digez votre code sur Basthon Exercice 26.2 \u2693\ufe0e Exercice 26.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une piste carr\u00e9e qui contient 4 cases par c\u00f4t\u00e9. Les cases sont num\u00e9rot\u00e9es de 0 inclus \u00e0 12 exclu comme ci-dessous : L\u2019objectif de l\u2019exercice est d\u2019impl\u00e9menter le jeu suivant : Au d\u00e9part, le joueur place son pion sur la case 0. A chaque coup, il lance un d\u00e9 \u00e9quilibr\u00e9 \u00e0 six faces et avance son pion d\u2019autant de cases que le nombre indiqu\u00e9 par le d\u00e9 (entre 1 et 6 inclus) dans le sens des aiguilles d\u2019une montre. Par exemple, s\u2019il obtient 2 au premier lancer, il pose son pion sur la case 2 puis s\u2019il obtient 6 au deuxi\u00e8me lancer, il le pose sur la case 8, puis s\u2019il obtient \u00e0 nouveau 6, il pose le pion sur la case 2. Le jeu se termine lorsque le joueur a pos\u00e9 son pion sur toutes les cases de la piste. Compl\u00e9ter la fonction nombre_coups ci-dessous de sorte qu\u2019elle renvoie le nombre de lancers al\u00e9atoires n\u00e9cessaires pour terminer le jeu. Proposer ensuite quelques tests pour en v\u00e9rifier le fonctionnement. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from random import randint def nombre_coups (): '''Simule un jeu de plateau avec 12 cases et renvoie le nombre minimal de coups pour visiter toutes les cases.''' nombre_cases = 12 # indique si une case a \u00e9t\u00e9 vue cases_vues = [ False ] * nombre_cases nombre_cases_vues = 1 cases_vues [ 0 ] = True case_en_cours = 0 n = ... while ... < ... : x = randint ( 1 , 6 ) case_en_cours = ( case_en_cours + ... ) % ... if ... : cases_vues [ case_en_cours ] = True nombre_cases_vues = ... n = ... return n \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from random import randint def nombre_coups (): '''Simule un jeu de plateau avec 12 cases et renvoie le nombre minimal de coups pour visiter toutes les cases.''' nombre_cases = 12 # indique si une case a \u00e9t\u00e9 vue cases_vues = [ False ] * nombre_cases nombre_cases_vues = 1 cases_vues [ 0 ] = True case_en_cours = 0 n = 0 while nombre_cases_vues < nombre_cases : x = randint ( 1 , 6 ) case_en_cours = ( case_en_cours + x ) % nombre_cases if not cases_vues [ case_en_cours ]: cases_vues [ case_en_cours ] = True nombre_cases_vues = nombre_cases_vues + 1 n = n + 1 return n Markdown On consid\u00e8re une piste carr\u00e9e qui contient 4 cases par c\u00f4t\u00e9. Les cases sont num\u00e9rot\u00e9es de 0 inclus \u00e0 12 exclu comme ci-dessous : ![ image ]( data2023/20_carre.png ){: .center width=20%} L\u2019objectif de l\u2019exercice est d\u2019impl\u00e9menter le jeu suivant : Au d\u00e9part, le joueur place son pion sur la case 0. A chaque coup, il lance un d\u00e9 \u00e9quilibr\u00e9 \u00e0 six faces et avance son pion d\u2019autant de cases que le nombre indiqu\u00e9 par le d\u00e9 (entre 1 et 6 inclus) dans le sens des aiguilles d\u2019une montre. Par exemple, s\u2019il obtient 2 au premier lancer, il pose son pion sur la case 2 puis s\u2019il obtient 6 au deuxi\u00e8me lancer, il le pose sur la case 8, puis s\u2019il obtient \u00e0 nouveau 6, il pose le pion sur la case 2. Le jeu se termine lorsque le joueur a pos\u00e9 son pion sur **toutes les cases** de la piste. Compl\u00e9ter la fonction `nombre_coups` ci-dessous de sorte qu\u2019elle renvoie le nombre de lancers al\u00e9atoires n\u00e9cessaires pour terminer le jeu. Proposer ensuite quelques tests pour en v\u00e9rifier le fonctionnement. ```python linenums='1' from random import randint def nombre_coups(): '''Simule un jeu de plateau avec 12 cases et renvoie le nombre minimal de coups pour visiter toutes les cases.''' nombre_cases = 12 # indique si une case a \u00e9t\u00e9 vue cases_vues = [ False ] * nombre_cases nombre_cases_vues = 1 cases_vues[0] = True case_en_cours = 0 n = ... while ... < ...: x = randint(1, 6) case_en_cours = (case_en_cours + ...) % ... if ...: cases_vues[case_en_cours] = True nombre_cases_vues = ... n = ... return n ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 27 \u2693\ufe0e Version originale du sujet en pdf. Exercice 27.1 \u2693\ufe0e Exercice 27.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction couples_consecutifs qui prend en param\u00e8tre un tableau de nombres entiers tab non vide (type list ), et qui renvoie la liste Python (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> couples_consecutifs ([ 1 , 4 , 3 , 5 ]) [] >>> couples_consecutifs ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> couples_consecutifs ([ 1 , 1 , 2 , 4 ]) [( 1 , 2 )] >>> couples_consecutifs ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> couples_consecutifs ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] \ud83d\udc0d Script Python 1 2 3 4 5 6 def couples_consecutifs ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \ud83d\udccb Texte \u00c9crire une fonction `couples_consecutifs` qui prend en param\u00e8tre un tableau de nombres entiers `tab` non vide (type `list`), et qui renvoie la liste Python (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans `tab`. Exemples : ```python >>> couples_consecutifs([1, 4, 3, 5]) [] >>> couples_consecutifs([1, 4, 5, 3]) [(4, 5)] >>> couples_consecutifs([1, 1, 2, 4]) [(1, 2)] >>> couples_consecutifs([7, 1, 2, 5, 3, 4]) [(1, 2), (3, 4)] >>> couples_consecutifs([5, 1, 2, 3, 8, -5, -4, 7]) [(1, 2), (2, 3), (-5, -4)] ``` R\u00e9digez votre code sur Basthon Exercice 27.2 \u2693\ufe0e Exercice 27.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction colore_comp1 prend pour param\u00e8tre une image M (repr\u00e9sent\u00e9e par une liste de listes), deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien sinon. Par exemple, colore_comp1(M, 2, 1, 3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction colore_comp1 donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def colore_comp1 ( M , i , j , val ): if M [ i ][ j ] != 1 : return M [ i ][ j ] = val if i - 1 >= 0 : # propage en haut colore_comp1 ( M , i - 1 , j , val ) if ... < len ( M ): # propage en bas colore_comp1 ( M , ... , j , val ) if ... : # propage \u00e0 gauche colore_comp1 ( M , ... , ... , val ) if ... : # propage \u00e0 droite ... dans le sujet original, les commentaires sur la direction de propagation sont erron\u00e9s Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 0 ]] >>> colore_comp1 ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def colore_comp1 ( M , i , j , val ): if M [ i ][ j ] != 1 : return M [ i ][ j ] = val if i - 1 >= 0 : # propage \u00e0 gauche colore_comp1 ( M , i - 1 , j , val ) if i + 1 < len ( M ): # propage \u00e0 droite colore_comp1 ( M , i + 1 , j , val ) if j - 1 >= 0 : # propage en haut colore_comp1 ( M , i , j - 1 , val ) if j + 1 < len ( M [ i ]): # propage en bas colore_comp1 ( M , i , j + 1 , val ) Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments `M[i][j]` , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 `0` soit \u00e0 `1` . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de `1` et de `0` qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de ![ image ]( data2023/36_carre1.png ){: .center} sont ![ image ]( data2023/36_carre2.png ){: .center width=30%} On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 `1` dans une image `M` , donner la valeur `val` \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction `colore_comp1` prend pour param\u00e8tre une image `M` (repr\u00e9sent\u00e9e par une liste de listes), deux entiers `i` et `j` et une valeur enti\u00e8re `val` . Elle met \u00e0 la valeur `val` tous les pixels de la composante du pixel `M[i][j]` s\u2019il vaut `1` et ne fait rien sinon. Par exemple, `colore_comp1(M, 2, 1, 3)` donne ![ image ]( data2023/36_carre3.png ){: .center width=30%} Compl\u00e9ter le code r\u00e9cursif de la fonction `colore_comp1` donn\u00e9 ci-dessous : ```python linenums='1' def colore_comp1(M, i, j, val): if M[i][j] != 1: return M[i][j] = val if i-1 >= 0: # propage en haut colore_comp1(M, i-1, j, val) if ... < len(M): # propage en bas colore_comp1(M, ..., j, val) if ...: # propage \u00e0 gauche colore_comp1(M, ..., ..., val) if ...: # propage \u00e0 droite ... dans le sujet original, les commentaires sur la direction de propagation sont erron\u00e9s Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 0 ]] >>> colore_comp1 ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 28 \u2693\ufe0e Version originale du sujet en pdf. Exercice 28.1 \u2693\ufe0e Exercice 28.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par : les deux premi\u00e8res valeurs sont \u00e9gales \u00e0 1 ; ensuite, chaque valeur est obtenue en faisant la somme des deux valeurs qui la pr\u00e9c\u00e8- dent. La troisi\u00e8me valeur est donc \\(1+1 = 2\\) , la quatri\u00e8me est \\(1+2 = 3\\) , la cinqui\u00e8me est \\(2+3 = 5\\) , la sixi\u00e8me est \\(3 + 5 = 8\\) , et ainsi de suite. Cette suite d\u2019entiers est connue sous le nom de suite de Fibonacci. \u00c9crire en Python une fonction fibonacci qui prend en param\u00e8tre un entier n suppos\u00e9 strictement positif et qui renvoie le terme d\u2019indice n de cette suite. Exemples : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 Version r\u00e9cursive : \ud83d\udc0d Script Python 1 2 3 4 5 def fibonacci ( n ): if n <= 2 : return 1 else : return fibonacci ( n - 1 ) + fibonacci ( n - 2 ) Version programmation dynamique bottom-up: \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonacci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] Version programmation dynamique top-down avec m\u00e9mo\u00efsation: \ud83d\udc0d Script Python 1 2 3 4 5 6 dict_fibo = { 1 : 1 , 2 : 1 } def fibonacci ( n ): if n in dict_fibo : return dict_fibo [ n ] dict_fibo [ n ] = fibonacci ( n - 1 ) + fibonacci ( n - 2 ) return dict_fibo [ n ] On peut constater que la version r\u00e9cursive \u00e9choue \u00e0 calculer fibonacci(45) , alors que les deux autres versions le font quasi-imm\u00e9diatement. \ud83d\udccb Texte On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par : - les deux premi\u00e8res valeurs sont \u00e9gales \u00e0 1 ; - ensuite, chaque valeur est obtenue en faisant la somme des deux valeurs qui la pr\u00e9c\u00e8- dent. La troisi\u00e8me valeur est donc $1+1 = 2$, la quatri\u00e8me est $1+2 = 3$, la cinqui\u00e8me est $2+3 = 5$, la sixi\u00e8me est $3 + 5 = 8$, et ainsi de suite. Cette suite d\u2019entiers est connue sous le nom de suite de Fibonacci. \u00c9crire en Python une fonction `fibonacci` qui prend en param\u00e8tre un entier `n` suppos\u00e9 strictement positif et qui renvoie le terme d\u2019indice `n` de cette suite. Exemples : ```python >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(25) 75025 ``` R\u00e9digez votre code sur Basthon Exercice 28.2 \u2693\ufe0e Exercice 28.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction eleves_du_mois prenant en param\u00e8tres eleves et notes deux tableaux de m\u00eame longueur, le premier contenant le nom des \u00e9l\u00e8ves et le second, des entiers positifs d\u00e9signant leur note \u00e0 un contr\u00f4le de sorte que eleves[i] a obtenu la note notes[i] . Cette fonction renvoie le couple constitu\u00e9 de la note maximale attribu\u00e9e et des noms des \u00e9l\u00e8ves ayant obtenu cette note regroup\u00e9s dans un tableau. Ainsi, l\u2019instruction eleves_du_mois(['a', 'b', 'c', 'd'], [15, 18, 12, 18]) renvoie le couple (18, ['b', 'd']) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def eleves_du_mois ( eleves , notes ): note_maxi = 0 meilleurs_eleves = ... for i in range ( ... ) : if notes [ i ] == ... : meilleurs_eleves . append ( ... ) elif notes [ i ] > note_maxi : note_maxi = ... meilleurs_eleves = [ ... ] return ( note_maxi , meilleurs_eleves ) Compl\u00e9ter ce code. Exemples : \ud83d\udc0d Script Python >>> eleves_nsi = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] >>> notes_nsi = [ 30 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] >>> eleves_du_mois ( eleves_nsi , notes_nsi ) ( 80 , [ 'c' , 'f' , 'h' ]) >>> eleves_du_mois ([],[]) ( 0 , []) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def eleves_du_mois ( eleves , notes ): note_maxi = 0 meilleurs_eleves = [] for i in range ( len ( eleves )) : if notes [ i ] == note_maxi : meilleurs_eleves . append ( eleves [ i ]) elif notes [ i ] > note_maxi : note_maxi = notes [ i ] meilleurs_eleves = [ eleves [ i ]] return ( note_maxi , meilleurs_eleves ) Markdown On consid\u00e8re la fonction `eleves_du_mois` prenant en param\u00e8tres `eleves` et `notes` deux tableaux de m\u00eame longueur, le premier contenant le nom des \u00e9l\u00e8ves et le second, des entiers positifs d\u00e9signant leur note \u00e0 un contr\u00f4le de sorte que `eleves[i]` a obtenu la note `notes[i]` . Cette fonction renvoie le couple constitu\u00e9 de la note maximale attribu\u00e9e et des noms des \u00e9l\u00e8ves ayant obtenu cette note regroup\u00e9s dans un tableau. Ainsi, l\u2019instruction `eleves_du_mois(['a', 'b', 'c', 'd'], [15, 18, 12, 18])` renvoie le couple `(18, ['b', 'd'])` . ```python linenums='1' def eleves_du_mois(eleves, notes): note_maxi = 0 meilleurs_eleves = ... for i in range(...) : if notes[i] == ... : meilleurs_eleves.append(...) elif notes[i] > note_maxi: note_maxi = ... meilleurs_eleves = [...] return (note_maxi,meilleurs_eleves) Compl\u00e9ter ce code. Exemples : \ud83d\udc0d Script Python >>> eleves_nsi = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] >>> notes_nsi = [ 30 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] >>> eleves_du_mois ( eleves_nsi , notes_nsi ) ( 80 , [ 'c' , 'f' , 'h' ]) >>> eleves_du_mois ([],[]) ( 0 , []) ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 29 \u2693\ufe0e Version originale du sujet en pdf. Exercice 29.1 \u2693\ufe0e Exercice 29.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne(notes) qui renvoie la moyenne pond\u00e9r\u00e9e des r\u00e9sultats contenus dans le tableau notes , non vide, donn\u00e9 en param\u00e8tre. Ce tableau contient des couples (note, coefficient) dans lesquels : note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier strictement positif. Ainsi l\u2019expression moyenne([(15.0,2),(9.0,1),(12.0,3)]) devra renvoyer 12.5 . \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( liste_notes ): somme_notes = 0 somme_coeffs = 0 for devoir in liste_notes : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \ud83d\udccb Texte \u00c9crire une fonction `moyenne(notes)` qui renvoie la moyenne pond\u00e9r\u00e9e des r\u00e9sultats contenus dans le tableau `notes`, non vide, donn\u00e9 en param\u00e8tre. Ce tableau contient des couples `(note, coefficient)` dans lesquels : - `note` est un nombre de type flottant (`float`) compris entre 0 et 20 ; - `coefficient` est un nombre entier strictement positif. Ainsi l\u2019expression `moyenne([(15.0,2),(9.0,1),(12.0,3)])` devra renvoyer `12.5`. $\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5$ R\u00e9digez votre code sur Basthon Exercice 29.2 \u2693\ufe0e Exercice 29.2 \u00c9nonc\u00e9 Correction Sources Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal (Figure 1). Dans le triangle de Pascal, chaque ligne commence et se termine par le nombre 1. Comme l\u2019illustre la Figure 2, on additionne deux valeurs successives d\u2019une ligne pour obtenir la valeur qui se situe sous la deuxi\u00e8me valeur. Compl\u00e9ter les fonctions ligne_suivante et pascal ci-dessous. La fonction ligne_suivante prend en param\u00e8tre une liste d\u2019entiers ligne correspondant \u00e0 une ligne du triangle de Pascal et renvoie la liste correspondant \u00e0 la ligne suivante du triangle de Pascal. La fonction pascal prend en param\u00e8tre un entier n et l\u2019utilise pour construire le triangle de Pascal ayant n+1 lignes sous la forme d\u2019une liste de listes. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def ligne_suivante ( ligne ): '''Renvoie la ligne suivant ligne du triangle de Pascal''' ligne_suiv = [ ... ] for i in range ( ... ): ligne_suiv . append ( ... ) ligne_suiv . append ( ... ) return ligne_suiv def pascal ( n ): '''Renvoie le triangle de Pascal de hauteur n''' triangle = [ [ 1 ] ] for k in range ( ... ): ligne_k = ... triangle . append ( ligne_k ) return triangle Exemples: \ud83d\udc0d Script Python >>> ligne_suivante ([ 1 , 3 , 3 , 1 ]) [ 1 , 4 , 6 , 4 , 1 ] >>> pascal ( 2 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ]] >>> pascal ( 3 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def ligne_suivante ( ligne ): '''Renvoie la ligne suivant ligne du triangle de Pascal''' ligne_suiv = [ ligne [ 0 ]] for i in range ( 1 , len ( ligne )): ligne_suiv . append ( ligne [ i - 1 ] + ligne [ i ]) ligne_suiv . append ( ligne [ - 1 ]) return ligne_suiv def pascal ( n ): '''Renvoie le triangle de Pascal de hauteur n''' triangle = [ [ 1 ] ] for k in range ( n ): ligne_k = ligne_suivante ( triangle [ - 1 ]) triangle . append ( ligne_k ) return triangle Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal (Figure 1). Dans le triangle de Pascal, chaque ligne commence et se termine par le nombre 1. Comme l\u2019illustre la Figure 2, on additionne deux valeurs successives d\u2019une ligne pour obtenir la valeur qui se situe sous la deuxi\u00e8me valeur. ![ image ]( data2023/17_triangle.png ){: .center width=60%} Compl\u00e9ter les fonctions `ligne_suivante` et `pascal` ci-dessous. La fonction `ligne_suivante` prend en param\u00e8tre une liste d\u2019entiers `ligne` correspondant \u00e0 une ligne du triangle de Pascal et renvoie la liste correspondant \u00e0 la ligne suivante du triangle de Pascal. La fonction `pascal` prend en param\u00e8tre un entier n et l\u2019utilise pour construire le triangle de Pascal ayant `n+1` lignes sous la forme d\u2019une liste de listes. ```python linenums='1' def ligne_suivante(ligne): '''Renvoie la ligne suivant ligne du triangle de Pascal''' ligne_suiv = [...] for i in range(...): ligne_suiv.append(...) ligne_suiv.append(...) return ligne_suiv def pascal(n): '''Renvoie le triangle de Pascal de hauteur n''' triangle = [ [1] ] for k in range(...): ligne_k = ... triangle.append(ligne_k) return triangle Exemples: \ud83d\udc0d Script Python >>> ligne_suivante ([ 1 , 3 , 3 , 1 ]) [ 1 , 4 , 6 , 4 , 1 ] >>> pascal ( 2 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ]] >>> pascal ( 3 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ]] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 30 \u2693\ufe0e Version originale du sujet en pdf. Exercice 30.1 \u2693\ufe0e Exercice 30.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction fusion prenant en param\u00e8tres deux tableaux non vides tab1 et tab2 (type list ) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de tab1 et tab2 . Exemples : \ud83d\udc0d Script Python >>> fusion ([ 3 , 5 ], [ 2 , 5 ]) [ 2 , 3 , 5 , 5 ] >>> fusion ([ - 2 , 4 ], [ - 3 , 5 , 10 ]) [ - 3 , - 2 , 4 , 5 , 10 ] >>> fusion ([ 4 ], [ 2 , 6 ]) [ 2 , 4 , 6 ] >>> fusion ([], []) [] >>> fusion ([ 1 , 2 , 3 ], []) [ 1 , 2 , 3 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fusion ( tab1 , tab2 ): tab_fusion = [] i1 = 0 i2 = 0 while i1 < len ( tab1 ) and i2 < len ( tab2 ): if tab1 [ i1 ] < tab2 [ i2 ]: tab_fusion . append ( tab1 [ i1 ]) i1 += 1 else : tab_fusion . append ( tab2 [ i2 ]) i2 += 1 if i1 == len ( tab1 ): while i2 < len ( tab2 ): tab_fusion . append ( tab2 [ i2 ]) i2 += 1 else : while i1 < len ( tab1 ): tab_fusion . append ( tab1 [ i1 ]) i1 += 1 return tab_fusion \ud83d\udccb Texte Programmer la fonction `fusion` prenant en param\u00e8tres deux tableaux non vides `tab1` et `tab2` (type `list`) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de `tab1` et `tab2`. Exemples : ```python >>> fusion([3, 5], [2, 5]) [2, 3, 5, 5] >>> fusion([-2, 4], [-3, 5, 10]) [-3, -2, 4, 5, 10] >>> fusion([4], [2, 6]) [2, 4, 6] >>> fusion([], []) [] >>> fusion([1, 2, 3], []) [1, 2, 3] ``` R\u00e9digez votre code sur Basthon Exercice 30.2 \u2693\ufe0e Exercice 30.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de cet exercice est d\u2019\u00e9crire une fonction r\u00e9cursive traduire_romain qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res, non vide, repr\u00e9sentant un nombre \u00e9crit en chiffres romains et qui renvoie son \u00e9criture d\u00e9cimale. Les chiffres romains consid\u00e9r\u00e9s sont : I, V, X, L, C, D et M. Ils repr\u00e9sentent respectivement les nombres 1, 5, 10, 50, 100, 500, et 1000 en base dix. On dispose d\u2019un dictionnaire romains dont les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale : romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000} Le code de la fonction traduire_romain fournie repose sur le principe suivant : la valeur d\u2019un caract\u00e8re est ajout\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur sup\u00e9rieure (ou \u00e9gale) \u00e0 celle du caract\u00e8re qui le suit ; la valeur d\u2019un caract\u00e8re est retranch\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur strictement inf\u00e9rieure \u00e0 celle du caract\u00e8re qui le suit. Ainsi, XIV correspond au nombre 10 + 5 - 1 puisque : la valeur de X (10) est sup\u00e9rieure \u00e0 celle de I (1), on ajoute donc 10 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire IV ; la valeur de I (1) est strictement inf\u00e9rieure \u00e0 celle de V (5), on soustrait donc 1 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire V. On rappelle que pour priver une cha\u00eene de caract\u00e8res de son premier caract\u00e8re, on utilisera l\u2019instruction : nom_de_variable[1:] Par exemple, si la variable mot contient la cha\u00eene \"CDI\" , mot[1:] renvoie \"DI\" . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 romains = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } def traduire_romain ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len ( nombre ) == 1 : return ... elif romains [ nombre [ 0 ]] >= ... return romains [ nombre [ 0 ]] + ... else : return ... Exemples : \ud83d\udc0d Script Python >>> traduire_romain ( \"XIV\" ) 14 >>> traduire_romain ( \"CXLII\" ) 142 >>> traduire_romain ( \"MMXXIV\" ) 2024 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 romains = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } def traduire_romain ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len ( nombre ) == 1 : return romains [ nombre ] elif romains [ nombre [ 0 ]] >= romains [ nombre [ 1 ]]: return romains [ nombre [ 0 ]] + traduire_romain ( nombre [ 1 :]) else : return traduire_romain ( nombre [ 1 :]) - romains [ nombre [ 0 ]] Markdown Le but de cet exercice est d\u2019\u00e9crire une fonction r\u00e9cursive `traduire_romain` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res, non vide, repr\u00e9sentant un nombre \u00e9crit en chiffres romains et qui renvoie son \u00e9criture d\u00e9cimale. Les chiffres romains consid\u00e9r\u00e9s sont : I, V, X, L, C, D et M. Ils repr\u00e9sentent respectivement les nombres 1, 5, 10, 50, 100, 500, et 1000 en base dix. On dispose d\u2019un dictionnaire `romains` dont les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale : `romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000}` Le code de la fonction `traduire_romain` fournie repose sur le principe suivant : - la valeur d\u2019un caract\u00e8re est ajout\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur sup\u00e9rieure (ou \u00e9gale) \u00e0 celle du caract\u00e8re qui le suit ; - la valeur d\u2019un caract\u00e8re est retranch\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur strictement inf\u00e9rieure \u00e0 celle du caract\u00e8re qui le suit. Ainsi, XIV correspond au nombre 10 + 5 - 1 puisque : - la valeur de X (10) est sup\u00e9rieure \u00e0 celle de I (1), on ajoute donc 10 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire IV ; - la valeur de I (1) est strictement inf\u00e9rieure \u00e0 celle de V (5), on soustrait donc 1 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire V. On rappelle que pour priver une cha\u00eene de caract\u00e8res de son premier caract\u00e8re, on utilisera l\u2019instruction : `nom_de_variable[1:]` Par exemple, si la variable `mot` contient la cha\u00eene `\"CDI\"` , `mot[1:]` renvoie `\"DI\"` . ```python linenums='1' romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000} def traduire_romain(nombre): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len(nombre) == 1: return ... elif romains[nombre[0]] >= ... return romains[nombre[0]] + ... else: return ... Exemples : \ud83d\udc0d Script Python >>> traduire_romain ( \"XIV\" ) 14 >>> traduire_romain ( \"CXLII\" ) 142 >>> traduire_romain ( \"MMXXIV\" ) 2024 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 31 \u2693\ufe0e Version originale du sujet en pdf. Exercice 31.1 \u2693\ufe0e Exercice 31.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers relatifs n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def multiplication ( n1 , n2 ): # on se ram\u00e8ne d'abord au cas o\u00f9 n1 et n2 sont tous les deux positifs : if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers relatifs `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. ```python >>> multiplication(3, 5) 15 >>> multiplication(-4, -8) 32 >>> multiplication(-2, 6) -12 >>> multiplication(-2, 0) 0 ``` R\u00e9digez votre code sur Basthon Exercice 31.2 \u2693\ufe0e Exercice 31.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse dans cet exercice \u00e0 la recherche dichotomique dans un tableau tri\u00e9 d\u2019en- tiers. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d'entiers tri\u00e9 dans l'ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Markdown On s\u2019int\u00e9resse dans cet exercice \u00e0 la recherche dichotomique dans un tableau tri\u00e9 d\u2019en- tiers. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau d'entiers tri\u00e9 dans l'ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 32 \u2693\ufe0e Version originale du sujet en pdf. Exercice 32.1 \u2693\ufe0e Exercice 32.1 \u00c9nonc\u00e9 Correction Source Markdown L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents. Il est symbolis\u00e9 par le caract\u00e8re \u2295. Ainsi : 0 \u2295 0 = 0 0 \u2295 1 = 1 1 \u2295 0 = 1 1 \u2295 1 = 0 \u00c9crire une fonction ou_exclusif qui prend en param\u00e8tres deux tableaux de 0 ou de 1 de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. \ud83d\udc0d Script Python >>> ou_exclusif ([ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ], [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ]) [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ] >>> ou_exclusif ([ 1 , 1 , 0 , 1 ], [ 0 , 0 , 1 , 1 ]) [ 1 , 1 , 1 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 def ou_exclusif ( tab1 , tab2 ): resultat = [] taille = len ( tab1 ) for i in range ( taille ): resultat . append ( tab1 [ i ] ^ tab2 [ i ]) return resultat Si on ne connait pas la fonction native ^ qui fait le \u00abou exclusif\u00bb de deux entiers en Python, on peut la recoder : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def ou_exc ( a , b ): if a == 0 and b == 0 : return 0 if a == 0 and b == 1 : return 1 if a == 1 and b == 0 : return 1 if a == 1 and b == 1 : return 0 Le code devient alors : \ud83d\udc0d Script Python 1 2 3 4 5 6 def ou_exclusif ( tab1 , tab2 ): resultat = [] taille = len ( tab1 ) for i in range ( taille ): resultat . append ( ou_exc ( tab1 [ i ], tab2 [ i ])) return resultat \ud83d\udccb Texte L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents. Il est symbolis\u00e9 par le caract\u00e8re \u2295. Ainsi : - 0 \u2295 0 = 0 - 0 \u2295 1 = 1 - 1 \u2295 0 = 1 - 1 \u2295 1 = 0 \u00c9crire une fonction `ou_exclusif` qui prend en param\u00e8tres deux tableaux de 0 ou de 1 de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position `i` est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position `i` des tableaux pass\u00e9s en param\u00e8tres. ```python >>> ou_exclusif([1, 0, 1, 0, 1, 1, 0, 1], [0, 1, 1, 1, 0, 1, 0, 0]) [1, 1, 0, 1, 1, 0, 0, 1] >>> ou_exclusif([1, 1, 0, 1], [0, 0, 1, 1]) [1, 1, 1, 0] ``` R\u00e9digez votre code sur Basthon Exercice 32.2 \u2693\ufe0e Exercice 32.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit semimagique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne sont \u00e9gales. Ainsi c2 et c3 sont semimagiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 8 pour c2 et 12 pour c3. Le carre c3bis n'est pas semimagique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 15 alors que celle de la deuxi\u00e8me ligne est \u00e9gale \u00e0 10. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. La m\u00e9thode constructeur cr\u00e9e un carr\u00e9 sous forme d\u2019un tableau \u00e0 deux dimensions \u00e0 partir d\u2019une liste d\u2019entiers, et d\u2019un ordre. La m\u00e9thode affiche permet d\u2019afficher le carr\u00e9 cr\u00e9\u00e9. Exemple : \ud83d\udc0d Script Python >>> lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] >>> c3 = Carre ( lst_c3 , 3 ) >>> c3 . affiche () [ 3 , 4 , 5 ] [ 4 , 4 , 4 ] [ 5 , 4 , 3 ] Compl\u00e9ter la m\u00e9thode est_semimagique qui renvoie True si le carr\u00e9 est semimagique, False sinon. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... ): if ... != s : return ... #test de la somme de chaque colonne for j in range ( ... ): if ... != s : return ... return ... Tester la m\u00e9thode est_semimagique sur les carr\u00e9s c2, c3 et c3bis. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( self . ordre ): if self . somme_ligne ( i ) != s : return False #test de la somme de chaque colonne for j in range ( self . ordre ): if self . somme_col ( j ) != s : return False return True Tests avec : \ud83d\udc0d Script Python 1 2 3 lst_c2 = [ 1 , 7 , 7 , 1 ] lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] lst_c3bis = [ 2 , 9 , 4 , 7 , 0 , 3 , 6 , 1 , 8 ] \ud83d\udc0d Script Python >>> c2 = Carre ( lst_c2 , 2 ) >>> c2 . est_semimagique () True >>> c3 = Carre ( lst_c3 , 3 ) >>> c3 . est_semimagique () True >>> c3bis = Carre ( lst_c3bis , 2 ) >>> c3bis . est_semimagique () False Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre $n$ un tableau de $n$ lignes et $n$ colonnes dont chaque case contient un entier naturel. Exemples : ![ image ]( data2023/35_carre.png ){: .center} Un carr\u00e9 est dit semimagique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne sont \u00e9gales. - Ainsi c2 et c3 sont semimagiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 8 pour c2 et 12 pour c3. - Le carre c3bis n'est pas semimagique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 15 alors que celle de la deuxi\u00e8me ligne est \u00e9gale \u00e0 10. La classe `Carre` ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. - La m\u00e9thode constructeur cr\u00e9e un carr\u00e9 sous forme d\u2019un tableau \u00e0 deux dimensions \u00e0 partir d\u2019une liste d\u2019entiers, et d\u2019un ordre. - La m\u00e9thode `affiche` permet d\u2019afficher le carr\u00e9 cr\u00e9\u00e9. Exemple : ```python >>> lst_c3 = [3, 4, 5, 4, 4, 4, 5, 4, 3] >>> c3 = Carre(lst_c3, 3) >>> c3.affiche() [3, 4, 5] [4, 4, 4] [5, 4, 3] Compl\u00e9ter la m\u00e9thode est_semimagique qui renvoie True si le carr\u00e9 est semimagique, False sinon. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... ): if ... != s : return ... #test de la somme de chaque colonne for j in range ( ... ): if ... != s : return ... return ... Tester la m\u00e9thode est_semimagique sur les carr\u00e9s c2, c3 et c3bis. ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 33 \u2693\ufe0e Version originale du sujet en pdf. Exercice 33.1 \u2693\ufe0e Exercice 33.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer une fonction renverse , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res mot et renvoie cette cha\u00eene de caract\u00e8res en ordre inverse. Exemple : \ud83d\udc0d Script Python >>> renverse ( \"\" ) \"\" >>> renverse ( \"abc\" ) \"cba\" >>> renverse ( \"informatique\" ) \"euqitamrofni\" \ud83d\udc0d Script Python 1 2 3 4 5 def renverse ( mot ): sol = '' for lettre in mot : sol = lettre + sol return sol \ud83d\udccb Texte Programmer une fonction `renverse`, prenant en param\u00e8tre une cha\u00eene de caract\u00e8res `mot` et renvoie cette cha\u00eene de caract\u00e8res en ordre inverse. Exemple : ```python >>> renverse(\"\") \"\" >>> renverse(\"abc\") \"cba\" >>> renverse(\"informatique\") \"euqitamrofni\" ``` R\u00e9digez votre code sur Basthon Exercice 33.2 \u2693\ufe0e Exercice 33.2 \u00c9nonc\u00e9 Correction Sources Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre n fix\u00e9. On consid\u00e8re pour cela un tableau tab de n bool\u00e9ens, initialement tous \u00e9gaux \u00e0 True , sauf tab[0] et tab[1] qui valent False , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice i : si tab[i] vaut True : le nombre i est premier et on donne la valeur False \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de i , \u00e0 partir de 2*i (c\u2019est-\u00e0-dire 2*i , 3*i ...). si tab[i] vaut False : le nombre i n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction crible , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier n strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que n . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def crible ( n ): \"\"\"Renvoie un tableau contenant tous les nombres premiers plus petits que n.\"\"\" premiers = [] tab = [ True ] * n tab [ 0 ], tab [ 1 ] = False , False for i in range ( n ): if tab [ i ]: premiers .... multiple = ... while multiple < n : tab [ multiple ] = ... multiple = ... return premiers Exemples : \ud83d\udc0d Script Python >>> crible ( 40 ) [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] >>> crible ( 5 ) [ 2 , 3 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ddef crible ( n ): \"\"\"Renvoie un tableau contenant tous les nombres premiers plus petits que n.\"\"\" premiers = [] tab = [ True ] * n tab [ 0 ], tab [ 1 ] = False , False for i in range ( n ): if tab [ i ]: premiers . append ( i ) multiple = i while multiple < n : tab [ multiple ] = False multiple = multiple + i return premiers Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre `n` fix\u00e9. On consid\u00e8re pour cela un tableau `tab` de `n` bool\u00e9ens, initialement tous \u00e9gaux \u00e0 `True` , sauf `tab[0]` et `tab[1]` qui valent `False` , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice `i` : - si `tab[i]` vaut `True` : le nombre `i` est premier et on donne la valeur `False` \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de `i` , \u00e0 partir de `2*i` (c\u2019est-\u00e0-dire `2*i` , `3*i` ...). - si `tab[i]` vaut `False` : le nombre `i` n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction `crible` , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier `n` strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que `n` . ```python linenums='1' def crible(n): \"\"\"Renvoie un tableau contenant tous les nombres premiers plus petits que n.\"\"\" premiers = [] tab = [True] * n tab[0], tab[1] = False, False for i in range(n): if tab[i]: premiers.... multiple = ... while multiple < n: tab[multiple] = ... multiple = ... return premiers Exemples : \ud83d\udc0d Script Python >>> crible ( 40 ) [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] >>> crible ( 5 ) [ 2 , 3 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 34 \u2693\ufe0e Version originale du sujet en pdf. Exercice 34.1 \u2693\ufe0e Exercice 34.1 \u00c9nonc\u00e9 Correction Source Markdown Le nombre d\u2019occurrences d\u2019un caract\u00e8re dans une cha\u00eene de caract\u00e8re est le nombre d\u2019apparitions de ce caract\u00e8re dans la cha\u00eene. Exemples : le nombre d\u2019occurrences du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; le nombre d\u2019occurrences du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; le nombre d\u2019occurrences du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; le nombre d\u2019occurrences du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs le nombre d\u2019occurrences de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} L\u2019ordre des clefs n\u2019a pas d\u2019importance. \u00c9crire une fonction nbr_occurrences prenant comme param\u00e8tre une cha\u00eene de caract\u00e8res chaine et renvoyant le dictionnaire des nombres d\u2019occurrences des caract\u00e8res de cette cha\u00eene. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def nbr_occurrences ( chaine ): nb_occ = {} for caractere in chaine : if caractere in nb_occ : nb_occ [ caractere ] += 1 else : nb_occ [ caractere ] = 1 return nb_occ \ud83d\udccb Texte Le nombre d\u2019occurrences d\u2019un caract\u00e8re dans une cha\u00eene de caract\u00e8re est le nombre d\u2019apparitions de ce caract\u00e8re dans la cha\u00eene. Exemples : - le nombre d\u2019occurrences du caract\u00e8re `\u2018o\u2019` dans `\u2018bonjour\u2019` est 2 ; - le nombre d\u2019occurrences du caract\u00e8re `\u2018b\u2019` dans `\u2018B\u00e9b\u00e9\u2019` est 1 ; - le nombre d\u2019occurrences du caract\u00e8re `\u2018B\u2019` dans `\u2018B\u00e9b\u00e9\u2019` est 1 ; - le nombre d\u2019occurrences du caract\u00e8re `\u2018 \u2018` dans `\u2018Hello world !\u2019` est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs le nombre d\u2019occurrences de ces caract\u00e8res. Par exemple : avec la phrase `'Hello world !'` le dictionnaire est le suivant : `{'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1}` *L\u2019ordre des clefs n\u2019a pas d\u2019importance.* \u00c9crire une fonction `nbr_occurrences` prenant comme param\u00e8tre une cha\u00eene de caract\u00e8res `chaine` et renvoyant le dictionnaire des nombres d\u2019occurrences des caract\u00e8res de cette cha\u00eene. R\u00e9digez votre code sur Basthon Exercice 34.2 \u2693\ufe0e Exercice 34.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction fusion prend deux tableaux tab1 , tab2 (type list ) d\u2019entiers tri\u00e9s par ordre croissant et les fusionne en un tableau tri\u00e9 tab12 qu\u2019elle renvoie. Compl\u00e9ter le code de la fonction fusion ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def fusion ( tab1 , tab2 ): '''Fusionne deux tableaux tri\u00e9s et renvoie le nouveau tableau tri\u00e9.''' n1 = len ( tab1 ) n2 = len ( tab2 ) tab12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if tab1 [ i1 ] < tab2 [ i2 ]: tab12 [ i ] = ... i1 = ... else : tab12 [ i ] = tab2 [ i2 ] i2 = ... i += 1 while i1 < n1 : tab12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : tab12 [ i ] = ... i2 = i2 + 1 i = ... return tab12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( tab1 , tab2 ): n1 = len ( tab1 ) n2 = len ( tab2 ) tab12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if tab1 [ i1 ] < tab2 [ i2 ]: tab12 [ i ] = tab1 [ i1 ] i1 = i1 + 1 else : tab12 [ i ] = tab2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : tab12 [ i ] = tab1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : tab12 [ i ] = tab2 [ i2 ] i2 = i2 + 1 i = i + 1 return tab12 Markdown La fonction `fusion` prend deux tableaux `tab1` , `tab2` (type `list` ) d\u2019entiers tri\u00e9s par ordre croissant et les fusionne en un tableau tri\u00e9 `tab12` qu\u2019elle renvoie. Compl\u00e9ter le code de la fonction `fusion` ci-dessous. ```python linenums='1' def fusion(tab1,tab2): '''Fusionne deux tableaux tri\u00e9s et renvoie le nouveau tableau tri\u00e9.''' n1 = len(tab1) n2 = len(tab2) tab12 = [0] * (n1 + n2) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ...: if tab1[i1] < tab2[i2]: tab12[i] = ... i1 = ... else: tab12[i] = tab2[i2] i2 = ... i += 1 while i1 < n1: tab12[i] = ... i1 = i1 + 1 i = ... while i2 < n2: tab12[i] = ... i2 = i2 + 1 i = ... return tab12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 35 \u2693\ufe0e Version originale du sujet en pdf. Exercice 35.1 \u2693\ufe0e Exercice 35.1 \u00c9nonc\u00e9 Correction Source Markdown On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux tableaux (de type list ) : l\u2019un pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction annee_temperature_minimale qui prend en param\u00e8tres ces deux tableaux et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. On suppose que la temp\u00e9rature minimale est atteinte une seule fois. Exemple : \ud83d\udc0d Script Python >>> annee_temperature_minimale ( t_moy , annees ) ( 12.5 , 2016 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def annee_temperature_minimale ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \ud83d\udccb Texte On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux tableaux (de type `list`) : l\u2019un pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : ```python t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7] annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019] ``` \u00c9crire la fonction `annee_temperature_minimale` qui prend en param\u00e8tres ces deux tableaux et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. On suppose que la temp\u00e9rature minimale est atteinte une seule fois. Exemple : ```python >>> annee_temperature_minimale(t_moy, annees) (12.5, 2016) ``` R\u00e9digez votre code sur Basthon Exercice 35.2 \u2693\ufe0e Exercice 35.2 \u00c9nonc\u00e9 Correction Sources Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : kayak , radar , et non sont des mots palindromes. De m\u00eame certains nombres ont des \u00e9critures d\u00e9cimales qui sont des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous qui s\u2019appuient les unes sur les autres : inverse_chaine : qui renvoie une cha\u00eene de caract\u00e8res invers\u00e9e ; est_palindrome : qui teste si une cha\u00eene de caract\u00e8res est un palindrome ; est_nbre_palindrome : qui teste si un nombre est un palindrome. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def inverse_chaine ( chaine ): '''Retourne la chaine invers\u00e9e''' resultat = ... for caractere in chaine : resultat = ... return resultat def est_palindrome ( chaine ): '''Renvoie un bool\u00e9en indiquant si la chaine ch est un palindrome''' inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): '''Renvoie un bool\u00e9en indiquant si le nombre nbre est un palindrome''' chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def inverse_chaine ( chaine ): '''Retourne la chaine invers\u00e9e''' resultat = '' for caractere in chaine : resultat = caractere + resultat return resultat def est_palindrome ( chaine ): '''Renvoie un bool\u00e9en indiquant si la chaine ch est un palindrome''' inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): '''Renvoie un bool\u00e9en indiquant si le nombre nbre est un palindrome''' chaine = str ( nbre ) return est_palindrome ( chaine ) Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : *kayak* , *radar* , et *non* sont des mots palindromes. De m\u00eame certains nombres ont des \u00e9critures d\u00e9cimales qui sont des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous qui s\u2019appuient les unes sur les autres : - `inverse_chaine` : qui renvoie une cha\u00eene de caract\u00e8res invers\u00e9e ; - `est_palindrome` : qui teste si une cha\u00eene de caract\u00e8res est un palindrome ; - `est_nbre_palindrome` : qui teste si un nombre est un palindrome. Compl\u00e9ter le code des trois fonctions ci-dessous. ```python linenums='1' def inverse_chaine(chaine): '''Retourne la chaine invers\u00e9e''' resultat = ... for caractere in chaine: resultat = ... return resultat def est_palindrome(chaine): '''Renvoie un bool\u00e9en indiquant si la chaine ch est un palindrome''' inverse = inverse_chaine(chaine) return ... def est_nbre_palindrome(nbre): '''Renvoie un bool\u00e9en indiquant si le nombre nbre est un palindrome''' chaine = ... return est_palindrome(chaine) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 36 \u2693\ufe0e Version originale du sujet en pdf. Exercice 36.1 \u2693\ufe0e Exercice 36.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction occurrences(caractere, chaine) qui prend en param\u00e8tres caractere , une cha\u00eene de caract\u00e8re de longueur 1, et chaine , une cha\u00eene de carac- t\u00e8res. Cette fonction renvoie le nombre d\u2019occurrences de caractere dans chaine , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans chaine . Exemples : \ud83d\udc0d Script Python >>> occurrences ( 'e' , \"sciences\" ) 2 >>> occurrences ( 'i' , \"mississippi\" ) 4 >>> occurrences ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def occurrences ( caractere , chaine ): somme = 0 for lettre in chaine : if lettre == caractere : somme += 1 return somme \ud83d\udccb Texte \u00c9crire une fonction `occurrences(caractere, chaine)` qui prend en param\u00e8tres `caractere`, une cha\u00eene de caract\u00e8re de longueur 1, et `chaine`, une cha\u00eene de carac- t\u00e8res. Cette fonction renvoie le nombre d\u2019occurrences de `caractere` dans `chaine`, c\u2019est-\u00e0-dire le nombre de fois o\u00f9 `caractere` appara\u00eet dans `chaine`. Exemples : ```python >>> occurrences('e', \"sciences\") 2 >>> occurrences('i',\"mississippi\") 4 >>> occurrences('a',\"mississippi\") 0 ``` R\u00e9digez votre code sur Basthon Exercice 36.2 \u2693\ufe0e Exercice 36.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste valeurs = [100, 50, 20, 10, 5, 2, 1] . On suppose que les pi\u00e8ces et billets sont disponibles sans limitation. On cherche \u00e0 donner la liste des valeurs \u00e0 rendre pour une somme donn\u00e9e en argument. L\u2019algorithme utilis\u00e9 est de type glouton. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 valeurs = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( a_rendre , rang ): if a_rendre == 0 : return ... v = valeurs [ rang ] if v <= ... : return ... + rendu_glouton ( a_rendre - v , rang ) else : return rendu_glouton ( a_rendre , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 67 , 0 ) [ 50 , 10 , 5 , 2 ] >>> rendu_glouton ( 291 , 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] >>> rendu_glouton ( 291 , 1 ) # si on ne dispose pas de billets de 100 [ 50 , 50 , 50 , 50 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 valeurs = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( a_rendre , rang ): if a_rendre == 0 : return [] v = valeurs [ rang ] if v <= a_rendre : return [ v ] + rendu_glouton ( a_rendre - v , rang ) else : return rendu_glouton ( a_rendre , rang + 1 ) Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste `valeurs = [100, 50, 20, 10, 5, 2, 1]`. On suppose que les pi\u00e8ces et billets sont disponibles sans limitation. On cherche \u00e0 donner la liste des valeurs \u00e0 rendre pour une somme donn\u00e9e en argument. L\u2019algorithme utilis\u00e9 est de type glouton. Compl\u00e9ter le code Python ci-dessous de la fonction `rendu_glouton` qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. ```python linenums='1' valeurs = [100, 50, 20, 10, 5, 2, 1] def rendu_glouton(a_rendre, rang): if a_rendre == 0: return ... v = valeurs[rang] if v <= ... : return ... + rendu_glouton(a_rendre - v, rang) else : return rendu_glouton(a_rendre, ...) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 67 , 0 ) [ 50 , 10 , 5 , 2 ] >>> rendu_glouton ( 291 , 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] >>> rendu_glouton ( 291 , 1 ) # si on ne dispose pas de billets de 100 [ 50 , 50 , 50 , 50 , 50 , 20 , 20 , 1 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 37 \u2693\ufe0e Version originale du sujet en pdf. Exercice 37.1 \u2693\ufe0e Exercice 37.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (de type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide. Proposer une fa\u00e7on de traiter le cas o\u00f9 le tableau pass\u00e9 en param\u00e8tre est vide. Dans cet exercice, on s\u2019interdira d\u2019utiliser la fonction Python sum . Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) # Comportement diff\u00e9rent suivant le traitement propos\u00e9. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'Le tableau donn\u00e9 est vide' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte Programmer la fonction ```moyenne``` prenant en param\u00e8tre un tableau d'entiers ```tab``` (de type `list`) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide. Proposer une fa\u00e7on de traiter le cas o\u00f9 le tableau pass\u00e9 en param\u00e8tre est vide. Dans cet exercice, on s\u2019interdira d\u2019utiliser la fonction Python `sum`. Exemples : ```python >>> moyenne([5,3,8]) 5.333333333333333 >>> moyenne([1,2,3,4,5,6,7,8,9,10]) 5.5 >>> moyenne([]) # Comportement diff\u00e9rent suivant le traitement propos\u00e9. ``` R\u00e9digez votre code sur Basthon Exercice 37.2 \u2693\ufe0e Exercice 37.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau d'entiers tab (de type list ) dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Au d\u00e9part, les zones ne contenant que des 0 et des 1 sont vides. Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Compl\u00e9ter la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def tri ( tab ): '''tab est un tableau d'entiers contenant des 0 et des 1. La fonction trie ce tableau en pla\u00e7ant tous les 0 \u00e0 gauche''' i = ... # premier indice de la zone non tri\u00e9e j = ... # dernier indice de la zone non tri\u00e9e while i < j : if tab [ i ] == 0 : i = ... else : valeur = ... tab [ j ] = ... ... j = ... Exemple : \ud83d\udc0d Script Python >>> tab = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] >>> tri ( tab ) >>> tab [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def tri ( tab ): '''tab est un tableau d'entiers contenant des 0 et des 1. La fonction trie ce tableau en pla\u00e7ant tous les 0 \u00e0 gauche''' i = 0 # premier indice de la zone non tri\u00e9e j = len ( tab ) - 1 # dernier indice de la zone non tri\u00e9e while i < j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 Markdown On consid\u00e8re un tableau d'entiers `tab` (de type `list` ) dont les \u00e9l\u00e9ments sont des `0` ou des `1` ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des `0` , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des `1` . Au d\u00e9part, les zones ne contenant que des `0` et des `1` sont vides. <table> <tr> <td>Zone de 0</td><td>Zone non tri\u00e9e</td><td>Zone de 1</td> </tr> </table> Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : - si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; - si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Compl\u00e9ter la fonction `tri` suivante : ```python linenums='1' def tri(tab): '''tab est un tableau d'entiers contenant des 0 et des 1. La fonction trie ce tableau en pla\u00e7ant tous les 0 \u00e0 gauche''' i = ... # premier indice de la zone non tri\u00e9e j = ... # dernier indice de la zone non tri\u00e9e while i < j: if tab[i] == 0: i = ... else: valeur = ... tab[j] = ... ... j = ... Exemple : \ud83d\udc0d Script Python >>> tab = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] >>> tri ( tab ) >>> tab [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 38 \u2693\ufe0e Version originale du sujet en pdf. Exercice 38.1 \u2693\ufe0e Exercice 38.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction indices_maxi qui prend en param\u00e8tre un tableau non vide de nombre entiers tab , repr\u00e9sent\u00e9 par une liste Python et qui renvoie un tuple ( maxi , indices ) o\u00f9 : maxi est le plus grand \u00e9l\u00e9ment du tableau tab ; indices est une liste Python contenant les indices du tableau tab o\u00f9 appara\u00eet ce plus grand \u00e9l\u00e9ment. Exemple : \ud83d\udc0d Script Python >>> indices_maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , [ 3 , 8 ]) >>> indices_maxi ([ 7 ]) ( 7 , [ 0 ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def indices_maxi ( tab ): val_max = tab [ 0 ] ind_max = [] for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] for i in range ( len ( tab )): if tab [ i ] == val_max : ind_max . append ( i ) return ( val_max , ind_max ) \ud83d\udccb Texte \u00c9crire une fonction `indices_maxi` qui prend en param\u00e8tre un tableau non vide de nombre entiers `tab`, repr\u00e9sent\u00e9 par une liste Python et qui renvoie un tuple (`maxi`, `indices`) o\u00f9 : - `maxi` est le plus grand \u00e9l\u00e9ment du tableau `tab` ; - `indices` est une liste Python contenant les indices du tableau `tab` o\u00f9 appara\u00eet ce plus grand \u00e9l\u00e9ment. Exemple : ```python >>> indices_maxi([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) (9, [3, 8]) >>> indices_maxi([7]) (7, [0]) ``` R\u00e9digez votre code sur Basthon Exercice 38.2 \u2693\ufe0e Exercice 38.2 \u00c9nonc\u00e9 Correction Sources Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es par des listes Python. Si pile est une pile, alors pile == [] indique si la pile est vide, pile.pop() retire et renvoie le sommet de la pile et pile.append(v) ajoute la valeur v au sommet de la pile. Si on consid\u00e8re qu\u2019une fonction manipule une pile, elle ne peut pas utiliser d\u2019autres op\u00e9ra- tions que celles d\u00e9crites ci-dessus. On cherche \u00e0 \u00e9crire une fonction positifs qui prend une pile de nombres entiers en param\u00e8tre et qui renvoie une nouvelle pile contenant les entiers positifs de la pile initiale, dans le m\u00eame ordre, quitte \u00e0 modifier la pile initiale. Pour cela, on va \u00e9galement \u00e9crire une fonction renverse qui prend une pile en param\u00e8tre et qui renvoie une nouvelle pile contenant les m\u00eames \u00e9l\u00e9ments que la pile initiale, mais dans l\u2019ordre inverse. Cette fonction sera \u00e9galement amen\u00e9e \u00e0 modifier la pile pass\u00e9e en param\u00e8tre. Compl\u00e9ter le code Python des fonctions renverse et positifs ci-apr\u00e8s \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def renverse ( pile ): '''renvoie une pile contenant les m\u00eames \u00e9l\u00e9ments que pile, mais dans l'ordre inverse. Cette fonction d\u00e9truit pile.''' pile_inverse = ... while pile != []: ... . append ( ... ) return ... def positifs ( pile ): '''renvoie une pile contenant les \u00e9l\u00e9ments positifs de pile, dans le m\u00eame ordre. Cette fonction d\u00e9truit pile.''' pile_positifs = ... while pile != []: ... = pile . pop () if ... >= 0 : ... return ... Exemple : \ud83d\udc0d Script Python >>> renverse ([ 1 , 2 , 3 , 4 , 5 ]) [ 5 , 4 , 3 , 2 , 1 ] >>> positifs ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) [ 0 , 5 , 4 , 10 , 9 ] >>> positifs ([ - 2 ]) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def renverse ( pile ): '''renvoie une pile contenant les m\u00eames \u00e9l\u00e9ments que pile, mais dans l'ordre inverse. Cette fonction d\u00e9truit pile.''' pile_inverse = [] while pile != []: pile_inverse . append ( pile . pop ()) return pile_inverse def positifs ( pile ): '''renvoie une pile contenant les \u00e9l\u00e9ments positifs de pile, dans le m\u00eame ordre. Cette fonction d\u00e9truit pile.''' pile_positifs = [] while pile != []: elt = pile . pop () if elt >= 0 : pile_positifs . append ( elt ) return renverse ( pile_positifs ) Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es par des listes Python. Si `pile` est une pile, alors `pile == []` indique si la pile est vide, `pile.pop()` retire et renvoie le sommet de la pile et `pile.append(v)` ajoute la valeur `v` au sommet de la pile. Si on consid\u00e8re qu\u2019une fonction manipule une pile, elle ne peut pas utiliser d\u2019autres op\u00e9ra- tions que celles d\u00e9crites ci-dessus. On cherche \u00e0 \u00e9crire une fonction `positifs` qui prend une pile de nombres entiers en param\u00e8tre et qui renvoie une nouvelle pile contenant les entiers positifs de la pile initiale, dans le m\u00eame ordre, quitte \u00e0 modifier la pile initiale. Pour cela, on va \u00e9galement \u00e9crire une fonction `renverse` qui prend une pile en param\u00e8tre et qui renvoie une nouvelle pile contenant les m\u00eames \u00e9l\u00e9ments que la pile initiale, mais dans l\u2019ordre inverse. Cette fonction sera \u00e9galement amen\u00e9e \u00e0 modifier la pile pass\u00e9e en param\u00e8tre. Compl\u00e9ter le code Python des fonctions `renverse` et `positifs` ci-apr\u00e8s ```python linenums='1' def renverse(pile): '''renvoie une pile contenant les m\u00eames \u00e9l\u00e9ments que pile, mais dans l'ordre inverse. Cette fonction d\u00e9truit pile.''' pile_inverse = ... while pile != []: ... .append(...) return ... def positifs(pile): '''renvoie une pile contenant les \u00e9l\u00e9ments positifs de pile, dans le m\u00eame ordre. Cette fonction d\u00e9truit pile.''' pile_positifs = ... while pile != []: ... = pile.pop() if ... >= 0: ... return ... Exemple : \ud83d\udc0d Script Python >>> renverse ([ 1 , 2 , 3 , 4 , 5 ]) [ 5 , 4 , 3 , 2 , 1 ] >>> positifs ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) [ 0 , 5 , 4 , 10 , 9 ] >>> positifs ([ - 2 ]) [] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 39 \u2693\ufe0e Version originale du sujet en pdf. Exercice 39.1 \u2693\ufe0e Exercice 39.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers (type list ), et qui renvoie l\u2019indice de la derni\u00e8re occurrence de elt dans tab si elt est dans tab et None sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) # renvoie None >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 1 , [ 1 , 0 , 42 , 7 ]) 0 >>> recherche ( 1 , [ 1 , 50 , 1 ]) 2 >>> recherche ( 1 , [ 8 , 1 , 10 , 1 , 7 , 1 , 8 ]) 5 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab ) - 1 , - 1 , - 1 ): if tab [ i ] == elt : return i return None \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers (type ```list``` ), et qui renvoie l\u2019indice de la derni\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `None` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) # renvoie None >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(1, [1, 0, 42, 7]) 0 >>> recherche(1, [1, 50, 1]) 2 >>> recherche(1, [8, 1, 10, 1, 7, 1, 8]) 5 ``` R\u00e9digez votre code sur Basthon Exercice 39.2 \u2693\ufe0e Exercice 39.2 \u00c9nonc\u00e9 Correction Sources Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octets ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" # Note : split d\u00e9coupe la chaine de caract\u00e8res # en fonction du s\u00e9parateur return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" reservees = [ ... ] return ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l'adresse self si elle existe et None sinon\"\"\" octets = ... if ... == 254 : return None octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . liste_octets () [ 192 , 168 , 0 , 1 ] >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse # acces valide \u00e0 adresse # ici car on sait que l'adresse suivante existe '192.168.0.3' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octets ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" # Note : split d\u00e9coupe la chaine de caract\u00e8res # en fonction du s\u00e9parateur return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" reservees = [ '192.168.0.0' , '192.168.0.255' ] return self . adresse in reservees def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l'adresse self si elle existe et None sinon\"\"\" octets = self . liste_octets () if octets [ 3 ] == 254 : return None octet_nouveau = octets [ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de `192.168.0.0` \u00e0 `192.168.0.255` . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP `192.168.0.0` et `192.168.0.255` sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe `AdresseIP` . ```python linenums='1' class AdresseIP: def __init__ (self, adresse): self.adresse = ... def liste_octets(self): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" # Note : split d\u00e9coupe la chaine de caract\u00e8res # en fonction du s\u00e9parateur return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" reservees = [ ... ] return ... def adresse_suivante(self): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l'adresse self si elle existe et None sinon\"\"\" octets = ... if ... == 254: return None octet_nouveau = ... + ... return AdresseIP('192.168.0.' + ...) Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . liste_octets () [ 192 , 168 , 0 , 1 ] >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse # acces valide \u00e0 adresse # ici car on sait que l'adresse suivante existe '192.168.0.3' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 40 \u2693\ufe0e Version originale du sujet en pdf. Exercice 40.1 \u2693\ufe0e Exercice 40.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des tables, c\u2019est-\u00e0-dire des tableaux de dictionnaires ayant tous les m\u00eames cl\u00e9s, qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont 'nom' , 'espece' , 'age' , 'enclos' . Voici un exemple d'une telle table : \ud83d\udc0d Script Python animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] Programmer une fonction selection_enclos qui : prend en param\u00e8tres : une table animaux contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), un num\u00e9ro d'enclos num_enclos ; renvoie une table contenant les enregistrements de animaux dont l'attribut 'enclos' est num_enclos . Exemples avec la table animaux ci-dessus : \ud83d\udc0d Script Python >>> selection_enclos ( animaux , 5 ) [{ 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] >>> selection_enclos ( animaux , 2 ) [{ 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }] >>> selection_enclos ( animaux , 7 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def selection_enclos ( animaux , num_enclos ): table = [] for animal in animaux : if animal [ 'enclos' ] == num_enclos : table . append ( animal ) return table \ud83d\udccb Texte On consid\u00e8re des tables, c\u2019est-\u00e0-dire des tableaux de dictionnaires ayant tous les m\u00eames cl\u00e9s, qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont `'nom'`, `'espece'`, `'age'`, `'enclos'`. Voici un exemple d'une telle table : ```python animaux = [ {'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}, {'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Tom', 'espece':'chat', 'age':7, 'enclos':4}, {'nom':'Belle', 'espece':'chien', 'age':6, 'enclos':3}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] ``` Programmer une fonction `selection_enclos` qui : - prend en param\u00e8tres : - une table `animaux` contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), - un num\u00e9ro d'enclos `num_enclos` ; - renvoie une table contenant les enregistrements de `animaux` dont l'attribut `'enclos'` est `num_enclos`. Exemples avec la table `animaux` ci-dessus : ```python >>> selection_enclos(animaux, 5) [{'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] >>> selection_enclos(animaux, 2) [{'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}] >>> selection_enclos(animaux, 7) [] ``` R\u00e9digez votre code sur Basthon Exercice 40.2 \u2693\ufe0e Exercice 40.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois \u00e0 la suite, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : \ud83d\udc0d Script Python tab_a = [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] #l'intrus est 7 tab_b = [ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ] #l'intrus est 8 tab_c = [ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme ceux ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Par exemple, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 12, on voit les valeurs 2 et 4 qui sont diff\u00e9rentes : l\u2019intrus est donc \u00e0 gauche de l\u2019indice 12 (indice 12 compris) En revanche, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 3, on voit les valeurs 9 et 9 qui sont identiques : l\u2019intrus est donc \u00e0 droite des indices 3-4-5, donc \u00e0 partir de l\u2019indice 6. Compl\u00e9ter la fonction r\u00e9cursive trouver_intrus propos\u00e9e page suivante qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return tab [ g ] else : nombre_de_triplets = ( d - g ) // 3 indice = g + 3 * ( nombre_de_triplets // 2 ) if tab [ indice ] != tab [ indice + 1 ] : return trouver_intrus ( tab , g , indice ) else : return trouver_intrus ( tab , indice + 3 , d ) Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois \u00e0 la suite, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : ```python tab_a = [3, 3, 3, 9, 9, 9, 1, 1, 1, 7, 2, 2, 2, 4, 4, 4, 8, 8, 8, 5, 5, 5] #l'intrus est 7 tab_b = [8, 5, 5, 5, 9, 9, 9, 18, 18, 18, 3, 3, 3] #l'intrus est 8 tab_c = [5, 5, 5, 1, 1, 1, 0, 0, 0, 6, 6, 6, 3, 8, 8, 8] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme ceux ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Par exemple, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 12, on voit les valeurs 2 et 4 qui sont diff\u00e9rentes : l\u2019intrus est donc \u00e0 gauche de l\u2019indice 12 (indice 12 compris) En revanche, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 3, on voit les valeurs 9 et 9 qui sont identiques : l\u2019intrus est donc \u00e0 droite des indices 3-4-5, donc \u00e0 partir de l\u2019indice 6. Compl\u00e9ter la fonction r\u00e9cursive trouver_intrus propos\u00e9e page suivante qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 41 \u2693\ufe0e Version originale du sujet en pdf. Exercice 41.1 \u2693\ufe0e Exercice 41.1 \u00c9nonc\u00e9 Correction Source Markdown Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None , soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe Noeud donn\u00e9e ci-dessous. \ud83d\udc0d Script Python class Noeud : def __init__ ( self , etiquette , gauche , droit ): self . v = etiquette self . gauche = gauche self . droit = droit L\u2019arbre ci-dessus sera donc impl\u00e9ment\u00e9 de la mani\u00e8re suivante : \ud83d\udc0d Script Python a = Noeud ( 1 , Noeud ( 4 , None , None ), Noeud ( 0 , None , Noeud ( 7 , None , None ))) \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tre un arbre a et qui renvoie la taille de l\u2019arbre que cette instance impl\u00e9mente. \u00c9crire de m\u00eame une fonction r\u00e9cursive hauteur prenant en param\u00e8tre un arbre a et qui renvoie la hauteur de l\u2019arbre que cette instance impl\u00e9mente. On consid\u00e8re que la hauteur d\u2019un arbre vide est -1 et la taille d\u2019un arbre vide est 0. Exemples : \ud83d\udc0d Script Python >>> hauteur ( a ) 2 >>> taille ( a ) 4 >>> hauteur ( None ) - 1 >>> taille ( None ) 0 >>> hauteur ( Noeud ( 1 , None , None )) 0 >>> taille ( Noeud ( 1 , None , None )) 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Noeud : def __init__ ( self , etiquette , gauche , droit ): self . v = etiquette self . gauche = gauche self . droit = droit a = Noeud ( 1 , Noeud ( 4 , None , None ), Noeud ( 0 , None , Noeud ( 7 , None , None ))) def taille ( a ): if a is None : return 0 return 1 + taille ( a . gauche ) + taille ( a . droit ) def hauteur ( a ): if a is None : return - 1 return 1 + max ( hauteur ( a . gauche ), hauteur ( a . droit )) \ud83d\udccb Texte Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur `None`, soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe `Noeud` donn\u00e9e ci-dessous. ```python class Noeud: def __init__(self, etiquette, gauche, droit): self.v = etiquette self.gauche = gauche self.droit = droit ``` ![image](data2023/29_arbre1.png){: .center} L\u2019arbre ci-dessus sera donc impl\u00e9ment\u00e9 de la mani\u00e8re suivante : ```python a = Noeud(1, Noeud(4, None, None), Noeud(0, None, Noeud(7, None, None))) ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tre un arbre `a` et qui renvoie la taille de l\u2019arbre que cette instance impl\u00e9mente. \u00c9crire de m\u00eame une fonction r\u00e9cursive `hauteur` prenant en param\u00e8tre un arbre `a` et qui renvoie la hauteur de l\u2019arbre que cette instance impl\u00e9mente. On consid\u00e8re que la hauteur d\u2019un arbre vide est -1 et la taille d\u2019un arbre vide est 0. Exemples : ```python >>> hauteur(a) 2 >>> taille(a) 4 >>> hauteur(None) -1 >>> taille(None) 0 >>> hauteur(Noeud(1, None, None)) 0 >>> taille(Noeud(1, None, None)) 1 ``` R\u00e9digez votre code sur Basthon Exercice 41.2 \u2693\ufe0e Exercice 41.2 \u00c9nonc\u00e9 Correction Sources Markdown On rappelle que les tableaux sont repr\u00e9sent\u00e9s par des listes en Python du type list . Le but de cet exercice est d\u2019\u00e9crire une fonction ajoute qui prend en param\u00e8tres trois arguments indice , element et tab et renvoie un tableau tab_ins dans lequel les \u00e9l\u00e9ments sont ceux du tableau tab avec, en plus, l\u2019\u00e9l\u00e9ment element \u00e0 l\u2019indice indice . On consid\u00e8re que les variables indice et element sont des entiers positifs et que les \u00e9l\u00e9ments de tab sont \u00e9galement des entiers. En r\u00e9alisant cette insertion, Les \u00e9l\u00e9ments du tableau tab dont les indices sont sup\u00e9rieurs ou \u00e9gaux \u00e0 indice apparaissent d\u00e9cal\u00e9s vers la droite dans le tableau tab_ins . Si indice est \u00e9gal au nombre d\u2019\u00e9l\u00e9ments du tableau tab , l\u2019\u00e9l\u00e9ment element est ajout\u00e9 dans tab_ins apr\u00e8s tous les \u00e9l\u00e9ments du tableau tab . Exemples : \ud83d\udc0d Script Python >>> ajoute ( 1 , 4 , [ 7 , 8 , 9 ]) [ 7 , 4 , 8 , 9 ] >>> ajoute ( 3 , 4 , [ 7 , 8 , 9 ]) [ 7 , 8 , 9 , 4 ] >>> ajoute ( 0 , 4 , [ 7 , 8 , 9 ]) [ 4 , 7 , 8 , 9 ] Compl\u00e9ter et tester le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def ajoute ( indice , element , tab ): '''Renvoie un nouveau tableau obtenu en ins\u00e9rant element \u00e0 l'indice indice dans le tableau tab.''' nbre_elts = len ( tab ) tab_ins = [ 0 ] * ( nbre_elts + 1 ) for i in range ( indice ): tab_ins [ i ] = ... tab_ins [ ... ] = ... for i in range ( indice + 1 , nbre_elts + 1 ): tab_ins [ i ] = ... return tab_ins \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def ajoute ( indice , element , tab ): '''Renvoie un nouveau tableau obtenu en ins\u00e9rant element \u00e0 l'indice indice dans le tableau tab.''' nbre_elts = len ( tab ) tab_ins = [ 0 ] * ( nbre_elts + 1 ) for i in range ( indice ): tab_ins [ i ] = tab [ i ] tab_ins [ indice ] = element for i in range ( indice + 1 , nbre_elts + 1 ): tab_ins [ i ] = tab [ i - 1 ] return tab_ins Markdown On rappelle que les tableaux sont repr\u00e9sent\u00e9s par des listes en Python du type `list` . Le but de cet exercice est d\u2019\u00e9crire une fonction ajoute qui prend en param\u00e8tres trois arguments `indice` , `element` et `tab` et renvoie un tableau `tab_ins` dans lequel les \u00e9l\u00e9ments sont ceux du tableau `tab` avec, en plus, l\u2019\u00e9l\u00e9ment `element` \u00e0 l\u2019indice `indice` . On consid\u00e8re que les variables `indice` et `element` sont des entiers positifs et que les \u00e9l\u00e9ments de `tab` sont \u00e9galement des entiers. En r\u00e9alisant cette insertion, Les \u00e9l\u00e9ments du tableau `tab` dont les indices sont sup\u00e9rieurs ou \u00e9gaux \u00e0 `indice` apparaissent d\u00e9cal\u00e9s vers la droite dans le tableau `tab_ins` . Si `indice` est \u00e9gal au nombre d\u2019\u00e9l\u00e9ments du tableau `tab` , l\u2019\u00e9l\u00e9ment `element` est ajout\u00e9 dans `tab_ins` apr\u00e8s tous les \u00e9l\u00e9ments du tableau `tab` . Exemples : ```python >>> ajoute(1, 4, [7, 8, 9]) [7, 4, 8, 9] >>> ajoute(3, 4, [7, 8, 9]) [7, 8, 9, 4] >>> ajoute(0, 4, [7, 8, 9]) [4, 7, 8, 9] Compl\u00e9ter et tester le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def ajoute ( indice , element , tab ): '''Renvoie un nouveau tableau obtenu en ins\u00e9rant element \u00e0 l'indice indice dans le tableau tab.''' nbre_elts = len ( tab ) tab_ins = [ 0 ] * ( nbre_elts + 1 ) for i in range ( indice ): tab_ins [ i ] = ... tab_ins [ ... ] = ... for i in range ( indice + 1 , nbre_elts + 1 ): tab_ins [ i ] = ... return tab_ins ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 42 \u2693\ufe0e Version originale du sujet en pdf. Exercice 42.1 \u2693\ufe0e Exercice 42.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau d\u2019entiers non vide et qui renvoie un nombre flottant donnant la moyenne de ces entiers. Attention : il est interdit d\u2019utiliser la fonction sum ou la fonction mean (module statistics ) de Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1 ]) 1.0 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]) 4.0 >>> moyenne ([ 1 , 2 ]) 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau d\u2019entiers non vide et qui renvoie un nombre flottant donnant la moyenne de ces entiers. **Attention** : il est interdit d\u2019utiliser la fonction `sum` ou la fonction `mean` (module `statistics`) de Python. Exemples : ```python >>> moyenne([1]) 1.0 >>> moyenne([1, 2, 3, 4, 5, 6, 7]) 4.0 >>> moyenne([1, 2]) 1.5 ``` R\u00e9digez votre code sur Basthon Exercice 42.2 \u2693\ufe0e Exercice 42.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def dichotomie ( tab , x ): \"\"\"applique une recherche dichotomique pour d\u00e9terminer si x est dans le tableau tri\u00e9 tab. La fonction renvoie True si tab contient x et False sinon\"\"\" debut = 0 fin = ... while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = ... else : fin = ... return False Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) False >>> dichotomie ([], 28 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def dichotomie ( tab , x ): \"\"\"applique une recherche dichotomique pour d\u00e9terminer si x est dans le tableau tri\u00e9 tab. La fonction renvoie True si tab contient x et False sinon\"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. ```python linenums='1' def dichotomie(tab, x): \"\"\"applique une recherche dichotomique pour d\u00e9terminer si x est dans le tableau tri\u00e9 tab. La fonction renvoie True si tab contient x et False sinon\"\"\" debut = 0 fin = ... while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = ... else: fin = ... return False Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) False >>> dichotomie ([], 28 ) False ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 43 \u2693\ufe0e Version originale du sujet en pdf. Exercice 43.1 \u2693\ufe0e Exercice 43.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction a_doublon qui prend en param\u00e8tre un tableau tri\u00e9 de nombres dans l\u2019ordre croissant et renvoie True si ce tableau contient au moins deux nombres identiques, False sinon. Exemple : \ud83d\udc0d Script Python >>> a_doublon ([]) False >>> a_doublon ([ 1 ]) False >>> a_doublon ([ 1 , 2 , 4 , 6 , 6 ]) True >>> a_doublon ([ 2 , 5 , 7 , 7 , 7 , 9 ]) True >>> a_doublon ([ 0 , 2 , 3 ]) False \ud83d\udc0d Script Python 1 2 3 4 5 def a_doublon ( tab ): for i in range ( len ( tab ) - 1 ): if tab [ i ] == tab [ i + 1 ]: return True return False \ud83d\udccb Texte \u00c9crire une fonction `a_doublon` qui prend en param\u00e8tre un tableau **tri\u00e9** de nombres dans l\u2019ordre croissant et renvoie `True` si ce tableau contient au moins deux nombres identiques, `False` sinon. Exemple : ```python >>> a_doublon([]) False >>> a_doublon([1]) False >>> a_doublon([1, 2, 4, 6, 6]) True >>> a_doublon([2, 5, 7, 7, 7, 9]) True >>> a_doublon([0, 2, 3]) False ``` R\u00e9digez votre code sur Basthon Exercice 43.2 \u2693\ufe0e Exercice 43.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite g\u00e9n\u00e9rer des grilles du jeu de d\u00e9mineur \u00e0 partir de la position des bombes \u00e0 placer. On se limite \u00e0 la g\u00e9n\u00e9ration de grilles carr\u00e9es de taille \\(n \\times n\\) o\u00f9 \\(n\\) est le nombre de bombes du jeu. Dans le jeu du d\u00e9mineur, chaque case de la grille contient soit une bombe, soit une valeur qui correspond aux nombres de bombes situ\u00e9es dans le voisinage direct de la case (au- dessus, en dessous, \u00e0 droite, \u00e0 gauche ou en diagonale : chaque case a donc 8 voisins si elle n'est pas situ\u00e9e au bord de la grille). Voici un exemple de grille \\(5 \\times 5\\) de d\u00e9mineur dans laquelle la bombe est repr\u00e9sent\u00e9e par une \u00e9toile : On utilise une liste de listes pour repr\u00e9senter la grille et on choisit de coder une bombe par la valeur -1. L'exemple ci-contre sera donc cod\u00e9 par la liste : \ud83d\udc0d Script Python [[ 1 , 1 , 1 , 0 , 0 ], [ 1 , - 1 , 1 , 1 , 1 ], [ 2 , 2 , 3 , 2 , - 1 ], [ 1 , - 1 , 2 , - 1 , 3 ], [ 1 , 1 , 2 , 2 , - 1 ]] Compl\u00e9ter le code suivant afin de g\u00e9n\u00e9rer des grilles de d\u00e9mineur, on pourra v\u00e9rifier que l'appel genere_grille([(1, 1), (2, 4), (3, 1), (3, 3), (4, 4)]) renvoie bien la liste donn\u00e9e en exemple. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = ... for l , c in voisins : if grille [ l ][ c ] != ... : # si ce n'est pas une bombe ... # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = ... # place la bombe ... # incr\u00e9mente ses voisins return grille \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = voisinage ( len ( grille ), ligne , colonne ) for l , c in voisins : if grille [ l ][ c ] != - 1 : # si ce n'est pas une bombe grille [ l ][ c ] += 1 # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = - 1 # place la bombe incremente_voisins ( grille , ligne , colonne ) # incr\u00e9mente ses voisins return grille Markdown On souhaite g\u00e9n\u00e9rer des grilles du jeu de d\u00e9mineur \u00e0 partir de la position des bombes \u00e0 placer. On se limite \u00e0 la g\u00e9n\u00e9ration de grilles carr\u00e9es de taille $n \\times n$ o\u00f9 $n$ est le nombre de bombes du jeu. Dans le jeu du d\u00e9mineur, chaque case de la grille contient soit une bombe, soit une valeur qui correspond aux nombres de bombes situ\u00e9es dans le voisinage direct de la case (au- dessus, en dessous, \u00e0 droite, \u00e0 gauche ou en diagonale : chaque case a donc 8 voisins si elle n'est pas situ\u00e9e au bord de la grille). Voici un exemple de grille $5 \\times 5$ de d\u00e9mineur dans laquelle la bombe est repr\u00e9sent\u00e9e par une \u00e9toile : ![ image ]( data2023/04grille.png ){: .center} On utilise une liste de listes pour repr\u00e9senter la grille et on choisit de coder une bombe par la valeur -1. L'exemple ci-contre sera donc cod\u00e9 par la liste : ```python [[1, 1, 1, 0, 0], [1, -1, 1, 1, 1], [2, 2, 3, 2, -1], [1, -1, 2, -1, 3], [1, 1, 2, 2, -1]] Compl\u00e9ter le code suivant afin de g\u00e9n\u00e9rer des grilles de d\u00e9mineur, on pourra v\u00e9rifier que l'appel genere_grille([(1, 1), (2, 4), (3, 1), (3, 3), (4, 4)]) renvoie bien la liste donn\u00e9e en exemple. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = ... for l , c in voisins : if grille [ l ][ c ] != ... : # si ce n'est pas une bombe ... # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = ... # place la bombe ... # incr\u00e9mente ses voisins return grille ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 44 \u2693\ufe0e Version originale du sujet en pdf. Exercice 44.1 \u2693\ufe0e Exercice 44.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction enumere qui prend en param\u00e8tre un tableau tab (type list ) et renvoie un dictionnaire d dont les cl\u00e9s sont les \u00e9l\u00e9ments de tab avec pour valeur associ\u00e9e la liste des indices de l\u2019\u00e9l\u00e9ment dans le tableau tab . Exemple : \ud83d\udc0d Script Python >>> enumere ([]) {} >>> enumere ([ 1 , 2 , 3 ]) { 1 : [ 0 ], 2 : [ 1 ], 3 : [ 2 ]} >>> enumere ([ 1 , 1 , 2 , 3 , 2 , 1 ]) { 1 : [ 0 , 1 , 5 ], 2 : [ 2 , 4 ], 3 : [ 3 ]} \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def enumere ( tab ): d = {} for i in range ( len ( tab )): if tab [ i ] in d : d [ tab [ i ]] . append ( i ) else : d [ tab [ i ]] = [ i ] return d \ud83d\udccb Texte \u00c9crire une fonction `enumere` qui prend en param\u00e8tre un tableau `tab` (type `list`) et renvoie un dictionnaire `d` dont les cl\u00e9s sont les \u00e9l\u00e9ments de `tab` avec pour valeur associ\u00e9e la liste des indices de l\u2019\u00e9l\u00e9ment dans le tableau `tab`. Exemple : ```python >>> enumere([]) {} >>> enumere([1, 2, 3]) {1: [0], 2: [1], 3: [2]} >>> enumere([1, 1, 2, 3, 2, 1]) {1: [0, 1, 5], 2: [2, 4], 3: [3]} ``` R\u00e9digez votre code sur Basthon Exercice 44.2 \u2693\ufe0e Exercice 44.2 \u00c9nonc\u00e9 Correction Sources Markdown Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None , soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe Noeud donn\u00e9e ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Noeud : \"\"\"Classe repr\u00e9sentant un noeud d'un arbre binaire\"\"\" def __init__ ( self , etiquette , gauche , droit ): \"\"\"Cr\u00e9e un noeud de valeur etiquette avec gauche et droit comme fils.\"\"\" self . etiquette = etiquette self . gauche = gauche self . droit = droit def parcours ( arbre , liste ): \"\"\"parcours r\u00e9cursivement l'arbre en ajoutant les \u00e9tiquettes de ses noeuds \u00e0 la liste pass\u00e9e en argument en ordre infixe.\"\"\" if arbre != None : parcours ( arbre . gauche , liste ) liste . append ( arbre . etiquette ) parcours ( arbre . droit , liste ) return liste La fonction r\u00e9cursive parcours renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre impl\u00e9- ment\u00e9 par l\u2019instance arbre dans l\u2019ordre du parcours en profondeur infixe \u00e0 partir d\u2019une liste vide pass\u00e9e en argument. Compl\u00e9ter le code de la fonction insere , pr\u00e9sent\u00e9 page suivante, qui prend en argument un arbre binaire de recherche arbre repr\u00e9sent\u00e9 ainsi et une \u00e9tiquette cle , non pr\u00e9sente dans l\u2019arbre, et qui : renvoie une nouvelle feuille d\u2019\u00e9tiquette cle s\u2019il est vide ; renvoie l\u2019arbre apr\u00e8s l\u2019avoir modifi\u00e9 en ins\u00e9rant cle sinon ; garantit que l\u2019arbre ainsi compl\u00e9t\u00e9 soit encore un arbre binaire de recherche. Tester ensuite ce code en utilisant la fonction parcours et en ins\u00e9rant successivement des n\u0153uds d\u2019\u00e9tiquette 1, 4, 6 et 8 dans l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci- dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def insere ( arbre , cle ): \"\"\"insere la cle dans l'arbre binaire de recherche repr\u00e9sent\u00e9 par arbre. Retourne l'arbre modifi\u00e9.\"\"\" if arbre == None : return Noeud ( cle , None , None ) # creation d'une feuille else : if ... : arbre . gauche = insere ( arbre . gauche , cle ) else : arbre . droit = ... return arbre \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def insere ( arbre , cle ): \"\"\"insere la cle dans l'arbre binaire de recherche repr\u00e9sent\u00e9 par arbre. Retourne l'arbre modifi\u00e9.\"\"\" if arbre == None : return Noeud ( cle , None , None ) # creation d'une feuille else : if cle < arbre . etiquette : arbre . gauche = insere ( arbre . gauche , cle ) else : arbre . droit = insere ( arbre . droit , cle ) return arbre Tests : \ud83d\udc0d Script Python >>> a = Noeud ( 5 , None , None ) >>> a = insere ( a , 2 ) >>> a = insere ( a , 3 ) >>> a = insere ( a , 7 ) >>> parcours ( a , []) [ 2 , 3 , 5 , 7 ] >>> a = insere ( a , 1 ) >>> a = insere ( a , 4 ) >>> a = insere ( a , 6 ) >>> a = insere ( a , 8 ) >>> parcours ( a , []) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] Markdown Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur `None` , soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe `Noeud` donn\u00e9e ci-dessous. ```python linenums='1' class Noeud: \"\"\"Classe repr\u00e9sentant un noeud d'un arbre binaire\"\"\" def __init__ (self, etiquette, gauche, droit): \"\"\"Cr\u00e9e un noeud de valeur etiquette avec gauche et droit comme fils.\"\"\" self.etiquette = etiquette self.gauche = gauche self.droit = droit def parcours(arbre, liste): \"\"\"parcours r\u00e9cursivement l'arbre en ajoutant les \u00e9tiquettes de ses noeuds \u00e0 la liste pass\u00e9e en argument en ordre infixe.\"\"\" if arbre != None: parcours(arbre.gauche, liste) liste.append(arbre.etiquette) parcours(arbre.droit, liste) return liste La fonction r\u00e9cursive parcours renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre impl\u00e9- ment\u00e9 par l\u2019instance arbre dans l\u2019ordre du parcours en profondeur infixe \u00e0 partir d\u2019une liste vide pass\u00e9e en argument. Compl\u00e9ter le code de la fonction insere , pr\u00e9sent\u00e9 page suivante, qui prend en argument un arbre binaire de recherche arbre repr\u00e9sent\u00e9 ainsi et une \u00e9tiquette cle , non pr\u00e9sente dans l\u2019arbre, et qui : renvoie une nouvelle feuille d\u2019\u00e9tiquette cle s\u2019il est vide ; renvoie l\u2019arbre apr\u00e8s l\u2019avoir modifi\u00e9 en ins\u00e9rant cle sinon ; garantit que l\u2019arbre ainsi compl\u00e9t\u00e9 soit encore un arbre binaire de recherche. Tester ensuite ce code en utilisant la fonction parcours et en ins\u00e9rant successivement des n\u0153uds d\u2019\u00e9tiquette 1, 4, 6 et 8 dans l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci- dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def insere ( arbre , cle ): \"\"\"insere la cle dans l'arbre binaire de recherche repr\u00e9sent\u00e9 par arbre. Retourne l'arbre modifi\u00e9.\"\"\" if arbre == None : return Noeud ( cle , None , None ) # creation d'une feuille else : if ... : arbre . gauche = insere ( arbre . gauche , cle ) else : arbre . droit = ... return arbre ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 45 \u2693\ufe0e Version originale du sujet en pdf. Exercice 45.1 \u2693\ufe0e Exercice 45.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction compte_occurrences prenant en param\u00e8tres une valeur x et un tableau tab (de type list ) et renvoyant le nombre d\u2019occurrences de x dans tab . L\u2019objectif de cet exercice \u00e9tant de parcourir un tableau, il est interdit d\u2019utiliser la m\u00e9thode count des listes Python. Exemples : \ud83d\udc0d Script Python >>> compte_occurrences ( 5 , []) 0 >>> compte_occurrences ( 5 , [ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> compte_occurrences ( 'a' , [ 'a' , 'b' , 'c' , 'a' , 'd' , 'e' , 'a' ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def compte_occurrences ( x , tab ): nb = 0 for element in tab : if element == x : nb += 1 return nb \ud83d\udccb Texte \u00c9crire une fonction `compte_occurrences` prenant en param\u00e8tres une valeur `x` et un tableau `tab` (de type `list`) et renvoyant le nombre d\u2019occurrences de `x` dans `tab`. L\u2019objectif de cet exercice \u00e9tant de parcourir un tableau, il est interdit d\u2019utiliser la m\u00e9thode `count` des listes Python. Exemples : ```python >>> compte_occurrences(5, []) 0 >>> compte_occurrences(5, [-2, 3, 1, 5, 3, 7, 4]) 1 >>> compte_occurrences('a', ['a','b','c','a','d','e','a']) 3 ``` R\u00e9digez votre code sur Basthon Exercice 45.2 \u2693\ufe0e Exercice 45.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re dans cet exercice un algorithme glouton pour le rendu de monnaie. Pour rendre une somme en monnaie, on utilise \u00e0 chaque fois la plus grosse pi\u00e8ce possible et ainsi de suite jusqu\u2019\u00e0 ce que la somme restante \u00e0 rendre soit nulle. Les pi\u00e8ces de monnaie utilis\u00e9es sont : pieces = [1, 2, 5, 10, 20, 50, 100, 200] On souhaite \u00e9crire une fonction rendu_monnaie qui prend en param\u00e8tres un entier somme_due repr\u00e9sentant la somme \u00e0 payer ; un entier somme_versee repr\u00e9sentant la somme vers\u00e9e qui est sup\u00e9rieure ou \u00e9gale \u00e0 somme_due ; et qui renvoie un tableau de type list contenant les pi\u00e8ces qui composent le rendu de la monnaie restante, c\u2019est-\u00e0-dire de somme_versee - somme_due . Ainsi, l\u2019instruction rendu_monnaie(452, 500) renvoie le tableau [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 euros soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction rendu_monnaie est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie ( somme_due , somme_versee ): '''Renvoie la liste des pi\u00e8ces \u00e0 rendre pour rendre la monnaie lorsqu'on doit rendre somme_versee - somme_due''' rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : while pieces [ i ] > a_rendre : i = i - 1 rendu . append ( ... ) a_rendre = ... return rendu Compl\u00e9ter ce code et le tester : \ud83d\udc0d Script Python >>> rendu_monnaie ( 700 , 700 ) [] >>> rendu_monnaie ( 102 , 500 ) [ 200 , 100 , 50 , 20 , 20 , 5 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] def rendu_monnaie ( somme_due , somme_versee ): '''Renvoie la liste des pi\u00e8ces \u00e0 rendre pour rendre la monnaie lorsqu'on doit rendre somme_versee - somme_due''' rendu = [] a_rendre = somme_versee - somme_due i = len ( pieces ) - 1 while a_rendre > 0 : while pieces [ i ] > a_rendre : i = i - 1 rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] return rendu Markdown On consid\u00e8re dans cet exercice un algorithme glouton pour le rendu de monnaie. Pour rendre une somme en monnaie, on utilise \u00e0 chaque fois la plus grosse pi\u00e8ce possible et ainsi de suite jusqu\u2019\u00e0 ce que la somme restante \u00e0 rendre soit nulle. Les pi\u00e8ces de monnaie utilis\u00e9es sont : `pieces = [1, 2, 5, 10, 20, 50, 100, 200]` On souhaite \u00e9crire une fonction `rendu_monnaie` qui prend en param\u00e8tres - un entier `somme_due` repr\u00e9sentant la somme \u00e0 payer ; - un entier `somme_versee` repr\u00e9sentant la somme vers\u00e9e qui est sup\u00e9rieure ou \u00e9gale \u00e0 `somme_due` ; et qui renvoie un tableau de type `list` contenant les pi\u00e8ces qui composent le rendu de la monnaie restante, c\u2019est-\u00e0-dire de `somme_versee - somme_due` . Ainsi, l\u2019instruction `rendu_monnaie(452, 500)` renvoie le tableau `[20, 20, 5, 2, 1]` . En effet, la somme \u00e0 rendre est de `48` euros soit `20 + 20 + 5 + 2 + 1` . Le code de la fonction `rendu_monnaie` est donn\u00e9 ci-dessous : ```python linenums='1' def rendu_monnaie(somme_due, somme_versee): '''Renvoie la liste des pi\u00e8ces \u00e0 rendre pour rendre la monnaie lorsqu'on doit rendre somme_versee - somme_due''' rendu = ... a_rendre = ... i = len(pieces) - 1 while a_rendre > ...: while pieces[i] > a_rendre: i = i - 1 rendu.append(...) a_rendre = ... return rendu Compl\u00e9ter ce code et le tester : \ud83d\udc0d Script Python >>> rendu_monnaie ( 700 , 700 ) [] >>> rendu_monnaie ( 102 , 500 ) [ 200 , 100 , 50 , 20 , 20 , 5 , 2 , 1 ] ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 46 \u2693\ufe0e Version originale du sujet en pdf. Exercice 46.1 \u2693\ufe0e Exercice 46.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, None sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) # renvoie None \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return None \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres un tableau `tab` de nombres entiers tri\u00e9s par ordre croissant et un nombre entier `n`, et qui effectue une recherche dichotomique du nombre entier `n` dans le tableau non vide `tab`. Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, `None` sinon. Exemples : ```python >>> recherche([2, 3, 4, 5, 6], 5) 3 >>> recherche([2, 3, 4, 6, 7], 5) # renvoie None ``` R\u00e9digez votre code sur Basthon Exercice 46.2 \u2693\ufe0e Exercice 46.2 \u00c9nonc\u00e9 Correction Sources Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019 ...) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res alphabet s\u2019il s\u2019y trouve. La fonction cesar prend en param\u00e8tres une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): '''Renvoie la position de la lettre dans l'alphabet''' return ord ( lettre ) - ord ( 'A' ) def cesar ( message , decalage ): '''Renvoie le message cod\u00e9 par la m\u00e9thode de C\u00e9sar pour le decalage donn\u00e9''' resultat = '' for ... in message : if 'A' <= c and c <= 'Z' : indice = ( ... ) % 26 resultat = resultat + alphabet [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): '''Renvoie la position de la lettre dans l'alphabet''' return ord ( lettre ) - ord ( 'A' ) def cesar ( message , decalage ): '''Renvoie le message cod\u00e9 par la m\u00e9thode de C\u00e9sar pour le decalage donn\u00e9''' resultat = '' for c in message : if 'A' <= c and c <= 'Z' : indice = ( position_alphabet ( c ) + decalage ) % 26 resultat = resultat + alphabet [ indice ] else : resultat = resultat + c return resultat Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019 ...) ne sont pas cod\u00e9s. La fonction `position_alphabet` ci-dessous prend en param\u00e8tre un caract\u00e8re `lettre` et renvoie la position de `lettre` dans la cha\u00eene de caract\u00e8res `alphabet` s\u2019il s\u2019y trouve. La fonction `cesar` prend en param\u00e8tres une cha\u00eene de caract\u00e8res `message` et un nombre entier `decalage` et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage `decalage` . ```python linenums='1' alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet(lettre): '''Renvoie la position de la lettre dans l'alphabet''' return ord(lettre) - ord('A') def cesar(message, decalage): '''Renvoie le message cod\u00e9 par la m\u00e9thode de C\u00e9sar pour le decalage donn\u00e9''' resultat = '' for ... in message: if 'A' <= c and c <= 'Z': indice = (...) % 26 resultat = resultat + alphabet[indice] else: resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 47 \u2693\ufe0e Version originale du sujet en pdf. Exercice 47.1 \u2693\ufe0e Exercice 47.1 \u00c9nonc\u00e9 Correction Source Markdown Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est une cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; la seconde valeur est cette valeur maximale. Exemples : \ud83d\udc0d Script Python >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def max_dico ( dico ): cle_max = '' val_max = 0 for cle in dico : if dico [ cle ] > val_max : val_max = dico [ cle ] cle_max = cle return ( cle_max , val_max ) \ud83d\udccb Texte Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : `{'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}` \u00c9crire une fonction `max_dico` qui : - Prend en param\u00e8tre un dictionnaire `dico` non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; - Renvoie un tuple dont : - La premi\u00e8re valeur est une cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; - la seconde valeur est cette valeur maximale. Exemples : ```python >>> max_dico({'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}) ('Ada', 201) >>> max_dico({'Alan': 222, 'Ada': 201, 'Eve': 220, 'Tim': 50}) ('Alan', 222) ``` R\u00e9digez votre code sur Basthon Exercice 47.2 \u2693\ufe0e Exercice 47.2 \u00c9nonc\u00e9 Correction Sources Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*'] . Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+'] . D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self . est_vide () return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = ... + ... else : resultat = ... p . empiler ( ... ) return ... Exemples : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 >>> eval_expression ([ 1 , 2 , '+' , 3 , '*' ]) 9 >>> eval_expression ([ 1 , 2 , 3 , '+' , '*' ]) 5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for element in tab : if element != '+' and element != '*' : p . empiler ( element ) else : if element == '+' : resultat = p . depiler () + p . depiler () else : resultat = p . depiler () * p . depiler () p . empiler ( resultat ) return p . depiler () Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau `[2, 3, '+', 5, '*']` . Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : `[3, 2, '*', 5, '+']` . D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : - Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; - Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. - \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe `Pile` qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction `eval_expression` qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. ```python linenums='1' class Pile: \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ (self): self.contenu = [] def est_vide(self): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self.contenu == [] def empiler(self, v): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self.contenu.append(v) def depiler(self): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self.est_vide() return self.contenu.pop() def eval_expression(tab): p = Pile() for ... in tab: if element != '+' ... element != '*': p.empiler(...) else: if element == ...: resultat = ... + ... else: resultat = ... p.empiler(...) return ... Exemples : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 >>> eval_expression ([ 1 , 2 , '+' , 3 , '*' ]) 9 >>> eval_expression ([ 1 , 2 , 3 , '+' , '*' ]) 5 ``` Compl\u00e9tez le code sur Basthon \u25b6 Sujet 48 \u2693\ufe0e Version originale du sujet en pdf. Exercice 48.1 \u2693\ufe0e Exercice 48.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re dans cet exercice un graphe orient\u00e9 repr\u00e9sent\u00e9 sous forme de listes d\u2019adjacence. On suppose que les sommets sont num\u00e9rot\u00e9s de 0 \u00e0 n-1 . Par exemple, le graphe suivant : est repr\u00e9sent\u00e9 par la liste d\u2019adjacence suivante : \ud83d\udc0d Script Python adj = [[ 1 , 2 ], [ 2 ], [ 0 ], [ 0 ]] \u00c9crire une fonction voisins_entrants(adj, x) qui prend en param\u00e8tre le graphe donn\u00e9 sous forme de liste d\u2019adjacence et qui renvoie une liste contenant les voisins entrants du sommet x , c\u2019est-\u00e0-dire les sommets y tels qu\u2019il existe une ar\u00eate de y vers x . Exemples : \ud83d\udc0d Script Python >>> voisins_entrants ([[ 1 , 2 ], [ 2 ], [ 0 ], [ 0 ]], 0 ) [ 2 , 3 ] >>> voisins_entrants ([[ 1 , 2 ], [ 2 ], [ 0 ], [ 0 ]], 1 ) [ 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 def voisins_entrants ( adj , x ): vois = [] for i in range ( len ( adj )): if x in adj [ i ]: vois . append ( i ) return vois \ud83d\udccb Texte On consid\u00e8re dans cet exercice un graphe orient\u00e9 repr\u00e9sent\u00e9 sous forme de listes d\u2019adjacence. On suppose que les sommets sont num\u00e9rot\u00e9s de `0` \u00e0 `n-1`. Par exemple, le graphe suivant : ![image](data2024/graph2.png){: .center} est repr\u00e9sent\u00e9 par la liste d\u2019adjacence suivante : ```python adj = [[1, 2], [2], [0], [0]] ``` \u00c9crire une fonction `voisins_entrants(adj, x)` qui prend en param\u00e8tre le graphe donn\u00e9 sous forme de liste d\u2019adjacence et qui renvoie une liste contenant les voisins entrants du sommet `x`, c\u2019est-\u00e0-dire les sommets `y` tels qu\u2019il existe une ar\u00eate de `y` vers `x`. Exemples : ```python >>> voisins_entrants([[1, 2], [2], [0], [0]], 0) [2, 3] >>> voisins_entrants([[1, 2], [2], [0], [0]], 1) [0] ``` R\u00e9digez votre code sur Basthon Exercice 48.2 \u2693\ufe0e Exercice 48.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re dans cet exercice la suite de nombre suivante : 1, 11, 21, 1211, 111221, ... Cette suite est construite ainsi : pour passer d\u2019une valeur \u00e0 la suivante, on la lit et on l\u2019\u00e9crit sous la forme d\u2019un nombre. Ainsi, pour 1211 : on lit un 1, un 2, deux 1 ; on \u00e9crit donc en nombre 1 1, 1 2, 2 1 ; puis on concat\u00e8ne 111221 . Compl\u00e9ter la fonction nombre_suivant qui prend en entr\u00e9e un nombre sous forme de chaine de caract\u00e8res et qui renvoie le nombre suivant par ce proc\u00e9d\u00e9, encore sous forme de cha\u00eene de caract\u00e8res. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def nombre_suivant ( s ): '''Renvoie le nombre suivant de celui represent\u00e9 par s en appliquant le proc\u00e9d\u00e9 de lecture.''' resultat = '' chiffre = s [ 0 ] compte = 1 for i in range ( ... ): if s [ i ] == chiffre : compte = ... else : resultat += ... + ... chiffre = ... ... lecture_ ... = ... + ... resultat += lecture_chiffre return resultat Exemples : \ud83d\udc0d Script Python >>> nombre_suivant ( '1211' ) '111221' >>> nombre_suivant ( '311' ) '1321' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def nombre_suivant ( s ): '''Renvoie le nombre suivant de celui represent\u00e9 par s en appliquant le proc\u00e9d\u00e9 de lecture.''' resultat = '' chiffre = s [ 0 ] compte = 1 for i in range ( 1 , len ( s )): if s [ i ] == chiffre : compte = compte + 1 else : resultat += str ( compte ) + chiffre chiffre = s [ i ] compte = 1 lecture_chiffre = str ( compte ) + chiffre resultat += lecture_chiffre return resultat Markdown On consid\u00e8re dans cet exercice la suite de nombre suivante : 1, 11, 21, 1211, 111221, ... Cette suite est construite ainsi : pour passer d\u2019une valeur \u00e0 la suivante, on la lit et on l\u2019\u00e9crit sous la forme d\u2019un nombre. Ainsi, pour 1211 : - on lit *un 1, un 2, deux 1* ; - on \u00e9crit donc en nombre *1 1, 1 2, 2 1* ; - puis on concat\u00e8ne *111221* . Compl\u00e9ter la fonction `nombre_suivant` qui prend en entr\u00e9e un nombre sous forme de chaine de caract\u00e8res et qui renvoie le nombre suivant par ce proc\u00e9d\u00e9, encore sous forme de cha\u00eene de caract\u00e8res. ```python linenums='1' def nombre_suivant(s): '''Renvoie le nombre suivant de celui represent\u00e9 par s en appliquant le proc\u00e9d\u00e9 de lecture.''' resultat = '' chiffre = s[0] compte = 1 for i in range(...): if s[i] == chiffre: compte = ... else: resultat += ... + ... chiffre = ... ... lecture_... = ... + ... resultat += lecture_chiffre return resultat Exemples : \ud83d\udc0d Script Python >>> nombre_suivant ( '1211' ) '111221' >>> nombre_suivant ( '311' ) '1321' ``` Compl\u00e9tez le code sur Basthon", "title": "BNS 2024"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#epreuve-pratique-bns-2024", "text": "Les sujets ci-dessous correspondent \u00e0 la derni\u00e8re version officielle, publi\u00e9e le 21/03/2024 . T\u00e9l\u00e9chargements Une archive contenant les 48 dossiers (contenant chacun le sujet en .pdf et le script en .py ) : BNS_2024.zip (1,6 Mo) Un pdf unique de tous les sujets : BNS_2024_pdf_unique.pdf (2,1 Mo)", "title": "\u00c9preuve Pratique BNS 2024"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-01", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 01"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-011", "text": "Exercice 01.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. On utilise la valeur '' pour repr\u00e9senter un fils vide. Par exemple, l\u2019arbre est stock\u00e9 dans \ud83d\udc0d Script Python a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], \\ 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], \\ 'H' :[ '' , '' ]} \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tres un arbre binaire arbre non vide sous la forme d\u2019un dictionnaire et un caract\u00e8re lettre qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153uds. On observe que, par exemple, arbre[lettre][0] , respectivement arbre[lettre][1] , permet d\u2019atteindre la cl\u00e9 du sous-arbre gauche, respectivement droit, de l\u2019arbre arbre de sommet lettre . Exemple : \ud83d\udc0d Script Python >>> taille ( a , 'F' ) 9 >>> taille ( a , 'B' ) 5 >>> taille ( a , 'I' ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 a = { 'F' :[ 'B' , 'G' ], 'B' :[ 'A' , 'D' ], 'A' :[ '' , '' ], 'D' :[ 'C' , 'E' ], 'C' :[ '' , '' ], 'E' :[ '' , '' ], 'G' :[ '' , 'I' ], 'I' :[ '' , 'H' ], 'H' :[ '' , '' ]} def taille ( arbre , lettre ): if lettre == '' : return 0 return 1 + taille ( arbre , arbre [ lettre ][ 0 ]) + taille ( arbre , arbre [ lettre ][ 1 ]) \ud83d\udccb Texte Dans cet exercice, un arbre binaire de caract\u00e8res est stock\u00e9 sous la forme d\u2019un dictionnaire o\u00f9 les clefs sont les caract\u00e8res des n\u0153uds de l\u2019arbre et les valeurs, pour chaque clef, la liste des caract\u00e8res des fils gauche et droit du n\u0153ud. On utilise la valeur `''` pour repr\u00e9senter un fils vide. Par exemple, l\u2019arbre ![image](data2023/33_arbre.png){: .center} est stock\u00e9 dans ```python a = {'F':['B','G'], 'B':['A','D'], 'A':['',''], 'D':['C','E'], \\ 'C':['',''], 'E':['',''], 'G':['','I'], 'I':['','H'], \\ 'H':['','']} ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tres un arbre binaire `arbre` non vide sous la forme d\u2019un dictionnaire et un caract\u00e8re `lettre` qui est la valeur du sommet de l\u2019arbre, et qui renvoie la taille de l\u2019arbre \u00e0 savoir le nombre total de n\u0153uds. On observe que, par exemple, `arbre[lettre][0]`, respectivement `arbre[lettre][1]`, permet d\u2019atteindre la cl\u00e9 du sous-arbre gauche, respectivement droit, de l\u2019arbre `arbre` de sommet `lettre`. Exemple : ```python >>> taille(a, 'F') 9 >>> taille(a, 'B') 5 >>> taille(a, 'I') 2 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 01.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-012", "text": "Exercice 01.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt le sous- tableau des \u00e9l\u00e9ments non rang\u00e9s et on place le plus petit \u00e9l\u00e9ment en premi\u00e8re position de ce sous-tableau. Exemple avec le tableau : t = [41, 55, 21, 18, 12, 6, 25] \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus petit \u00e9l\u00e9ment avec le premier. Le tableau devient t = [6, 55, 21, 18, 12, 41, 25] \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments sauf le premier , on permute le plus petit \u00e9l\u00e9ment trouv\u00e9 avec le second. Le tableau devient : t = [6, 12, 21, 18, 55, 41, 25] Et ainsi de suite. Le programme ci-dessous impl\u00e9mente cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def echange ( tab , i , j ): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = ... tab [ i ] = ... tab [ j ] = ... def tri_selection ( tab ): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri par s\u00e9lection.''' N = len ( tab ) for k in range ( ... ): imin = ... for i in range ( ... , N ): if tab [ i ] < ... : imin = i echange ( tab , ... , ... ) Compl\u00e9ter le code de cette fonction de fa\u00e7on \u00e0 obtenir : \ud83d\udc0d Script Python >>> liste = [ 41 , 55 , 21 , 18 , 12 , 6 , 25 ] >>> tri_selection ( liste ) >>> liste [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def echange ( tab , i , j ): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = tab [ i ] tab [ i ] = tab [ j ] tab [ j ] = temp def tri_selection ( tab ): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri par s\u00e9lection.''' N = len ( tab ) for k in range ( N ): imin = k for i in range ( k + 1 , N ): if tab [ i ] < tab [ imin ]: imin = i echange ( tab , k , imin ) Markdown On consid\u00e8re l'algorithme de tri de tableau suivant : \u00e0 chaque \u00e9tape, on parcourt le sous- tableau des \u00e9l\u00e9ments non rang\u00e9s et on place le plus petit \u00e9l\u00e9ment en premi\u00e8re position de ce sous-tableau. Exemple avec le tableau : ```t = [41, 55, 21, 18, 12, 6, 25]``` - \u00c9tape 1 : on parcourt tous les \u00e9l\u00e9ments du tableau, on permute le plus petit \u00e9l\u00e9ment avec le premier. Le tableau devient `t = [6, 55, 21, 18, 12, 41, 25]` - \u00c9tape 2 : on parcourt tous les \u00e9l\u00e9ments **sauf le premier** , on permute le plus petit \u00e9l\u00e9ment trouv\u00e9 avec le second. Le tableau devient : ```t = [6, 12, 21, 18, 55, 41, 25]``` Et ainsi de suite. Le programme ci-dessous impl\u00e9mente cet algorithme. ```python linenums='1' def echange(tab, i, j): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = ... tab[i] = ... tab[j] = ... def tri_selection(tab): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri par s\u00e9lection.''' N = len(tab) for k in range(...): imin = ... for i in range(..., N): if tab[i] < ...: imin = i echange(tab, ..., ...) Compl\u00e9ter le code de cette fonction de fa\u00e7on \u00e0 obtenir : \ud83d\udc0d Script Python >>> liste = [ 41 , 55 , 21 , 18 , 12 , 6 , 25 ] >>> tri_selection ( liste ) >>> liste [ 6 , 12 , 18 , 21 , 25 , 41 , 55 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 01.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-02", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 02"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-021", "text": "Exercice 02.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des carac- t\u00e8res * appel\u00e9es mots \u00e0 trous . Par exemple INFO*MA*IQUE , ***I***E** et *S* sont des mots \u00e0 trous. Programmer une fonction correspond qui : prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res mot et mot_a_trous o\u00f9 mot_a_trous est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, renvoie : True si on peut obtenir mot en rempla\u00e7ant convenablement les caract\u00e8res '*' de mot_a_trous . False sinon. Exemple : \ud83d\udc0d Script Python >>> correspond ( 'INFORMATIQUE' , 'INFO*MA*IQUE' ) True >>> correspond ( 'AUTOMATIQUE' , 'INFO*MA*IQUE' ) False >>> correspond ( 'STOP' , 'S*' ) False >>> correspond ( 'AUTO' , '*UT*' ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def correspond ( mot , mot_a_trous ): if len ( mot ) != len ( mot_a_trous ): return False for i in range ( len ( mot )): if mot [ i ] != mot_a_trous [ i ] and mot_a_trous [ i ] != '*' : return False return True \ud83d\udccb Texte On consid\u00e8re des cha\u00eenes de caract\u00e8res contenant uniquement des majuscules et des carac- t\u00e8res `*` appel\u00e9es *mots \u00e0 trous*. Par exemple `INFO*MA*IQUE`, `***I***E**` et `*S*` sont des mots \u00e0 trous. Programmer une fonction `correspond` qui : - prend en param\u00e8tres deux cha\u00eenes de caract\u00e8res `mot` et `mot_a_trous` o\u00f9 `mot_a_trous` est un mot \u00e0 trous comme indiqu\u00e9 ci-dessus, - renvoie : - `True` si on peut obtenir `mot` en rempla\u00e7ant convenablement les caract\u00e8res `'*'` de `mot_a_trous`. - `False` sinon. Exemple : ```python >>> correspond('INFORMATIQUE', 'INFO*MA*IQUE') True >>> correspond('AUTOMATIQUE', 'INFO*MA*IQUE') False >>> correspond('STOP', 'S*') False >>> correspond('AUTO', '*UT*') True ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 02.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-022", "text": "Exercice 02.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : chaque personne ne peut envoyer des messages qu'\u00e0 une seule personne (\u00e9ventuellement elle-m\u00eame), chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : A envoie ses messages \u00e0 E E envoie ses messages \u00e0 B B envoie ses messages \u00e0 F F envoie ses messages \u00e0 A C envoie ses messages \u00e0 D D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'} Un cycle est une suite de personnes dans laquelle la derni\u00e8re est la m\u00eame que la premi\u00e8re. Sur le plan d'envoi plan_a des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi plan_b ci-dessous : plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'} comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un unique cycle , on dit que le plan d\u2019envoi est cyclique . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : on part d\u2019un exp\u00e9diteur (ici A) et on inspecte son destinataire dans le plan d'envoi, chaque destinataire devient \u00e0 son tour exp\u00e9diteur, selon le plan d\u2019envoi, tant qu\u2019on ne \u00ab retombe \u00bb pas sur l\u2019exp\u00e9diteur initial, le plan d\u2019envoi est cyclique si on l\u2019a parcouru en entier. Compl\u00e9ter la fonction est_cyclique en respectant la sp\u00e9cification. On rappelle que la fonction Python len permet d'obtenir la longueur d'un dictionnaire. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def est_cyclique ( plan ): '''Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon.''' expediteur = 'A' destinataire = plan [ ... ] nb_destinataires = 1 while destinataire != expediteur : destinataire = ... nb_destinataires = ... return nb_destinataires == ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def est_cyclique ( plan ): '''Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon.''' expediteur = 'A' destinataire = plan [ expediteur ] nb_destinaires = 1 while destinataire != expediteur : destinataire = plan [ destinataire ] nb_destinaires += 1 return nb_destinaires == len ( plan ) #tests print ( est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' })) print ( est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' })) print ( est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' })) Markdown On consid\u00e8re au plus 26 personnes A, B, C, D, E, F ... qui peuvent s'envoyer des messages avec deux r\u00e8gles \u00e0 respecter : - chaque personne ne peut envoyer des messages qu'\u00e0 une seule personne (\u00e9ventuellement elle-m\u00eame), - chaque personne ne peut recevoir des messages qu'en provenance d'une seule personne (\u00e9ventuellement elle-m\u00eame). Voici un exemple - avec 6 personnes - de \u00ab plan d'envoi des messages \u00bb qui respecte les r\u00e8gles ci-dessus, puisque chaque personne est pr\u00e9sente une seule fois dans chaque colonne : - A envoie ses messages \u00e0 E - E envoie ses messages \u00e0 B - B envoie ses messages \u00e0 F - F envoie ses messages \u00e0 A - C envoie ses messages \u00e0 D - D envoie ses messages \u00e0 C Et le dictionnaire correspondant \u00e0 ce plan d'envoi est le suivant : `plan_a = {'A':'E', 'B':'F', 'C':'D', 'D':'C', 'E':'B', 'F':'A'}` Un cycle est une suite de personnes dans laquelle la derni\u00e8re est la m\u00eame que la premi\u00e8re. Sur le plan d'envoi `plan_a` des messages ci-dessus, il y a deux cycles distincts : un premier cycle avec A, E, B, F et un second cycle avec C et D. En revanche, le plan d\u2019envoi `plan_b` ci-dessous : `plan_b = {'A':'C', 'B':'F', 'C':'E', 'D':'A', 'E':'B', 'F':'D'}` comporte un unique cycle : A, C, E, B, F, D. Dans ce cas, lorsqu\u2019un plan d\u2019envoi comporte un *unique cycle* , on dit que le plan d\u2019envoi est *cyclique* . Pour savoir si un plan d'envoi de messages comportant N personnes est cyclique, on peut utiliser l'algorithme ci-dessous : - on part d\u2019un exp\u00e9diteur (ici A) et on inspecte son destinataire dans le plan d'envoi, - chaque destinataire devient \u00e0 son tour exp\u00e9diteur, selon le plan d\u2019envoi, tant qu\u2019on ne \u00ab retombe \u00bb pas sur l\u2019exp\u00e9diteur initial, - le plan d\u2019envoi est cyclique si on l\u2019a parcouru en entier. Compl\u00e9ter la fonction `est_cyclique` en respectant la sp\u00e9cification. On rappelle que la fonction Python `len` permet d'obtenir la longueur d'un dictionnaire. ```python linenums='1' def est_cyclique(plan): '''Prend en param\u00e8tre un dictionnaire `plan` correspondant \u00e0 un plan d'envoi de messages (ici entre les personnes A, B, C, D, E, F). Renvoie True si le plan d'envoi de messages est cyclique et False sinon.''' expediteur = 'A' destinataire = plan[...] nb_destinataires = 1 while destinataire != expediteur: destinataire = ... nb_destinataires = ... return nb_destinataires == ... Exemples : \ud83d\udc0d Script Python >>> est_cyclique ({ 'A' : 'E' , 'F' : 'A' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'C' }) False >>> est_cyclique ({ 'A' : 'E' , 'F' : 'C' , 'C' : 'D' , 'E' : 'B' , 'B' : 'F' , 'D' : 'A' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'C' , 'C' : 'D' , 'E' : 'A' , 'B' : 'F' , 'D' : 'E' }) True >>> est_cyclique ({ 'A' : 'B' , 'F' : 'A' , 'C' : 'D' , 'E' : 'C' , 'B' : 'F' , 'D' : 'E' }) False ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 02.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-03", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 03"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-031", "text": "Exercice 03.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire la fonction maximum_tableau , prenant en param\u00e8tre un tableau non vide de nombres tab (de type list ) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : \ud83d\udc0d Script Python >>> maximum_tableau ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maximum_tableau ([ - 27 , 24 , - 3 , 15 ]) 24 \ud83d\udc0d Script Python 1 2 3 4 5 6 def maximum_tableau ( tab ): maximum = tab [ 0 ] for element in tab : if element > maximum : maximum = element return maximum \ud83d\udccb Texte \u00c9crire la fonction `maximum_tableau`, prenant en param\u00e8tre un tableau non vide de nombres `tab` (de type `list`) et renvoyant le plus grand \u00e9l\u00e9ment de ce tableau. Exemples : ```python >>> maximum_tableau([98, 12, 104, 23, 131, 9]) 131 >>> maximum_tableau([-27, 24, -3, 15]) 24 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 03.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-032", "text": "Exercice 03.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, ((()())(())) est un parenth\u00e9sage correct. Les parenth\u00e9sages ())(() et (())(() sont, eux, incorrects. On dispose du code de la classe Pile suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie un bool\u00e9en indiquant si la pile est vide.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l'\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self . est_vide () return self . contenu . pop () On souhaite programmer une fonction bon_parenthesage qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res ch form\u00e9e de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. Compl\u00e9ter le code de la fonction bon_parenthesage ci-dessous: \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def bon_parenthesage ( ch ): \"\"\"Renvoie un bool\u00e9en indiquant si la cha\u00eene ch est bien parenth\u00e9s\u00e9e\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): ... else : ... return ... Exemples : \ud83d\udc0d Script Python >>> bon_parenthesage ( \"((()())(()))\" ) True >>> bon_parenthesage ( \"())(()\" ) False >>> bon_parenthesage ( \"(())(()\" ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie un bool\u00e9en indiquant si la pile est vide.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l'\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self . est_vide () return self . contenu . pop () def bon_parenthesage ( ch ): \"\"\"Renvoie un bool\u00e9en indiquant si la cha\u00eene ch est bien parenth\u00e9s\u00e9e\"\"\" p = Pile () for c in ch : if c == '(' : p . empiler ( c ) elif c == ')' : if p . est_vide (): return False else : p . depiler () return p . est_vide () Markdown On dispose de cha\u00eenes de caract\u00e8res contenant uniquement des parenth\u00e8ses ouvrantes et fermantes. Un parenth\u00e9sage est correct si : - le nombre de parenth\u00e8ses ouvrantes de la cha\u00eene est \u00e9gal au nombre de parenth\u00e8ses fermantes. - en parcourant la cha\u00eene de gauche \u00e0 droite, le nombre de parenth\u00e8ses d\u00e9j\u00e0 ouvertes doit \u00eatre, \u00e0 tout moment, sup\u00e9rieur ou \u00e9gal au nombre de parenth\u00e8ses d\u00e9j\u00e0 ferm\u00e9es. Ainsi, `((()())(()))` est un parenth\u00e9sage correct. Les parenth\u00e9sages `())(()` et `(())(()` sont, eux, incorrects. On dispose du code de la classe `Pile` suivant : ```python linenums='1' class Pile: \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ (self): self.contenu = [] def est_vide(self): \"\"\"Renvoie un bool\u00e9en indiquant si la pile est vide.\"\"\" return self.contenu == [] def empiler(self, v): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self.contenu.append(v) def depiler(self): \"\"\" Retire et renvoie l'\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self.est_vide() return self.contenu.pop() On souhaite programmer une fonction bon_parenthesage qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res ch form\u00e9e de parenth\u00e8ses et renvoie True si la cha\u00eene est bien parenth\u00e9s\u00e9e et False sinon. Cette fonction utilise une pile et suit le principe suivant : en parcourant la cha\u00eene de gauche \u00e0 droite, si on trouve une parenth\u00e8se ouvrante, on l\u2019empile au sommet de la pile et si on trouve une parenth\u00e8se fermante, on d\u00e9pile (si possible) la parenth\u00e8se ouvrante stock\u00e9e au sommet de la pile. La cha\u00eene est alors bien parenth\u00e9s\u00e9e si, \u00e0 la fin du parcours, la pile est vide. Elle est, par contre, mal parenth\u00e9s\u00e9e : si dans le parcours, on trouve une parenth\u00e8se fermante, alors que la pile est vide ; ou si, \u00e0 la fin du parcours, la pile n\u2019est pas vide. Compl\u00e9ter le code de la fonction bon_parenthesage ci-dessous: \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def bon_parenthesage ( ch ): \"\"\"Renvoie un bool\u00e9en indiquant si la cha\u00eene ch est bien parenth\u00e9s\u00e9e\"\"\" p = Pile () for c in ch : if c == ... : p . empiler ( c ) elif c == ... : if p . est_vide (): ... else : ... return ... Exemples : \ud83d\udc0d Script Python >>> bon_parenthesage ( \"((()())(()))\" ) True >>> bon_parenthesage ( \"())(()\" ) False >>> bon_parenthesage ( \"(())(()\" ) False ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 03.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-04", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 04"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-041", "text": "Exercice 04.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction recherche , prenant en param\u00e8tres un tableau non vide tab (type list ) d'entiers et un entier n , et qui renvoie l'indice de la derni\u00e8re occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie None . Exemples \ud83d\udc0d Script Python >>> recherche ([ 5 , 3 ], 1 ) # renvoie None 2 >>> recherche ([ 2 , 4 ], 2 ) 0 >>> recherche ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche ( tab , n ): indice_solution = None for i in range ( len ( tab )): if tab [ i ] == n : indice_solution = i return indice_solution \ud83d\udccb Texte Programmer la fonction `recherche`, prenant en param\u00e8tres un tableau non vide `tab` (type `list`) d'entiers et un entier `n`, et qui renvoie l'indice de la **derni\u00e8re** occurrence de l'\u00e9l\u00e9ment cherch\u00e9. Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie `None`. Exemples ```python >>> recherche([5, 3], 1) # renvoie None 2 >>> recherche([2, 4], 2) 0 >>> recherche([2, 3, 5, 2, 4], 2) 3 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 04.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-042", "text": "Exercice 04.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es \\((x;y)\\) et \\((x';y')\\) v\u00e9rifie la formule : \\[d^2=(x-x')^2+(y-y')^2\\] Compl\u00e9ter le code des fonctions distance_carre et point_le_plus_proche fournies ci-dessous pour qu\u2019elles r\u00e9pondent \u00e0 leurs sp\u00e9cifications. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def distance_carre ( point1 , point2 ): \"\"\" Calcule et renvoie la distance au carre entre deux points.\"\"\" return ( ... ) ** 2 + ( ... ) ** 2 def point_le_plus_proche ( depart , tab ): \"\"\" Renvoie les coordonn\u00e9es du premier point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" min_point = tab [ 0 ] min_dist = ... for i in range ( 1 , len ( tab )): if distance_carre ( tab [ i ], depart ) < ... : min_point = ... min_dist = ... return min_point Exemples : \ud83d\udc0d Script Python >>> distance_carre (( 1 , 0 ), ( 5 , 3 )) 25 >>> distance_carre (( 1 , 0 ), ( 0 , 1 )) 2 >>> point_le_plus_proche (( 0 , 0 ), [( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )]) ( 2 , 5 ) >>> point_le_plus_proche (( 5 , 2 ), [( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )]) ( 5 , 2 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def distance_carre ( point1 , point2 ): \"\"\" Calcule et renvoie la distance au carre entre deux points.\"\"\" return ( point1 [ 0 ] - point2 [ 0 ]) ** 2 + (( point1 [ 1 ] - point2 [ 1 ])) ** 2 def point_le_plus_proche ( depart , tab ): \"\"\" Renvoie les coordonn\u00e9es du premier point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" min_point = tab [ 0 ] min_dist = distance_carre ( min_point , depart ) for i in range ( 1 , len ( tab )): if distance_carre ( tab [ i ], depart ) < min_dist : min_point = tab [ i ] min_dist = distance_carre ( tab [ i ], depart ) return min_point Markdown On souhaite programmer une fonction donnant la distance la plus courte entre un point de d\u00e9part et une liste de points. Les points sont tous \u00e0 coordonn\u00e9es enti\u00e8res. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. On rappelle que la distance entre deux points du plan de coordonn\u00e9es $(x;y)$ et $(x';y')$ v\u00e9rifie la formule : $$d^2=(x-x')^2+(y-y')^2$$ Compl\u00e9ter le code des fonctions `distance_carre` et `point_le_plus_proche` fournies ci-dessous pour qu\u2019elles r\u00e9pondent \u00e0 leurs sp\u00e9cifications. ```python linenums='1' def distance_carre(point1, point2): \"\"\" Calcule et renvoie la distance au carre entre deux points.\"\"\" return (...)**2 + (...)**2 def point_le_plus_proche(depart, tab): \"\"\" Renvoie les coordonn\u00e9es du premier point du tableau tab se trouvant \u00e0 la plus courte distance du point depart.\"\"\" min_point = tab[0] min_dist = ... for i in range(1, len(tab)): if distance_carre(tab[i], depart) < ...: min_point = ... min_dist = ... return min_point Exemples : \ud83d\udc0d Script Python >>> distance_carre (( 1 , 0 ), ( 5 , 3 )) 25 >>> distance_carre (( 1 , 0 ), ( 0 , 1 )) 2 >>> point_le_plus_proche (( 0 , 0 ), [( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )]) ( 2 , 5 ) >>> point_le_plus_proche (( 5 , 2 ), [( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )]) ( 5 , 2 ) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 04.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-05", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 05"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-051", "text": "Exercice 05.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction max_et_indice qui prend en param\u00e8tre un tableau non vide tab de nombres entiers et qui renvoie la valeur du plus grand \u00e9l\u00e9ment de ce tableau ainsi que l\u2019indice de sa premi\u00e8re apparition dans ce tableau. L\u2019utilisation de la fonction native max n\u2019est pas autoris\u00e9e. Exemples : \ud83d\udc0d Script Python >>> max_et_indice ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , 3 ) >>> max_et_indice ([ - 2 ]) ( - 2 , 0 ) >>> max_et_indice ([ - 1 , - 1 , 3 , 3 , 3 ]) ( 3 , 2 ) >>> max_et_indice ([ 1 , 1 , 1 , 1 ]) ( 1 , 0 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def max_et_indice ( tab ): ''' renvoie la valeur du plus grand \u00e9l\u00e9ment de ce tableau ainsi que l\u2019indice de sa premi\u00e8re apparition dans ce tableau. ''' val_max = tab [ 0 ] ind_max = 0 for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] ind_max = i return ( val_max , ind_max ) \ud83d\udccb Texte \u00c9crire une fonction `max_et_indice` qui prend en param\u00e8tre un tableau non vide `tab` de nombres entiers et qui renvoie la valeur du plus grand \u00e9l\u00e9ment de ce tableau ainsi que l\u2019indice de sa premi\u00e8re apparition dans ce tableau. L\u2019utilisation de la fonction native `max` n\u2019est pas autoris\u00e9e. Exemples : ```python >>> max_et_indice([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) (9, 3) >>> max_et_indice([-2]) (-2, 0) >>> max_et_indice([-1, -1, 3, 3, 3]) (3, 2) >>> max_et_indice([1, 1, 1, 1]) (1, 0) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 05.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-052", "text": "Exercice 05.2 \u00c9nonc\u00e9 Correction Sources Markdown L\u2019ordre des g\u00e8nes sur un chromosome est repr\u00e9sent\u00e9 par un tableau ordre de n cases d\u2019entiers distincts deux \u00e0 deux et compris entre 1 et n . Par exemple, ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9] dans le cas n = 9 . On dit qu\u2019il y a un point de rupture dans ordre dans chacune des situations suivantes : la premi\u00e8re valeur de ordre n\u2019est pas 1 ; l\u2019\u00e9cart entre deux g\u00e8nes cons\u00e9cutifs n\u2019est pas \u00e9gal \u00e0 1 ; la derni\u00e8re valeur de ordre n\u2019est pas n. Par exemple, si ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9] avec n = 9 , on a un point de rupture au d\u00e9but car 5 est diff\u00e9rent de 1 un point de rupture entre 3 et 6 (l\u2019\u00e9cart est de 3) un point de rupture entre 7 et 2 (l\u2019\u00e9cart est de 5) un point de rupture entre 1 et 8 (l\u2019\u00e9cart est de 7) Il y a donc 4 points de rupture. Compl\u00e9ter les fonctions Python est_un_ordre et nombre_points_rupture propos\u00e9es \u00e0 la page suivante pour que : la fonction est_un_ordre renvoie True si le tableau pass\u00e9 en param\u00e8tre repr\u00e9sente bien un ordre de g\u00e8nes de chromosome et False sinon ; la fonction nombre_points_rupture renvoie le nombre de points de rupture d\u2019un tableau pass\u00e9 en param\u00e8tre repr\u00e9sentant l\u2019ordre de g\u00e8nes d\u2019un chromosome. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def est_un_ordre ( tab ): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' n = len ( tab ) # les entiers vus lors du parcours vus = ... for x in tab : if x < ... or x >... or ... : return False ... . append ( ... ) return True def nombre_points_rupture ( ordre ): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' # on v\u00e9rifie que ordre est un ordre de g\u00e8nes assert ... n = len ( ordre ) nb = 0 if ordre [ ... ] != 1 : # le premier n'est pas 1 nb = nb + 1 i = 0 while i < ... : if ... not in [ - 1 , 1 ]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre [ i ] != ... : # le dernier n'est pas n nb = nb + 1 return nb Exemples : \ud83d\udc0d Script Python >>> est_un_ordre ([ 1 , 6 , 2 , 8 , 3 , 7 ]) False >>> est_un_ordre ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) True >>> nombre_points_rupture ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) 4 >>> nombre_points_rupture ([ 1 , 2 , 3 , 4 , 5 ]) 0 >>> nombre_points_rupture ([ 1 , 6 , 2 , 8 , 3 , 7 , 4 , 5 ]) 7 >>> nombre_points_rupture ([ 2 , 1 , 3 , 4 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def est_un_ordre ( tab ): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' n = len ( tab ) # les entiers vus lors du parcours vus = [] for x in tab : if x < 1 or x > n or x in vus : return False vus . append ( x ) return True def nombre_points_rupture ( ordre ): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' # on v\u00e9rifie que ordre est un ordre de g\u00e8nes assert est_un_ordre ( ordre ) n = len ( ordre ) nb = 0 if ordre [ 0 ] != 1 : # le premier n'est pas 1 nb = nb + 1 i = 0 while i < n - 1 : if ordre [ i + 1 ] - ordre [ i ] not in [ - 1 , 1 ]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre [ i ] != n : # le dernier n'est pas n nb = nb + 1 return nb Markdown L\u2019ordre des g\u00e8nes sur un chromosome est repr\u00e9sent\u00e9 par un tableau `ordre` de `n` cases d\u2019entiers distincts deux \u00e0 deux et compris entre 1 et `n` . Par exemple, `ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9]` dans le cas `n = 9` . On dit qu\u2019il y a un point de rupture dans `ordre` dans chacune des situations suivantes : - la premi\u00e8re valeur de `ordre` n\u2019est pas 1 ; - l\u2019\u00e9cart entre deux g\u00e8nes cons\u00e9cutifs n\u2019est pas \u00e9gal \u00e0 1 ; - la derni\u00e8re valeur de `ordre` n\u2019est pas n. Par exemple, si `ordre = [5, 4, 3, 6, 7, 2, 1, 8, 9]` avec `n = 9` , on a - un point de rupture au d\u00e9but car 5 est diff\u00e9rent de 1 - un point de rupture entre 3 et 6 (l\u2019\u00e9cart est de 3) - un point de rupture entre 7 et 2 (l\u2019\u00e9cart est de 5) - un point de rupture entre 1 et 8 (l\u2019\u00e9cart est de 7) Il y a donc 4 points de rupture. Compl\u00e9ter les fonctions Python `est_un_ordre` et `nombre_points_rupture` propos\u00e9es \u00e0 la page suivante pour que : - la fonction `est_un_ordre` renvoie `True` si le tableau pass\u00e9 en param\u00e8tre repr\u00e9sente bien un ordre de g\u00e8nes de chromosome et `False` sinon ; - la fonction `nombre_points_rupture` renvoie le nombre de points de rupture d\u2019un tableau pass\u00e9 en param\u00e8tre repr\u00e9sentant l\u2019ordre de g\u00e8nes d\u2019un chromosome. ```python linenums='1' def est_un_ordre(tab): ''' Renvoie True si tab est de longueur n et contient tous les entiers de 1 \u00e0 n, False sinon ''' n = len(tab) # les entiers vus lors du parcours vus = ... for x in tab: if x < ... or x >... or ...: return False ... .append(...) return True def nombre_points_rupture(ordre): ''' Renvoie le nombre de point de rupture de ordre qui repr\u00e9sente un ordre de g\u00e8nes de chromosome ''' # on v\u00e9rifie que ordre est un ordre de g\u00e8nes assert ... n = len(ordre) nb = 0 if ordre[...] != 1: # le premier n'est pas 1 nb = nb + 1 i = 0 while i < ...: if ... not in [-1, 1]: # l'\u00e9cart n'est pas 1 nb = nb + 1 i = i + 1 if ordre[i] != ...: # le dernier n'est pas n nb = nb + 1 return nb Exemples : \ud83d\udc0d Script Python >>> est_un_ordre ([ 1 , 6 , 2 , 8 , 3 , 7 ]) False >>> est_un_ordre ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) True >>> nombre_points_rupture ([ 5 , 4 , 3 , 6 , 7 , 2 , 1 , 8 , 9 ]) 4 >>> nombre_points_rupture ([ 1 , 2 , 3 , 4 , 5 ]) 0 >>> nombre_points_rupture ([ 1 , 6 , 2 , 8 , 3 , 7 , 4 , 5 ]) 7 >>> nombre_points_rupture ([ 2 , 1 , 3 , 4 ]) 2 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 05.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-06", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 06"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-061", "text": "Exercice 06.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction verifie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques et qui renvoie True si ce tableau est tri\u00e9 dans l\u2019ordre croissant, False sinon. Un tableau vide est consid\u00e9r\u00e9 comme tri\u00e9. Exemples : \ud83d\udc0d Script Python Exemples : >>> verifie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> verifie ([ 8 , 12 , 4 ]) False >>> verifie ([ - 1 , 4 ]) True >>> verifie ([]) True >>> verifie ([ 5 ]) True \ud83d\udc0d Script Python 1 2 3 4 5 def verifie ( tab ): for i in range ( 1 , len ( tab )): if tab [ i ] < tab [ i - 1 ]: return False return True \ud83d\udccb Texte \u00c9crire une fonction `verifie` qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques et qui renvoie `True` si ce tableau est tri\u00e9 dans l\u2019ordre croissant, `False` sinon. Un tableau vide est consid\u00e9r\u00e9 comme tri\u00e9. Exemples : ```python Exemples : >>> verifie([0, 5, 8, 8, 9]) True >>> verifie([8, 12, 4]) False >>> verifie([-1, 4]) True >>> verifie([]) True >>> verifie([5]) True ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 06.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-062", "text": "Exercice 06.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re dans cet exercice l\u2019\u00e9lection d\u2019un vainqueur \u00e0 l\u2019issue d\u2019un vote. Les r\u00e9sultats du vote sont stock\u00e9s dans un tableau : chaque vote exprim\u00e9 est le nom d\u2019un ou d\u2019une candidate. Par exemple, les r\u00e9sultats pourraient correspondre au tableau : \ud83d\udc0d Script Python urne = [ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ] indiquant que 3 candidats ont obtenu au moins un vote chacun : A, B et C. On cherche \u00e0 d\u00e9terminer le ou les candidats ayant obtenu le plus de suffrages. Pour cela, on propose d\u2019\u00e9crire deux fonctions : La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des issues et les valeurs le nombre de votes en leur faveur. La fonction vainqueurs doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire non vide dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueurs ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def depouille ( urne ): '''prend en param\u00e8tre une liste de suffrages et renvoie un dictionnaire avec le nombre de voix pour chaque candidat''' resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueurs ( election ): '''prend en param\u00e8tre un dictionnaire non vide avec le nombre de voix pour chaque candidat et renvoie la liste des vainqueurs''' nmax = 0 for candidat in election : if ... > ... : nmax = ... liste_finale = [ nom for nom in election if ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> depouille ([ 'A' , 'B' , 'A' ]) { 'A' : 2 , 'B' : 1 } >>> depouille ([]) {} >>> election = depouille ([ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ]) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } >>> vainqueurs ( election ) [ 'B' ] >>> vainqueurs ({ 'A' : 2 , 'B' : 2 , 'C' : 1 }) [ 'A' , 'B' ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def depouille ( urne ): '''prend en param\u00e8tre une liste de suffrages et renvoie un dictionnaire avec le nombre de voix pour chaque candidat''' resultat = {} for bulletin in urne : if bulletin in resultat : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : resultat [ bulletin ] = 1 return resultat def vainqueurs ( election ): '''prend en param\u00e8tre un dictionnaire non vide avec le nombre de voix pour chaque candidat et renvoie la liste des vainqueurs''' nmax = 0 for candidat in election : if election [ candidat ] > nmax : nmax = election [ candidat ] liste_finale = [ nom for nom in election if election [ nom ] == nmax ] return liste_finale Markdown On consid\u00e8re dans cet exercice l\u2019\u00e9lection d\u2019un vainqueur \u00e0 l\u2019issue d\u2019un vote. Les r\u00e9sultats du vote sont stock\u00e9s dans un tableau : chaque vote exprim\u00e9 est le nom d\u2019un ou d\u2019une candidate. Par exemple, les r\u00e9sultats pourraient correspondre au tableau : ```python urne = ['A', 'A', 'A', 'B', 'C', 'B', 'C', 'B', 'C', 'B'] indiquant que 3 candidats ont obtenu au moins un vote chacun : A, B et C. On cherche \u00e0 d\u00e9terminer le ou les candidats ayant obtenu le plus de suffrages. Pour cela, on propose d\u2019\u00e9crire deux fonctions : La fonction depouille doit permettre de compter le nombre de votes exprim\u00e9s pour chaque artiste. Elle prend en param\u00e8tre un tableau et renvoie le r\u00e9sultat dans un dictionnaire dont les cl\u00e9s sont les noms des issues et les valeurs le nombre de votes en leur faveur. La fonction vainqueurs doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire non vide dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s\u2019il y a des artistes ex- aequo. Compl\u00e9ter les fonctions depouille et vainqueurs ci-apr\u00e8s pour qu\u2019elles renvoient les r\u00e9sultats attendus. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def depouille ( urne ): '''prend en param\u00e8tre une liste de suffrages et renvoie un dictionnaire avec le nombre de voix pour chaque candidat''' resultat = ... for bulletin in urne : if ... : resultat [ bulletin ] = resultat [ bulletin ] + 1 else : ... return resultat def vainqueurs ( election ): '''prend en param\u00e8tre un dictionnaire non vide avec le nombre de voix pour chaque candidat et renvoie la liste des vainqueurs''' nmax = 0 for candidat in election : if ... > ... : nmax = ... liste_finale = [ nom for nom in election if ... ] return ... Exemples d\u2019utilisation : \ud83d\udc0d Script Python >>> depouille ([ 'A' , 'B' , 'A' ]) { 'A' : 2 , 'B' : 1 } >>> depouille ([]) {} >>> election = depouille ([ 'A' , 'A' , 'A' , 'B' , 'C' , 'B' , 'C' , 'B' , 'C' , 'B' ]) >>> election { 'A' : 3 , 'B' : 4 , 'C' : 3 } >>> vainqueurs ( election ) [ 'B' ] >>> vainqueurs ({ 'A' : 2 , 'B' : 2 , 'C' : 1 }) [ 'A' , 'B' ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 06.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-07", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 07"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-071", "text": "Exercice 07.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re dans cet exercice une repr\u00e9sentation binaire d\u2019un entier non sign\u00e9 en tant que tableau de bool\u00e9ens. Si \ud83d\udc0d Script Python tab = [ True , False , True , False , False , True , True ] est un tel tableau, alors l\u2019entier qu\u2019il repr\u00e9sente est \\(2^6 +2^4 + 2^1 + 2^0 = 83\\) . Cette repr\u00e9sentation consistant \u00e0 placer en premier le bool\u00e9en indiquant la puissance la plus \u00e9lev\u00e9e de 2 est dite big-endian ou grand-boutiste. \u00c9crire une fonction gb_vers_entier qui prend en param\u00e8tre un tel tableau et renvoie l\u2019entier qu\u2019il repr\u00e9sente. Exemple : \ud83d\udc0d Script Python >>> gb_vers_entier ([]) 0 >>> gb_vers_entier ([ True ]) 1 >>> gb_vers_entier ([ True , False , True , False , False , True , True ]) 83 >>> gb_vers_entier ([ True , False , False , False , False , False , True , False ]) 130 \ud83d\udc0d Script Python 1 2 3 4 5 6 def gb_vers_entier ( tab ): somme = 0 for i in range ( len ( tab )): if tab [ i ]: somme += 2 ** ( len ( tab ) - 1 - i ) return somme \ud83d\udccb Texte On consid\u00e8re dans cet exercice une repr\u00e9sentation binaire d\u2019un entier non sign\u00e9 en tant que tableau de bool\u00e9ens. Si ```python tab = [True, False, True, False, False, True, True] ``` est un tel tableau, alors l\u2019entier qu\u2019il repr\u00e9sente est $2^6 +2^4 + 2^1 + 2^0 = 83$. Cette repr\u00e9sentation consistant \u00e0 placer en premier le bool\u00e9en indiquant la puissance la plus \u00e9lev\u00e9e de 2 est dite *big-endian* ou grand-boutiste. \u00c9crire une fonction `gb_vers_entier` qui prend en param\u00e8tre un tel tableau et renvoie l\u2019entier qu\u2019il repr\u00e9sente. Exemple : ```python >>> gb_vers_entier([]) 0 >>> gb_vers_entier([True]) 1 >>> gb_vers_entier([True, False, True, False, False, True, True]) 83 >>> gb_vers_entier([True, False, False, False, False, False, True, False]) 130 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 07.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-072", "text": "Exercice 07.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_insertion suivante prend en argument un tableau tab et trie ce tableau en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. On rappelle le principe du tri par insertion : on consid\u00e8re les \u00e9l\u00e9ments \u00e0 trier un par un, le premier \u00e9l\u00e9ment constituant, \u00e0 lui tout seul, un tableau tri\u00e9 de longueur 1. On range ensuite le second \u00e9l\u00e9ment pour constituer un tableau tri\u00e9 de longueur 2, puis on range le troisi\u00e8me \u00e9l\u00e9ment pour avoir un tableau tri\u00e9 de longueur 3 et ainsi de suite... A chaque \u00e9tape, le premier \u00e9l\u00e9ment du sous-tableau non tri\u00e9 est plac\u00e9 dans le sous-tableau des \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s de sorte que ce sous-tableau demeure tri\u00e9. Le principe du tri par insertion est donc d'ins\u00e9rer \u00e0 la n-i\u00e8me it\u00e9ration, le n-i\u00e8me \u00e9l\u00e9ment \u00e0 la bonne place. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tri_insertion ( tab ): '''Trie le tableau tab par ordre croissant en appliquant l'algorithme de tri par insertion''' n = len ( tab ) for i in range ( 1 , n ): valeur_insertion = ... # la variable j sert \u00e0 d\u00e9terminer # o\u00f9 placer la valeur \u00e0 ranger j = ... # tant qu'on n'a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 # ins\u00e9rer on d\u00e9cale les valeurs du tableau vers la droite while j > ... and valeur_insertion < tab [ ... ]: tab [ j ] = tab [ j - 1 ] j = ... tab [ j ] = ... Exemples : \ud83d\udc0d Script Python >>> tab = [ 98 , 12 , 104 , 23 , 131 , 9 ] >>> tri_insertion ( tab ) >>> tab [ 9 , 12 , 23 , 98 , 104 , 131 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def tri_insertion ( tab ): '''Trie le tableau tab par ordre croissant en appliquant l'algorithme de tri par insertion''' n = len ( tab ) for i in range ( 1 , n ): valeur_insertion = tab [ i ] # la variable j sert \u00e0 d\u00e9terminer # o\u00f9 placer la valeur \u00e0 ranger j = i # tant qu'on n'a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 # ins\u00e9rer on d\u00e9cale les valeurs du tableau vers la droite while j > 0 and valeur_insertion < tab [ j - 1 ]: tab [ j ] = tab [ j - 1 ] j = j - 1 tab [ j ] = valeur_insertion Markdown La fonction `tri_insertion` suivante prend en argument un tableau `tab` et trie ce tableau en utilisant la m\u00e9thode du tri par insertion. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. On rappelle le principe du tri par insertion : on consid\u00e8re les \u00e9l\u00e9ments \u00e0 trier un par un, le premier \u00e9l\u00e9ment constituant, \u00e0 lui tout seul, un tableau tri\u00e9 de longueur 1. On range ensuite le second \u00e9l\u00e9ment pour constituer un tableau tri\u00e9 de longueur 2, puis on range le troisi\u00e8me \u00e9l\u00e9ment pour avoir un tableau tri\u00e9 de longueur 3 et ainsi de suite... A chaque \u00e9tape, le premier \u00e9l\u00e9ment du sous-tableau non tri\u00e9 est plac\u00e9 dans le sous-tableau des \u00e9l\u00e9ments d\u00e9j\u00e0 tri\u00e9s de sorte que ce sous-tableau demeure tri\u00e9. Le principe du tri par insertion est donc d'ins\u00e9rer \u00e0 la n-i\u00e8me it\u00e9ration, le n-i\u00e8me \u00e9l\u00e9ment \u00e0 la bonne place. ```python linenums='1' def tri_insertion(tab): '''Trie le tableau tab par ordre croissant en appliquant l'algorithme de tri par insertion''' n = len(tab) for i in range(1, n): valeur_insertion = ... # la variable j sert \u00e0 d\u00e9terminer # o\u00f9 placer la valeur \u00e0 ranger j = ... # tant qu'on n'a pas trouv\u00e9 la place de l'\u00e9l\u00e9ment \u00e0 # ins\u00e9rer on d\u00e9cale les valeurs du tableau vers la droite while j > ... and valeur_insertion < tab[...]: tab[j] = tab[j-1] j = ... tab[j] = ... Exemples : \ud83d\udc0d Script Python >>> tab = [ 98 , 12 , 104 , 23 , 131 , 9 ] >>> tri_insertion ( tab ) >>> tab [ 9 , 12 , 23 , 98 , 104 , 131 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 07.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-08", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 08"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-081", "text": "Exercice 08.1 \u00c9nonc\u00e9 Correction Source Markdown Le codage par diff\u00e9rence ( delta encoding en anglais) permet de compresser un tableau d\u2019entiers dont les valeurs sont proches les unes des autres. Le principe est de stocker la premi\u00e8re donn\u00e9e en indiquant pour chaque autre donn\u00e9e sa diff\u00e9rence avec la pr\u00e9c\u00e9dente plut\u00f4t que la donn\u00e9e elle-m\u00eame. On se retrouve alors avec un tableau de donn\u00e9es plus petit, n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta(liste) qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : \ud83d\udc0d Script Python >>> delta ([ 1000 , 800 , 802 , 1000 , 1003 ]) [ 1000 , - 200 , 2 , 198 , 3 ] >>> delta ([ 42 ]) [ 42 ] \ud83d\udc0d Script Python 1 2 3 4 5 def delta ( tab ): diff = [ tab [ 0 ]] for i in range ( 1 , len ( tab )): diff . append ( tab [ i ] - tab [ i - 1 ]) return diff \ud83d\udccb Texte Le codage par diff\u00e9rence (*delta encoding* en anglais) permet de compresser un tableau d\u2019entiers dont les valeurs sont proches les unes des autres. Le principe est de stocker la premi\u00e8re donn\u00e9e en indiquant pour chaque autre donn\u00e9e sa diff\u00e9rence avec la pr\u00e9c\u00e9dente plut\u00f4t que la donn\u00e9e elle-m\u00eame. On se retrouve alors avec un tableau de donn\u00e9es plus petit, n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction `delta(liste)` qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tableau contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l\u2019aide cette technique. Exemples : ```python >>> delta([1000, 800, 802, 1000, 1003]) [1000, -200, 2, 198, 3] >>> delta([42]) [42] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 08.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-082", "text": "Exercice 08.2 \u00c9nonc\u00e9 Correction Sources Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212, \u00d7, \u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : \\[(3 \\times (8 + 7)) \u2212 (2 + 1)\\] La classe Expr ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire pour repr\u00e9senter de telles expressions. Compl\u00e9ter la m\u00e9thode r\u00e9cursive infixe qui renvoie une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses repr\u00e9sentant l\u2019expression arithm\u00e9tique sur laquelle on l\u2019applique. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Expr : \"\"\"Classe impl\u00e9mentant un arbre d'expression.\"\"\" def __init__ ( self , g , v , d ): \"\"\"un objet Expr poss\u00e8de 3 attributs : - gauche : la sous-expression gauche ; - valeur : la valeur de l'\u00e9tiquette, op\u00e9rande ou nombre ; - droite : la sous-expression droite.\"\"\" self . gauche = g self . valeur = v self . droite = d def est_une_feuille ( self ): \"\"\"renvoie True si et seulement si le noeud est une feuille\"\"\" return self . gauche is None and self . droite is None def infixe ( self ): \"\"\"renvoie la repr\u00e9sentation infixe de l'expression en chaine de caract\u00e8res\"\"\" s = ... if self . gauche is not None : s = '(' + s + ... . infixe () s = s + ... if ... is not None : s = s + ... + ... return s Exemples : \ud83d\udc0d Script Python >>> a = Expr ( Expr ( None , 1 , None ), '+' , Expr ( None , 2 , None )) >>> a . infixe () '(1+2)' >>> b = Expr ( Expr ( Expr ( None , 1 , None ), '+' , Expr ( None , 2 , None )), '*' , Expr ( Expr ( None , 3 , None ), '+' , Expr ( None , 4 , None ))) >>> b . infixe () '((1+2)*(3+4))' >>> e = Expr ( Expr ( Expr ( None , 3 , None ), '*' , Expr ( Expr ( None , 8 , None ), '+' , Expr ( None , 7 , None ))), '-' , Expr ( Expr ( None , 2 , None ), '+' , Expr ( None , 1 , None ))) >>> e . infixe () '((3*(8+7))-(2+1))' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Expr : \"\"\"Classe impl\u00e9mentant un arbre d'expression.\"\"\" def __init__ ( self , g , v , d ): \"\"\"un objet Expr poss\u00e8de 3 attributs : - gauche : la sous-expression gauche ; - valeur : la valeur de l'\u00e9tiquette, op\u00e9rande ou nombre ; - droite : la sous-expression droite.\"\"\" self . gauche = g self . valeur = v self . droite = d def est_une_feuille ( self ): \"\"\"renvoie True si et seulement si le noeud est une feuille\"\"\" return self . gauche is None and self . droite is None def infixe ( self ): \"\"\"renvoie la repr\u00e9sentation infixe de l'expression en chaine de caract\u00e8res\"\"\" s = '' if self . gauche is not None : s = '(' + s + self . gauche . infixe () s = s + str ( self . valeur ) if self . droite is not None : s = s + self . droite . infixe () + ')' return s Markdown Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations +, \u2212, \u00d7, \u00f7 peut \u00eatre repr\u00e9sent\u00e9e sous forme d\u2019arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. ![ image ]( data2023/21_arbre.png ){: .center width=30%} En parcourant en profondeur infixe l\u2019arbre binaire ci-dessus, on retrouve l\u2019expression not\u00e9e habituellement : $$(3 \\times (8 + 7)) \u2212 (2 + 1)$$ La classe `Expr` ci-apr\u00e8s permet d\u2019impl\u00e9menter une structure d\u2019arbre binaire pour repr\u00e9senter de telles expressions. Compl\u00e9ter la m\u00e9thode r\u00e9cursive `infixe` qui renvoie une cha\u00eene de caract\u00e8res contenant des parenth\u00e8ses repr\u00e9sentant l\u2019expression arithm\u00e9tique sur laquelle on l\u2019applique. ```python linenums='1' class Expr: \"\"\"Classe impl\u00e9mentant un arbre d'expression.\"\"\" def __init__ (self, g, v, d): \"\"\"un objet Expr poss\u00e8de 3 attributs : - gauche : la sous-expression gauche ; - valeur : la valeur de l'\u00e9tiquette, op\u00e9rande ou nombre ; - droite : la sous-expression droite.\"\"\" self.gauche = g self.valeur = v self.droite = d def est_une_feuille(self): \"\"\"renvoie True si et seulement si le noeud est une feuille\"\"\" return self.gauche is None and self.droite is None def infixe(self): \"\"\"renvoie la repr\u00e9sentation infixe de l'expression en chaine de caract\u00e8res\"\"\" s = ... if self.gauche is not None: s = '(' + s + ... .infixe() s = s + ... if ... is not None: s = s + ... + ... return s Exemples : \ud83d\udc0d Script Python >>> a = Expr ( Expr ( None , 1 , None ), '+' , Expr ( None , 2 , None )) >>> a . infixe () '(1+2)' >>> b = Expr ( Expr ( Expr ( None , 1 , None ), '+' , Expr ( None , 2 , None )), '*' , Expr ( Expr ( None , 3 , None ), '+' , Expr ( None , 4 , None ))) >>> b . infixe () '((1+2)*(3+4))' >>> e = Expr ( Expr ( Expr ( None , 3 , None ), '*' , Expr ( Expr ( None , 8 , None ), '+' , Expr ( None , 7 , None ))), '-' , Expr ( Expr ( None , 2 , None ), '+' , Expr ( None , 1 , None ))) >>> e . infixe () '((3*(8+7))-(2+1))' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 08.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-09", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 09"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-091", "text": "Exercice 09.1 \u00c9nonc\u00e9 Correction Source Markdown On veut trier par ordre croissant les notes d\u2019une \u00e9valuation qui sont des nombres entiers compris entre 0 et 10 (inclus). Ces notes sont contenues dans un tableau notes_eval (type list ) \u00c9crire une fonction effectif_notes prenant en param\u00e8tre le tableau notes_eval et renvoyant un tableau de longueur 11 tel que la valeur d\u2019indice i soit le nombre de notes valant i dans le tableau notes_eval . \u00c9crire ensuite une fonction notes_triees prenant en param\u00e8tre le tableau des effectifs des notes et renvoyant un tableau contenant les m\u00eames valeurs que notes_eval mais tri\u00e9es dans l\u2019ordre croissant. Exemple : \ud83d\udc0d Script Python >>> notes_eval = [ 2 , 0 , 5 , 9 , 6 , 9 , 10 , 5 , 7 , 9 , 9 , 5 , 0 , 9 , 6 , 5 , 4 ] >>> eff = effectif_notes ( notes_eval ) >>> eff [ 2 , 0 , 1 , 0 , 1 , 4 , 2 , 1 , 0 , 5 , 1 ] >>> notes_triees ( eff ) [ 0 , 0 , 2 , 4 , 5 , 5 , 5 , 5 , 6 , 6 , 7 , 9 , 9 , 9 , 9 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def effectif_notes ( notes_eval ): tab = [ 0 ] * 11 for note in notes_eval : tab [ note ] += 1 return tab def notes_triees ( eff ): triees = [] for i in range ( 11 ): if eff [ i ] != 0 : #(1) for _ in range ( eff [ i ]): triees . append ( i ) return triees On peut ne pas effectuer ce test, car si eff[i] vaut 0, on ne rentrera pas dans la boucle for _ in range(0) et donc on ne touchera pas \u00e0 la liste triees . \ud83d\udccb Texte On veut trier par ordre croissant les notes d\u2019une \u00e9valuation qui sont des nombres entiers compris entre 0 et 10 (inclus). Ces notes sont contenues dans un tableau `notes_eval` (type `list`) \u00c9crire une fonction `effectif_notes` prenant en param\u00e8tre le tableau `notes_eval` et renvoyant un tableau de longueur 11 tel que la valeur d\u2019indice `i` soit le nombre de notes valant `i` dans le tableau `notes_eval`. \u00c9crire ensuite une fonction `notes_triees` prenant en param\u00e8tre le tableau des effectifs des notes et renvoyant un tableau contenant les m\u00eames valeurs que `notes_eval` mais tri\u00e9es dans l\u2019ordre croissant. Exemple : ```python >>> notes_eval = [2, 0, 5, 9, 6, 9, 10, 5, 7, 9, 9, 5, 0, 9, 6, 5, 4] >>> eff = effectif_notes(notes_eval) >>> eff [2, 0, 1, 0, 1, 4, 2, 1, 0, 5, 1] >>> notes_triees(eff) [0, 0, 2, 4, 5, 5, 5, 5, 6, 6, 7, 9, 9, 9, 9, 9, 10] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 09.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-092", "text": "Exercice 09.2 \u00c9nonc\u00e9 Correction Sources Markdown L\u2019objectif de cet exercice est d\u2019\u00e9crire deux fonctions r\u00e9cursives dec_to_bin et bin_to_dec assurant respectivement la conversion de l\u2019\u00e9criture d\u00e9cimale d\u2019un nombre entier vers son \u00e9criture en binaire et, r\u00e9ciproquement, la conversion de l\u2019\u00e9criture en binaire d\u2019un nombre vers son \u00e9criture d\u00e9cimale. Dans cet exercice, on s\u2019interdit l\u2019usage des fonctions Python bin et int . L'exemple suivant montre comment obtenir l\u2019\u00e9criture en binaire du nombre 25 : \\(25 = 2 \\times 12 + 1\\) \\(\\phantom{25} = 2 \\times (2 \\times 6 + 0) + 1\\) \\(\\phantom{25} = 2 \\times (2 \\times (2 \\times 3 + 0) + 0) + 1\\) \\(\\phantom{25} = 2 \\times (2 \\times (2 \\times (2 \\times 1+1) + 0) + 0) + 1\\) \\(\\phantom{25} = 2 \\times (2 \\times (2 \\times (2 \\times (2 \\times 0 + 1)+1) + 0) + 0) + 1\\) \\(\\phantom{25} = 1 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) L'\u00e9criture binaire de 25 est donc 11001 . 0n rappelle \u00e9galement que : a // 2 renvoie le quotient de la division euclidienne de a par 2. a % 2 renvoie le reste dans la division euclidienne de a par 2. On indique enfin qu\u2019en Python si mot = \"informatique\" alors : mot[-1] renvoie 'e' , c\u2019est-\u00e0-dire le dernier caract\u00e8re de la cha\u00eene de caract\u00e8res mot . mot[:-1] renvoie 'informatiqu' , c\u2019est-\u00e0-dire l\u2019ensemble de la cha\u00eene de caract\u00e8res mot priv\u00e9e de son dernier caract\u00e8re. Compl\u00e9ter, puis tester, les codes de deux fonctions ci-dessous. On pr\u00e9cise que la fonction r\u00e9cursive dec_to_bin prend en param\u00e8tre un nombre entier et renvoie une cha\u00eene de caract\u00e8res contenant l\u2019\u00e9criture en binaire du nombre pass\u00e9 en param\u00e8tre. Exemple : \ud83d\udc0d Script Python >>> dec_to_bin ( 25 ) '11001' La fonction r\u00e9cursive bin_to_dec prend en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019\u00e9criture d\u2019un nombre en binaire et renvoie l\u2019\u00e9criture d\u00e9cimale de ce nombre. \ud83d\udc0d Script Python >>> bin_to_dec ( '101010' ) 42 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == ... : return ... else : return dec_to_bin ( ... ) + ... def bin_to_dec ( nb_bin ): if len ( nb_bin ) == 1 : if ... == '0' : return 0 else : return ... else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : ... return ... * bin_to_dec ( nb_bin [: - 1 ]) + ... \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == 0 : return str ( r ) else : return dec_to_bin ( q ) + str ( r ) def bin_to_dec ( nb_bin ): if len ( nb_bin ) == 1 : if nb_bin == '0' : return 0 else : return 1 else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : bit_droit = 1 return 2 * bin_to_dec ( nb_bin [: - 1 ]) + bit_droit Markdown L\u2019objectif de cet exercice est d\u2019\u00e9crire deux fonctions r\u00e9cursives `dec_to_bin` et `bin_to_dec` assurant respectivement la conversion de l\u2019\u00e9criture d\u00e9cimale d\u2019un nombre entier vers son \u00e9criture en binaire et, r\u00e9ciproquement, la conversion de l\u2019\u00e9criture en binaire d\u2019un nombre vers son \u00e9criture d\u00e9cimale. Dans cet exercice, on s\u2019interdit l\u2019usage des fonctions Python `bin` et `int` . L'exemple suivant montre comment obtenir l\u2019\u00e9criture en binaire du nombre 25 : $25 = 2 \\times 12 + 1$ $\\phantom{25} = 2 \\times (2 \\times 6 + 0) + 1$ $\\phantom{25} = 2 \\times (2 \\times (2 \\times 3 + 0) + 0) + 1$ $\\phantom{25} = 2 \\times (2 \\times (2 \\times (2 \\times 1+1) + 0) + 0) + 1$ $\\phantom{25} = 2 \\times (2 \\times (2 \\times (2 \\times (2 \\times 0 + 1)+1) + 0) + 0) + 1$ $\\phantom{25} = 1 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0$ L'\u00e9criture binaire de 25 est donc ```11001```. 0n rappelle \u00e9galement que : - `a // 2` renvoie le quotient de la division euclidienne de `a` par 2. - ` a % 2` renvoie le reste dans la division euclidienne de `a` par 2. On indique enfin qu\u2019en Python si `mot = \"informatique\"` alors : - `mot[-1]` renvoie `'e'` , c\u2019est-\u00e0-dire le dernier caract\u00e8re de la cha\u00eene de caract\u00e8res `mot` . - `mot[:-1]` renvoie `'informatiqu'` , c\u2019est-\u00e0-dire l\u2019ensemble de la cha\u00eene de caract\u00e8res `mot` priv\u00e9e de son dernier caract\u00e8re. Compl\u00e9ter, puis tester, les codes de deux fonctions ci-dessous. On pr\u00e9cise que la fonction r\u00e9cursive `dec_to_bin` prend en param\u00e8tre un nombre entier et renvoie une cha\u00eene de caract\u00e8res contenant l\u2019\u00e9criture en binaire du nombre pass\u00e9 en param\u00e8tre. Exemple : ```python >>> dec_to_bin(25) '11001' La fonction r\u00e9cursive bin_to_dec prend en param\u00e8tre une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019\u00e9criture d\u2019un nombre en binaire et renvoie l\u2019\u00e9criture d\u00e9cimale de ce nombre. \ud83d\udc0d Script Python >>> bin_to_dec ( '101010' ) 42 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def dec_to_bin ( nb_dec ): q , r = nb_dec // 2 , nb_dec % 2 if q == ... : return ... else : return dec_to_bin ( ... ) + ... def bin_to_dec ( nb_bin ): if len ( nb_bin ) == 1 : if ... == '0' : return 0 else : return ... else : if nb_bin [ - 1 ] == '0' : bit_droit = 0 else : ... return ... * bin_to_dec ( nb_bin [: - 1 ]) + ... ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 09.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-10", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 10"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-101", "text": "Exercice 10.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice on cherche \u00e0 calculer la moyenne pond\u00e9r\u00e9e d\u2019un \u00e9l\u00e8ve dans une mati\u00e8re donn\u00e9e. Chaque note est associ\u00e9e \u00e0 un coefficient qui la pond\u00e8re. Par exemple, si ses notes sont : 14 avec coefficient 3, 12 avec coefficient 1 et 16 avec coeffi- cient 2, sa moyenne pond\u00e9r\u00e9e sera donn\u00e9e par \\[\\dfrac{14 \\times 3 + 12 \\times 1 + 16 \\times 2}{3+1+2}=14,333... \\] \u00c9crire une fonction moyenne : qui prend en param\u00e8tre une liste notes non vide de tuples \u00e0 deux \u00e9l\u00e9ments entiers de la forme (note, coefficient) ( int ou float ) positifs ou nuls ; et qui renvoie la moyenne pond\u00e9r\u00e9e des notes de la liste sous forme de flottant si la somme des coefficients est non nulle, None sinon. Exemple : \ud83d\udc0d Script Python >>> moyenne ([( 8 , 2 ), ( 12 , 0 ), ( 13.5 , 1 ), ( 5 , 0.5 )]) 9.142857142857142 >>> moyenne ([( 3 , 0 ), ( 5 , 0 )]) None \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): somme = 0 coeffs = 0 for couple in tab : somme += couple [ 0 ] * couple [ 1 ] coeffs += couple [ 1 ] if coeffs == 0 : return None return somme / coeffs \ud83d\udccb Texte Dans cet exercice on cherche \u00e0 calculer la moyenne pond\u00e9r\u00e9e d\u2019un \u00e9l\u00e8ve dans une mati\u00e8re donn\u00e9e. Chaque note est associ\u00e9e \u00e0 un coefficient qui la pond\u00e8re. Par exemple, si ses notes sont : 14 avec coefficient 3, 12 avec coefficient 1 et 16 avec coeffi- cient 2, sa moyenne pond\u00e9r\u00e9e sera donn\u00e9e par $$\\dfrac{14 \\times 3 + 12 \\times 1 + 16 \\times 2}{3+1+2}=14,333... $$ \u00c9crire une fonction `moyenne` : - qui prend en param\u00e8tre une liste notes non vide de tuples \u00e0 deux \u00e9l\u00e9ments entiers de la forme `(note, coefficient)` (`int` ou `float`) positifs ou nuls ; - et qui renvoie la moyenne pond\u00e9r\u00e9e des notes de la liste sous forme de flottant si la somme des coefficients est non nulle, `None` sinon. Exemple : ```python >>> moyenne([(8, 2), (12, 0), (13.5, 1), (5, 0.5)]) 9.142857142857142 >>> moyenne([(3, 0), (5, 0)]) None ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 10.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-102", "text": "Exercice 10.2 \u00c9nonc\u00e9 Correction Sources Markdown On travaille sur des dessins en noir et blanc obtenus \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction affiche permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction liste_zoom prend en arguments une liste liste_depart et un entier k . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de liste_depart est dupliqu\u00e9 k fois. La fonction dessin_zoom prend en argument la grille dessin et renvoie une grille o\u00f9 toutes les lignes de dessin sont zoom\u00e9es k fois et r\u00e9p\u00e9t\u00e9es k fois. Compl\u00e9ter les fonctions liste_zoom et dessin_zoom du code suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \"*\" , les 0 par un espace \" \" ''' for ligne in dessin : affichage = '' for col in ligne : if col == 1 : affichage = affichage + \"*\" else : affichage = affichage + \" \" print ( affichage ) def liste_zoom ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoomee = ... for elt in ... : for i in range ( k ): ... return liste_zoomee def dessin_zoom ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoomee = [] for ligne in grille : ligne_zoomee = ... for i in range ( k ): ... . append ( ... ) return grille_zoomee Exemples : \ud83d\udc0d Script Python >>> coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] >>> affiche ( coeur ) * * * * * * * * * * * * * * * * * * * * * * * * >>> affiche ( dessin_zoom ( coeur , 2 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * >>> liste_zoom ([ 1 , 2 , 3 ], 3 ) [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] def affiche ( dessin ): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \" *\" , les 0 par deux espaces \" \" ''' for ligne in dessin : affichage = '' for col in ligne : if col == 1 : affichage = affichage + \"*\" else : affichage = affichage + \" \" print ( affichage ) def liste_zoom ( liste_depart , k ): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoomee = [] for elt in liste_depart : for i in range ( k ): liste_zoomee . append ( elt ) return liste_zoomee def dessin_zoom ( grille , k ): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoomee = [] for ligne in grille : liste_zoomee = liste_zoom ( ligne , k ) for i in range ( k ): grille_zoomee . append ( liste_zoomee ) return grille_zoomee Markdown ![ image ]( data2023/03_coeur.png ){: .center width=30%} On travaille sur des dessins en noir et blanc obtenus \u00e0 partir de pixels noirs et blancs : La figure \u00ab c\u0153ur \u00bb ci-dessus va servir d\u2019exemple. On la repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire par une liste compos\u00e9e de sous-listes de m\u00eame longueurs. Chaque sous-liste repr\u00e9sentera donc une ligne du dessin. Dans le code ci-dessous, la fonction `affiche` permet d\u2019afficher le dessin. Les pixels noirs (1 dans la grille) seront repr\u00e9sent\u00e9s par le caract\u00e8re \"*\" et les blancs (0 dans la grille) par deux espaces. La fonction `liste_zoom` prend en arguments une liste `liste_depart` et un entier `k` . Elle renvoie une liste o\u00f9 chaque \u00e9l\u00e9ment de `liste_depart` est dupliqu\u00e9 `k` fois. La fonction `dessin_zoom` prend en argument la grille `dessin` et renvoie une grille o\u00f9 toutes les lignes de `dessin` sont zoom\u00e9es `k` fois et r\u00e9p\u00e9t\u00e9es `k` fois. Compl\u00e9ter les fonctions `liste_zoom` et `dessin_zoom` du code suivant : ```python linenums='1' def affiche(dessin): ''' affichage d'une grille : les 1 sont repr\u00e9sent\u00e9s par des \"*\" , les 0 par un espace \" \" ''' for ligne in dessin: affichage = '' for col in ligne: if col == 1: affichage = affichage + \"*\" else: affichage = affichage + \" \" print(affichage) def liste_zoom(liste_depart,k): '''renvoie une liste contenant k fois chaque \u00e9l\u00e9ment de liste_depart''' liste_zoomee = ... for elt in ... : for i in range(k): ... return liste_zoomee def dessin_zoom(grille,k): '''renvoie une grille o\u00f9 les lignes sont zoom\u00e9es k fois ET r\u00e9p\u00e9t\u00e9es k fois''' grille_zoomee=[] for ligne in grille: ligne_zoomee = ... for i in range(k): ... .append(...) return grille_zoomee Exemples : \ud83d\udc0d Script Python >>> coeur = [[ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]] >>> affiche ( coeur ) * * * * * * * * * * * * * * * * * * * * * * * * >>> affiche ( dessin_zoom ( coeur , 2 )) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * >>> liste_zoom ([ 1 , 2 , 3 ], 3 ) [ 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 10.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-11", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 11"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-111", "text": "Exercice 11.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, on consid\u00e8re des phrases compos\u00e9es de mots. On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, On appelle phrase une cha\u00eene de caract\u00e8res : compos\u00e9e avec un ou plusieurs mots s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace ' ' , se finissant : soit par un point '.' qui est alors coll\u00e9 au dernier mot, soit par un point d'exclamation '!' ou d'interrogation '?' qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace ' ' . Voici deux exemples de phrases : 'Cet exercice est simple.' 'Le point d exclamation est separe !' Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction nombre_de_mots qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. \ud83d\udc0d Script Python >>> nombre_de_mots ( 'Cet exercice est simple.' ) 4 >>> nombre_de_mots ( 'Le point d exclamation est s\u00e9par\u00e9 !' ) 6 >>> nombre_de_mots ( 'Combien de mots y a t il dans cette phrase ?' ) 10 >>> nombre_de_mots ( 'Fin.' ) 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nombre_de_mots ( phrase ): nb_mots = 0 for caractere in phrase : if caractere == ' ' or caractere == '.' : nb_mots += 1 return nb_mots \ud83d\udccb Texte Dans cet exercice, on consid\u00e8re des phrases compos\u00e9es de mots. - On appelle \u00ab mot \u00bb une cha\u00eene de caract\u00e8res compos\u00e9e avec des caract\u00e8res choisis parmi les 26 lettres minuscules ou majuscules de l'alphabet, - On appelle *phrase* une cha\u00eene de caract\u00e8res : - compos\u00e9e avec un ou plusieurs *mots* s\u00e9par\u00e9s entre eux par un seul caract\u00e8re espace `' '`, - se finissant : - soit par un point `'.'` qui est alors coll\u00e9 au dernier mot, - soit par un point d'exclamation `'!'` ou d'interrogation `'?'` qui est alors s\u00e9par\u00e9 du dernier mot par un seul caract\u00e8re espace `' '`. Voici deux exemples de phrases : - 'Cet exercice est simple.' - 'Le point d exclamation est separe !' Apr\u00e8s avoir remarqu\u00e9 le lien entre le nombre de mots et le nombres de caract\u00e8res espace dans une phrase, programmer une fonction `nombre_de_mots` qui prend en param\u00e8tre une phrase et renvoie le nombre de mots pr\u00e9sents dans cette phrase. ```python >>> nombre_de_mots('Cet exercice est simple.') 4 >>> nombre_de_mots('Le point d exclamation est s\u00e9par\u00e9 !') 6 >>> nombre_de_mots('Combien de mots y a t il dans cette phrase ?') 10 >>> nombre_de_mots('Fin.') 1 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 11.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-112", "text": "Exercice 11.2 \u00c9nonc\u00e9 Correction Sources Markdown Un arbre binaire de recherche est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None, soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe Noeud donn\u00e9e ci-dessous. On consid\u00e8re ici que les \u00e9tiquettes des n\u0153uds sont des entiers et que les arbres binaires de recherche consid\u00e9r\u00e9s ne contiennent pas de doublons. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Noeud : def __init__ ( self , etiquette ): '''M\u00e9thode constructeur pour la classe Noeud. Cr\u00e9e une feuille d'\u00e9tiquette donn\u00e9e.''' self . etiquette = etiquette self . gauche = None self . droit = None def inserer ( self , cle ): '''Ins\u00e8re la cl\u00e9 dans l'arbre binaire de recherche en pr\u00e9servant sa structure.''' if cle < self . etiquette : if self . gauche != None : ... else : self . gauche = ... else : ... ... else : ... = Noeud ( cle ) Compl\u00e9ter la m\u00e9thode r\u00e9cursive inserer afin qu\u2019elle permette d\u2019ins\u00e9rer une cl\u00e9 dans l\u2019arbre binaire de recherche non vide sur lequel on l\u2019appelle. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> arbre = Noeud ( 7 ) >>> for cle in ( 3 , 9 , 1 , 6 ): arbre . inserer ( cle ) >>> arbre . gauche . etiquette 3 >>> arbre . droit . etiquette 9 >>> arbre . gauche . gauche . etiquette 1 >>> arbre . gauche . droit . etiquette 6 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Noeud : def __init__ ( self , etiquette ): '''M\u00e9thode constructeur pour la classe Noeud. Cr\u00e9e une feuille d'\u00e9tiquette donn\u00e9e.''' self . etiquette = etiquette self . gauche = None self . droit = None def inserer ( self , cle ): '''Ins\u00e8re la cl\u00e9 dans l'arbre binaire de recherche en pr\u00e9servant sa structure.''' if cle < self . etiquette : if self . gauche != None : self . gauche . inserer ( cle ) else : self . gauche = Noeud ( cle ) else : if self . droit != None : self . droit . inserer ( cle ) else : self . droit = Noeud ( cle ) Markdown Un arbre binaire de recherche est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None, soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe Noeud donn\u00e9e ci-dessous. On consid\u00e8re ici que les \u00e9tiquettes des n\u0153uds sont des entiers et que les arbres binaires de recherche consid\u00e9r\u00e9s ne contiennent pas de doublons. ```python linenums='1' class Noeud: def __init__ (self, etiquette): '''M\u00e9thode constructeur pour la classe Noeud. Cr\u00e9e une feuille d'\u00e9tiquette donn\u00e9e.''' self.etiquette = etiquette self.gauche = None self.droit = None def inserer(self, cle): '''Ins\u00e8re la cl\u00e9 dans l'arbre binaire de recherche en pr\u00e9servant sa structure.''' if cle < self.etiquette: if self.gauche != None: ... else: self.gauche = ... else: ... ... else: ... = Noeud(cle) Compl\u00e9ter la m\u00e9thode r\u00e9cursive inserer afin qu\u2019elle permette d\u2019ins\u00e9rer une cl\u00e9 dans l\u2019arbre binaire de recherche non vide sur lequel on l\u2019appelle. Voici un exemple d'utilisation : \ud83d\udc0d Script Python >>> arbre = Noeud ( 7 ) >>> for cle in ( 3 , 9 , 1 , 6 ): arbre . inserer ( cle ) >>> arbre . gauche . etiquette 3 >>> arbre . droit . etiquette 9 >>> arbre . gauche . gauche . etiquette 1 >>> arbre . gauche . droit . etiquette 6 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 11.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-12", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 12"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-121", "text": "Exercice 12.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction tri_selection qui prend en param\u00e8tre un tableau tab de nombres entiers (type list ) et qui le modifie afin qu\u2019il soit tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : on recherche le plus petit \u00e9l\u00e9ment du tableau, en le parcourant du rang 0 au dernier rang, et on l\u2019\u00e9change avec l\u2019\u00e9l\u00e9ment d\u2019indice 0 ; on recherche ensuite le plus petit \u00e9l\u00e9ment du tableau restreint du rang 1 au dernier rang, et on l\u2019\u00e9change avec l\u2019\u00e9l\u00e9ment d\u2019indice 1 ; on continue de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : \ud83d\udc0d Script Python >>> tab = [ 1 , 52 , 6 , - 9 , 12 ] >>> tri_selection ( tab ) >>> tab [ - 9 , 1 , 6 , 12 , 52 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def tri_selection ( tab ): for i in range ( len ( tab ) - 1 ): indice_min = i for j in range ( i + 1 , len ( tab )): if tab [ j ] < tab [ indice_min ]: indice_min = j tab [ i ], tab [ indice_min ] = tab [ indice_min ], tab [ i ] return tab \ud83d\udccb Texte \u00c9crire une fonction `tri_selection` qui prend en param\u00e8tre un tableau `tab` de nombres entiers (type `list`) et qui le modifie afin qu\u2019il soit tri\u00e9 par ordre croissant. On utilisera l\u2019algorithme suivant : - on recherche le plus petit \u00e9l\u00e9ment du tableau, en le parcourant du rang 0 au dernier rang, et on l\u2019\u00e9change avec l\u2019\u00e9l\u00e9ment d\u2019indice 0 ; - on recherche ensuite le plus petit \u00e9l\u00e9ment du tableau restreint du rang 1 au dernier rang, et on l\u2019\u00e9change avec l\u2019\u00e9l\u00e9ment d\u2019indice 1 ; - on continue de cette fa\u00e7on jusqu\u2019\u00e0 ce que le tableau soit enti\u00e8rement tri\u00e9. Exemple : ```python >>> tab = [1, 52, 6, -9, 12] >>> tri_selection(tab) >>> tab [-9, 1, 6, 12, 52] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 12.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-122", "text": "Exercice 12.2 \u00c9nonc\u00e9 Correction Sources Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Une \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; si la proposition de l\u2019utilisatrice est plus petite que le nombre cherch\u00e9, l\u2019utilisatrice en est avertie. Elle peut alors en tester un autre ; si la proposition de l\u2019utilisatrice est plus grande que le nombre cherch\u00e9, l\u2019utilisatrice en est avertie. Elle peut alors en tester un autre ; si l\u2019utilisatrice trouve le bon nombre en 10 essais ou moins, elle gagne ; si l\u2019utilisatrice a fait plus de 10 essais sans trouver le bon nombre, elle perd. La fonction randint est utilis\u00e9e. Si a et b sont des entiers tels que a <= b , randint(a,b) renvoie un nombre entier compris entre a et b . Compl\u00e9ter le code ci-dessous et le tester : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , ... ) nb_test = int ( input ( \"Proposez un nombre entre 1 et 99 : \" )) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test : nb_test = int ( input ( \"Trop petit ! Testez encore : \" )) else : nb_test = int ( input ( \"Trop grand ! Testez encore : \" )) if nb_mystere == nb_test : print ( \"Bravo ! Le nombre \u00e9tait \" , ... ) print ( \"Nombre d'essais: \" , ... ) else : print ( \"Perdu ! Le nombre \u00e9tait \" , ... ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from random import randint def plus_ou_moins (): nb_mystere = randint ( 1 , 99 ) nb_test = int ( input ( 'Proposez un nombre entre 1 et 99 : ' )) compteur = 1 while nb_mystere != nb_test and compteur < 10 : compteur = compteur + 1 if nb_mystere > nb_test : nb_test = int ( input ( 'Trop petit ! Testez encore : ' )) else : nb_test = int ( input ( 'Trop grand ! Testez encore : ' )) if nb_mystere == nb_test : print ( 'Bravo ! Le nombre \u00e9tait ' , nb_mystere ) print ( 'Nombre d essais: ' , compteur ) else : print ( 'Perdu ! Le nombre \u00e9tait ' , nb_mystere ) Markdown Le jeu du \u00ab plus ou moins \u00bb consiste \u00e0 deviner un nombre entier choisi entre 1 et 99. Une \u00e9l\u00e8ve de NSI d\u00e9cide de le coder en langage Python de la mani\u00e8re suivante : - le programme g\u00e9n\u00e8re un nombre entier al\u00e9atoire compris entre 1 et 99 ; - si la proposition de l\u2019utilisatrice est plus petite que le nombre cherch\u00e9, l\u2019utilisatrice en est avertie. Elle peut alors en tester un autre ; - si la proposition de l\u2019utilisatrice est plus grande que le nombre cherch\u00e9, l\u2019utilisatrice en est avertie. Elle peut alors en tester un autre ; - si l\u2019utilisatrice trouve le bon nombre en 10 essais ou moins, elle gagne ; - si l\u2019utilisatrice a fait plus de 10 essais sans trouver le bon nombre, elle perd. La fonction `randint` est utilis\u00e9e. Si a et b sont des entiers tels que `a <= b` , `randint(a,b)` renvoie un nombre entier compris entre `a` et `b` . Compl\u00e9ter le code ci-dessous et le tester : ```python linenums='1' from random import randint def plus_ou_moins(): nb_mystere = randint(1,...) nb_test = int(input(\"Proposez un nombre entre 1 et 99 : \")) compteur = ... while nb_mystere != ... and compteur < ... : compteur = compteur + ... if nb_mystere ... nb_test: nb_test = int(input(\"Trop petit ! Testez encore : \")) else: nb_test = int(input(\"Trop grand ! Testez encore : \")) if nb_mystere == nb_test: print (\"Bravo ! Le nombre \u00e9tait \",...) print(\"Nombre d'essais: \",...) else: print (\"Perdu ! Le nombre \u00e9tait \",...) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 12.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-13", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 13"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-131", "text": "Exercice 13.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers (type list ), et qui renvoie l\u2019indice de la premi\u00e8re occurrence de elt dans tab si elt est dans tab et None sinon. L\u2019objectif de cet exercice est de parcourir un tableau, il est interdit d\u2019utiliser la m\u00e9thode index des listes Python. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) # renvoie None >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 50 , [ 1 , 50 , 1 ]) 1 >>> recherche ( 15 , [ 8 , 9 , 10 , 15 ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab )): if tab [ i ] == elt : return i return None \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers (type `list`), et qui renvoie l\u2019indice de la premi\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `None` sinon. L\u2019objectif de cet exercice est de parcourir un tableau, il est interdit d\u2019utiliser la m\u00e9thode `index` des listes Python. Exemples : ```python >>> recherche(1, [2, 3, 4]) # renvoie None >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(50, [1, 50, 1]) 1 >>> recherche(15, [8, 9, 10, 15]) 3 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 13.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-132", "text": "Exercice 13.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction insere ci-dessous qui prend en argument un tableau tab d\u2019en- tiers tri\u00e9s par ordre croissant et un entier a . Cette fonction cr\u00e9e et renvoie un nouveau tableau \u00e0 partir de celui fourni en param\u00e8tre en y ins\u00e9rant la valeur a de sorte que le tableau renvoy\u00e9 soit encore tri\u00e9 par ordre croissant. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes Python. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( tab , a ): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" tab_a = [ a ] + tab # nouveau tableau contenant a # suivi des \u00e9l\u00e9ments de tab i = 0 while i < ... and a > ... : tab_a [ i ] = ... tab_a [ i + 1 ] = a i = ... return tab_a Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ([ 1 , 2 , 4 , 5 ], 3 ) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ([ 1 , 2 , 7 , 12 , 14 , 25 ], 30 ) [ 1 , 2 , 7 , 12 , 14 , 25 , 30 ] >>> insere ([ 2 , 3 , 4 ], 1 ) [ 1 , 2 , 3 , 4 ] >>> insere ([], 1 ) [ 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def insere ( tab , a ): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" tab_a = [ a ] + tab # nouveau tableau contenant a # suivi des \u00e9l\u00e9ments de tab i = 0 while i < len ( tab_a ) - 1 and a > tab_a [ i + 1 ]: tab_a [ i ] = tab_a [ i + 1 ] tab_a [ i + 1 ] = a i = i + 1 return tab_a Markdown On consid\u00e8re la fonction `insere` ci-dessous qui prend en argument un tableau `tab` d\u2019en- tiers tri\u00e9s par ordre croissant et un entier `a` . Cette fonction cr\u00e9e et renvoie un nouveau tableau \u00e0 partir de celui fourni en param\u00e8tre en y ins\u00e9rant la valeur `a` de sorte que le tableau renvoy\u00e9 soit encore tri\u00e9 par ordre croissant. Les tableaux seront repr\u00e9sent\u00e9s sous la forme de listes Python. ```python linenums='1' def insere(tab, a): \"\"\" Ins\u00e8re l'\u00e9l\u00e9ment a (int) dans le tableau tab (list) tri\u00e9 par ordre croissant \u00e0 sa place et renvoie le nouveau tableau. \"\"\" tab_a = [ a ] + tab # nouveau tableau contenant a # suivi des \u00e9l\u00e9ments de tab i = 0 while i < ... and a > ...: tab_a[i] = ... tab_a[i+1] = a i = ... return tab_a Compl\u00e9ter la fonction insere ci-dessus. Exemples : \ud83d\udc0d Script Python >>> insere ([ 1 , 2 , 4 , 5 ], 3 ) [ 1 , 2 , 3 , 4 , 5 ] >>> insere ([ 1 , 2 , 7 , 12 , 14 , 25 ], 30 ) [ 1 , 2 , 7 , 12 , 14 , 25 , 30 ] >>> insere ([ 2 , 3 , 4 ], 1 ) [ 1 , 2 , 3 , 4 ] >>> insere ([], 1 ) [ 1 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 13.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-14", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 14"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-141", "text": "Exercice 14.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction min_et_max qui prend en param\u00e8tre un tableau de nombres tab non vide, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s min et max . Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. L\u2019utilisation des fonctions natives min , max et sorted , ainsi que la m\u00e9thode sort n\u2019est pas autoris\u00e9e. Exemples : \ud83d\udc0d Script Python >>> min_et_max ([ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ]) { 'min' : - 2 , 'max' : 9 } >>> min_et_max ([ 0 , 1 , 2 , 3 ]) { 'min' : 0 , 'max' : 3 } >>> min_et_max ([ 3 ]) { 'min' : 3 , 'max' : 3 } >>> min_et_max ([ 1 , 3 , 2 , 1 , 3 ]) { 'min' : 1 , 'max' : 3 } >>> min_et_max ([ - 1 , - 1 , - 1 , - 1 , - 1 ]) { 'min' : - 1 , 'max' : - 1 } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def min_et_max ( tab ): d = {} d [ 'min' ] = tab [ 0 ] d [ 'max' ] = tab [ 0 ] for val in tab : if val < d [ 'min' ]: d [ 'min' ] = val if val > d [ 'max' ]: d [ 'max' ] = val return d \ud83d\udccb Texte \u00c9crire une fonction `min_et_max` qui prend en param\u00e8tre un tableau de nombres `tab` non vide, et qui renvoie la plus petite et la plus grande valeur du tableau sous la forme d\u2019un dictionnaire \u00e0 deux cl\u00e9s `min` et `max`. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. L\u2019utilisation des fonctions natives `min`, `max` et `sorted`, ainsi que la m\u00e9thode `sort` n\u2019est pas autoris\u00e9e. Exemples : ```python >>> min_et_max([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) {'min': -2, 'max': 9} >>> min_et_max([0, 1, 2, 3]) {'min': 0, 'max': 3} >>> min_et_max([3]) {'min': 3, 'max': 3} >>> min_et_max([1, 3, 2, 1, 3]) {'min': 1, 'max': 3} >>> min_et_max([-1, -1, -1, -1, -1]) {'min': -1, 'max': -1} ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 14.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-142", "text": "Exercice 14.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019une classe Carte permettant de cr\u00e9er des objets mod\u00e9lisant des cartes \u00e0 jouer. Compl\u00e9ter la classe Paquet_de_cartes suivante en respectant les sp\u00e9cifications donn\u00e9es dans les cha\u00eenes de documentation. Ajouter une assertion dans la m\u00e9thode recuperer_carte afin de v\u00e9rifier que le param\u00e8tre pos est correct. On rappelle que l\u2019instruction \ud83d\udc0d Script Python assert condition , message permet de v\u00e9rifier que la condition est vraie. Si ce n\u2019est pas le cas, le programme s\u2019arr\u00eate et affiche le message d\u2019erreur fourni. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Carte : def __init__ ( self , c , v ): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def recuperer_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def recuperer_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" ... ... ... ... def recuperer_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" ... ... Exemple : \ud83d\udc0d Script Python >>> jeu = Paquet_de_cartes () >>> carte1 = jeu . recuperer_carte ( 20 ) >>> carte1 . recuperer_valeur () + \" de \" + carte1 . recuperer_couleur () \"8 de coeur\" >>> carte2 = jeu . recuperer_carte ( 0 ) >>> carte2 . recuperer_valeur () + \" de \" + carte2 . recuperer_couleur () \"As de pique\" >>> carte3 = jeu . recuperer_carte ( 52 ) AssertionError : param\u00e8tre pos invalide \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Carte : def __init__ ( self , c , v ): \"\"\"Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def recuperer_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def recuperer_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis c\u0153ur, carreau et tr\u00e8fle. \"\"\" self . contenu = [] for c in range ( 1 , 5 ): for v in range ( 1 , 14 ): self . contenu . append ( Carte ( c , v )) def recuperer_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" assert 0 <= pos <= 51 , 'param\u00e8tre pos invalide' return self . contenu [ pos ] Markdown On dispose d\u2019une classe `Carte` permettant de cr\u00e9er des objets mod\u00e9lisant des cartes \u00e0 jouer. Compl\u00e9ter la classe `Paquet_de_cartes` suivante en respectant les sp\u00e9cifications donn\u00e9es dans les cha\u00eenes de documentation. Ajouter une assertion dans la m\u00e9thode `recuperer_carte` afin de v\u00e9rifier que le param\u00e8tre `pos` est correct. On rappelle que l\u2019instruction ```python assert condition, message permet de v\u00e9rifier que la condition est vraie. Si ce n\u2019est pas le cas, le programme s\u2019arr\u00eate et affiche le message d\u2019erreur fourni. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Carte : def __init__ ( self , c , v ): \"\"\" Initialise les attributs couleur (entre 1 et 4), et valeur (entre 1 et 13). \"\"\" self . couleur = c self . valeur = v def recuperer_valeur ( self ): \"\"\" Renvoie la valeur de la carte : As, 2, ..., 10, Valet, Dame, Roi \"\"\" valeurs = [ 'As' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '10' , 'Valet' , 'Dame' , 'Roi' ] return valeurs [ self . valeur - 1 ] def recuperer_couleur ( self ): \"\"\" Renvoie la couleur de la carte (parmi pique, coeur, carreau, tr\u00e8fle). \"\"\" couleurs = [ 'pique' , 'coeur' , 'carreau' , 'tr\u00e8fle' ] return couleurs [ self . couleur - 1 ] class Paquet_de_cartes : def __init__ ( self ): \"\"\" Initialise l'attribut contenu avec une liste des 52 objets Carte possibles rang\u00e9s par valeurs croissantes en commen\u00e7ant par pique, puis coeur, carreau et tr\u00e9fle. \"\"\" ... ... ... ... def recuperer_carte ( self , pos ): \"\"\" Renvoie la carte qui se trouve \u00e0 la position pos (entier compris entre 0 et 51). \"\"\" ... ... Exemple : \ud83d\udc0d Script Python >>> jeu = Paquet_de_cartes () >>> carte1 = jeu . recuperer_carte ( 20 ) >>> carte1 . recuperer_valeur () + \" de \" + carte1 . recuperer_couleur () \"8 de coeur\" >>> carte2 = jeu . recuperer_carte ( 0 ) >>> carte2 . recuperer_valeur () + \" de \" + carte2 . recuperer_couleur () \"As de pique\" >>> carte3 = jeu . recuperer_carte ( 52 ) AssertionError : param\u00e8tre pos invalide ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 14.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-15", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 15"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-151", "text": "Exercice 15.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1.0 ]) 1.0 >>> moyenne ([ 1.0 , 2.0 , 4.0 ]) 2.3333333333333335 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for val in tab : somme += val return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau non vide de nombres flottants et qui renvoie la moyenne des valeurs du tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> moyenne([1.0]) 1.0 >>> moyenne([1.0, 2.0, 4.0]) 2.3333333333333335 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 15.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-152", "text": "Exercice 15.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction binaire . Cette fonction prend en param\u00e8tre un entier positif a en \u00e9criture d\u00e9cimale et renvoie son \u00e9criture binaire sous la forme d\u2019une chaine de caract\u00e8res. L\u2019algorithme utilise la m\u00e9thode des divisions euclidiennes successives comme l\u2019illustre l\u2019exemple ci-apr\u00e8s. Compl\u00e9ter le code de la fonction binaire . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def binaire ( a ): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0 : return ... bin_a = ... while ... : bin_a = ... + bin_a a = ... return bin_a Exemples : \ud83d\udc0d Script Python >>> binaire ( 83 ) '1010011' >>> binaire ( 127 ) '1111111' >>> binaire ( 0 ) '0' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def binaire ( a ): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0 : return '0' bin_a = '' while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown On consid\u00e8re la fonction `binaire` . Cette fonction prend en param\u00e8tre un entier positif `a` en \u00e9criture d\u00e9cimale et renvoie son \u00e9criture binaire sous la forme d\u2019une chaine de caract\u00e8res. L\u2019algorithme utilise la m\u00e9thode des divisions euclidiennes successives comme l\u2019illustre l\u2019exemple ci-apr\u00e8s. ![ image ]( data2023/30_divisions.png ){: .center} Compl\u00e9ter le code de la fonction `binaire` . ```python linenums='1' def binaire(a): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0: return ... bin_a = ... while ... : bin_a = ... + bin_a a = ... return bin_a Exemples : \ud83d\udc0d Script Python >>> binaire ( 83 ) '1010011' >>> binaire ( 127 ) '1111111' >>> binaire ( 0 ) '0' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 15.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-16", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 16"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-161", "text": "Exercice 16.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction ecriture_binaire_entier_positif qui prend en param\u00e8tre un entier positif n et renvoie une une chaine de caract\u00e8re correspondant \u00e0 l\u2018\u00e9criture binaire de n . On rappelle que : l\u2019\u00e9criture binaire de 25 est 11001 car \\(25 = 1 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) ; n % 2 vaut 0 ou 1 selon que n est pair ou impair ; n // 2 donne le quotient de la division euclidienne de n par 2. Il est interdit dans cet exercice d\u2019utiliser la fonction bin de Python. Exemples : \ud83d\udc0d Script Python >>> 5 % 2 1 >>> 5 // 2 2 >>> ecriture_binaire_entier_positif ( 0 ) '0' >>> ecriture_binaire_entier_positif ( 2 ) '10' >>> ecriture_binaire_entier_positif ( 105 ) '1101001' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def ecriture_binaire_entier_positif ( n ): if n == 0 : return '0' bin_n = '' while n != 0 : bin_n = str ( n % 2 ) + bin_n n = n // 2 return bin_n \ud83d\udccb Texte \u00c9crire une fonction `ecriture_binaire_entier_positif` qui prend en param\u00e8tre un entier positif `n` et renvoie une une chaine de caract\u00e8re correspondant \u00e0 l\u2018\u00e9criture binaire de `n`. On rappelle que : - l\u2019\u00e9criture binaire de 25 est 11001 car $25 = 1 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0$ ; - `n % 2` vaut 0 ou 1 selon que `n` est pair ou impair ; - `n // 2` donne le quotient de la division euclidienne de `n` par 2. Il est interdit dans cet exercice d\u2019utiliser la fonction `bin` de Python. Exemples : ```python >>> 5 % 2 1 >>> 5 // 2 2 >>> ecriture_binaire_entier_positif(0) '0' >>> ecriture_binaire_entier_positif(2) '10' >>> ecriture_binaire_entier_positif(105) '1101001' ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 16.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-162", "text": "Exercice 16.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction tri_bulles prend en param\u00e8tre une liste tab d\u2019entiers (type list ) et le modifie pour le trier par ordre croissant. Le tri \u00e0 bulles est un tri en place qui commence par placer le plus grand \u00e9l\u00e9ment en derni\u00e8re position en parcourant le tableau de gauche \u00e0 droite et en \u00e9changeant au passage les \u00e9l\u00e9ments voisins mal ordonn\u00e9s (si la valeur de l\u2019\u00e9l\u00e9ment d\u2019indice i a une valeur strictement sup\u00e9rieure \u00e0 celle de l\u2019indice i + 1 , ils sont \u00e9chang\u00e9s). Le tri place ensuite en avant-derni\u00e8re position le plus grand \u00e9l\u00e9ment du tableau priv\u00e9 de son dernier \u00e9l\u00e9ment en proc\u00e9dant encore \u00e0 des \u00e9changes d\u2019\u00e9l\u00e9ments voisins. Ce principe est r\u00e9p\u00e9t\u00e9 jusqu\u2019\u00e0 placer le minimum en premi\u00e8re position. Exemple : pour trier le tableau [7, 9, 4, 3] : premi\u00e8re \u00e9tape : 7 et 9 ne sont pas \u00e9chang\u00e9s, puis 9 et 4 sont \u00e9chang\u00e9s, puis 9 et 3 sont \u00e9chang\u00e9s, le tableau est alors [7, 4, 3, 9] deuxi\u00e8me \u00e9tape : 7 et 4 sont \u00e9chang\u00e9s, puis 7 et 3 sont \u00e9chang\u00e9s, le tableau est alors [4, 3, 7, 9] troisi\u00e8me \u00e9tape : 4 et 3 sont \u00e9chang\u00e9s, le tableau est alors [3, 4, 7, 9] Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def echange ( tab , i , j ): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = ... tab [ i ] = ... tab [ j ] = ... def tri_bulles ( tab ): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri \u00e0 bulles.''' n = len ( tab ) for i in range ( ... ): for j in range ( ... ): if ... > ... : echange ( tab , j , ... ) Exemples : \ud83d\udc0d Script Python >>> tab = [] >>> tri_bulles ( tab ) >>> tab [] >>> tab2 = [ 9 , 3 , 7 , 2 , 3 , 1 , 6 ] >>> tri_bulles ( tab2 ) >>> tab2 [ 1 , 2 , 3 , 3 , 6 , 7 , 9 ] >>> tab3 = [ 9 , 7 , 4 , 3 ] >>> tri_bulles ( tab3 ) >>> tab3 [ 3 , 4 , 7 , 9 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def echange ( tab , i , j ): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = tab [ i ] tab [ i ] = tab [ j ] tab [ j ] = temp def tri_bulles ( tab ): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri \u00e0 bulles.''' n = len ( tab ) for i in range ( n - 1 , - 1 , - 1 ): for j in range ( i ): if tab [ j ] > tab [ j + 1 ]: echange ( tab , j , j + 1 ) Markdown La fonction `tri_bulles` prend en param\u00e8tre une liste `tab` d\u2019entiers (type `list` ) et le modifie pour le trier par ordre croissant. Le tri \u00e0 bulles est un tri en place qui commence par placer le plus grand \u00e9l\u00e9ment en derni\u00e8re position en parcourant le tableau de gauche \u00e0 droite et en \u00e9changeant au passage les \u00e9l\u00e9ments voisins mal ordonn\u00e9s (si la valeur de l\u2019\u00e9l\u00e9ment d\u2019indice `i` a une valeur strictement sup\u00e9rieure \u00e0 celle de l\u2019indice `i + 1` , ils sont \u00e9chang\u00e9s). Le tri place ensuite en avant-derni\u00e8re position le plus grand \u00e9l\u00e9ment du tableau priv\u00e9 de son dernier \u00e9l\u00e9ment en proc\u00e9dant encore \u00e0 des \u00e9changes d\u2019\u00e9l\u00e9ments voisins. Ce principe est r\u00e9p\u00e9t\u00e9 jusqu\u2019\u00e0 placer le minimum en premi\u00e8re position. Exemple : pour trier le tableau `[7, 9, 4, 3]` : - premi\u00e8re \u00e9tape : 7 et 9 ne sont pas \u00e9chang\u00e9s, puis 9 et 4 sont \u00e9chang\u00e9s, puis 9 et 3 sont \u00e9chang\u00e9s, le tableau est alors `[7, 4, 3, 9]` - deuxi\u00e8me \u00e9tape : 7 et 4 sont \u00e9chang\u00e9s, puis 7 et 3 sont \u00e9chang\u00e9s, le tableau est alors `[4, 3, 7, 9]` - troisi\u00e8me \u00e9tape : 4 et 3 sont \u00e9chang\u00e9s, le tableau est alors `[3, 4, 7, 9]` Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles. ```python linenums='1' def echange(tab, i, j): '''Echange les \u00e9l\u00e9ments d'indice i et j dans le tableau tab.''' temp = ... tab[i] = ... tab[j] = ... def tri_bulles(tab): '''Trie le tableau tab dans l'ordre croissant par la m\u00e9thode du tri \u00e0 bulles.''' n = len(tab) for i in range(...): for j in range(...): if ... > ...: echange(tab, j, ...) Exemples : \ud83d\udc0d Script Python >>> tab = [] >>> tri_bulles ( tab ) >>> tab [] >>> tab2 = [ 9 , 3 , 7 , 2 , 3 , 1 , 6 ] >>> tri_bulles ( tab2 ) >>> tab2 [ 1 , 2 , 3 , 3 , 6 , 7 , 9 ] >>> tab3 = [ 9 , 7 , 4 , 3 ] >>> tri_bulles ( tab3 ) >>> tab3 [ 3 , 4 , 7 , 9 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 16.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-17", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 17"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-171", "text": "Exercice 17.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction Python appel\u00e9e nb_repetitions qui prend en param\u00e8tres un \u00e9l\u00e9ment elt et un tableau tab (type list ) et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans le tableau. Exemples : \ud83d\udc0d Script Python >>> nb_repetitions ( 5 , [ 2 , 5 , 3 , 5 , 6 , 9 , 5 ]) 3 >>> nb_repetitions ( 'A' , [ 'B' , 'A' , 'B' , 'A' , 'R' ]) 2 >>> nb_repetitions ( 12 , [ 1 , 3 , 7 , 21 , 36 , 44 ]) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def nb_repetitions ( elt , tab ): nb = 0 for element in tab : if element == elt : nb += 1 return nb \ud83d\udccb Texte \u00c9crire une fonction Python appel\u00e9e `nb_repetitions` qui prend en param\u00e8tres un \u00e9l\u00e9ment `elt` et un tableau `tab` (type `list`) et renvoie le nombre de fois o\u00f9 l\u2019\u00e9l\u00e9ment appara\u00eet dans le tableau. Exemples : ```python >>> nb_repetitions(5, [2, 5, 3, 5, 6, 9, 5]) 3 >>> nb_repetitions('A', ['B', 'A', 'B', 'A', 'R']) 2 >>> nb_repetitions(12, [1, 3, 7, 21, 36, 44]) 0 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 17.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-172", "text": "Exercice 17.2 \u00c9nonc\u00e9 Correction Sources Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : Compl\u00e9ter la fonction binaire \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def binaire ( a ): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0 : return '0' bin_a = ... while ... : bin_a = ... + bin_a a = ... return bin_a . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def binaire ( a ): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0 : return '0' bin_a = '' while a != 0 : bin_a = str ( a % 2 ) + bin_a a = a // 2 return bin_a Markdown Pour rappel, la conversion d\u2019un nombre entier positif en binaire peut s\u2019effectuer \u00e0 l\u2019aide des divisions successives comme illustr\u00e9 ici : ![ image ]( data2023/31_divisions.png ){: .center} Voici une fonction Python bas\u00e9e sur la m\u00e9thode des divisions successives permettant de convertir un nombre entier positif en binaire : Compl\u00e9ter la fonction ```binaire``` ```python linenums='1' def binaire(a): '''convertit un nombre entier a en sa representation binaire sous forme de chaine de caract\u00e8res.''' if a == 0: return '0' bin_a = ... while ...: bin_a = ... + bin_a a = ... return bin_a . Exemples : \ud83d\udc0d Script Python >>> binaire ( 0 ) '0' >>> binaire ( 77 ) '1001101' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 17.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-18", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 18"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-181", "text": "Exercice 18.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers relatifs n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations arithm\u00e9tiques autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def multiplication ( n1 , n2 ): if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers relatifs `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations arithm\u00e9tiques autoris\u00e9es sont l\u2019addition et la soustraction. Exemples : ```python >>> multiplication(3,5) 15 >>> multiplication(-4,-8) 32 >>> multiplication(-2,6) -12 >>> multiplication(-2,0) 0 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 18.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-182", "text": "Exercice 18.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit tab un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et n un entier. La fonction chercher ci-dessous doit renvoyer un indice o\u00f9 la valeur n appara\u00eet dans tab si cette valeur y figure et None sinon. Les param\u00e8tres de la fonction sont : tab , le tableau dans lequel s'effectue la recherche ; x , l'entier \u00e0 chercher dans le tableau ; i , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; j , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. L\u2019algorithme demand\u00e9 est une recherche dichotomique r\u00e9cursive. Recopier et compl\u00e9ter le code de la fonction chercher suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( tab , x , i , j ): '''Renvoie l'indice de x dans tab, si x est dans tab, None sinon. On suppose que tab est tri\u00e9 dans l'ordre croissant.''' if i > j : return None m = ( i + j ) // ... if ... < x : return chercher ( tab , x , ... , ... ) elif tab [ m ] > x : return chercher ( tab , x , ... , ... ) else : return ... Exemples : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def chercher ( tab , x , i , j ): '''Renvoie l'indice de x dans tab, si x est dans tab, None sinon. On suppose que tab est tri\u00e9 dans l'ordre croissant.''' if i > j : return None m = ( i + j ) // 2 if tab [ m ] < x : return chercher ( tab , x , m + 1 , j ) elif tab [ m ] > x : return chercher ( tab , x , i , m - 1 ) else : return m Markdown Soit `tab` un tableau non vide d'entiers tri\u00e9s dans l'ordre croissant et `n` un entier. La fonction `chercher` ci-dessous doit renvoyer un indice o\u00f9 la valeur `n` appara\u00eet dans `tab` si cette valeur y figure et `None` sinon. Les param\u00e8tres de la fonction sont : - `tab` , le tableau dans lequel s'effectue la recherche ; - `x` , l'entier \u00e0 chercher dans le tableau ; - `i` , l'indice de d\u00e9but de la partie du tableau o\u00f9 s'effectue la recherche ; - `j` , l'indice de fin de la partie du tableau o\u00f9 s'effectue la recherche. L\u2019algorithme demand\u00e9 est une recherche dichotomique r\u00e9cursive. Recopier et compl\u00e9ter le code de la fonction `chercher` suivante : ```python linenums='1' def chercher(tab, x, i, j): '''Renvoie l'indice de x dans tab, si x est dans tab, None sinon. On suppose que tab est tri\u00e9 dans l'ordre croissant.''' if i > j: return None m = (i + j) // ... if ... < x: return chercher(tab, x, ... , ...) elif tab[m] > x: return chercher(tab, x, ... , ...) else: return ... Exemples : \ud83d\udc0d Script Python >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 10 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 7 , 0 , 5 ) >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 9 , 0 , 5 ) 4 >>> chercher ([ 1 , 5 , 6 , 6 , 9 , 12 ], 6 , 0 , 5 ) 2 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 18.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-19", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 19"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-191", "text": "Exercice 19.1 \u00c9nonc\u00e9 Correction Source Markdown On rappelle que : le nombre \\(a^n\\) est le nombre \\(a \\times a \\times a \\times \\dots \\times a\\) , o\u00f9 le facteur \\(a\\) appara\u00eet \\(n\\) fois, en langage Python, l\u2019instruction t[-1] permet d\u2019acc\u00e9der au dernier \u00e9l\u00e9ment du tableau t . Dans cet exercice, l\u2019op\u00e9rateur ** et la fonction pow ne sont pas autoris\u00e9s. Programmer en langage Python une fonction liste_puissances qui prend en arguments un nombre entier a , un entier strictement positif n et qui renvoie la liste de ses puissances \\(\\rm{[a^1, a^2, ..., a^n]}\\) . Programmer \u00e9galement une fonction liste_puisssances_borne qui prend en arguments un nombre entier a sup\u00e9rieur ou \u00e9gal \u00e0 2 et un entier borne , et qui renvoie la liste de ses puissances, \u00e0 l\u2019exclusion de \\(\\rm{a^0}\\) , strictement inf\u00e9rieures \u00e0 borne . Exemples : \ud83d\udc0d Script Python >>> liste_puissances ( 3 , 5 ) [ 3 , 9 , 27 , 81 , 243 ] >>> liste_puissances ( - 2 , 4 ) [ - 2 , 4 , - 8 , 16 ] >>> liste_puissances_borne ( 2 , 16 ) [ 2 , 4 , 8 ] >>> liste_puissances_borne ( 2 , 17 ) [ 2 , 4 , 8 , 16 ] >>> liste_puissances_borne ( 5 , 5 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def liste_puissances ( a , n ): puissances = [ a ] for i in range ( n - 1 ): puissances . append ( puissances [ - 1 ] * a ) return puissances def liste_puissances_borne ( a , borne ): lst = [] val = a while val < borne : lst . append ( val ) val = val * a return lst \ud83d\udccb Texte On rappelle que : - le nombre $a^n$ est le nombre $a \\times a \\times a \\times \\dots \\times a$, o\u00f9 le facteur $a$ appara\u00eet $n$ fois, - en langage Python, l\u2019instruction `t[-1]` permet d\u2019acc\u00e9der au dernier \u00e9l\u00e9ment du tableau `t`. Dans cet exercice, l\u2019op\u00e9rateur ```**``` et la fonction `pow` ne sont pas autoris\u00e9s. Programmer en langage Python une fonction `liste_puissances` qui prend en arguments un nombre entier `a`, un entier strictement positif `n` et qui renvoie la liste de ses puissances $\\rm{[a^1, a^2, ..., a^n]}$. Programmer \u00e9galement une fonction `liste_puisssances_borne` qui prend en arguments un nombre entier `a` sup\u00e9rieur ou \u00e9gal \u00e0 2 et un entier `borne`, et qui renvoie la liste de ses puissances, \u00e0 l\u2019exclusion de $\\rm{a^0}$, strictement inf\u00e9rieures \u00e0 `borne`. Exemples : ```python >>> liste_puissances(3, 5) [3, 9, 27, 81, 243] >>> liste_puissances(-2, 4) [-2, 4, -8, 16] >>> liste_puissances_borne(2, 16) [2, 4, 8] >>> liste_puissances_borne(2, 17) [2, 4, 8, 16] >>> liste_puissances_borne(5, 5) [] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 19.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-192", "text": "Exercice 19.2 \u00c9nonc\u00e9 Correction Sources Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : A B C D E F G H I J K L M 1 2 3 4 5 6 7 8 9 10 11 12 13 N O P Q R S T U V W X Y Z 14 15 16 17 18 19 20 21 22 23 24 25 26 Cette table de correspondance est stock\u00e9e dans un dictionnaire dico o\u00f9 les cl\u00e9s sont les lettres de l\u2019alphabet et les valeurs les codes correspondants. \ud83d\udc0d Script Python dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction codes_parfait situ\u00e9e \u00e0 la page suivante et qui prend en param\u00e8tre un mot en majuscule et renvoie un triplet constitu\u00e9 du code additionn\u00e9, du code concat\u00e9n\u00e9 et d\u2019un bool\u00e9en indiquant si le mot est parfait ou non. On rappelle que pour tester si un entier a divise un entier b , on utilise l\u2019op\u00e9rateur modulo b % a qui renvoie le reste de la division euclidienne de b par a . Si b % a vaut 0 , alors a divise b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def codes_parfait ( mot ): \"\"\"Renvoie un triplet (code_additionne, code_concatene, mot_est_parfait) o\u00f9 : - code_additionne est la somme des codes des lettres du mot ; - code_concatene est le code des lettres du mot concat\u00e9n\u00e9es ; - mot_est_parfait est un bool\u00e9en indiquant si le mot est parfait.\"\"\" code_concatene = \"\" code_additionne = ... for c in mot : code_concatene = code_concatene + ... code_additionne = code_additionne + ... code_concatene = int ( code_concatene ) mot_est_parfait = ... return code_additionne , code_concatene , mot_est_parfait Exemples : \ud83d\udc0d Script Python >>> codes_parfait ( \"PAUL\" ) ( 50 , 1612112 , False ) >>> codes_parfait ( \"ALAIN\" ) ( 37 , 1121914 , True ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 dico = { \"A\" : 1 , \"B\" : 2 , \"C\" : 3 , \"D\" : 4 , \"E\" : 5 , \"F\" : 6 , \"G\" : 7 , \"H\" : 8 , \"I\" : 9 , \"J\" : 10 , \"K\" : 11 , \"L\" : 12 , \"M\" : 13 , \"N\" : 14 , \"O\" : 15 , \"P\" : 16 , \"Q\" : 17 , \"R\" : 18 , \"S\" : 19 , \"T\" : 20 , \"U\" : 21 , \"V\" : 22 , \"W\" : 23 , \"X\" : 24 , \"Y\" : 25 , \"Z\" : 26 } def codes_parfait ( mot ): # mot est une cha\u00eene de caract\u00e8res (en lettres majuscules) code_concatene = \"\" code_additionne = 0 for c in mot : code_concatene = code_concatene + str ( dico [ c ]) code_additionne = code_additionne + dico [ c ] code_concatene = int ( code_concatene ) mot_est_parfait = code_concatene % code_additionne == 0 return code_additionne , code_concatene , mot_est_parfait Markdown On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : | A | B | C | D | E | F | G | H | I | J | K | L | M | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | Cette table de correspondance est stock\u00e9e dans un dictionnaire `dico` o\u00f9 les cl\u00e9s sont les lettres de l\u2019alphabet et les valeurs les codes correspondants. ```python dico = {\"A\": 1, \"B\": 2, \"C\": 3, \"D\": 4, \"E\": 5, \"F\": 6, \"G\": 7, \"H\": 8, \"I\": 9, \"J\": 10, \"K\": 11, \"L\": 12, \"M\": 13, \"N\": 14, \"O\": 15, \"P\": 16, \"Q\": 17, \"R\": 18, \"S\": 19, \"T\": 20, \"U\": 21, \"V\": 22, \"W\": 23, \"X\": 24, \"Y\": 25, \"Z\": 26} Pour un mot donn\u00e9, on d\u00e9termine d\u2019une part son code alphab\u00e9tique concat\u00e9n\u00e9 , obtenu par la juxtaposition des codes de chacun de ses caract\u00e8res, et d\u2019autre part, son code additionn\u00e9 , qui est la somme des codes de chacun de ses caract\u00e8res. Par ailleurs, on dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples : Pour le mot \"PAUL\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1612112' , soit l\u2019entier 1 612 112. Son code additionn\u00e9 est l\u2019entier 50 car 16 + 1 + 21 + 12 = 50. 50 ne divise pas l\u2019entier 1 612 112 ; par cons\u00e9quent, le mot \"PAUL\" n\u2019est pas parfait. Pour le mot \"ALAIN\" , le code concat\u00e9n\u00e9 est la cha\u00eene '1121914' , soit l\u2019entier 1 121 914. Le code additionn\u00e9 est l\u2019entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 37 divise l\u2019entier 1 121 914 ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Compl\u00e9ter la fonction codes_parfait situ\u00e9e \u00e0 la page suivante et qui prend en param\u00e8tre un mot en majuscule et renvoie un triplet constitu\u00e9 du code additionn\u00e9, du code concat\u00e9n\u00e9 et d\u2019un bool\u00e9en indiquant si le mot est parfait ou non. On rappelle que pour tester si un entier a divise un entier b , on utilise l\u2019op\u00e9rateur modulo b % a qui renvoie le reste de la division euclidienne de b par a . Si b % a vaut 0 , alors a divise b . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def codes_parfait ( mot ): \"\"\"Renvoie un triplet (code_additionne, code_concatene, mot_est_parfait) o\u00f9 : - code_additionne est la somme des codes des lettres du mot ; - code_concatene est le code des lettres du mot concat\u00e9n\u00e9es ; - mot_est_parfait est un bool\u00e9en indiquant si le mot est parfait.\"\"\" code_concatene = \"\" code_additionne = ... for c in mot : code_concatene = code_concatene + ... code_additionne = code_additionne + ... code_concatene = int ( code_concatene ) mot_est_parfait = ... return code_additionne , code_concatene , mot_est_parfait Exemples : \ud83d\udc0d Script Python >>> codes_parfait ( \"PAUL\" ) ( 50 , 1612112 , False ) >>> codes_parfait ( \"ALAIN\" ) ( 37 , 1121914 , True ) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 19.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-20", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 20"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-201", "text": "Exercice 20.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice les tableaux sont repr\u00e9sent\u00e9s par des listes Python (type list ). \u00c9crire en python deux fonctions : lancer de param\u00e8tre n , un entier positif, qui renvoie un tableau de n entiers obtenus al\u00e9atoirement entre 1 et 6 (1 et 6 inclus) ; paire_6 de param\u00e8tre tab , un tableau de n entiers compris entre 1 et 6 et qui renvoie un bool\u00e9en \u00e9gal \u00e0 True si le nombre de 6 est sup\u00e9rieur ou \u00e9gal \u00e0 2, False sinon. On pourra utiliser la fonction randint(a,b) du module random pour laquelle la documentation officielle est la suivante : random.randint(a, b) Renvoie un entier al\u00e9atoire N tel que a <=N <= b. Exemples : \ud83d\udc0d Script Python >>> lancer1 = lancer ( 5 ) [ 5 , 6 , 6 , 2 , 2 ] >>> paire_6 ( lancer1 ) True >>> lancer2 = lancer ( 5 ) [ 6 , 5 , 1 , 6 , 6 ] >>> paire_6 ( lancer2 ) True >>> lancer3 = lancer ( 3 ) [ 2 , 2 , 6 ] >>> paire_6 ( lancer3 ) False >>> lancer4 = lancer ( 0 ) [] >>> paire_6 ( lancer4 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from random import randint def lancer ( n ): return [ randint ( 1 , 6 ) for _ in range ( n )] def paire_6 ( tab ): nb = 0 for elt in tab : if elt == 6 : nb += 1 if nb >= 2 : return True else : return False \ud83d\udccb Texte Dans cet exercice les tableaux sont repr\u00e9sent\u00e9s par des listes Python (type `list`). \u00c9crire en python deux fonctions : - `lancer` de param\u00e8tre `n`, un entier positif, qui renvoie un tableau de `n` entiers obtenus al\u00e9atoirement entre 1 et 6 (1 et 6 inclus) ; - `paire_6` de param\u00e8tre `tab`, un tableau de n entiers compris entre 1 et 6 et qui renvoie un bool\u00e9en \u00e9gal \u00e0 `True` si le nombre de 6 est sup\u00e9rieur ou \u00e9gal \u00e0 2, `False` sinon. On pourra utiliser la fonction `randint(a,b)` du module `random` pour laquelle la documentation officielle est la suivante : `random.randint(a, b)` ` Renvoie un entier al\u00e9atoire N tel que a <=N <= b.` Exemples : ```python >>> lancer1 = lancer(5) [5, 6, 6, 2, 2] >>> paire_6(lancer1) True >>> lancer2 = lancer(5) [6, 5, 1, 6, 6] >>> paire_6(lancer2) True >>> lancer3 = lancer(3) [2, 2, 6] >>> paire_6(lancer3) False >>> lancer4 = lancer(0) [] >>> paire_6(lancer4) False ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 20.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-202", "text": "Exercice 20.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Le n\u00e9gatif d\u2019une image est l\u2019image constitu\u00e9e des pixels x_n tels que x_n + x_i = 255 o\u00f9 x_i est le pixel correspondant de l\u2019image initiale. Compl\u00e9ter le programme suivant : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def nombre_lignes ( image ): '''renvoie le nombre de lignes de l'image''' return ... def nombre_colonnes ( image ): '''renvoie la largeur de l'image''' return ... def negatif ( image ): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions # que le parametre image nouvelle_image = [[ 0 for k in range ( nombre_colonnes ( image ))] for i in range ( nombre_lignes ( image ))] for i in range ( nombre_lignes ( image )): for j in range ( ... ): nouvelle_image [ i ][ j ] = ... return nouvelle_image def binaire ( image , seuil ): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' nouvelle_image = [[ 0 ] * nombre_colonnes ( image ) for i in range ( nombre_lignes ( image ))] for i in range ( nombre_lignes ( image )): for j in range ( ... ): if image [ i ][ j ] < ... : nouvelle_image [ i ][ j ] = ... else : nouvelle_image [ i ][ j ] = ... return nouvelle_image Exemples : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 237 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nombre_lignes ( img ) 4 >>> nombre_colonnes ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , 18 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( img , 120 ) [[ 0 , 0 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 1 , 0 ],[ 1 , 1 , 1 , 0 , 0 ],[ 1 , 0 , 0 , 1 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def nombre_lignes ( image ): '''renvoie le nombre de lignes de l'image''' return len ( image ) def nombre_colonnes ( image ): '''renvoie la largeur de l'image''' return len ( image [ 0 ]) def negatif ( image ): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions # que le parametre image nouvelle_image = [[ 0 for k in range ( nombre_colonnes ( image ))] for i in range ( nombre_lignes ( image ))] for i in range ( nombre_lignes ( image )): for j in range ( nombre_colonnes ( image )): nouvelle_image [ i ][ j ] = 255 - image [ i ][ j ] return nouvelle_image def binaire ( image , seuil ): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' nouvelle_image = [[ 0 ] * nombre_colonnes ( image ) for i in range ( nombre_lignes ( image ))] for i in range ( nombre_lignes ( image )): for j in range ( nombre_colonnes ( image )): if image [ i ][ j ] < seuil : nouvelle_image [ i ][ j ] = 0 else : nouvelle_image [ i ][ j ] = 1 return nouvelle_image Markdown On consid\u00e8re une image en 256 niveaux de gris que l\u2019on repr\u00e9sente par une grille de nombres, c\u2019est-\u00e0-dire une liste compos\u00e9e de sous-listes toutes de longueurs identiques. La largeur de l\u2019image est donc la longueur d\u2019une sous-liste et la hauteur de l\u2019image est le nombre de sous-listes. Chaque sous-liste repr\u00e9sente une ligne de l\u2019image et chaque \u00e9l\u00e9ment des sous-listes est un entier compris entre 0 et 255, repr\u00e9sentant l\u2019intensit\u00e9 lumineuse du pixel. Le n\u00e9gatif d\u2019une image est l\u2019image constitu\u00e9e des pixels `x_n` tels que `x_n + x_i = 255` o\u00f9 `x_i` est le pixel correspondant de l\u2019image initiale. Compl\u00e9ter le programme suivant : ```python linenums='1' def nombre_lignes(image): '''renvoie le nombre de lignes de l'image''' return ... def nombre_colonnes(image): '''renvoie la largeur de l'image''' return ... def negatif(image): '''renvoie le negatif de l'image sous la forme d'une liste de listes''' # on cree une image de 0 aux memes dimensions # que le parametre image nouvelle_image = [[0 for k in range(nombre_colonnes(image))] for i in range(nombre_lignes(image))] for i in range(nombre_lignes(image)): for j in range(...): nouvelle_image[i][j] = ... return nouvelle_image def binaire(image, seuil): '''renvoie une image binarisee de l'image sous la forme d'une liste de listes contenant des 0 si la valeur du pixel est strictement inferieure au seuil et 1 sinon''' nouvelle_image = [[0] * nombre_colonnes(image) for i in range(nombre_lignes(image))] for i in range(nombre_lignes(image)): for j in range(...): if image[i][j] < ... : nouvelle_image[i][j] = ... else: nouvelle_image[i][j] = ... return nouvelle_image Exemples : \ud83d\udc0d Script Python >>> img = [[ 20 , 34 , 254 , 145 , 6 ], [ 23 , 124 , 237 , 225 , 69 ], [ 197 , 174 , 207 , 25 , 87 ], [ 255 , 0 , 24 , 197 , 189 ]] >>> nombre_lignes ( img ) 4 >>> nombre_colonnes ( img ) 5 >>> negatif ( img ) [[ 235 , 221 , 1 , 110 , 249 ], [ 232 , 131 , 18 , 30 , 186 ], [ 58 , 81 , 48 , 230 , 168 ], [ 0 , 255 , 231 , 58 , 66 ]] >>> binaire ( img , 120 ) [[ 0 , 0 , 1 , 1 , 0 ],[ 0 , 1 , 1 , 1 , 0 ],[ 1 , 1 , 1 , 0 , 0 ],[ 1 , 0 , 0 , 1 , 1 ]] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 20.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-21", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 21"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-211", "text": "Exercice 21.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_motif qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res motif non vide et une cha\u00eene de caract\u00e8res texte et qui renvoie la liste des positions de motif dans texte . Si motif n\u2019appara\u00eet pas, la fonction renvoie une liste vide. Exemples: \ud83d\udc0d Script Python >>> recherche_motif ( \"ab\" , \"\" ) [] >>> recherche_motif ( \"ab\" , \"cdcdcdcd\" ) [] >>> recherche_motif ( \"ab\" , \"abracadabra\" ) [ 0 , 7 ] >>> recherche_motif ( \"ab\" , \"abracadabraab\" ) [ 0 , 7 , 11 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def recherche_motif ( motif , texte ): sol = [] i = 0 while i <= len ( texte ) - len ( motif ): j = 0 while j < len ( motif ) and motif [ j ] == texte [ j + i ]: j += 1 if j == len ( motif ): sol . append ( i ) i += 1 return sol \ud83d\udccb Texte \u00c9crire une fonction `recherche_motif` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res `motif` non vide et une cha\u00eene de caract\u00e8res `texte` et qui renvoie la liste des positions de `motif` dans `texte`. Si `motif` n\u2019appara\u00eet pas, la fonction renvoie une liste vide. Exemples: ```python >>> recherche_motif(\"ab\", \"\") [] >>> recherche_motif(\"ab\", \"cdcdcdcd\") [] >>> recherche_motif(\"ab\", \"abracadabra\") [0, 7] >>> recherche_motif(\"ab\", \"abracadabraab\") [0, 7, 11] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 21.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-212", "text": "Exercice 21.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on consid\u00e8re un graphe non orient\u00e9 repr\u00e9sent\u00e9 sous forme de listes d\u2019adjacence. On suppose que les sommets sont num\u00e9rot\u00e9s de 0 \u00e0 n-1. Ainsi, le graphe suivant: sera repr\u00e9sent\u00e9 par la liste d\u2019adjacence suivante: adj = [[1, 2], [0, 3], [0], [1], [5], [4]] On souhaite d\u00e9terminer les sommets accessibles depuis un sommet donn\u00e9 dans le graphe. Pour cela, on va proc\u00e9der \u00e0 un parcours en profondeur du graphe. Compl\u00e9ter la fonction suivante. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def parcours ( adj , x , acc ): '''R\u00e9alise un parcours en profondeur r\u00e9cursif du graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x en accumulant les sommets rencontr\u00e9s dans acc''' if x ... : acc . append ( x ) for y in ... : parcours ( adj , ... ) def accessibles ( adj , x ): '''Renvoie la liste des sommets accessibles dans le graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x.''' acc = [] parcours ( adj , ... ) return acc Exemples : \ud83d\udc0d Script Python >>> accessibles ([[ 1 , 2 ], [ 0 ], [ 0 , 3 ], [ 1 ], [ 5 ], [ 4 ]], 0 ) [ 0 , 1 , 2 , 3 ] >>> accessibles ([[ 1 , 2 ], [ 0 ], [ 0 , 3 ], [ 1 ], [ 5 ], [ 4 ]], 4 ) [ 4 , 5 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 adj = [[ 1 , 2 ], [ 0 , 3 ], [ 0 ], [ 1 ], [ 5 ], [ 4 ]] def parcours ( adj , x , acc ): '''R\u00e9alise un parcours en profondeur r\u00e9cursif du graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x en accumulant les sommets rencontr\u00e9s dans acc''' if x not in acc : acc . append ( x ) for y in adj [ x ]: parcours ( adj , y , acc ) def accessibles ( adj , x ): '''Renvoie la liste des sommets accessibles dans le graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x.''' acc = [] parcours ( adj , x , acc ) return acc Markdown Dans cet exercice, on consid\u00e8re un graphe non orient\u00e9 repr\u00e9sent\u00e9 sous forme de listes d\u2019adjacence. On suppose que les sommets sont num\u00e9rot\u00e9s de 0 \u00e0 n-1. Ainsi, le graphe suivant: ![ image ]( data2024/graph1.png ){: .center} sera repr\u00e9sent\u00e9 par la liste d\u2019adjacence suivante: `adj = [[1, 2], [0, 3], [0], [1], [5], [4]]` On souhaite d\u00e9terminer les sommets accessibles depuis un sommet donn\u00e9 dans le graphe. Pour cela, on va proc\u00e9der \u00e0 un parcours en profondeur du graphe. Compl\u00e9ter la fonction suivante. ```python linenums='1' def parcours(adj, x, acc): '''R\u00e9alise un parcours en profondeur r\u00e9cursif du graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x en accumulant les sommets rencontr\u00e9s dans acc''' if x ...: acc.append(x) for y in ...: parcours(adj, ...) def accessibles(adj, x): '''Renvoie la liste des sommets accessibles dans le graphe donn\u00e9 par les listes d'adjacence adj depuis le sommet x.''' acc = [] parcours(adj, ...) return acc Exemples : \ud83d\udc0d Script Python >>> accessibles ([[ 1 , 2 ], [ 0 ], [ 0 , 3 ], [ 1 ], [ 5 ], [ 4 ]], 0 ) [ 0 , 1 , 2 , 3 ] >>> accessibles ([[ 1 , 2 ], [ 0 ], [ 0 , 3 ], [ 1 ], [ 5 ], [ 4 ]], 4 ) [ 4 , 5 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 21.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-22", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 22"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-221", "text": "Exercice 22.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_indices_classement qui prend en param\u00e8tres un entier elt et un tableau d\u2019entiers tab , et qui renvoie trois listes : la premi\u00e8re liste contient les indices des valeurs du tableau tab strictement inf\u00e9rieures \u00e0 elt ; la deuxi\u00e8me liste contient les indices des valeurs du tableau tab \u00e9gales \u00e0 elt ; la troisi\u00e8me liste contient les indices des valeurs du tableau tab strictement sup\u00e9rieures \u00e0 elt . Exemples : \ud83d\udc0d Script Python >>> recherche_indices_classement ( 3 , [ 1 , 3 , 4 , 2 , 4 , 6 , 3 , 0 ]) ([ 0 , 3 , 7 ], [ 1 , 6 ], [ 2 , 4 , 5 ]) >>> recherche_indices_classement ( 3 , [ 1 , 4 , 2 , 4 , 6 , 0 ]) ([ 0 , 2 , 5 ], [], [ 1 , 3 , 4 ]) >>> recherche_indices_classement ( 3 , [ 1 , 1 , 1 , 1 ]) ([ 0 , 1 , 2 , 3 ], [], []) >>> recherche_indices_classement ( 3 , []) ([], [], []) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche_indices_classement ( elt , tab ): ind_inf = [] ind_egal = [] ind_sup = [] for i in range ( len ( tab )): if tab [ i ] < elt : ind_inf . append ( i ) elif tab [ i ] > elt : ind_sup . append ( i ) else : ind_egal . append ( i ) return ( ind_inf , ind_egal , ind_sup ) \ud83d\udccb Texte \u00c9crire une fonction `recherche_indices_classement` qui prend en param\u00e8tres un entier `elt` et un tableau d\u2019entiers `tab`, et qui renvoie trois listes : - la premi\u00e8re liste contient les indices des valeurs du tableau `tab` strictement inf\u00e9rieures \u00e0 `elt` ; - la deuxi\u00e8me liste contient les indices des valeurs du tableau `tab` \u00e9gales \u00e0 `elt` ; - la troisi\u00e8me liste contient les indices des valeurs du tableau `tab` strictement sup\u00e9rieures \u00e0 `elt`. Exemples : ```python >>> recherche_indices_classement(3, [1, 3, 4, 2, 4, 6, 3, 0]) ([0, 3, 7], [1, 6], [2, 4, 5]) >>> recherche_indices_classement(3, [1, 4, 2, 4, 6, 0]) ([0, 2, 5], [], [1, 3, 4]) >>>recherche_indices_classement(3, [1, 1, 1, 1]) ([0, 1, 2, 3], [], []) >>> recherche_indices_classement(3, []) ([], [], []) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 22.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-222", "text": "Exercice 22.2 \u00c9nonc\u00e9 Correction Sources Markdown Une professeure de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : les clefs sont les noms des \u00e9l\u00e8ves ; les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves sous forme de cha\u00eene de caract\u00e8res et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients dans une liste. Avec : \ud83d\udc0d Script Python resultats = { 'Dupont' : { 'DS1' : [ 15.5 , 4 ], 'DM1' : [ 14.5 , 1 ], 'DS2' : [ 13 , 4 ], 'PROJET1' : [ 16 , 3 ], 'DS3' : [ 14 , 4 ] }, 'Durand' : { 'DS1' : [ 6 , 4 ], 'DS2' : [ 8 , 4 ], 'PROJET1' : [ 9 , 3 ], 'IE1' : [ 7 , 2 ], 'DS3' : [ 12 , 4 ] } } L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ses \u00e9l\u00e8ves et renvoie sa moyenne arrondie au dixi\u00e8me. Si l\u2019\u00e9l\u00e8ve n\u2019a pas de notes, on consid\u00e8re que sa moyenne est nulle. Si le nom donn\u00e9 n\u2019est pas dans les r\u00e9sultats, la fonction renvoie None . Compl\u00e9ter le code de la professeure ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def moyenne ( nom , resultats ): '''Renvoie la moyenne de l'\u00e9l\u00e8ve nom, selon le dictionnaire resultats. Si nom n'est pas dans le dictionnaire, la fonction renvoie None.''' if nom in ... : notes = resultats [ nom ] if ... : # pas de notes return 0 total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient ... = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return None Exemples : \ud83d\udc0d Script Python >>> moyenne ( \"Dupont\" , resultats ) 14.5 >>> moyenne ( \"Durand\" , resultats ) 8.5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def moyenne ( nom , resultats ): '''Renvoie la moyenne de l'\u00e9l\u00e8ve nom, selon le dictionnaire resultats. Si nom n'est pas dans le dictionnaire, la fonction renvoie None.''' if nom in resultats : notes = resultats [ nom ] if notes == {}: # pas de notes return 0 total_points = 0 total_coefficients = 0 for valeurs in notes . values (): note , coefficient = valeurs total_points = total_points + note * coefficient total_coefficients = total_coefficients + coefficient return round ( total_points / total_coefficients , 1 ) else : return None Markdown Une professeure de NSI d\u00e9cide de g\u00e9rer les r\u00e9sultats de sa classe sous la forme d\u2019un dictionnaire : - les clefs sont les noms des \u00e9l\u00e8ves ; - les valeurs sont des dictionnaires dont les clefs sont les types d\u2019\u00e9preuves sous forme de cha\u00eene de caract\u00e8res et les valeurs sont les notes obtenues associ\u00e9es \u00e0 leurs coefficients dans une liste. Avec : ```python resultats = {'Dupont': { 'DS1': [15.5, 4], 'DM1': [14.5, 1], 'DS2': [13, 4], 'PROJET1': [16, 3], 'DS3': [14, 4] }, 'Durand': { 'DS1': [6 , 4], 'DS2': [8, 4], 'PROJET1': [9, 3], 'IE1': [7, 2], 'DS3': [12, 4] } } L\u2019\u00e9l\u00e8ve dont le nom est Durand a ainsi obtenu au DS2 la note de 8 avec un coefficient 4. Le professeur cr\u00e9e une fonction moyenne qui prend en param\u00e8tre le nom d\u2019un de ses \u00e9l\u00e8ves et renvoie sa moyenne arrondie au dixi\u00e8me. Si l\u2019\u00e9l\u00e8ve n\u2019a pas de notes, on consid\u00e8re que sa moyenne est nulle. Si le nom donn\u00e9 n\u2019est pas dans les r\u00e9sultats, la fonction renvoie None . Compl\u00e9ter le code de la professeure ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def moyenne ( nom , resultats ): '''Renvoie la moyenne de l'\u00e9l\u00e8ve nom, selon le dictionnaire resultats. Si nom n'est pas dans le dictionnaire, la fonction renvoie None.''' if nom in ... : notes = resultats [ nom ] if ... : # pas de notes return 0 total_points = ... total_coefficients = ... for ... in notes . values (): note , coefficient = valeurs total_points = total_points + ... * coefficient ... = ... + coefficient return round ( ... / total_coefficients , 1 ) else : return None Exemples : \ud83d\udc0d Script Python >>> moyenne ( \"Dupont\" , resultats ) 14.5 >>> moyenne ( \"Durand\" , resultats ) 8.5 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 22.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-23", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 23"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-231", "text": "Exercice 23.1 \u00c9nonc\u00e9 Correction Source Markdown Dans cet exercice, on consid\u00e8re des arbres binaires de recherche qui sont : soit l\u2019arbre vide identifi\u00e9 par None ; soit un n\u0153ud, contenant une cl\u00e9 et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par un triplet (g, v, d) o\u00f9 g et d sont les sous-arbres gauche et droit et v la cl\u00e9. Ainsi, l\u2019arbre binaire de recherche abr1 ci- contre est cr\u00e9\u00e9 par le code python ci- dessous \ud83d\udc0d Script Python n0 = ( None , 0 , None ) n3 = ( None , 3 , None ) n2 = ( None , 2 , n3 ) abr1 = ( n0 , 1 , n2 ) \u00c9crire une fonction r\u00e9cursive insertion_abr(a, cle) qui prend en param\u00e8tres une cl\u00e9 cle et un arbre binaire de recherche a , et qui renvoie un arbre binaire de recherche dans lequel cle a \u00e9t\u00e9 ins\u00e9r\u00e9e. Dans le cas o\u00f9 cle est d\u00e9j\u00e0 pr\u00e9sente dans a , la fonction renvoie l\u2019arbre a inchang\u00e9. R\u00e9sultats \u00e0 obtenir : \ud83d\udc0d Script Python >>> insertion_abr ( abr1 , 4 ) (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 ,( None , 4 , None )))) >>> insertion_abr ( abr1 , - 5 ) ((( None , - 5 , None ), 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) >>> insertion_abr ( abr1 , 2 ) (( None , 0 , None ), 1 ,( None , 2 ,( None , 3 , None ))) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def insertion_abr ( a , cle ): if a is None : return ( None , cle , None ) elif cle > a [ 1 ]: return ( a [ 0 ], a [ 1 ], insertion_abr ( a [ 2 ], cle )) elif cle < a [ 1 ]: return ( insertion_abr ( a [ 0 ], cle ), a [ 1 ], a [ 2 ]) return a \ud83d\udccb Texte Dans cet exercice, on consid\u00e8re des arbres binaires de recherche qui sont : - soit l\u2019arbre vide identifi\u00e9 par `None` ; - soit un n\u0153ud, contenant une cl\u00e9 et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par un triplet `(g, v, d)` o\u00f9 `g` et `d` sont les sous-arbres gauche et droit et `v` la cl\u00e9. ![image](data2023/12_arbre.png){: .center width=30%} Ainsi, l\u2019arbre binaire de recherche `abr1` ci- contre est cr\u00e9\u00e9 par le code python ci- dessous ```python n0 = (None, 0, None) n3 = (None, 3, None) n2 = (None, 2, n3) abr1 = (n0, 1, n2) ``` \u00c9crire une fonction r\u00e9cursive `insertion_abr(a, cle)` qui prend en param\u00e8tres une cl\u00e9 `cle` et un arbre binaire de recherche `a`, et qui renvoie un arbre binaire de recherche dans lequel `cle` a \u00e9t\u00e9 ins\u00e9r\u00e9e. Dans le cas o\u00f9 `cle` est d\u00e9j\u00e0 pr\u00e9sente dans `a`, la fonction renvoie l\u2019arbre a inchang\u00e9. R\u00e9sultats \u00e0 obtenir : ```python >>> insertion_abr(abr1, 4) ((None,0,None),1,(None,2,(None,3,(None,4,None)))) >>> insertion_abr(abr1, -5) (((None,-5,None),0,None),1,(None,2,(None,3,None))) >>> insertion_abr(abr1, 2) ((None,0,None),1,(None,2,(None,3,None))) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 23.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-232", "text": "Exercice 23.2 \u00c9nonc\u00e9 Correction Sources Markdown On dispose d\u2019un ensemble d\u2019objets dont on conna\u00eet, pour chacun, la masse. On souhaite ranger l\u2019ensemble de ces objets dans des boites identiques de telle mani\u00e8re que la somme des masses des objets contenus dans une bo\u00eete ne d\u00e9passe pas la capacit\u00e9 c de la bo\u00eete. On souhaite utiliser le moins de bo\u00eetes possibles pour ranger cet ensemble d\u2019objets. Pour r\u00e9soudre ce probl\u00e8me, on utilisera un algorithme glouton consistant \u00e0 placer chacun des objets dans la premi\u00e8re bo\u00eete o\u00f9 cela est possible. Par exemple, pour ranger dans des bo\u00eetes de capacit\u00e9 c = 5 un ensemble de trois objets dont les masses sont repr\u00e9sent\u00e9es en Python par la liste [1, 5, 2] , on proc\u00e8de de la fa\u00e7on suivante : Le premier objet, de masse 1, va dans une premi\u00e8re boite. Le deuxi\u00e8me objet, de masse 5, ne peut pas aller dans la m\u00eame boite que le premier objet car cela d\u00e9passerait la capacit\u00e9 de la boite. On place donc cet objet dans une deuxi\u00e8me bo\u00eete. Le troisi\u00e8me objet, de masse 2, va dans la premi\u00e8re bo\u00eete. On a donc utilis\u00e9 deux bo\u00eetes de capacit\u00e9 c = 5 pour ranger les 3 objets. Compl\u00e9ter la fonction Python empaqueter(liste_masses, c) suivante pour qu\u2019elle renvoie le nombre de bo\u00eetes de capacit\u00e9 c n\u00e9cessaires pour empaqueter un ensemble d\u2019objets dont les masses sont contenues dans la liste liste_masses . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def empaqueter ( liste_masses , c ): \"\"\"Renvoie le nombre minimal de bo\u00eetes n\u00e9cessaires pour empaqueter les objets de la liste liste_masses, sachant que chaque bo\u00eete peut contenir au maximum c kilogrammes\"\"\" n = len ( liste_masses ) nb_boites = 0 boites = [ 0 for _ in range ( n ) ] for masse in ... : i = 0 while i < nb_boites and boites [ i ] + ... > c : i = i + 1 if i == nb_boites : ... boites [ i ] = ... return ... Exemples : \ud83d\udc0d Script Python >>> empaqueter ([ 1 , 2 , 3 , 4 , 5 ], 10 ) 2 >>> empaqueter ([ 1 , 2 , 3 , 4 , 5 ], 5 ) 4 >>> empaqueter ([ 7 , 6 , 3 , 4 , 8 , 5 , 9 , 2 ], 11 ) 5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def empaqueter ( liste_masses , c ): \"\"\"Renvoie le nombre minimal de bo\u00eetes n\u00e9cessaires pour empaqueter les objets de la liste liste_masses, sachant que chaque bo\u00eete peut contenir au maximum c kilogrammes\"\"\" n = len ( liste_masses ) nb_boites = 0 boites = [ 0 for _ in range ( n ) ] for masse in liste_masses : i = 0 while i < nb_boites and boites [ i ] + masse > c : i = i + 1 if i == nb_boites : nb_boites = nb_boites + 1 boites [ i ] = boites [ i ] + masse return nb_boites Markdown On dispose d\u2019un ensemble d\u2019objets dont on conna\u00eet, pour chacun, la masse. On souhaite ranger l\u2019ensemble de ces objets dans des boites identiques de telle mani\u00e8re que la somme des masses des objets contenus dans une bo\u00eete ne d\u00e9passe pas la capacit\u00e9 `c` de la bo\u00eete. On souhaite utiliser le moins de bo\u00eetes possibles pour ranger cet ensemble d\u2019objets. Pour r\u00e9soudre ce probl\u00e8me, on utilisera un algorithme glouton consistant \u00e0 placer chacun des objets dans la premi\u00e8re bo\u00eete o\u00f9 cela est possible. Par exemple, pour ranger dans des bo\u00eetes de capacit\u00e9 `c = 5` un ensemble de trois objets dont les masses sont repr\u00e9sent\u00e9es en Python par la liste `[1, 5, 2]` , on proc\u00e8de de la fa\u00e7on suivante : - Le premier objet, de masse 1, va dans une premi\u00e8re boite. - Le deuxi\u00e8me objet, de masse 5, ne peut pas aller dans la m\u00eame boite que le premier objet car cela d\u00e9passerait la capacit\u00e9 de la boite. On place donc cet objet dans une deuxi\u00e8me bo\u00eete. - Le troisi\u00e8me objet, de masse 2, va dans la premi\u00e8re bo\u00eete. On a donc utilis\u00e9 deux bo\u00eetes de capacit\u00e9 `c = 5` pour ranger les 3 objets. Compl\u00e9ter la fonction Python `empaqueter(liste_masses, c)` suivante pour qu\u2019elle renvoie le nombre de bo\u00eetes de capacit\u00e9 `c` n\u00e9cessaires pour empaqueter un ensemble d\u2019objets dont les masses sont contenues dans la liste `liste_masses` . ```python linenums='1' def empaqueter(liste_masses, c): \"\"\"Renvoie le nombre minimal de bo\u00eetes n\u00e9cessaires pour empaqueter les objets de la liste liste_masses, sachant que chaque bo\u00eete peut contenir au maximum c kilogrammes\"\"\" n = len(liste_masses) nb_boites = 0 boites = [ 0 for _ in range(n) ] for masse in ...: i = 0 while i < nb_boites and boites[i] + ... > c: i = i + 1 if i == nb_boites: ... boites[i] = ... return ... Exemples : \ud83d\udc0d Script Python >>> empaqueter ([ 1 , 2 , 3 , 4 , 5 ], 10 ) 2 >>> empaqueter ([ 1 , 2 , 3 , 4 , 5 ], 5 ) 4 >>> empaqueter ([ 7 , 6 , 3 , 4 , 8 , 5 , 9 , 2 ], 11 ) 5 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 23.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-24", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 24"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-241", "text": "Exercice 24.1 \u00c9nonc\u00e9 Correction Source Markdown Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None , soit un n\u0153ud repr\u00e9sent\u00e9 par un triplet (g, x, d) o\u00f9 x est l\u2019\u00e9tiquette du n\u0153ud et g et d sont les sous-arbres gauche et droit. On souhaite \u00e9crire une fonction parcours_largeur qui prend en param\u00e8tre un arbre binaire et qui renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre parcourus en largeur. Exemples : \ud83d\udc0d Script Python >>> arbre = ( ( ( None , 1 , None ), 2 , ( None , 3 , None ) ), 4 , ( ( None , 5 , None ), 6 , ( None , 7 , None ) ) ) >>> parcours_largeur ( arbre ) [ 4 , 2 , 6 , 1 , 3 , 5 , 7 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def parcours_largeur ( arbre ): parcours = [] file = [ arbre ] while file != []: a = file . pop ( 0 ) parcours . append ( a [ 1 ]) if a [ 0 ] != None : file . append ( a [ 0 ]) if a [ 2 ] != None : file . append ( a [ 2 ]) return parcours \ud83d\udccb Texte Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur `None`, soit un n\u0153ud repr\u00e9sent\u00e9 par un triplet `(g, x, d)` o\u00f9 `x` est l\u2019\u00e9tiquette du n\u0153ud et `g` et `d` sont les sous-arbres gauche et droit. On souhaite \u00e9crire une fonction `parcours_largeur` qui prend en param\u00e8tre un arbre binaire et qui renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre parcourus en largeur. Exemples : ```python >>> arbre = ( ( (None, 1, None), 2, (None, 3, None) ), 4, ( (None, 5, None), 6, (None, 7, None) ) ) >>> parcours_largeur(arbre) [4, 2, 6, 1, 3, 5, 7] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 24.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-242", "text": "Exercice 24.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau non vide de nombre entiers, positifs ou n\u00e9gatifs, et on souhaite d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs. Par exemple, dans le tableau [1, -2, 3, 10, -4, 7, 2, -5] , la plus grande somme est 18 obtenue en additionnant les \u00e9l\u00e9ments 3, 10, -4, 7, 2. Pour cela, on va r\u00e9soudre le probl\u00e8me par programmation dynamique. Si on note tab le tableau consid\u00e9r\u00e9 et i un indice dans ce tableau, on se ram\u00e8ne \u00e0 un probl\u00e8me plus simple : d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice i . Si on connait la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice i-1 , on peut d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice i : soit on obtient une plus grande somme en ajoutant tab[i] \u00e0 cette somme pr\u00e9c\u00e9dente ; soit on commence une nouvelle somme \u00e0 partir de tab[i] . Remarque : les sommes consid\u00e9r\u00e9es contiennent toujours au moins un terme. Compl\u00e9ter la fonction somme_max ci-dessous qui r\u00e9alise cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def somme_max ( tab ): n = len ( tab ) sommes_max = [ 0 ] * n sommes_max [ 0 ] = tab [ 0 ] # on calcule la plus grande somme se terminant en i for i in range ( 1 , n ): if ... + ... > ... : sommes_max [ i ] = ... else : sommes_max [ i ] = ... # on en d\u00e9duit la plus grande somme de celles-ci maximum = 0 for i in range ( 1 , n ): if ... > ... : maximum = i return sommes_max [ ... ] Exemples : \ud83d\udc0d Script Python >>> somme_max ([ 1 , 2 , 3 , 4 , 5 ]) 15 >> somme_max ([ 1 , 2 , - 3 , 4 , 5 ]) 9 >>> somme_max ([ 1 , 2 , - 2 , 4 , 5 ]) 10 >>> somme_max ([ 1 , - 2 , 3 , 10 , - 4 , 7 , 2 , - 5 ]) 18 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def somme_max ( tab ): n = len ( tab ) sommes_max = [ 0 ] * n sommes_max [ 0 ] = tab [ 0 ] # on calcule la plus grande somme se terminant en i for i in range ( 1 , n ): if sommes_max [ i - 1 ] + tab [ i ] > tab [ i ]: sommes_max [ i ] = sommes_max [ i - 1 ] + tab [ i ] else : sommes_max [ i ] = tab [ i ] # on en d\u00e9duit la plus grande somme de celles-ci maximum = 0 for i in range ( 1 , n ): if sommes_max [ i ] > sommes_max [ maximum ]: maximum = i return sommes_max [ maximum ] Merci \u00e0 N. Maier pour la correction Markdown On consid\u00e8re un tableau non vide de nombre entiers, positifs ou n\u00e9gatifs, et on souhaite d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs. Par exemple, dans le tableau `[1, -2, 3, 10, -4, 7, 2, -5]` , la plus grande somme est 18 obtenue en additionnant les \u00e9l\u00e9ments 3, 10, -4, 7, 2. Pour cela, on va r\u00e9soudre le probl\u00e8me par programmation dynamique. Si on note `tab` le tableau consid\u00e9r\u00e9 et `i` un indice dans ce tableau, on se ram\u00e8ne \u00e0 un probl\u00e8me plus simple : d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice `i` . Si on connait la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice `i-1` , on peut d\u00e9terminer la plus grande somme possible de ses \u00e9l\u00e9ments cons\u00e9cutifs se terminant \u00e0 l\u2019indice `i` : - soit on obtient une plus grande somme en ajoutant `tab[i]` \u00e0 cette somme pr\u00e9c\u00e9dente ; - soit on commence une nouvelle somme \u00e0 partir de `tab[i]` . *Remarque :* les sommes consid\u00e9r\u00e9es contiennent toujours au moins un terme. Compl\u00e9ter la fonction `somme_max` ci-dessous qui r\u00e9alise cet algorithme. ```python linenums='1' def somme_max(tab): n = len(tab) sommes_max = [0]*n sommes_max[0] = tab[0] # on calcule la plus grande somme se terminant en i for i in range(1,n): if ... + ... > ...: sommes_max[i] = ... else: sommes_max[i] = ... # on en d\u00e9duit la plus grande somme de celles-ci maximum = 0 for i in range(1, n): if ... > ...: maximum = i return sommes_max[...] Exemples : \ud83d\udc0d Script Python >>> somme_max ([ 1 , 2 , 3 , 4 , 5 ]) 15 >> somme_max ([ 1 , 2 , - 3 , 4 , 5 ]) 9 >>> somme_max ([ 1 , 2 , - 2 , 4 , 5 ]) 10 >>> somme_max ([ 1 , - 2 , 3 , 10 , - 4 , 7 , 2 , - 5 ]) 18 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 24.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-25", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 25"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-251", "text": "Exercice 25.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche_min qui prend en param\u00e8tre un tableau de nombres tab , et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : \ud83d\udc0d Script Python >>> recherche_min ([ 5 ]) 0 >>> recherche_min ([ 2 , 4 , 1 ]) 2 >>> recherche_min ([ 5 , 3 , 2 , 2 , 4 ]) 2 >>> recherche_min ([ - 1 , - 2 , - 3 , - 3 ]) 2 \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche_min ( tab ): indice_min = 0 for i in range ( len ( tab )): if tab [ i ] < tab [ indice_min ]: indice_min = i return indice_min \ud83d\udccb Texte \u00c9crire une fonction `recherche_min` qui prend en param\u00e8tre un tableau de nombres `tab`, et qui renvoie l'indice de la premi\u00e8re occurrence du minimum de ce tableau. Les tableaux seront repr\u00e9sent\u00e9s sous forme de liste Python. Exemples : ```python >>> recherche_min([5]) 0 >>> recherche_min([2, 4, 1]) 2 >>> recherche_min([5, 3, 2, 2, 4]) 2 >>> recherche_min([-1, -2, -3, -3]) 2 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 25.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-252", "text": "Exercice 25.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction separe ci-dessous qui prend en argument un tableau tab dont les \u00e9l\u00e9ments sont des 0 et des 1 et qui s\u00e9pare les 0 des 1 en pla\u00e7ant les 0 en d\u00e9but de tableau et les 1 \u00e0 la suite. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def separe ( tab ): '''Separe les 0 et les 1 dans le tableau tab''' gauche = 0 droite = ... while gauche < droite : if tab [ gauche ] == 0 : gauche = ... else : tab [ gauche ] = ... tab [ droite ] = ... droite = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Description d\u2019\u00e9tapes effectu\u00e9es par la fonction separe sur le tableau ci-dessous, les caract\u00e8res ^ indiquent les cases point\u00e9es par les indices gauche et droite : \ud83d\udc0d Script Python tab = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ^ ^ Etape 1 : on regarde la premi\u00e8re case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec la derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus la derni\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 2 : on regarde \u00e0 nouveau la premi\u00e8re case, qui contient maintenant un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la premi\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 3 : on regarde la seconde case, qui contient un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la seconde case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 4 : on regarde la troisi\u00e8me case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec l\u2019avant-derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus l\u2019avant-derni\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Et ainsi de suite... tab = [0, 0, 0, 0, 1, 1, 1, 1] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def separe ( tab ): '''Separe les 0 et les 1 dans le tableau tab''' gauche = 0 droite = len ( tab ) - 1 while gauche < droite : if tab [ gauche ] == 0 : gauche = gauche + 1 else : tab [ gauche ] = tab [ droite ] tab [ droite ] = 1 droite = droite - 1 return tab Markdown On consid\u00e8re la fonction `separe` ci-dessous qui prend en argument un tableau `tab` dont les \u00e9l\u00e9ments sont des `0` et des `1` et qui s\u00e9pare les `0` des `1` en pla\u00e7ant les `0` en d\u00e9but de tableau et les `1` \u00e0 la suite. ```python linenums='1' def separe(tab): '''Separe les 0 et les 1 dans le tableau tab''' gauche = 0 droite = ... while gauche < droite: if tab[gauche] == 0 : gauche = ... else : tab[gauche] = ... tab[droite] = ... droite = ... return tab Compl\u00e9ter la fonction separe ci-dessus. Exemples : \ud83d\udc0d Script Python >>> separe ([ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] >>> separe ([ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] Description d\u2019\u00e9tapes effectu\u00e9es par la fonction separe sur le tableau ci-dessous, les caract\u00e8res ^ indiquent les cases point\u00e9es par les indices gauche et droite : \ud83d\udc0d Script Python tab = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ^ ^ Etape 1 : on regarde la premi\u00e8re case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec la derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus la derni\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 2 : on regarde \u00e0 nouveau la premi\u00e8re case, qui contient maintenant un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la premi\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 3 : on regarde la seconde case, qui contient un 0 : ce 0 va aller dans la premi\u00e8re partie du tableau final et est bien positionn\u00e9 : on ne prend plus la seconde case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Etape 4 : on regarde la troisi\u00e8me case, qui contient un 1 : ce 1 va aller dans la seconde partie du tableau final et on l\u2019\u00e9change avec l\u2019avant-derni\u00e8re case. Il est \u00e0 pr\u00e9sent bien positionn\u00e9 : on ne prend plus l\u2019avant-derni\u00e8re case en compte. \ud83d\udc0d Script Python tab = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ^ ^ Et ainsi de suite... tab = [0, 0, 0, 0, 1, 1, 1, 1] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 25.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-26", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 26"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-261", "text": "Exercice 26.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction ajoute_dictionnaires qui prend en param\u00e8tres deux dictionnaires d1 et d2 dont les cl\u00e9s sont des nombres et renvoie le dictionnaire d d\u00e9fini de la fa\u00e7on suivante : Les cl\u00e9s de d sont celles de d1 et celles de d2 r\u00e9unies. Si une cl\u00e9 est pr\u00e9sente dans les deux dictionnaires d1 et d2 , sa valeur associ\u00e9e dans le dictionnaire d est la somme de ses valeurs dans les dictionnaires d1 et d2 . Si une cl\u00e9 n\u2019est pr\u00e9sente que dans un des deux dictionnaires, sa valeur associ\u00e9e dans le dictionnaire d est la m\u00eame que sa valeur dans le dictionnaire o\u00f9 elle est pr\u00e9sente. Exemples : \ud83d\udc0d Script Python >>> ajoute_dictionnaires ({ 1 : 5 , 2 : 7 }, { 2 : 9 , 3 : 11 }) { 1 : 5 , 2 : 16 , 3 : 11 } >>> ajoute_dictionnaires ({}, { 2 : 9 , 3 : 11 }) { 2 : 9 , 3 : 11 } >>> ajoute_dictionnaires ({ 1 : 5 , 2 : 7 }, {}) { 1 : 5 , 2 : 7 } \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def ajoute_dictionnaires ( d1 , d2 ): d = {} for cle in d1 : d [ cle ] = d1 [ cle ] for cle in d2 : if cle in d : d [ cle ] += d2 [ cle ] else : d [ cle ] = d2 [ cle ] return d \ud83d\udccb Texte \u00c9crire une fonction `ajoute_dictionnaires` qui prend en param\u00e8tres deux dictionnaires `d1` et `d2` dont les cl\u00e9s sont des nombres et renvoie le dictionnaire `d` d\u00e9fini de la fa\u00e7on suivante : - Les cl\u00e9s de `d` sont celles de `d1` et celles de `d2` r\u00e9unies. - Si une cl\u00e9 est pr\u00e9sente dans les deux dictionnaires `d1` et `d2`, sa valeur associ\u00e9e dans le dictionnaire `d` est la somme de ses valeurs dans les dictionnaires `d1` et `d2`. - Si une cl\u00e9 n\u2019est pr\u00e9sente que dans un des deux dictionnaires, sa valeur associ\u00e9e dans le dictionnaire `d` est la m\u00eame que sa valeur dans le dictionnaire o\u00f9 elle est pr\u00e9sente. Exemples : ```python >>> ajoute_dictionnaires({1: 5, 2: 7}, {2: 9, 3: 11}) {1: 5, 2: 16, 3: 11} >>> ajoute_dictionnaires({}, {2: 9, 3: 11}) {2: 9, 3: 11} >>> ajoute_dictionnaires({1: 5, 2: 7}, {}) {1: 5, 2: 7} ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 26.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-262", "text": "Exercice 26.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re une piste carr\u00e9e qui contient 4 cases par c\u00f4t\u00e9. Les cases sont num\u00e9rot\u00e9es de 0 inclus \u00e0 12 exclu comme ci-dessous : L\u2019objectif de l\u2019exercice est d\u2019impl\u00e9menter le jeu suivant : Au d\u00e9part, le joueur place son pion sur la case 0. A chaque coup, il lance un d\u00e9 \u00e9quilibr\u00e9 \u00e0 six faces et avance son pion d\u2019autant de cases que le nombre indiqu\u00e9 par le d\u00e9 (entre 1 et 6 inclus) dans le sens des aiguilles d\u2019une montre. Par exemple, s\u2019il obtient 2 au premier lancer, il pose son pion sur la case 2 puis s\u2019il obtient 6 au deuxi\u00e8me lancer, il le pose sur la case 8, puis s\u2019il obtient \u00e0 nouveau 6, il pose le pion sur la case 2. Le jeu se termine lorsque le joueur a pos\u00e9 son pion sur toutes les cases de la piste. Compl\u00e9ter la fonction nombre_coups ci-dessous de sorte qu\u2019elle renvoie le nombre de lancers al\u00e9atoires n\u00e9cessaires pour terminer le jeu. Proposer ensuite quelques tests pour en v\u00e9rifier le fonctionnement. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from random import randint def nombre_coups (): '''Simule un jeu de plateau avec 12 cases et renvoie le nombre minimal de coups pour visiter toutes les cases.''' nombre_cases = 12 # indique si une case a \u00e9t\u00e9 vue cases_vues = [ False ] * nombre_cases nombre_cases_vues = 1 cases_vues [ 0 ] = True case_en_cours = 0 n = ... while ... < ... : x = randint ( 1 , 6 ) case_en_cours = ( case_en_cours + ... ) % ... if ... : cases_vues [ case_en_cours ] = True nombre_cases_vues = ... n = ... return n \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from random import randint def nombre_coups (): '''Simule un jeu de plateau avec 12 cases et renvoie le nombre minimal de coups pour visiter toutes les cases.''' nombre_cases = 12 # indique si une case a \u00e9t\u00e9 vue cases_vues = [ False ] * nombre_cases nombre_cases_vues = 1 cases_vues [ 0 ] = True case_en_cours = 0 n = 0 while nombre_cases_vues < nombre_cases : x = randint ( 1 , 6 ) case_en_cours = ( case_en_cours + x ) % nombre_cases if not cases_vues [ case_en_cours ]: cases_vues [ case_en_cours ] = True nombre_cases_vues = nombre_cases_vues + 1 n = n + 1 return n Markdown On consid\u00e8re une piste carr\u00e9e qui contient 4 cases par c\u00f4t\u00e9. Les cases sont num\u00e9rot\u00e9es de 0 inclus \u00e0 12 exclu comme ci-dessous : ![ image ]( data2023/20_carre.png ){: .center width=20%} L\u2019objectif de l\u2019exercice est d\u2019impl\u00e9menter le jeu suivant : Au d\u00e9part, le joueur place son pion sur la case 0. A chaque coup, il lance un d\u00e9 \u00e9quilibr\u00e9 \u00e0 six faces et avance son pion d\u2019autant de cases que le nombre indiqu\u00e9 par le d\u00e9 (entre 1 et 6 inclus) dans le sens des aiguilles d\u2019une montre. Par exemple, s\u2019il obtient 2 au premier lancer, il pose son pion sur la case 2 puis s\u2019il obtient 6 au deuxi\u00e8me lancer, il le pose sur la case 8, puis s\u2019il obtient \u00e0 nouveau 6, il pose le pion sur la case 2. Le jeu se termine lorsque le joueur a pos\u00e9 son pion sur **toutes les cases** de la piste. Compl\u00e9ter la fonction `nombre_coups` ci-dessous de sorte qu\u2019elle renvoie le nombre de lancers al\u00e9atoires n\u00e9cessaires pour terminer le jeu. Proposer ensuite quelques tests pour en v\u00e9rifier le fonctionnement. ```python linenums='1' from random import randint def nombre_coups(): '''Simule un jeu de plateau avec 12 cases et renvoie le nombre minimal de coups pour visiter toutes les cases.''' nombre_cases = 12 # indique si une case a \u00e9t\u00e9 vue cases_vues = [ False ] * nombre_cases nombre_cases_vues = 1 cases_vues[0] = True case_en_cours = 0 n = ... while ... < ...: x = randint(1, 6) case_en_cours = (case_en_cours + ...) % ... if ...: cases_vues[case_en_cours] = True nombre_cases_vues = ... n = ... return n ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 26.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-27", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 27"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-271", "text": "Exercice 27.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction couples_consecutifs qui prend en param\u00e8tre un tableau de nombres entiers tab non vide (type list ), et qui renvoie la liste Python (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans tab . Exemples : \ud83d\udc0d Script Python >>> couples_consecutifs ([ 1 , 4 , 3 , 5 ]) [] >>> couples_consecutifs ([ 1 , 4 , 5 , 3 ]) [( 4 , 5 )] >>> couples_consecutifs ([ 1 , 1 , 2 , 4 ]) [( 1 , 2 )] >>> couples_consecutifs ([ 7 , 1 , 2 , 5 , 3 , 4 ]) [( 1 , 2 ), ( 3 , 4 )] >>> couples_consecutifs ([ 5 , 1 , 2 , 3 , 8 , - 5 , - 4 , 7 ]) [( 1 , 2 ), ( 2 , 3 ), ( - 5 , - 4 )] \ud83d\udc0d Script Python 1 2 3 4 5 6 def couples_consecutifs ( tab ): solution = [] for i in range ( len ( tab ) - 1 ): if tab [ i ] + 1 == tab [ i + 1 ]: solution . append (( tab [ i ], tab [ i + 1 ])) return solution \ud83d\udccb Texte \u00c9crire une fonction `couples_consecutifs` qui prend en param\u00e8tre un tableau de nombres entiers `tab` non vide (type `list`), et qui renvoie la liste Python (\u00e9ventuellement vide) des couples d'entiers cons\u00e9cutifs successifs qu'il peut y avoir dans `tab`. Exemples : ```python >>> couples_consecutifs([1, 4, 3, 5]) [] >>> couples_consecutifs([1, 4, 5, 3]) [(4, 5)] >>> couples_consecutifs([1, 1, 2, 4]) [(1, 2)] >>> couples_consecutifs([7, 1, 2, 5, 3, 4]) [(1, 2), (3, 4)] >>> couples_consecutifs([5, 1, 2, 3, 8, -5, -4, 7]) [(1, 2), (2, 3), (-5, -4)] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 27.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-272", "text": "Exercice 27.2 \u00c9nonc\u00e9 Correction Sources Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 0 soit \u00e0 1 . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de 1 et de 0 qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 1 dans une image M , donner la valeur val \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction colore_comp1 prend pour param\u00e8tre une image M (repr\u00e9sent\u00e9e par une liste de listes), deux entiers i et j et une valeur enti\u00e8re val . Elle met \u00e0 la valeur val tous les pixels de la composante du pixel M[i][j] s\u2019il vaut 1 et ne fait rien sinon. Par exemple, colore_comp1(M, 2, 1, 3) donne Compl\u00e9ter le code r\u00e9cursif de la fonction colore_comp1 donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def colore_comp1 ( M , i , j , val ): if M [ i ][ j ] != 1 : return M [ i ][ j ] = val if i - 1 >= 0 : # propage en haut colore_comp1 ( M , i - 1 , j , val ) if ... < len ( M ): # propage en bas colore_comp1 ( M , ... , j , val ) if ... : # propage \u00e0 gauche colore_comp1 ( M , ... , ... , val ) if ... : # propage \u00e0 droite ... dans le sujet original, les commentaires sur la direction de propagation sont erron\u00e9s Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 0 ]] >>> colore_comp1 ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def colore_comp1 ( M , i , j , val ): if M [ i ][ j ] != 1 : return M [ i ][ j ] = val if i - 1 >= 0 : # propage \u00e0 gauche colore_comp1 ( M , i - 1 , j , val ) if i + 1 < len ( M ): # propage \u00e0 droite colore_comp1 ( M , i + 1 , j , val ) if j - 1 >= 0 : # propage en haut colore_comp1 ( M , i , j - 1 , val ) if j + 1 < len ( M [ i ]): # propage en bas colore_comp1 ( M , i , j + 1 , val ) Markdown Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments `M[i][j]` , appel\u00e9s pixels, sont \u00e9gaux soit \u00e0 `0` soit \u00e0 `1` . Une composante d\u2019une image est un sous-ensemble de l\u2019image constitu\u00e9 uniquement de `1` et de `0` qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement soit verticalement. Par exemple, les composantes de ![ image ]( data2023/36_carre1.png ){: .center} sont ![ image ]( data2023/36_carre2.png ){: .center width=30%} On souhaite, \u00e0 partir d\u2019un pixel \u00e9gal \u00e0 `1` dans une image `M` , donner la valeur `val` \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction `colore_comp1` prend pour param\u00e8tre une image `M` (repr\u00e9sent\u00e9e par une liste de listes), deux entiers `i` et `j` et une valeur enti\u00e8re `val` . Elle met \u00e0 la valeur `val` tous les pixels de la composante du pixel `M[i][j]` s\u2019il vaut `1` et ne fait rien sinon. Par exemple, `colore_comp1(M, 2, 1, 3)` donne ![ image ]( data2023/36_carre3.png ){: .center width=30%} Compl\u00e9ter le code r\u00e9cursif de la fonction `colore_comp1` donn\u00e9 ci-dessous : ```python linenums='1' def colore_comp1(M, i, j, val): if M[i][j] != 1: return M[i][j] = val if i-1 >= 0: # propage en haut colore_comp1(M, i-1, j, val) if ... < len(M): # propage en bas colore_comp1(M, ..., j, val) if ...: # propage \u00e0 gauche colore_comp1(M, ..., ..., val) if ...: # propage \u00e0 droite ... dans le sujet original, les commentaires sur la direction de propagation sont erron\u00e9s Exemple : \ud83d\udc0d Script Python >>> M = [[ 0 , 0 , 1 , 0 ], [ 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 1 , 0 ]] >>> colore_comp1 ( M , 2 , 1 , 3 ) >>> M [[ 0 , 0 , 1 , 0 ], [ 0 , 3 , 0 , 1 ], [ 3 , 3 , 3 , 0 ], [ 0 , 3 , 3 , 0 ]] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 27.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-28", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 28"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-281", "text": "Exercice 28.1 \u00c9nonc\u00e9 Correction Source Markdown On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par : les deux premi\u00e8res valeurs sont \u00e9gales \u00e0 1 ; ensuite, chaque valeur est obtenue en faisant la somme des deux valeurs qui la pr\u00e9c\u00e8- dent. La troisi\u00e8me valeur est donc \\(1+1 = 2\\) , la quatri\u00e8me est \\(1+2 = 3\\) , la cinqui\u00e8me est \\(2+3 = 5\\) , la sixi\u00e8me est \\(3 + 5 = 8\\) , et ainsi de suite. Cette suite d\u2019entiers est connue sous le nom de suite de Fibonacci. \u00c9crire en Python une fonction fibonacci qui prend en param\u00e8tre un entier n suppos\u00e9 strictement positif et qui renvoie le terme d\u2019indice n de cette suite. Exemples : \ud83d\udc0d Script Python >>> fibonacci ( 1 ) 1 >>> fibonacci ( 2 ) 1 >>> fibonacci ( 25 ) 75025 Version r\u00e9cursive : \ud83d\udc0d Script Python 1 2 3 4 5 def fibonacci ( n ): if n <= 2 : return 1 else : return fibonacci ( n - 1 ) + fibonacci ( n - 2 ) Version programmation dynamique bottom-up: \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fibonacci ( n ): d = {} d [ 1 ] = 1 d [ 2 ] = 1 for k in range ( 3 , n + 1 ): d [ k ] = d [ k - 1 ] + d [ k - 2 ] return d [ n ] Version programmation dynamique top-down avec m\u00e9mo\u00efsation: \ud83d\udc0d Script Python 1 2 3 4 5 6 dict_fibo = { 1 : 1 , 2 : 1 } def fibonacci ( n ): if n in dict_fibo : return dict_fibo [ n ] dict_fibo [ n ] = fibonacci ( n - 1 ) + fibonacci ( n - 2 ) return dict_fibo [ n ] On peut constater que la version r\u00e9cursive \u00e9choue \u00e0 calculer fibonacci(45) , alors que les deux autres versions le font quasi-imm\u00e9diatement. \ud83d\udccb Texte On s\u2019int\u00e9resse \u00e0 la suite d\u2019entiers d\u00e9finie par : - les deux premi\u00e8res valeurs sont \u00e9gales \u00e0 1 ; - ensuite, chaque valeur est obtenue en faisant la somme des deux valeurs qui la pr\u00e9c\u00e8- dent. La troisi\u00e8me valeur est donc $1+1 = 2$, la quatri\u00e8me est $1+2 = 3$, la cinqui\u00e8me est $2+3 = 5$, la sixi\u00e8me est $3 + 5 = 8$, et ainsi de suite. Cette suite d\u2019entiers est connue sous le nom de suite de Fibonacci. \u00c9crire en Python une fonction `fibonacci` qui prend en param\u00e8tre un entier `n` suppos\u00e9 strictement positif et qui renvoie le terme d\u2019indice `n` de cette suite. Exemples : ```python >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(25) 75025 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 28.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-282", "text": "Exercice 28.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re la fonction eleves_du_mois prenant en param\u00e8tres eleves et notes deux tableaux de m\u00eame longueur, le premier contenant le nom des \u00e9l\u00e8ves et le second, des entiers positifs d\u00e9signant leur note \u00e0 un contr\u00f4le de sorte que eleves[i] a obtenu la note notes[i] . Cette fonction renvoie le couple constitu\u00e9 de la note maximale attribu\u00e9e et des noms des \u00e9l\u00e8ves ayant obtenu cette note regroup\u00e9s dans un tableau. Ainsi, l\u2019instruction eleves_du_mois(['a', 'b', 'c', 'd'], [15, 18, 12, 18]) renvoie le couple (18, ['b', 'd']) . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def eleves_du_mois ( eleves , notes ): note_maxi = 0 meilleurs_eleves = ... for i in range ( ... ) : if notes [ i ] == ... : meilleurs_eleves . append ( ... ) elif notes [ i ] > note_maxi : note_maxi = ... meilleurs_eleves = [ ... ] return ( note_maxi , meilleurs_eleves ) Compl\u00e9ter ce code. Exemples : \ud83d\udc0d Script Python >>> eleves_nsi = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] >>> notes_nsi = [ 30 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] >>> eleves_du_mois ( eleves_nsi , notes_nsi ) ( 80 , [ 'c' , 'f' , 'h' ]) >>> eleves_du_mois ([],[]) ( 0 , []) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def eleves_du_mois ( eleves , notes ): note_maxi = 0 meilleurs_eleves = [] for i in range ( len ( eleves )) : if notes [ i ] == note_maxi : meilleurs_eleves . append ( eleves [ i ]) elif notes [ i ] > note_maxi : note_maxi = notes [ i ] meilleurs_eleves = [ eleves [ i ]] return ( note_maxi , meilleurs_eleves ) Markdown On consid\u00e8re la fonction `eleves_du_mois` prenant en param\u00e8tres `eleves` et `notes` deux tableaux de m\u00eame longueur, le premier contenant le nom des \u00e9l\u00e8ves et le second, des entiers positifs d\u00e9signant leur note \u00e0 un contr\u00f4le de sorte que `eleves[i]` a obtenu la note `notes[i]` . Cette fonction renvoie le couple constitu\u00e9 de la note maximale attribu\u00e9e et des noms des \u00e9l\u00e8ves ayant obtenu cette note regroup\u00e9s dans un tableau. Ainsi, l\u2019instruction `eleves_du_mois(['a', 'b', 'c', 'd'], [15, 18, 12, 18])` renvoie le couple `(18, ['b', 'd'])` . ```python linenums='1' def eleves_du_mois(eleves, notes): note_maxi = 0 meilleurs_eleves = ... for i in range(...) : if notes[i] == ... : meilleurs_eleves.append(...) elif notes[i] > note_maxi: note_maxi = ... meilleurs_eleves = [...] return (note_maxi,meilleurs_eleves) Compl\u00e9ter ce code. Exemples : \ud83d\udc0d Script Python >>> eleves_nsi = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' ] >>> notes_nsi = [ 30 , 40 , 80 , 60 , 58 , 80 , 75 , 80 , 60 , 24 ] >>> eleves_du_mois ( eleves_nsi , notes_nsi ) ( 80 , [ 'c' , 'f' , 'h' ]) >>> eleves_du_mois ([],[]) ( 0 , []) ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 28.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-29", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 29"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-291", "text": "Exercice 29.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne(notes) qui renvoie la moyenne pond\u00e9r\u00e9e des r\u00e9sultats contenus dans le tableau notes , non vide, donn\u00e9 en param\u00e8tre. Ce tableau contient des couples (note, coefficient) dans lesquels : note est un nombre de type flottant ( float ) compris entre 0 et 20 ; coefficient est un nombre entier strictement positif. Ainsi l\u2019expression moyenne([(15.0,2),(9.0,1),(12.0,3)]) devra renvoyer 12.5 . \\(\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5\\) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( liste_notes ): somme_notes = 0 somme_coeffs = 0 for devoir in liste_notes : note = devoir [ 0 ] coeff = devoir [ 1 ] somme_notes += note * coeff somme_coeffs += coeff return somme_notes / somme_coeffs \ud83d\udccb Texte \u00c9crire une fonction `moyenne(notes)` qui renvoie la moyenne pond\u00e9r\u00e9e des r\u00e9sultats contenus dans le tableau `notes`, non vide, donn\u00e9 en param\u00e8tre. Ce tableau contient des couples `(note, coefficient)` dans lesquels : - `note` est un nombre de type flottant (`float`) compris entre 0 et 20 ; - `coefficient` est un nombre entier strictement positif. Ainsi l\u2019expression `moyenne([(15.0,2),(9.0,1),(12.0,3)])` devra renvoyer `12.5`. $\\dfrac{2 \\times 15 + 1 \\times 9 + 3 \\times 12 }{2+1+3}=12,5$ R\u00e9digez votre code sur Basthon", "title": "Exercice 29.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-292", "text": "Exercice 29.2 \u00c9nonc\u00e9 Correction Sources Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal (Figure 1). Dans le triangle de Pascal, chaque ligne commence et se termine par le nombre 1. Comme l\u2019illustre la Figure 2, on additionne deux valeurs successives d\u2019une ligne pour obtenir la valeur qui se situe sous la deuxi\u00e8me valeur. Compl\u00e9ter les fonctions ligne_suivante et pascal ci-dessous. La fonction ligne_suivante prend en param\u00e8tre une liste d\u2019entiers ligne correspondant \u00e0 une ligne du triangle de Pascal et renvoie la liste correspondant \u00e0 la ligne suivante du triangle de Pascal. La fonction pascal prend en param\u00e8tre un entier n et l\u2019utilise pour construire le triangle de Pascal ayant n+1 lignes sous la forme d\u2019une liste de listes. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def ligne_suivante ( ligne ): '''Renvoie la ligne suivant ligne du triangle de Pascal''' ligne_suiv = [ ... ] for i in range ( ... ): ligne_suiv . append ( ... ) ligne_suiv . append ( ... ) return ligne_suiv def pascal ( n ): '''Renvoie le triangle de Pascal de hauteur n''' triangle = [ [ 1 ] ] for k in range ( ... ): ligne_k = ... triangle . append ( ligne_k ) return triangle Exemples: \ud83d\udc0d Script Python >>> ligne_suivante ([ 1 , 3 , 3 , 1 ]) [ 1 , 4 , 6 , 4 , 1 ] >>> pascal ( 2 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ]] >>> pascal ( 3 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ]] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def ligne_suivante ( ligne ): '''Renvoie la ligne suivant ligne du triangle de Pascal''' ligne_suiv = [ ligne [ 0 ]] for i in range ( 1 , len ( ligne )): ligne_suiv . append ( ligne [ i - 1 ] + ligne [ i ]) ligne_suiv . append ( ligne [ - 1 ]) return ligne_suiv def pascal ( n ): '''Renvoie le triangle de Pascal de hauteur n''' triangle = [ [ 1 ] ] for k in range ( n ): ligne_k = ligne_suivante ( triangle [ - 1 ]) triangle . append ( ligne_k ) return triangle Markdown On cherche \u00e0 d\u00e9terminer les valeurs du triangle de Pascal (Figure 1). Dans le triangle de Pascal, chaque ligne commence et se termine par le nombre 1. Comme l\u2019illustre la Figure 2, on additionne deux valeurs successives d\u2019une ligne pour obtenir la valeur qui se situe sous la deuxi\u00e8me valeur. ![ image ]( data2023/17_triangle.png ){: .center width=60%} Compl\u00e9ter les fonctions `ligne_suivante` et `pascal` ci-dessous. La fonction `ligne_suivante` prend en param\u00e8tre une liste d\u2019entiers `ligne` correspondant \u00e0 une ligne du triangle de Pascal et renvoie la liste correspondant \u00e0 la ligne suivante du triangle de Pascal. La fonction `pascal` prend en param\u00e8tre un entier n et l\u2019utilise pour construire le triangle de Pascal ayant `n+1` lignes sous la forme d\u2019une liste de listes. ```python linenums='1' def ligne_suivante(ligne): '''Renvoie la ligne suivant ligne du triangle de Pascal''' ligne_suiv = [...] for i in range(...): ligne_suiv.append(...) ligne_suiv.append(...) return ligne_suiv def pascal(n): '''Renvoie le triangle de Pascal de hauteur n''' triangle = [ [1] ] for k in range(...): ligne_k = ... triangle.append(ligne_k) return triangle Exemples: \ud83d\udc0d Script Python >>> ligne_suivante ([ 1 , 3 , 3 , 1 ]) [ 1 , 4 , 6 , 4 , 1 ] >>> pascal ( 2 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ]] >>> pascal ( 3 ) [[ 1 ], [ 1 , 1 ], [ 1 , 2 , 1 ], [ 1 , 3 , 3 , 1 ]] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 29.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-30", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 30"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-301", "text": "Exercice 30.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction fusion prenant en param\u00e8tres deux tableaux non vides tab1 et tab2 (type list ) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de tab1 et tab2 . Exemples : \ud83d\udc0d Script Python >>> fusion ([ 3 , 5 ], [ 2 , 5 ]) [ 2 , 3 , 5 , 5 ] >>> fusion ([ - 2 , 4 ], [ - 3 , 5 , 10 ]) [ - 3 , - 2 , 4 , 5 , 10 ] >>> fusion ([ 4 ], [ 2 , 6 ]) [ 2 , 4 , 6 ] >>> fusion ([], []) [] >>> fusion ([ 1 , 2 , 3 ], []) [ 1 , 2 , 3 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fusion ( tab1 , tab2 ): tab_fusion = [] i1 = 0 i2 = 0 while i1 < len ( tab1 ) and i2 < len ( tab2 ): if tab1 [ i1 ] < tab2 [ i2 ]: tab_fusion . append ( tab1 [ i1 ]) i1 += 1 else : tab_fusion . append ( tab2 [ i2 ]) i2 += 1 if i1 == len ( tab1 ): while i2 < len ( tab2 ): tab_fusion . append ( tab2 [ i2 ]) i2 += 1 else : while i1 < len ( tab1 ): tab_fusion . append ( tab1 [ i1 ]) i1 += 1 return tab_fusion \ud83d\udccb Texte Programmer la fonction `fusion` prenant en param\u00e8tres deux tableaux non vides `tab1` et `tab2` (type `list`) d'entiers, chacun dans l\u2019ordre croissant, et renvoyant un tableau tri\u00e9 dans l\u2019ordre croissant et contenant l\u2019ensemble des valeurs de `tab1` et `tab2`. Exemples : ```python >>> fusion([3, 5], [2, 5]) [2, 3, 5, 5] >>> fusion([-2, 4], [-3, 5, 10]) [-3, -2, 4, 5, 10] >>> fusion([4], [2, 6]) [2, 4, 6] >>> fusion([], []) [] >>> fusion([1, 2, 3], []) [1, 2, 3] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 30.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-302", "text": "Exercice 30.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de cet exercice est d\u2019\u00e9crire une fonction r\u00e9cursive traduire_romain qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res, non vide, repr\u00e9sentant un nombre \u00e9crit en chiffres romains et qui renvoie son \u00e9criture d\u00e9cimale. Les chiffres romains consid\u00e9r\u00e9s sont : I, V, X, L, C, D et M. Ils repr\u00e9sentent respectivement les nombres 1, 5, 10, 50, 100, 500, et 1000 en base dix. On dispose d\u2019un dictionnaire romains dont les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale : romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000} Le code de la fonction traduire_romain fournie repose sur le principe suivant : la valeur d\u2019un caract\u00e8re est ajout\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur sup\u00e9rieure (ou \u00e9gale) \u00e0 celle du caract\u00e8re qui le suit ; la valeur d\u2019un caract\u00e8re est retranch\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur strictement inf\u00e9rieure \u00e0 celle du caract\u00e8re qui le suit. Ainsi, XIV correspond au nombre 10 + 5 - 1 puisque : la valeur de X (10) est sup\u00e9rieure \u00e0 celle de I (1), on ajoute donc 10 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire IV ; la valeur de I (1) est strictement inf\u00e9rieure \u00e0 celle de V (5), on soustrait donc 1 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire V. On rappelle que pour priver une cha\u00eene de caract\u00e8res de son premier caract\u00e8re, on utilisera l\u2019instruction : nom_de_variable[1:] Par exemple, si la variable mot contient la cha\u00eene \"CDI\" , mot[1:] renvoie \"DI\" . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 romains = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } def traduire_romain ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len ( nombre ) == 1 : return ... elif romains [ nombre [ 0 ]] >= ... return romains [ nombre [ 0 ]] + ... else : return ... Exemples : \ud83d\udc0d Script Python >>> traduire_romain ( \"XIV\" ) 14 >>> traduire_romain ( \"CXLII\" ) 142 >>> traduire_romain ( \"MMXXIV\" ) 2024 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 romains = { \"I\" : 1 , \"V\" : 5 , \"X\" : 10 , \"L\" : 50 , \"C\" : 100 , \"D\" : 500 , \"M\" : 1000 } def traduire_romain ( nombre ): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len ( nombre ) == 1 : return romains [ nombre ] elif romains [ nombre [ 0 ]] >= romains [ nombre [ 1 ]]: return romains [ nombre [ 0 ]] + traduire_romain ( nombre [ 1 :]) else : return traduire_romain ( nombre [ 1 :]) - romains [ nombre [ 0 ]] Markdown Le but de cet exercice est d\u2019\u00e9crire une fonction r\u00e9cursive `traduire_romain` qui prend en param\u00e8tre une cha\u00eene de caract\u00e8res, non vide, repr\u00e9sentant un nombre \u00e9crit en chiffres romains et qui renvoie son \u00e9criture d\u00e9cimale. Les chiffres romains consid\u00e9r\u00e9s sont : I, V, X, L, C, D et M. Ils repr\u00e9sentent respectivement les nombres 1, 5, 10, 50, 100, 500, et 1000 en base dix. On dispose d\u2019un dictionnaire `romains` dont les cl\u00e9s sont les caract\u00e8res apparaissant dans l\u2019\u00e9criture en chiffres romains et les valeurs sont les nombres entiers associ\u00e9s en \u00e9criture d\u00e9cimale : `romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000}` Le code de la fonction `traduire_romain` fournie repose sur le principe suivant : - la valeur d\u2019un caract\u00e8re est ajout\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur sup\u00e9rieure (ou \u00e9gale) \u00e0 celle du caract\u00e8re qui le suit ; - la valeur d\u2019un caract\u00e8re est retranch\u00e9e \u00e0 la valeur du reste de la cha\u00eene si ce caract\u00e8re a une valeur strictement inf\u00e9rieure \u00e0 celle du caract\u00e8re qui le suit. Ainsi, XIV correspond au nombre 10 + 5 - 1 puisque : - la valeur de X (10) est sup\u00e9rieure \u00e0 celle de I (1), on ajoute donc 10 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire IV ; - la valeur de I (1) est strictement inf\u00e9rieure \u00e0 celle de V (5), on soustrait donc 1 \u00e0 la valeur du reste de la cha\u00eene, c\u2019est-\u00e0-dire V. On rappelle que pour priver une cha\u00eene de caract\u00e8res de son premier caract\u00e8re, on utilisera l\u2019instruction : `nom_de_variable[1:]` Par exemple, si la variable `mot` contient la cha\u00eene `\"CDI\"` , `mot[1:]` renvoie `\"DI\"` . ```python linenums='1' romains = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000} def traduire_romain(nombre): \"\"\" Renvoie l\u2019\u00e9criture d\u00e9cimale du nombre donn\u00e9 en chiffres romains \"\"\" if len(nombre) == 1: return ... elif romains[nombre[0]] >= ... return romains[nombre[0]] + ... else: return ... Exemples : \ud83d\udc0d Script Python >>> traduire_romain ( \"XIV\" ) 14 >>> traduire_romain ( \"CXLII\" ) 142 >>> traduire_romain ( \"MMXXIV\" ) 2024 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 30.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-31", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 31"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-311", "text": "Exercice 31.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction multiplication , prenant en param\u00e8tres deux nombres entiers relatifs n1 et n2 , et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. \ud83d\udc0d Script Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) - 12 >>> multiplication ( - 2 , 0 ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def multiplication ( n1 , n2 ): # on se ram\u00e8ne d'abord au cas o\u00f9 n1 et n2 sont tous les deux positifs : if n1 < 0 : return - multiplication ( - n1 , n2 ) if n2 < 0 : return - multiplication ( n1 , - n2 ) resultat = 0 for _ in range ( n2 ): resultat += n1 return resultat \ud83d\udccb Texte Programmer la fonction `multiplication`, prenant en param\u00e8tres deux nombres entiers relatifs `n1` et `n2`, et qui renvoie le produit de ces deux nombres. Les seules op\u00e9rations autoris\u00e9es sont l\u2019addition et la soustraction. ```python >>> multiplication(3, 5) 15 >>> multiplication(-4, -8) 32 >>> multiplication(-2, 6) -12 >>> multiplication(-2, 0) 0 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 31.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-312", "text": "Exercice 31.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse dans cet exercice \u00e0 la recherche dichotomique dans un tableau tri\u00e9 d\u2019en- tiers. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d'entiers tri\u00e9 dans l'ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = m + 1 else : fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dichotomie ( tab , x ): \"\"\" tab : tableau d\u2019entiers tri\u00e9 dans l\u2019ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Markdown On s\u2019int\u00e9resse dans cet exercice \u00e0 la recherche dichotomique dans un tableau tri\u00e9 d\u2019en- tiers. Compl\u00e9ter la fonction suivante en respectant la sp\u00e9cification. ```python linenums='1' def dichotomie(tab, x): \"\"\" tab : tableau d'entiers tri\u00e9 dans l'ordre croissant x : nombre entier La fonction renvoie True si tab contient x et False sinon \"\"\" debut = 0 fin = len(tab) - 1 while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = m + 1 else: fin = ... return ... Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 31.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-32", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 32"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-321", "text": "Exercice 32.1 \u00c9nonc\u00e9 Correction Source Markdown L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents. Il est symbolis\u00e9 par le caract\u00e8re \u2295. Ainsi : 0 \u2295 0 = 0 0 \u2295 1 = 1 1 \u2295 0 = 1 1 \u2295 1 = 0 \u00c9crire une fonction ou_exclusif qui prend en param\u00e8tres deux tableaux de 0 ou de 1 de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position i est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position i des tableaux pass\u00e9s en param\u00e8tres. \ud83d\udc0d Script Python >>> ou_exclusif ([ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ], [ 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ]) [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ] >>> ou_exclusif ([ 1 , 1 , 0 , 1 ], [ 0 , 0 , 1 , 1 ]) [ 1 , 1 , 1 , 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 def ou_exclusif ( tab1 , tab2 ): resultat = [] taille = len ( tab1 ) for i in range ( taille ): resultat . append ( tab1 [ i ] ^ tab2 [ i ]) return resultat Si on ne connait pas la fonction native ^ qui fait le \u00abou exclusif\u00bb de deux entiers en Python, on peut la recoder : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def ou_exc ( a , b ): if a == 0 and b == 0 : return 0 if a == 0 and b == 1 : return 1 if a == 1 and b == 0 : return 1 if a == 1 and b == 1 : return 0 Le code devient alors : \ud83d\udc0d Script Python 1 2 3 4 5 6 def ou_exclusif ( tab1 , tab2 ): resultat = [] taille = len ( tab1 ) for i in range ( taille ): resultat . append ( ou_exc ( tab1 [ i ], tab2 [ i ])) return resultat \ud83d\udccb Texte L'op\u00e9rateur \u00ab ou exclusif \u00bb entre deux bits renvoie 0 si les deux bits sont \u00e9gaux et 1 s'ils sont diff\u00e9rents. Il est symbolis\u00e9 par le caract\u00e8re \u2295. Ainsi : - 0 \u2295 0 = 0 - 0 \u2295 1 = 1 - 1 \u2295 0 = 1 - 1 \u2295 1 = 0 \u00c9crire une fonction `ou_exclusif` qui prend en param\u00e8tres deux tableaux de 0 ou de 1 de m\u00eame longueur et qui renvoie un tableau o\u00f9 l\u2019\u00e9l\u00e9ment situ\u00e9 \u00e0 position `i` est le r\u00e9sultat, par l\u2019op\u00e9rateur \u00ab ou exclusif \u00bb, des \u00e9l\u00e9ments \u00e0 la position `i` des tableaux pass\u00e9s en param\u00e8tres. ```python >>> ou_exclusif([1, 0, 1, 0, 1, 1, 0, 1], [0, 1, 1, 1, 0, 1, 0, 0]) [1, 1, 0, 1, 1, 0, 0, 1] >>> ou_exclusif([1, 1, 0, 1], [0, 0, 1, 1]) [1, 1, 1, 0] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 32.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-322", "text": "Exercice 32.2 \u00c9nonc\u00e9 Correction Sources Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre \\(n\\) un tableau de \\(n\\) lignes et \\(n\\) colonnes dont chaque case contient un entier naturel. Exemples : Un carr\u00e9 est dit semimagique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne sont \u00e9gales. Ainsi c2 et c3 sont semimagiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 8 pour c2 et 12 pour c3. Le carre c3bis n'est pas semimagique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 15 alors que celle de la deuxi\u00e8me ligne est \u00e9gale \u00e0 10. La classe Carre ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. La m\u00e9thode constructeur cr\u00e9e un carr\u00e9 sous forme d\u2019un tableau \u00e0 deux dimensions \u00e0 partir d\u2019une liste d\u2019entiers, et d\u2019un ordre. La m\u00e9thode affiche permet d\u2019afficher le carr\u00e9 cr\u00e9\u00e9. Exemple : \ud83d\udc0d Script Python >>> lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] >>> c3 = Carre ( lst_c3 , 3 ) >>> c3 . affiche () [ 3 , 4 , 5 ] [ 4 , 4 , 4 ] [ 5 , 4 , 3 ] Compl\u00e9ter la m\u00e9thode est_semimagique qui renvoie True si le carr\u00e9 est semimagique, False sinon. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... ): if ... != s : return ... #test de la somme de chaque colonne for j in range ( ... ): if ... != s : return ... return ... Tester la m\u00e9thode est_semimagique sur les carr\u00e9s c2, c3 et c3bis. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( self . ordre ): if self . somme_ligne ( i ) != s : return False #test de la somme de chaque colonne for j in range ( self . ordre ): if self . somme_col ( j ) != s : return False return True Tests avec : \ud83d\udc0d Script Python 1 2 3 lst_c2 = [ 1 , 7 , 7 , 1 ] lst_c3 = [ 3 , 4 , 5 , 4 , 4 , 4 , 5 , 4 , 3 ] lst_c3bis = [ 2 , 9 , 4 , 7 , 0 , 3 , 6 , 1 , 8 ] \ud83d\udc0d Script Python >>> c2 = Carre ( lst_c2 , 2 ) >>> c2 . est_semimagique () True >>> c3 = Carre ( lst_c3 , 3 ) >>> c3 . est_semimagique () True >>> c3bis = Carre ( lst_c3bis , 2 ) >>> c3bis . est_semimagique () False Markdown Dans cet exercice, on appelle carr\u00e9 d\u2019ordre $n$ un tableau de $n$ lignes et $n$ colonnes dont chaque case contient un entier naturel. Exemples : ![ image ]( data2023/35_carre.png ){: .center} Un carr\u00e9 est dit semimagique lorsque les sommes des \u00e9l\u00e9ments situ\u00e9s sur chaque ligne, chaque colonne sont \u00e9gales. - Ainsi c2 et c3 sont semimagiques car la somme de chaque ligne, chaque colonne et chaque diagonale est \u00e9gale \u00e0 8 pour c2 et 12 pour c3. - Le carre c3bis n'est pas semimagique car la somme de la premi\u00e8re ligne est \u00e9gale \u00e0 15 alors que celle de la deuxi\u00e8me ligne est \u00e9gale \u00e0 10. La classe `Carre` ci-apr\u00e8s contient des m\u00e9thodes qui permettent de manipuler des carr\u00e9s. - La m\u00e9thode constructeur cr\u00e9e un carr\u00e9 sous forme d\u2019un tableau \u00e0 deux dimensions \u00e0 partir d\u2019une liste d\u2019entiers, et d\u2019un ordre. - La m\u00e9thode `affiche` permet d\u2019afficher le carr\u00e9 cr\u00e9\u00e9. Exemple : ```python >>> lst_c3 = [3, 4, 5, 4, 4, 4, 5, 4, 3] >>> c3 = Carre(lst_c3, 3) >>> c3.affiche() [3, 4, 5] [4, 4, 4] [5, 4, 3] Compl\u00e9ter la m\u00e9thode est_semimagique qui renvoie True si le carr\u00e9 est semimagique, False sinon. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Carre : def __init__ ( self , liste , n ): self . ordre = n self . tableau = [[ liste [ i + j * n ] for i in range ( n )] for j in range ( n )] def affiche ( self ): '''Affiche un carr\u00e9''' for i in range ( self . ordre ): print ( self . tableau [ i ]) def somme_ligne ( self , i ): '''Calcule la somme des valeurs de la ligne i''' somme = 0 for j in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def somme_col ( self , j ): '''Calcule la somme des valeurs de la colonne j''' somme = 0 for i in range ( self . ordre ): somme = somme + self . tableau [ i ][ j ] return somme def est_semimagique ( self ): s = self . somme_ligne ( 0 ) #test de la somme de chaque ligne for i in range ( ... ): if ... != s : return ... #test de la somme de chaque colonne for j in range ( ... ): if ... != s : return ... return ... Tester la m\u00e9thode est_semimagique sur les carr\u00e9s c2, c3 et c3bis. ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 32.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-33", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 33"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-331", "text": "Exercice 33.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer une fonction renverse , prenant en param\u00e8tre une cha\u00eene de caract\u00e8res mot et renvoie cette cha\u00eene de caract\u00e8res en ordre inverse. Exemple : \ud83d\udc0d Script Python >>> renverse ( \"\" ) \"\" >>> renverse ( \"abc\" ) \"cba\" >>> renverse ( \"informatique\" ) \"euqitamrofni\" \ud83d\udc0d Script Python 1 2 3 4 5 def renverse ( mot ): sol = '' for lettre in mot : sol = lettre + sol return sol \ud83d\udccb Texte Programmer une fonction `renverse`, prenant en param\u00e8tre une cha\u00eene de caract\u00e8res `mot` et renvoie cette cha\u00eene de caract\u00e8res en ordre inverse. Exemple : ```python >>> renverse(\"\") \"\" >>> renverse(\"abc\") \"cba\" >>> renverse(\"informatique\") \"euqitamrofni\" ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 33.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-332", "text": "Exercice 33.2 \u00c9nonc\u00e9 Correction Sources Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre n fix\u00e9. On consid\u00e8re pour cela un tableau tab de n bool\u00e9ens, initialement tous \u00e9gaux \u00e0 True , sauf tab[0] et tab[1] qui valent False , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice i : si tab[i] vaut True : le nombre i est premier et on donne la valeur False \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de i , \u00e0 partir de 2*i (c\u2019est-\u00e0-dire 2*i , 3*i ...). si tab[i] vaut False : le nombre i n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction crible , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier n strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que n . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def crible ( n ): \"\"\"Renvoie un tableau contenant tous les nombres premiers plus petits que n.\"\"\" premiers = [] tab = [ True ] * n tab [ 0 ], tab [ 1 ] = False , False for i in range ( n ): if tab [ i ]: premiers .... multiple = ... while multiple < n : tab [ multiple ] = ... multiple = ... return premiers Exemples : \ud83d\udc0d Script Python >>> crible ( 40 ) [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] >>> crible ( 5 ) [ 2 , 3 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ddef crible ( n ): \"\"\"Renvoie un tableau contenant tous les nombres premiers plus petits que n.\"\"\" premiers = [] tab = [ True ] * n tab [ 0 ], tab [ 1 ] = False , False for i in range ( n ): if tab [ i ]: premiers . append ( i ) multiple = i while multiple < n : tab [ multiple ] = False multiple = multiple + i return premiers Markdown Un nombre premier est un nombre entier naturel qui admet exactement deux diviseurs distincts entiers et positifs : 1 et lui-m\u00eame. Le crible d\u2019\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petit qu\u2019un certain nombre `n` fix\u00e9. On consid\u00e8re pour cela un tableau `tab` de `n` bool\u00e9ens, initialement tous \u00e9gaux \u00e0 `True` , sauf `tab[0]` et `tab[1]` qui valent `False` , 0 et 1 n\u2019\u00e9tant pas des nombres premiers. On parcourt alors ce tableau de gauche \u00e0 droite. Pour chaque indice `i` : - si `tab[i]` vaut `True` : le nombre `i` est premier et on donne la valeur `False` \u00e0 toutes les cases du tableau dont l\u2019indice est un multiple de `i` , \u00e0 partir de `2*i` (c\u2019est-\u00e0-dire `2*i` , `3*i` ...). - si `tab[i]` vaut `False` : le nombre `i` n\u2019est pas premier et on n\u2019effectue aucun changement sur le tableau. On dispose de la fonction `crible` , incompl\u00e8te et donn\u00e9e ci-dessous, prenant en param\u00e8tre un entier `n` strictement positif et renvoyant un tableau contenant tous les nombres premiers plus petits que `n` . ```python linenums='1' def crible(n): \"\"\"Renvoie un tableau contenant tous les nombres premiers plus petits que n.\"\"\" premiers = [] tab = [True] * n tab[0], tab[1] = False, False for i in range(n): if tab[i]: premiers.... multiple = ... while multiple < n: tab[multiple] = ... multiple = ... return premiers Exemples : \ud83d\udc0d Script Python >>> crible ( 40 ) [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ] >>> crible ( 5 ) [ 2 , 3 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 33.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-34", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 34"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-341", "text": "Exercice 34.1 \u00c9nonc\u00e9 Correction Source Markdown Le nombre d\u2019occurrences d\u2019un caract\u00e8re dans une cha\u00eene de caract\u00e8re est le nombre d\u2019apparitions de ce caract\u00e8re dans la cha\u00eene. Exemples : le nombre d\u2019occurrences du caract\u00e8re \u2018o\u2019 dans \u2018bonjour\u2019 est 2 ; le nombre d\u2019occurrences du caract\u00e8re \u2018b\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; le nombre d\u2019occurrences du caract\u00e8re \u2018B\u2019 dans \u2018B\u00e9b\u00e9\u2019 est 1 ; le nombre d\u2019occurrences du caract\u00e8re \u2018 \u2018 dans \u2018Hello world !\u2019 est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs le nombre d\u2019occurrences de ces caract\u00e8res. Par exemple : avec la phrase 'Hello world !' le dictionnaire est le suivant : {'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1} L\u2019ordre des clefs n\u2019a pas d\u2019importance. \u00c9crire une fonction nbr_occurrences prenant comme param\u00e8tre une cha\u00eene de caract\u00e8res chaine et renvoyant le dictionnaire des nombres d\u2019occurrences des caract\u00e8res de cette cha\u00eene. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def nbr_occurrences ( chaine ): nb_occ = {} for caractere in chaine : if caractere in nb_occ : nb_occ [ caractere ] += 1 else : nb_occ [ caractere ] = 1 return nb_occ \ud83d\udccb Texte Le nombre d\u2019occurrences d\u2019un caract\u00e8re dans une cha\u00eene de caract\u00e8re est le nombre d\u2019apparitions de ce caract\u00e8re dans la cha\u00eene. Exemples : - le nombre d\u2019occurrences du caract\u00e8re `\u2018o\u2019` dans `\u2018bonjour\u2019` est 2 ; - le nombre d\u2019occurrences du caract\u00e8re `\u2018b\u2019` dans `\u2018B\u00e9b\u00e9\u2019` est 1 ; - le nombre d\u2019occurrences du caract\u00e8re `\u2018B\u2019` dans `\u2018B\u00e9b\u00e9\u2019` est 1 ; - le nombre d\u2019occurrences du caract\u00e8re `\u2018 \u2018` dans `\u2018Hello world !\u2019` est 2. On cherche les occurrences des caract\u00e8res dans une phrase. On souhaite stocker ces occurrences dans un dictionnaire dont les clefs seraient les caract\u00e8res de la phrase et les valeurs le nombre d\u2019occurrences de ces caract\u00e8res. Par exemple : avec la phrase `'Hello world !'` le dictionnaire est le suivant : `{'H': 1,'e': 1,'l': 3,'o': 2,' ': 2,'w': 1,'r': 1,'d': 1,'!': 1}` *L\u2019ordre des clefs n\u2019a pas d\u2019importance.* \u00c9crire une fonction `nbr_occurrences` prenant comme param\u00e8tre une cha\u00eene de caract\u00e8res `chaine` et renvoyant le dictionnaire des nombres d\u2019occurrences des caract\u00e8res de cette cha\u00eene. R\u00e9digez votre code sur Basthon", "title": "Exercice 34.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-342", "text": "Exercice 34.2 \u00c9nonc\u00e9 Correction Sources Markdown La fonction fusion prend deux tableaux tab1 , tab2 (type list ) d\u2019entiers tri\u00e9s par ordre croissant et les fusionne en un tableau tri\u00e9 tab12 qu\u2019elle renvoie. Compl\u00e9ter le code de la fonction fusion ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def fusion ( tab1 , tab2 ): '''Fusionne deux tableaux tri\u00e9s et renvoie le nouveau tableau tri\u00e9.''' n1 = len ( tab1 ) n2 = len ( tab2 ) tab12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ... : if tab1 [ i1 ] < tab2 [ i2 ]: tab12 [ i ] = ... i1 = ... else : tab12 [ i ] = tab2 [ i2 ] i2 = ... i += 1 while i1 < n1 : tab12 [ i ] = ... i1 = i1 + 1 i = ... while i2 < n2 : tab12 [ i ] = ... i2 = i2 + 1 i = ... return tab12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def fusion ( tab1 , tab2 ): n1 = len ( tab1 ) n2 = len ( tab2 ) tab12 = [ 0 ] * ( n1 + n2 ) i1 = 0 i2 = 0 i = 0 while i1 < n1 and i2 < n2 : if tab1 [ i1 ] < tab2 [ i2 ]: tab12 [ i ] = tab1 [ i1 ] i1 = i1 + 1 else : tab12 [ i ] = tab2 [ i2 ] i2 = i2 + 1 i += 1 while i1 < n1 : tab12 [ i ] = tab1 [ i1 ] i1 = i1 + 1 i = i + 1 while i2 < n2 : tab12 [ i ] = tab2 [ i2 ] i2 = i2 + 1 i = i + 1 return tab12 Markdown La fonction `fusion` prend deux tableaux `tab1` , `tab2` (type `list` ) d\u2019entiers tri\u00e9s par ordre croissant et les fusionne en un tableau tri\u00e9 `tab12` qu\u2019elle renvoie. Compl\u00e9ter le code de la fonction `fusion` ci-dessous. ```python linenums='1' def fusion(tab1,tab2): '''Fusionne deux tableaux tri\u00e9s et renvoie le nouveau tableau tri\u00e9.''' n1 = len(tab1) n2 = len(tab2) tab12 = [0] * (n1 + n2) i1 = 0 i2 = 0 i = 0 while i1 < n1 and ...: if tab1[i1] < tab2[i2]: tab12[i] = ... i1 = ... else: tab12[i] = tab2[i2] i2 = ... i += 1 while i1 < n1: tab12[i] = ... i1 = i1 + 1 i = ... while i2 < n2: tab12[i] = ... i2 = i2 + 1 i = ... return tab12 Compl\u00e9ter le code. Exemple : \ud83d\udc0d Script Python >>> fusion ([ 1 , 6 , 10 ],[ 0 , 7 , 8 , 9 ]) [ 0 , 1 , 6 , 7 , 8 , 9 , 10 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 34.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-35", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 35"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-351", "text": "Exercice 35.1 \u00c9nonc\u00e9 Correction Source Markdown On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux tableaux (de type list ) : l\u2019un pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : \ud83d\udc0d Script Python t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] \u00c9crire la fonction annee_temperature_minimale qui prend en param\u00e8tres ces deux tableaux et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. On suppose que la temp\u00e9rature minimale est atteinte une seule fois. Exemple : \ud83d\udc0d Script Python >>> annee_temperature_minimale ( t_moy , annees ) ( 12.5 , 2016 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 t_moy = [ 14.9 , 13.3 , 13.1 , 12.5 , 13.0 , 13.6 , 13.7 ] annees = [ 2013 , 2014 , 2015 , 2016 , 2017 , 2018 , 2019 ] def annee_temperature_minimale ( releve , date ): temp_mini = releve [ 0 ] date_mini = date [ 0 ] for i in range ( len ( releve )): if releve [ i ] < temp_mini : temp_mini = releve [ i ] date_mini = date [ i ] return temp_mini , date_mini \ud83d\udccb Texte On a relev\u00e9 les valeurs moyennes annuelles des temp\u00e9ratures \u00e0 Paris pour la p\u00e9riode allant de 2013 \u00e0 2019. Les r\u00e9sultats ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9s sous la forme de deux tableaux (de type `list`) : l\u2019un pour les temp\u00e9ratures, l\u2019autre pour les ann\u00e9es : ```python t_moy = [14.9, 13.3, 13.1, 12.5, 13.0, 13.6, 13.7] annees = [2013, 2014, 2015, 2016, 2017, 2018, 2019] ``` \u00c9crire la fonction `annee_temperature_minimale` qui prend en param\u00e8tres ces deux tableaux et qui renvoie la plus petite valeur relev\u00e9e au cours de la p\u00e9riode et l\u2019ann\u00e9e correspondante. On suppose que la temp\u00e9rature minimale est atteinte une seule fois. Exemple : ```python >>> annee_temperature_minimale(t_moy, annees) (12.5, 2016) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 35.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-352", "text": "Exercice 35.2 \u00c9nonc\u00e9 Correction Sources Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : kayak , radar , et non sont des mots palindromes. De m\u00eame certains nombres ont des \u00e9critures d\u00e9cimales qui sont des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous qui s\u2019appuient les unes sur les autres : inverse_chaine : qui renvoie une cha\u00eene de caract\u00e8res invers\u00e9e ; est_palindrome : qui teste si une cha\u00eene de caract\u00e8res est un palindrome ; est_nbre_palindrome : qui teste si un nombre est un palindrome. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def inverse_chaine ( chaine ): '''Retourne la chaine invers\u00e9e''' resultat = ... for caractere in chaine : resultat = ... return resultat def est_palindrome ( chaine ): '''Renvoie un bool\u00e9en indiquant si la chaine ch est un palindrome''' inverse = inverse_chaine ( chaine ) return ... def est_nbre_palindrome ( nbre ): '''Renvoie un bool\u00e9en indiquant si le nombre nbre est un palindrome''' chaine = ... return est_palindrome ( chaine ) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def inverse_chaine ( chaine ): '''Retourne la chaine invers\u00e9e''' resultat = '' for caractere in chaine : resultat = caractere + resultat return resultat def est_palindrome ( chaine ): '''Renvoie un bool\u00e9en indiquant si la chaine ch est un palindrome''' inverse = inverse_chaine ( chaine ) return chaine == inverse def est_nbre_palindrome ( nbre ): '''Renvoie un bool\u00e9en indiquant si le nombre nbre est un palindrome''' chaine = str ( nbre ) return est_palindrome ( chaine ) Markdown Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : *kayak* , *radar* , et *non* sont des mots palindromes. De m\u00eame certains nombres ont des \u00e9critures d\u00e9cimales qui sont des palindromes : 33, 121, 345543. L\u2019objectif de cet exercice est d\u2019obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci- dessous qui s\u2019appuient les unes sur les autres : - `inverse_chaine` : qui renvoie une cha\u00eene de caract\u00e8res invers\u00e9e ; - `est_palindrome` : qui teste si une cha\u00eene de caract\u00e8res est un palindrome ; - `est_nbre_palindrome` : qui teste si un nombre est un palindrome. Compl\u00e9ter le code des trois fonctions ci-dessous. ```python linenums='1' def inverse_chaine(chaine): '''Retourne la chaine invers\u00e9e''' resultat = ... for caractere in chaine: resultat = ... return resultat def est_palindrome(chaine): '''Renvoie un bool\u00e9en indiquant si la chaine ch est un palindrome''' inverse = inverse_chaine(chaine) return ... def est_nbre_palindrome(nbre): '''Renvoie un bool\u00e9en indiquant si le nombre nbre est un palindrome''' chaine = ... return est_palindrome(chaine) Exemples : \ud83d\udc0d Script Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbre_palindrome ( 214312 ) False >>> est_nbre_palindrome ( 213312 ) True ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 35.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-36", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 36"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-361", "text": "Exercice 36.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction occurrences(caractere, chaine) qui prend en param\u00e8tres caractere , une cha\u00eene de caract\u00e8re de longueur 1, et chaine , une cha\u00eene de carac- t\u00e8res. Cette fonction renvoie le nombre d\u2019occurrences de caractere dans chaine , c\u2019est-\u00e0-dire le nombre de fois o\u00f9 caractere appara\u00eet dans chaine . Exemples : \ud83d\udc0d Script Python >>> occurrences ( 'e' , \"sciences\" ) 2 >>> occurrences ( 'i' , \"mississippi\" ) 4 >>> occurrences ( 'a' , \"mississippi\" ) 0 \ud83d\udc0d Script Python 1 2 3 4 5 6 def occurrences ( caractere , chaine ): somme = 0 for lettre in chaine : if lettre == caractere : somme += 1 return somme \ud83d\udccb Texte \u00c9crire une fonction `occurrences(caractere, chaine)` qui prend en param\u00e8tres `caractere`, une cha\u00eene de caract\u00e8re de longueur 1, et `chaine`, une cha\u00eene de carac- t\u00e8res. Cette fonction renvoie le nombre d\u2019occurrences de `caractere` dans `chaine`, c\u2019est-\u00e0-dire le nombre de fois o\u00f9 `caractere` appara\u00eet dans `chaine`. Exemples : ```python >>> occurrences('e', \"sciences\") 2 >>> occurrences('i',\"mississippi\") 4 >>> occurrences('a',\"mississippi\") 0 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 36.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-362", "text": "Exercice 36.2 \u00c9nonc\u00e9 Correction Sources Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste valeurs = [100, 50, 20, 10, 5, 2, 1] . On suppose que les pi\u00e8ces et billets sont disponibles sans limitation. On cherche \u00e0 donner la liste des valeurs \u00e0 rendre pour une somme donn\u00e9e en argument. L\u2019algorithme utilis\u00e9 est de type glouton. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_glouton qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 valeurs = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( a_rendre , rang ): if a_rendre == 0 : return ... v = valeurs [ rang ] if v <= ... : return ... + rendu_glouton ( a_rendre - v , rang ) else : return rendu_glouton ( a_rendre , ... ) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 67 , 0 ) [ 50 , 10 , 5 , 2 ] >>> rendu_glouton ( 291 , 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] >>> rendu_glouton ( 291 , 1 ) # si on ne dispose pas de billets de 100 [ 50 , 50 , 50 , 50 , 50 , 20 , 20 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 valeurs = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_glouton ( a_rendre , rang ): if a_rendre == 0 : return [] v = valeurs [ rang ] if v <= a_rendre : return [ v ] + rendu_glouton ( a_rendre - v , rang ) else : return rendu_glouton ( a_rendre , rang + 1 ) Markdown On s\u2019int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d\u2019une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d\u2019une liste `valeurs = [100, 50, 20, 10, 5, 2, 1]`. On suppose que les pi\u00e8ces et billets sont disponibles sans limitation. On cherche \u00e0 donner la liste des valeurs \u00e0 rendre pour une somme donn\u00e9e en argument. L\u2019algorithme utilis\u00e9 est de type glouton. Compl\u00e9ter le code Python ci-dessous de la fonction `rendu_glouton` qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. ```python linenums='1' valeurs = [100, 50, 20, 10, 5, 2, 1] def rendu_glouton(a_rendre, rang): if a_rendre == 0: return ... v = valeurs[rang] if v <= ... : return ... + rendu_glouton(a_rendre - v, rang) else : return rendu_glouton(a_rendre, ...) On devra obtenir : \ud83d\udc0d Script Python >>> rendu_glouton ( 67 , 0 ) [ 50 , 10 , 5 , 2 ] >>> rendu_glouton ( 291 , 0 ) [ 100 , 100 , 50 , 20 , 20 , 1 ] >>> rendu_glouton ( 291 , 1 ) # si on ne dispose pas de billets de 100 [ 50 , 50 , 50 , 50 , 50 , 20 , 20 , 1 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 36.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-37", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 37"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-371", "text": "Exercice 37.1 \u00c9nonc\u00e9 Correction Source Markdown Programmer la fonction moyenne prenant en param\u00e8tre un tableau d'entiers tab (de type list ) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide. Proposer une fa\u00e7on de traiter le cas o\u00f9 le tableau pass\u00e9 en param\u00e8tre est vide. Dans cet exercice, on s\u2019interdira d\u2019utiliser la fonction Python sum . Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 5 , 3 , 8 ]) 5.333333333333333 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ]) 5.5 >>> moyenne ([]) # Comportement diff\u00e9rent suivant le traitement propos\u00e9. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def moyenne ( tab ): if tab == []: print ( 'Le tableau donn\u00e9 est vide' ) return None else : somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte Programmer la fonction ```moyenne``` prenant en param\u00e8tre un tableau d'entiers ```tab``` (de type `list`) qui renvoie la moyenne de ses \u00e9l\u00e9ments si le tableau est non vide. Proposer une fa\u00e7on de traiter le cas o\u00f9 le tableau pass\u00e9 en param\u00e8tre est vide. Dans cet exercice, on s\u2019interdira d\u2019utiliser la fonction Python `sum`. Exemples : ```python >>> moyenne([5,3,8]) 5.333333333333333 >>> moyenne([1,2,3,4,5,6,7,8,9,10]) 5.5 >>> moyenne([]) # Comportement diff\u00e9rent suivant le traitement propos\u00e9. ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 37.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-372", "text": "Exercice 37.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re un tableau d'entiers tab (de type list ) dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Au d\u00e9part, les zones ne contenant que des 0 et des 1 sont vides. Zone de 0 Zone non tri\u00e9e Zone de 1 Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Compl\u00e9ter la fonction tri suivante : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def tri ( tab ): '''tab est un tableau d'entiers contenant des 0 et des 1. La fonction trie ce tableau en pla\u00e7ant tous les 0 \u00e0 gauche''' i = ... # premier indice de la zone non tri\u00e9e j = ... # dernier indice de la zone non tri\u00e9e while i < j : if tab [ i ] == 0 : i = ... else : valeur = ... tab [ j ] = ... ... j = ... Exemple : \ud83d\udc0d Script Python >>> tab = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] >>> tri ( tab ) >>> tab [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def tri ( tab ): '''tab est un tableau d'entiers contenant des 0 et des 1. La fonction trie ce tableau en pla\u00e7ant tous les 0 \u00e0 gauche''' i = 0 # premier indice de la zone non tri\u00e9e j = len ( tab ) - 1 # dernier indice de la zone non tri\u00e9e while i < j : if tab [ i ] == 0 : i = i + 1 else : valeur = tab [ j ] tab [ j ] = tab [ i ] tab [ i ] = valeur j = j - 1 Markdown On consid\u00e8re un tableau d'entiers `tab` (de type `list` ) dont les \u00e9l\u00e9ments sont des `0` ou des `1` ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des `0` , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des `1` . Au d\u00e9part, les zones ne contenant que des `0` et des `1` sont vides. <table> <tr> <td>Zone de 0</td><td>Zone non tri\u00e9e</td><td>Zone de 1</td> </tr> </table> Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : - si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; - si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu\u2019il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Compl\u00e9ter la fonction `tri` suivante : ```python linenums='1' def tri(tab): '''tab est un tableau d'entiers contenant des 0 et des 1. La fonction trie ce tableau en pla\u00e7ant tous les 0 \u00e0 gauche''' i = ... # premier indice de la zone non tri\u00e9e j = ... # dernier indice de la zone non tri\u00e9e while i < j: if tab[i] == 0: i = ... else: valeur = ... tab[j] = ... ... j = ... Exemple : \ud83d\udc0d Script Python >>> tab = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] >>> tri ( tab ) >>> tab [ 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 37.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-38", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 38"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-381", "text": "Exercice 38.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction indices_maxi qui prend en param\u00e8tre un tableau non vide de nombre entiers tab , repr\u00e9sent\u00e9 par une liste Python et qui renvoie un tuple ( maxi , indices ) o\u00f9 : maxi est le plus grand \u00e9l\u00e9ment du tableau tab ; indices est une liste Python contenant les indices du tableau tab o\u00f9 appara\u00eet ce plus grand \u00e9l\u00e9ment. Exemple : \ud83d\udc0d Script Python >>> indices_maxi ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) ( 9 , [ 3 , 8 ]) >>> indices_maxi ([ 7 ]) ( 7 , [ 0 ]) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 def indices_maxi ( tab ): val_max = tab [ 0 ] ind_max = [] for i in range ( len ( tab )): if tab [ i ] > val_max : val_max = tab [ i ] for i in range ( len ( tab )): if tab [ i ] == val_max : ind_max . append ( i ) return ( val_max , ind_max ) \ud83d\udccb Texte \u00c9crire une fonction `indices_maxi` qui prend en param\u00e8tre un tableau non vide de nombre entiers `tab`, repr\u00e9sent\u00e9 par une liste Python et qui renvoie un tuple (`maxi`, `indices`) o\u00f9 : - `maxi` est le plus grand \u00e9l\u00e9ment du tableau `tab` ; - `indices` est une liste Python contenant les indices du tableau `tab` o\u00f9 appara\u00eet ce plus grand \u00e9l\u00e9ment. Exemple : ```python >>> indices_maxi([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) (9, [3, 8]) >>> indices_maxi([7]) (7, [0]) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 38.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-382", "text": "Exercice 38.2 \u00c9nonc\u00e9 Correction Sources Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es par des listes Python. Si pile est une pile, alors pile == [] indique si la pile est vide, pile.pop() retire et renvoie le sommet de la pile et pile.append(v) ajoute la valeur v au sommet de la pile. Si on consid\u00e8re qu\u2019une fonction manipule une pile, elle ne peut pas utiliser d\u2019autres op\u00e9ra- tions que celles d\u00e9crites ci-dessus. On cherche \u00e0 \u00e9crire une fonction positifs qui prend une pile de nombres entiers en param\u00e8tre et qui renvoie une nouvelle pile contenant les entiers positifs de la pile initiale, dans le m\u00eame ordre, quitte \u00e0 modifier la pile initiale. Pour cela, on va \u00e9galement \u00e9crire une fonction renverse qui prend une pile en param\u00e8tre et qui renvoie une nouvelle pile contenant les m\u00eames \u00e9l\u00e9ments que la pile initiale, mais dans l\u2019ordre inverse. Cette fonction sera \u00e9galement amen\u00e9e \u00e0 modifier la pile pass\u00e9e en param\u00e8tre. Compl\u00e9ter le code Python des fonctions renverse et positifs ci-apr\u00e8s \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def renverse ( pile ): '''renvoie une pile contenant les m\u00eames \u00e9l\u00e9ments que pile, mais dans l'ordre inverse. Cette fonction d\u00e9truit pile.''' pile_inverse = ... while pile != []: ... . append ( ... ) return ... def positifs ( pile ): '''renvoie une pile contenant les \u00e9l\u00e9ments positifs de pile, dans le m\u00eame ordre. Cette fonction d\u00e9truit pile.''' pile_positifs = ... while pile != []: ... = pile . pop () if ... >= 0 : ... return ... Exemple : \ud83d\udc0d Script Python >>> renverse ([ 1 , 2 , 3 , 4 , 5 ]) [ 5 , 4 , 3 , 2 , 1 ] >>> positifs ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) [ 0 , 5 , 4 , 10 , 9 ] >>> positifs ([ - 2 ]) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def renverse ( pile ): '''renvoie une pile contenant les m\u00eames \u00e9l\u00e9ments que pile, mais dans l'ordre inverse. Cette fonction d\u00e9truit pile.''' pile_inverse = [] while pile != []: pile_inverse . append ( pile . pop ()) return pile_inverse def positifs ( pile ): '''renvoie une pile contenant les \u00e9l\u00e9ments positifs de pile, dans le m\u00eame ordre. Cette fonction d\u00e9truit pile.''' pile_positifs = [] while pile != []: elt = pile . pop () if elt >= 0 : pile_positifs . append ( elt ) return renverse ( pile_positifs ) Markdown Cet exercice utilise des piles qui seront repr\u00e9sent\u00e9es par des listes Python. Si `pile` est une pile, alors `pile == []` indique si la pile est vide, `pile.pop()` retire et renvoie le sommet de la pile et `pile.append(v)` ajoute la valeur `v` au sommet de la pile. Si on consid\u00e8re qu\u2019une fonction manipule une pile, elle ne peut pas utiliser d\u2019autres op\u00e9ra- tions que celles d\u00e9crites ci-dessus. On cherche \u00e0 \u00e9crire une fonction `positifs` qui prend une pile de nombres entiers en param\u00e8tre et qui renvoie une nouvelle pile contenant les entiers positifs de la pile initiale, dans le m\u00eame ordre, quitte \u00e0 modifier la pile initiale. Pour cela, on va \u00e9galement \u00e9crire une fonction `renverse` qui prend une pile en param\u00e8tre et qui renvoie une nouvelle pile contenant les m\u00eames \u00e9l\u00e9ments que la pile initiale, mais dans l\u2019ordre inverse. Cette fonction sera \u00e9galement amen\u00e9e \u00e0 modifier la pile pass\u00e9e en param\u00e8tre. Compl\u00e9ter le code Python des fonctions `renverse` et `positifs` ci-apr\u00e8s ```python linenums='1' def renverse(pile): '''renvoie une pile contenant les m\u00eames \u00e9l\u00e9ments que pile, mais dans l'ordre inverse. Cette fonction d\u00e9truit pile.''' pile_inverse = ... while pile != []: ... .append(...) return ... def positifs(pile): '''renvoie une pile contenant les \u00e9l\u00e9ments positifs de pile, dans le m\u00eame ordre. Cette fonction d\u00e9truit pile.''' pile_positifs = ... while pile != []: ... = pile.pop() if ... >= 0: ... return ... Exemple : \ud83d\udc0d Script Python >>> renverse ([ 1 , 2 , 3 , 4 , 5 ]) [ 5 , 4 , 3 , 2 , 1 ] >>> positifs ([ - 1 , 0 , 5 , - 3 , 4 , - 6 , 10 , 9 , - 8 ]) [ 0 , 5 , 4 , 10 , 9 ] >>> positifs ([ - 2 ]) [] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 38.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-39", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 39"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-391", "text": "Exercice 39.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres elt un nombre entier et tab un tableau de nombres entiers (type list ), et qui renvoie l\u2019indice de la derni\u00e8re occurrence de elt dans tab si elt est dans tab et None sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ( 1 , [ 2 , 3 , 4 ]) # renvoie None >>> recherche ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> recherche ( 1 , [ 1 , 0 , 42 , 7 ]) 0 >>> recherche ( 1 , [ 1 , 50 , 1 ]) 2 >>> recherche ( 1 , [ 8 , 1 , 10 , 1 , 7 , 1 , 8 ]) 5 \ud83d\udc0d Script Python 1 2 3 4 5 def recherche ( elt , tab ): for i in range ( len ( tab ) - 1 , - 1 , - 1 ): if tab [ i ] == elt : return i return None \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres `elt` un nombre entier et `tab` un tableau de nombres entiers (type ```list``` ), et qui renvoie l\u2019indice de la derni\u00e8re occurrence de `elt` dans `tab` si `elt` est dans `tab` et `None` sinon. Exemples : ```python >>> recherche(1, [2, 3, 4]) # renvoie None >>> recherche(1, [10, 12, 1, 56]) 2 >>> recherche(1, [1, 0, 42, 7]) 0 >>> recherche(1, [1, 50, 1]) 2 >>> recherche(1, [8, 1, 10, 1, 7, 1, 8]) 5 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 39.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-392", "text": "Exercice 39.2 \u00c9nonc\u00e9 Correction Sources Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de 192.168.0.0 \u00e0 192.168.0.255 . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP 192.168.0.0 et 192.168.0.255 sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe AdresseIP . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class AdresseIP : def __init__ ( self , adresse ): self . adresse = ... def liste_octets ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" # Note : split d\u00e9coupe la chaine de caract\u00e8res # en fonction du s\u00e9parateur return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" reservees = [ ... ] return ... def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l'adresse self si elle existe et None sinon\"\"\" octets = ... if ... == 254 : return None octet_nouveau = ... + ... return AdresseIP ( '192.168.0.' + ... ) Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . liste_octets () [ 192 , 168 , 0 , 1 ] >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse # acces valide \u00e0 adresse # ici car on sait que l'adresse suivante existe '192.168.0.3' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class AdresseIP : def __init__ ( self , adresse ): self . adresse = adresse def liste_octets ( self ): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" # Note : split d\u00e9coupe la chaine de caract\u00e8res # en fonction du s\u00e9parateur return [ int ( i ) for i in self . adresse . split ( \".\" )] def est_reservee ( self ): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" reservees = [ '192.168.0.0' , '192.168.0.255' ] return self . adresse in reservees def adresse_suivante ( self ): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l'adresse self si elle existe et None sinon\"\"\" octets = self . liste_octets () if octets [ 3 ] == 254 : return None octet_nouveau = octets [ 3 ] + 1 return AdresseIP ( '192.168.0.' + str ( octet_nouveau )) adresse1 = AdresseIP ( '192.168.0.1' ) adresse2 = AdresseIP ( '192.168.0.2' ) adresse3 = AdresseIP ( '192.168.0.0' ) Markdown On d\u00e9finit une classe g\u00e9rant une adresse IPv4. On rappelle qu\u2019une adresse IPv4 est une adresse de longueur 4 octets, not\u00e9e en d\u00e9cimale \u00e0 point, en s\u00e9parant chacun des octets par un point. On consid\u00e8re un r\u00e9seau priv\u00e9 avec une plage d\u2019adresses IP de `192.168.0.0` \u00e0 `192.168.0.255` . On consid\u00e8re que les adresses IP saisies sont valides. Les adresses IP `192.168.0.0` et `192.168.0.255` sont des adresses r\u00e9serv\u00e9es. Le code ci-dessous impl\u00e9mente la classe `AdresseIP` . ```python linenums='1' class AdresseIP: def __init__ (self, adresse): self.adresse = ... def liste_octets(self): \"\"\"renvoie une liste de nombres entiers, la liste des octets de l'adresse IP\"\"\" # Note : split d\u00e9coupe la chaine de caract\u00e8res # en fonction du s\u00e9parateur return [int(i) for i in self.adresse.split(\".\")] def est_reservee(self): \"\"\"renvoie True si l'adresse IP est une adresse r\u00e9serv\u00e9e, False sinon\"\"\" reservees = [ ... ] return ... def adresse_suivante(self): \"\"\"renvoie un objet de AdresseIP avec l'adresse IP qui suit l'adresse self si elle existe et None sinon\"\"\" octets = ... if ... == 254: return None octet_nouveau = ... + ... return AdresseIP('192.168.0.' + ...) Compl\u00e9ter le code ci-dessus et instancier trois objets : adresse1 , adresse2 , adresse3 avec respectivement les arguments suivants : '192.168.0.1' , '192.168.0.2' , '192.168.0.0' V\u00e9rifier que : \ud83d\udc0d Script Python >>> adresse1 . liste_octets () [ 192 , 168 , 0 , 1 ] >>> adresse1 . est_reservee () False >>> adresse3 . est_reservee () True >>> adresse2 . adresse_suivante () . adresse # acces valide \u00e0 adresse # ici car on sait que l'adresse suivante existe '192.168.0.3' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 39.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-40", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 40"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-401", "text": "Exercice 40.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re des tables, c\u2019est-\u00e0-dire des tableaux de dictionnaires ayant tous les m\u00eames cl\u00e9s, qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont 'nom' , 'espece' , 'age' , 'enclos' . Voici un exemple d'une telle table : \ud83d\udc0d Script Python animaux = [ { 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }, { 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Tom' , 'espece' : 'chat' , 'age' : 7 , 'enclos' : 4 }, { 'nom' : 'Belle' , 'espece' : 'chien' , 'age' : 6 , 'enclos' : 3 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] Programmer une fonction selection_enclos qui : prend en param\u00e8tres : une table animaux contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), un num\u00e9ro d'enclos num_enclos ; renvoie une table contenant les enregistrements de animaux dont l'attribut 'enclos' est num_enclos . Exemples avec la table animaux ci-dessus : \ud83d\udc0d Script Python >>> selection_enclos ( animaux , 5 ) [{ 'nom' : 'Titine' , 'espece' : 'chat' , 'age' : 2 , 'enclos' : 5 }, { 'nom' : 'Mirza' , 'espece' : 'chat' , 'age' : 6 , 'enclos' : 5 }] >>> selection_enclos ( animaux , 2 ) [{ 'nom' : 'Medor' , 'espece' : 'chien' , 'age' : 5 , 'enclos' : 2 }] >>> selection_enclos ( animaux , 7 ) [] \ud83d\udc0d Script Python 1 2 3 4 5 6 def selection_enclos ( animaux , num_enclos ): table = [] for animal in animaux : if animal [ 'enclos' ] == num_enclos : table . append ( animal ) return table \ud83d\udccb Texte On consid\u00e8re des tables, c\u2019est-\u00e0-dire des tableaux de dictionnaires ayant tous les m\u00eames cl\u00e9s, qui contiennent des enregistrements relatifs \u00e0 des animaux h\u00e9berg\u00e9s dans un refuge. Les attributs des enregistrements sont `'nom'`, `'espece'`, `'age'`, `'enclos'`. Voici un exemple d'une telle table : ```python animaux = [ {'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}, {'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Tom', 'espece':'chat', 'age':7, 'enclos':4}, {'nom':'Belle', 'espece':'chien', 'age':6, 'enclos':3}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] ``` Programmer une fonction `selection_enclos` qui : - prend en param\u00e8tres : - une table `animaux` contenant des enregistrements relatifs \u00e0 des animaux (comme dans l'exemple ci-dessus), - un num\u00e9ro d'enclos `num_enclos` ; - renvoie une table contenant les enregistrements de `animaux` dont l'attribut `'enclos'` est `num_enclos`. Exemples avec la table `animaux` ci-dessus : ```python >>> selection_enclos(animaux, 5) [{'nom':'Titine', 'espece':'chat', 'age':2, 'enclos':5}, {'nom':'Mirza', 'espece':'chat', 'age':6, 'enclos':5}] >>> selection_enclos(animaux, 2) [{'nom':'Medor', 'espece':'chien', 'age':5, 'enclos':2}] >>> selection_enclos(animaux, 7) [] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 40.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-402", "text": "Exercice 40.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois \u00e0 la suite, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : \ud83d\udc0d Script Python tab_a = [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] #l'intrus est 7 tab_b = [ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ] #l'intrus est 8 tab_c = [ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme ceux ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Par exemple, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 12, on voit les valeurs 2 et 4 qui sont diff\u00e9rentes : l\u2019intrus est donc \u00e0 gauche de l\u2019indice 12 (indice 12 compris) En revanche, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 3, on voit les valeurs 9 et 9 qui sont identiques : l\u2019intrus est donc \u00e0 droite des indices 3-4-5, donc \u00e0 partir de l\u2019indice 6. Compl\u00e9ter la fonction r\u00e9cursive trouver_intrus propos\u00e9e page suivante qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return tab [ g ] else : nombre_de_triplets = ( d - g ) // 3 indice = g + 3 * ( nombre_de_triplets // 2 ) if tab [ indice ] != tab [ indice + 1 ] : return trouver_intrus ( tab , g , indice ) else : return trouver_intrus ( tab , indice + 3 , d ) Markdown On consid\u00e8re des tableaux de nombres dont tous les \u00e9l\u00e9ments sont pr\u00e9sents exactement trois fois \u00e0 la suite, sauf un \u00e9l\u00e9ment qui est pr\u00e9sent une unique fois et que l'on appelle \u00ab l'intrus \u00bb. Voici quelques exemples : ```python tab_a = [3, 3, 3, 9, 9, 9, 1, 1, 1, 7, 2, 2, 2, 4, 4, 4, 8, 8, 8, 5, 5, 5] #l'intrus est 7 tab_b = [8, 5, 5, 5, 9, 9, 9, 18, 18, 18, 3, 3, 3] #l'intrus est 8 tab_c = [5, 5, 5, 1, 1, 1, 0, 0, 0, 6, 6, 6, 3, 8, 8, 8] #l'intrus est 3 On remarque qu'avec de tels tableaux : pour les indices multiples de 3 situ\u00e9s strictement avant l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite sont \u00e9gaux, pour les indices multiples de 3 situ\u00e9s apr\u00e8s l'intrus, l'\u00e9l\u00e9ment correspondant et son voisin de droite - s'il existe - sont diff\u00e9rents. Ce que l'on peut observer ci-dessous en observant les valeurs des paires de voisins marqu\u00e9es par des caract\u00e8res ^ : \ud83d\udc0d Script Python [ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ] ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 0 3 6 9 12 15 18 21 Dans des listes comme ceux ci-dessus, un algorithme r\u00e9cursif pour trouver l'intrus consiste alors \u00e0 choisir un indice i multiple de 3 situ\u00e9 approximativement au milieu des indices parmi lesquels se trouve l'intrus. Puis, en fonction des valeurs de l'\u00e9l\u00e9ment d'indice i et de son voisin de droite, \u00e0 appliquer r\u00e9cursivement l'algorithme \u00e0 la moiti\u00e9 droite ou \u00e0 la moiti\u00e9 gauche des indices parmi lesquels se trouve l'intrus. Par exemple, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 12, on voit les valeurs 2 et 4 qui sont diff\u00e9rentes : l\u2019intrus est donc \u00e0 gauche de l\u2019indice 12 (indice 12 compris) En revanche, si on s\u2019int\u00e9resse \u00e0 l\u2019indice 3, on voit les valeurs 9 et 9 qui sont identiques : l\u2019intrus est donc \u00e0 droite des indices 3-4-5, donc \u00e0 partir de l\u2019indice 6. Compl\u00e9ter la fonction r\u00e9cursive trouver_intrus propos\u00e9e page suivante qui met en \u0153uvre cet algorithme. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def trouver_intrus ( tab , g , d ): ''' Renvoie la valeur de l'intrus situ\u00e9 entre les indices g et d dans la liste tab o\u00f9 : tab v\u00e9rifie les conditions de l'exercice, g et d sont des multiples de 3. ''' if g == d : return ... else : nombre_de_triplets = ( d - g ) // ... indice = g + 3 * ( nombre_de_triplets // 2 ) if ... : return ... else : return ... Exemples : \ud83d\udc0d Script Python >>> trouver_intrus ([ 3 , 3 , 3 , 9 , 9 , 9 , 1 , 1 , 1 , 7 , 2 , 2 , 2 , 4 , 4 , 4 , 8 , 8 , 8 , 5 , 5 , 5 ], 0 , 21 ) 7 >>> trouver_intrus ([ 8 , 5 , 5 , 5 , 9 , 9 , 9 , 18 , 18 , 18 , 3 , 3 , 3 ], 0 , 12 ) 8 >>> trouver_intrus ([ 5 , 5 , 5 , 1 , 1 , 1 , 0 , 0 , 0 , 6 , 6 , 6 , 3 , 8 , 8 , 8 ], 0 , 15 ) 3 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 40.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-41", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 41"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-411", "text": "Exercice 41.1 \u00c9nonc\u00e9 Correction Source Markdown Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None , soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe Noeud donn\u00e9e ci-dessous. \ud83d\udc0d Script Python class Noeud : def __init__ ( self , etiquette , gauche , droit ): self . v = etiquette self . gauche = gauche self . droit = droit L\u2019arbre ci-dessus sera donc impl\u00e9ment\u00e9 de la mani\u00e8re suivante : \ud83d\udc0d Script Python a = Noeud ( 1 , Noeud ( 4 , None , None ), Noeud ( 0 , None , Noeud ( 7 , None , None ))) \u00c9crire une fonction r\u00e9cursive taille prenant en param\u00e8tre un arbre a et qui renvoie la taille de l\u2019arbre que cette instance impl\u00e9mente. \u00c9crire de m\u00eame une fonction r\u00e9cursive hauteur prenant en param\u00e8tre un arbre a et qui renvoie la hauteur de l\u2019arbre que cette instance impl\u00e9mente. On consid\u00e8re que la hauteur d\u2019un arbre vide est -1 et la taille d\u2019un arbre vide est 0. Exemples : \ud83d\udc0d Script Python >>> hauteur ( a ) 2 >>> taille ( a ) 4 >>> hauteur ( None ) - 1 >>> taille ( None ) 0 >>> hauteur ( Noeud ( 1 , None , None )) 0 >>> taille ( Noeud ( 1 , None , None )) 1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Noeud : def __init__ ( self , etiquette , gauche , droit ): self . v = etiquette self . gauche = gauche self . droit = droit a = Noeud ( 1 , Noeud ( 4 , None , None ), Noeud ( 0 , None , Noeud ( 7 , None , None ))) def taille ( a ): if a is None : return 0 return 1 + taille ( a . gauche ) + taille ( a . droit ) def hauteur ( a ): if a is None : return - 1 return 1 + max ( hauteur ( a . gauche ), hauteur ( a . droit )) \ud83d\udccb Texte Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur `None`, soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe `Noeud` donn\u00e9e ci-dessous. ```python class Noeud: def __init__(self, etiquette, gauche, droit): self.v = etiquette self.gauche = gauche self.droit = droit ``` ![image](data2023/29_arbre1.png){: .center} L\u2019arbre ci-dessus sera donc impl\u00e9ment\u00e9 de la mani\u00e8re suivante : ```python a = Noeud(1, Noeud(4, None, None), Noeud(0, None, Noeud(7, None, None))) ``` \u00c9crire une fonction r\u00e9cursive `taille` prenant en param\u00e8tre un arbre `a` et qui renvoie la taille de l\u2019arbre que cette instance impl\u00e9mente. \u00c9crire de m\u00eame une fonction r\u00e9cursive `hauteur` prenant en param\u00e8tre un arbre `a` et qui renvoie la hauteur de l\u2019arbre que cette instance impl\u00e9mente. On consid\u00e8re que la hauteur d\u2019un arbre vide est -1 et la taille d\u2019un arbre vide est 0. Exemples : ```python >>> hauteur(a) 2 >>> taille(a) 4 >>> hauteur(None) -1 >>> taille(None) 0 >>> hauteur(Noeud(1, None, None)) 0 >>> taille(Noeud(1, None, None)) 1 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 41.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-412", "text": "Exercice 41.2 \u00c9nonc\u00e9 Correction Sources Markdown On rappelle que les tableaux sont repr\u00e9sent\u00e9s par des listes en Python du type list . Le but de cet exercice est d\u2019\u00e9crire une fonction ajoute qui prend en param\u00e8tres trois arguments indice , element et tab et renvoie un tableau tab_ins dans lequel les \u00e9l\u00e9ments sont ceux du tableau tab avec, en plus, l\u2019\u00e9l\u00e9ment element \u00e0 l\u2019indice indice . On consid\u00e8re que les variables indice et element sont des entiers positifs et que les \u00e9l\u00e9ments de tab sont \u00e9galement des entiers. En r\u00e9alisant cette insertion, Les \u00e9l\u00e9ments du tableau tab dont les indices sont sup\u00e9rieurs ou \u00e9gaux \u00e0 indice apparaissent d\u00e9cal\u00e9s vers la droite dans le tableau tab_ins . Si indice est \u00e9gal au nombre d\u2019\u00e9l\u00e9ments du tableau tab , l\u2019\u00e9l\u00e9ment element est ajout\u00e9 dans tab_ins apr\u00e8s tous les \u00e9l\u00e9ments du tableau tab . Exemples : \ud83d\udc0d Script Python >>> ajoute ( 1 , 4 , [ 7 , 8 , 9 ]) [ 7 , 4 , 8 , 9 ] >>> ajoute ( 3 , 4 , [ 7 , 8 , 9 ]) [ 7 , 8 , 9 , 4 ] >>> ajoute ( 0 , 4 , [ 7 , 8 , 9 ]) [ 4 , 7 , 8 , 9 ] Compl\u00e9ter et tester le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def ajoute ( indice , element , tab ): '''Renvoie un nouveau tableau obtenu en ins\u00e9rant element \u00e0 l'indice indice dans le tableau tab.''' nbre_elts = len ( tab ) tab_ins = [ 0 ] * ( nbre_elts + 1 ) for i in range ( indice ): tab_ins [ i ] = ... tab_ins [ ... ] = ... for i in range ( indice + 1 , nbre_elts + 1 ): tab_ins [ i ] = ... return tab_ins \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def ajoute ( indice , element , tab ): '''Renvoie un nouveau tableau obtenu en ins\u00e9rant element \u00e0 l'indice indice dans le tableau tab.''' nbre_elts = len ( tab ) tab_ins = [ 0 ] * ( nbre_elts + 1 ) for i in range ( indice ): tab_ins [ i ] = tab [ i ] tab_ins [ indice ] = element for i in range ( indice + 1 , nbre_elts + 1 ): tab_ins [ i ] = tab [ i - 1 ] return tab_ins Markdown On rappelle que les tableaux sont repr\u00e9sent\u00e9s par des listes en Python du type `list` . Le but de cet exercice est d\u2019\u00e9crire une fonction ajoute qui prend en param\u00e8tres trois arguments `indice` , `element` et `tab` et renvoie un tableau `tab_ins` dans lequel les \u00e9l\u00e9ments sont ceux du tableau `tab` avec, en plus, l\u2019\u00e9l\u00e9ment `element` \u00e0 l\u2019indice `indice` . On consid\u00e8re que les variables `indice` et `element` sont des entiers positifs et que les \u00e9l\u00e9ments de `tab` sont \u00e9galement des entiers. En r\u00e9alisant cette insertion, Les \u00e9l\u00e9ments du tableau `tab` dont les indices sont sup\u00e9rieurs ou \u00e9gaux \u00e0 `indice` apparaissent d\u00e9cal\u00e9s vers la droite dans le tableau `tab_ins` . Si `indice` est \u00e9gal au nombre d\u2019\u00e9l\u00e9ments du tableau `tab` , l\u2019\u00e9l\u00e9ment `element` est ajout\u00e9 dans `tab_ins` apr\u00e8s tous les \u00e9l\u00e9ments du tableau `tab` . Exemples : ```python >>> ajoute(1, 4, [7, 8, 9]) [7, 4, 8, 9] >>> ajoute(3, 4, [7, 8, 9]) [7, 8, 9, 4] >>> ajoute(0, 4, [7, 8, 9]) [4, 7, 8, 9] Compl\u00e9ter et tester le code ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def ajoute ( indice , element , tab ): '''Renvoie un nouveau tableau obtenu en ins\u00e9rant element \u00e0 l'indice indice dans le tableau tab.''' nbre_elts = len ( tab ) tab_ins = [ 0 ] * ( nbre_elts + 1 ) for i in range ( indice ): tab_ins [ i ] = ... tab_ins [ ... ] = ... for i in range ( indice + 1 , nbre_elts + 1 ): tab_ins [ i ] = ... return tab_ins ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 41.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-42", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 42"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-421", "text": "Exercice 42.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction moyenne qui prend en param\u00e8tre un tableau d\u2019entiers non vide et qui renvoie un nombre flottant donnant la moyenne de ces entiers. Attention : il est interdit d\u2019utiliser la fonction sum ou la fonction mean (module statistics ) de Python. Exemples : \ud83d\udc0d Script Python >>> moyenne ([ 1 ]) 1.0 >>> moyenne ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]) 4.0 >>> moyenne ([ 1 , 2 ]) 1.5 \ud83d\udc0d Script Python 1 2 3 4 5 def moyenne ( tab ): somme = 0 for elt in tab : somme += elt return somme / len ( tab ) \ud83d\udccb Texte \u00c9crire une fonction `moyenne` qui prend en param\u00e8tre un tableau d\u2019entiers non vide et qui renvoie un nombre flottant donnant la moyenne de ces entiers. **Attention** : il est interdit d\u2019utiliser la fonction `sum` ou la fonction `mean` (module `statistics`) de Python. Exemples : ```python >>> moyenne([1]) 1.0 >>> moyenne([1, 2, 3, 4, 5, 6, 7]) 4.0 >>> moyenne([1, 2]) 1.5 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 42.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-422", "text": "Exercice 42.2 \u00c9nonc\u00e9 Correction Sources Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def dichotomie ( tab , x ): \"\"\"applique une recherche dichotomique pour d\u00e9terminer si x est dans le tableau tri\u00e9 tab. La fonction renvoie True si tab contient x et False sinon\"\"\" debut = 0 fin = ... while debut <= fin : m = ... if x == tab [ m ]: return ... if x > tab [ m ]: debut = ... else : fin = ... return False Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) False >>> dichotomie ([], 28 ) False \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def dichotomie ( tab , x ): \"\"\"applique une recherche dichotomique pour d\u00e9terminer si x est dans le tableau tri\u00e9 tab. La fonction renvoie True si tab contient x et False sinon\"\"\" debut = 0 fin = len ( tab ) - 1 while debut <= fin : m = ( debut + fin ) // 2 if x == tab [ m ]: return True if x > tab [ m ]: debut = m + 1 else : fin = m - 1 return False Markdown Le but de l'exercice est de compl\u00e9ter une fonction qui d\u00e9termine si une valeur est pr\u00e9sente dans un tableau de valeurs tri\u00e9es dans l'ordre croissant. Compl\u00e9ter l'algorithme de dichotomie donn\u00e9 ci-apr\u00e8s. ```python linenums='1' def dichotomie(tab, x): \"\"\"applique une recherche dichotomique pour d\u00e9terminer si x est dans le tableau tri\u00e9 tab. La fonction renvoie True si tab contient x et False sinon\"\"\" debut = 0 fin = ... while debut <= fin: m = ... if x == tab[m]: return ... if x > tab[m]: debut = ... else: fin = ... return False Exemples : \ud83d\udc0d Script Python >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 28 ) True >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 27 ) False >>> dichotomie ([ 15 , 16 , 18 , 19 , 23 , 24 , 28 , 29 , 31 , 33 ], 1 ) False >>> dichotomie ([], 28 ) False ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 42.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-43", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 43"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-431", "text": "Exercice 43.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction a_doublon qui prend en param\u00e8tre un tableau tri\u00e9 de nombres dans l\u2019ordre croissant et renvoie True si ce tableau contient au moins deux nombres identiques, False sinon. Exemple : \ud83d\udc0d Script Python >>> a_doublon ([]) False >>> a_doublon ([ 1 ]) False >>> a_doublon ([ 1 , 2 , 4 , 6 , 6 ]) True >>> a_doublon ([ 2 , 5 , 7 , 7 , 7 , 9 ]) True >>> a_doublon ([ 0 , 2 , 3 ]) False \ud83d\udc0d Script Python 1 2 3 4 5 def a_doublon ( tab ): for i in range ( len ( tab ) - 1 ): if tab [ i ] == tab [ i + 1 ]: return True return False \ud83d\udccb Texte \u00c9crire une fonction `a_doublon` qui prend en param\u00e8tre un tableau **tri\u00e9** de nombres dans l\u2019ordre croissant et renvoie `True` si ce tableau contient au moins deux nombres identiques, `False` sinon. Exemple : ```python >>> a_doublon([]) False >>> a_doublon([1]) False >>> a_doublon([1, 2, 4, 6, 6]) True >>> a_doublon([2, 5, 7, 7, 7, 9]) True >>> a_doublon([0, 2, 3]) False ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 43.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-432", "text": "Exercice 43.2 \u00c9nonc\u00e9 Correction Sources Markdown On souhaite g\u00e9n\u00e9rer des grilles du jeu de d\u00e9mineur \u00e0 partir de la position des bombes \u00e0 placer. On se limite \u00e0 la g\u00e9n\u00e9ration de grilles carr\u00e9es de taille \\(n \\times n\\) o\u00f9 \\(n\\) est le nombre de bombes du jeu. Dans le jeu du d\u00e9mineur, chaque case de la grille contient soit une bombe, soit une valeur qui correspond aux nombres de bombes situ\u00e9es dans le voisinage direct de la case (au- dessus, en dessous, \u00e0 droite, \u00e0 gauche ou en diagonale : chaque case a donc 8 voisins si elle n'est pas situ\u00e9e au bord de la grille). Voici un exemple de grille \\(5 \\times 5\\) de d\u00e9mineur dans laquelle la bombe est repr\u00e9sent\u00e9e par une \u00e9toile : On utilise une liste de listes pour repr\u00e9senter la grille et on choisit de coder une bombe par la valeur -1. L'exemple ci-contre sera donc cod\u00e9 par la liste : \ud83d\udc0d Script Python [[ 1 , 1 , 1 , 0 , 0 ], [ 1 , - 1 , 1 , 1 , 1 ], [ 2 , 2 , 3 , 2 , - 1 ], [ 1 , - 1 , 2 , - 1 , 3 ], [ 1 , 1 , 2 , 2 , - 1 ]] Compl\u00e9ter le code suivant afin de g\u00e9n\u00e9rer des grilles de d\u00e9mineur, on pourra v\u00e9rifier que l'appel genere_grille([(1, 1), (2, 4), (3, 1), (3, 3), (4, 4)]) renvoie bien la liste donn\u00e9e en exemple. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = ... for l , c in voisins : if grille [ l ][ c ] != ... : # si ce n'est pas une bombe ... # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = ... # place la bombe ... # incr\u00e9mente ses voisins return grille \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = voisinage ( len ( grille ), ligne , colonne ) for l , c in voisins : if grille [ l ][ c ] != - 1 : # si ce n'est pas une bombe grille [ l ][ c ] += 1 # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = - 1 # place la bombe incremente_voisins ( grille , ligne , colonne ) # incr\u00e9mente ses voisins return grille Markdown On souhaite g\u00e9n\u00e9rer des grilles du jeu de d\u00e9mineur \u00e0 partir de la position des bombes \u00e0 placer. On se limite \u00e0 la g\u00e9n\u00e9ration de grilles carr\u00e9es de taille $n \\times n$ o\u00f9 $n$ est le nombre de bombes du jeu. Dans le jeu du d\u00e9mineur, chaque case de la grille contient soit une bombe, soit une valeur qui correspond aux nombres de bombes situ\u00e9es dans le voisinage direct de la case (au- dessus, en dessous, \u00e0 droite, \u00e0 gauche ou en diagonale : chaque case a donc 8 voisins si elle n'est pas situ\u00e9e au bord de la grille). Voici un exemple de grille $5 \\times 5$ de d\u00e9mineur dans laquelle la bombe est repr\u00e9sent\u00e9e par une \u00e9toile : ![ image ]( data2023/04grille.png ){: .center} On utilise une liste de listes pour repr\u00e9senter la grille et on choisit de coder une bombe par la valeur -1. L'exemple ci-contre sera donc cod\u00e9 par la liste : ```python [[1, 1, 1, 0, 0], [1, -1, 1, 1, 1], [2, 2, 3, 2, -1], [1, -1, 2, -1, 3], [1, 1, 2, 2, -1]] Compl\u00e9ter le code suivant afin de g\u00e9n\u00e9rer des grilles de d\u00e9mineur, on pourra v\u00e9rifier que l'appel genere_grille([(1, 1), (2, 4), (3, 1), (3, 3), (4, 4)]) renvoie bien la liste donn\u00e9e en exemple. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def voisinage ( n , ligne , colonne ): \"\"\" Renvoie la liste des coordonn\u00e9es des voisins de la case (ligne, colonne) en g\u00e9rant les cases sur les bords. \"\"\" voisins = [] for l in range ( max ( 0 , ligne - 1 ), min ( n , ligne + 2 )): for c in range ( max ( 0 , colonne - 1 ), min ( n , colonne + 2 )): if ( l , c ) != ( ligne , colonne ): voisins . append (( l , c )) return voisins def incremente_voisins ( grille , ligne , colonne ): \"\"\" Incr\u00e9mente de 1 toutes les cases voisines d'une bombe.\"\"\" voisins = ... for l , c in voisins : if grille [ l ][ c ] != ... : # si ce n'est pas une bombe ... # on ajoute 1 \u00e0 sa valeur def genere_grille ( bombes ): \"\"\" Renvoie une grille de d\u00e9mineur de taille nxn o\u00f9 n est le nombre de bombes, en pla\u00e7ant les bombes \u00e0 l'aide de la liste bombes de coordonn\u00e9es (tuples) pass\u00e9e en param\u00e8tre. \"\"\" n = len ( bombes ) # Initialisation d'une grille nxn remplie de 0 grille = [[ 0 for colonne in range ( n )] for ligne in range ( n )] # Place les bombes et calcule les valeurs des autres cases for ligne , colonne in bombes : grille [ ligne ][ colonne ] = ... # place la bombe ... # incr\u00e9mente ses voisins return grille ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 43.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-44", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 44"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-441", "text": "Exercice 44.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction enumere qui prend en param\u00e8tre un tableau tab (type list ) et renvoie un dictionnaire d dont les cl\u00e9s sont les \u00e9l\u00e9ments de tab avec pour valeur associ\u00e9e la liste des indices de l\u2019\u00e9l\u00e9ment dans le tableau tab . Exemple : \ud83d\udc0d Script Python >>> enumere ([]) {} >>> enumere ([ 1 , 2 , 3 ]) { 1 : [ 0 ], 2 : [ 1 ], 3 : [ 2 ]} >>> enumere ([ 1 , 1 , 2 , 3 , 2 , 1 ]) { 1 : [ 0 , 1 , 5 ], 2 : [ 2 , 4 ], 3 : [ 3 ]} \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def enumere ( tab ): d = {} for i in range ( len ( tab )): if tab [ i ] in d : d [ tab [ i ]] . append ( i ) else : d [ tab [ i ]] = [ i ] return d \ud83d\udccb Texte \u00c9crire une fonction `enumere` qui prend en param\u00e8tre un tableau `tab` (type `list`) et renvoie un dictionnaire `d` dont les cl\u00e9s sont les \u00e9l\u00e9ments de `tab` avec pour valeur associ\u00e9e la liste des indices de l\u2019\u00e9l\u00e9ment dans le tableau `tab`. Exemple : ```python >>> enumere([]) {} >>> enumere([1, 2, 3]) {1: [0], 2: [1], 3: [2]} >>> enumere([1, 1, 2, 3, 2, 1]) {1: [0, 1, 5], 2: [2, 4], 3: [3]} ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 44.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-442", "text": "Exercice 44.2 \u00c9nonc\u00e9 Correction Sources Markdown Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur None , soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe Noeud donn\u00e9e ci-dessous. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Noeud : \"\"\"Classe repr\u00e9sentant un noeud d'un arbre binaire\"\"\" def __init__ ( self , etiquette , gauche , droit ): \"\"\"Cr\u00e9e un noeud de valeur etiquette avec gauche et droit comme fils.\"\"\" self . etiquette = etiquette self . gauche = gauche self . droit = droit def parcours ( arbre , liste ): \"\"\"parcours r\u00e9cursivement l'arbre en ajoutant les \u00e9tiquettes de ses noeuds \u00e0 la liste pass\u00e9e en argument en ordre infixe.\"\"\" if arbre != None : parcours ( arbre . gauche , liste ) liste . append ( arbre . etiquette ) parcours ( arbre . droit , liste ) return liste La fonction r\u00e9cursive parcours renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre impl\u00e9- ment\u00e9 par l\u2019instance arbre dans l\u2019ordre du parcours en profondeur infixe \u00e0 partir d\u2019une liste vide pass\u00e9e en argument. Compl\u00e9ter le code de la fonction insere , pr\u00e9sent\u00e9 page suivante, qui prend en argument un arbre binaire de recherche arbre repr\u00e9sent\u00e9 ainsi et une \u00e9tiquette cle , non pr\u00e9sente dans l\u2019arbre, et qui : renvoie une nouvelle feuille d\u2019\u00e9tiquette cle s\u2019il est vide ; renvoie l\u2019arbre apr\u00e8s l\u2019avoir modifi\u00e9 en ins\u00e9rant cle sinon ; garantit que l\u2019arbre ainsi compl\u00e9t\u00e9 soit encore un arbre binaire de recherche. Tester ensuite ce code en utilisant la fonction parcours et en ins\u00e9rant successivement des n\u0153uds d\u2019\u00e9tiquette 1, 4, 6 et 8 dans l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci- dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def insere ( arbre , cle ): \"\"\"insere la cle dans l'arbre binaire de recherche repr\u00e9sent\u00e9 par arbre. Retourne l'arbre modifi\u00e9.\"\"\" if arbre == None : return Noeud ( cle , None , None ) # creation d'une feuille else : if ... : arbre . gauche = insere ( arbre . gauche , cle ) else : arbre . droit = ... return arbre \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def insere ( arbre , cle ): \"\"\"insere la cle dans l'arbre binaire de recherche repr\u00e9sent\u00e9 par arbre. Retourne l'arbre modifi\u00e9.\"\"\" if arbre == None : return Noeud ( cle , None , None ) # creation d'une feuille else : if cle < arbre . etiquette : arbre . gauche = insere ( arbre . gauche , cle ) else : arbre . droit = insere ( arbre . droit , cle ) return arbre Tests : \ud83d\udc0d Script Python >>> a = Noeud ( 5 , None , None ) >>> a = insere ( a , 2 ) >>> a = insere ( a , 3 ) >>> a = insere ( a , 7 ) >>> parcours ( a , []) [ 2 , 3 , 5 , 7 ] >>> a = insere ( a , 1 ) >>> a = insere ( a , 4 ) >>> a = insere ( a , 6 ) >>> a = insere ( a , 8 ) >>> parcours ( a , []) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] Markdown Un arbre binaire est soit vide, repr\u00e9sent\u00e9 en Python par la valeur `None` , soit un n\u0153ud, contenant une \u00e9tiquette et deux sous-arbres gauche et droit et repr\u00e9sent\u00e9 par une instance de la classe `Noeud` donn\u00e9e ci-dessous. ```python linenums='1' class Noeud: \"\"\"Classe repr\u00e9sentant un noeud d'un arbre binaire\"\"\" def __init__ (self, etiquette, gauche, droit): \"\"\"Cr\u00e9e un noeud de valeur etiquette avec gauche et droit comme fils.\"\"\" self.etiquette = etiquette self.gauche = gauche self.droit = droit def parcours(arbre, liste): \"\"\"parcours r\u00e9cursivement l'arbre en ajoutant les \u00e9tiquettes de ses noeuds \u00e0 la liste pass\u00e9e en argument en ordre infixe.\"\"\" if arbre != None: parcours(arbre.gauche, liste) liste.append(arbre.etiquette) parcours(arbre.droit, liste) return liste La fonction r\u00e9cursive parcours renvoie la liste des \u00e9tiquettes des n\u0153uds de l\u2019arbre impl\u00e9- ment\u00e9 par l\u2019instance arbre dans l\u2019ordre du parcours en profondeur infixe \u00e0 partir d\u2019une liste vide pass\u00e9e en argument. Compl\u00e9ter le code de la fonction insere , pr\u00e9sent\u00e9 page suivante, qui prend en argument un arbre binaire de recherche arbre repr\u00e9sent\u00e9 ainsi et une \u00e9tiquette cle , non pr\u00e9sente dans l\u2019arbre, et qui : renvoie une nouvelle feuille d\u2019\u00e9tiquette cle s\u2019il est vide ; renvoie l\u2019arbre apr\u00e8s l\u2019avoir modifi\u00e9 en ins\u00e9rant cle sinon ; garantit que l\u2019arbre ainsi compl\u00e9t\u00e9 soit encore un arbre binaire de recherche. Tester ensuite ce code en utilisant la fonction parcours et en ins\u00e9rant successivement des n\u0153uds d\u2019\u00e9tiquette 1, 4, 6 et 8 dans l\u2019arbre binaire de recherche repr\u00e9sent\u00e9 ci- dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def insere ( arbre , cle ): \"\"\"insere la cle dans l'arbre binaire de recherche repr\u00e9sent\u00e9 par arbre. Retourne l'arbre modifi\u00e9.\"\"\" if arbre == None : return Noeud ( cle , None , None ) # creation d'une feuille else : if ... : arbre . gauche = insere ( arbre . gauche , cle ) else : arbre . droit = ... return arbre ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 44.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-45", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 45"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-451", "text": "Exercice 45.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction compte_occurrences prenant en param\u00e8tres une valeur x et un tableau tab (de type list ) et renvoyant le nombre d\u2019occurrences de x dans tab . L\u2019objectif de cet exercice \u00e9tant de parcourir un tableau, il est interdit d\u2019utiliser la m\u00e9thode count des listes Python. Exemples : \ud83d\udc0d Script Python >>> compte_occurrences ( 5 , []) 0 >>> compte_occurrences ( 5 , [ - 2 , 3 , 1 , 5 , 3 , 7 , 4 ]) 1 >>> compte_occurrences ( 'a' , [ 'a' , 'b' , 'c' , 'a' , 'd' , 'e' , 'a' ]) 3 \ud83d\udc0d Script Python 1 2 3 4 5 6 def compte_occurrences ( x , tab ): nb = 0 for element in tab : if element == x : nb += 1 return nb \ud83d\udccb Texte \u00c9crire une fonction `compte_occurrences` prenant en param\u00e8tres une valeur `x` et un tableau `tab` (de type `list`) et renvoyant le nombre d\u2019occurrences de `x` dans `tab`. L\u2019objectif de cet exercice \u00e9tant de parcourir un tableau, il est interdit d\u2019utiliser la m\u00e9thode `count` des listes Python. Exemples : ```python >>> compte_occurrences(5, []) 0 >>> compte_occurrences(5, [-2, 3, 1, 5, 3, 7, 4]) 1 >>> compte_occurrences('a', ['a','b','c','a','d','e','a']) 3 ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 45.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-452", "text": "Exercice 45.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re dans cet exercice un algorithme glouton pour le rendu de monnaie. Pour rendre une somme en monnaie, on utilise \u00e0 chaque fois la plus grosse pi\u00e8ce possible et ainsi de suite jusqu\u2019\u00e0 ce que la somme restante \u00e0 rendre soit nulle. Les pi\u00e8ces de monnaie utilis\u00e9es sont : pieces = [1, 2, 5, 10, 20, 50, 100, 200] On souhaite \u00e9crire une fonction rendu_monnaie qui prend en param\u00e8tres un entier somme_due repr\u00e9sentant la somme \u00e0 payer ; un entier somme_versee repr\u00e9sentant la somme vers\u00e9e qui est sup\u00e9rieure ou \u00e9gale \u00e0 somme_due ; et qui renvoie un tableau de type list contenant les pi\u00e8ces qui composent le rendu de la monnaie restante, c\u2019est-\u00e0-dire de somme_versee - somme_due . Ainsi, l\u2019instruction rendu_monnaie(452, 500) renvoie le tableau [20, 20, 5, 2, 1] . En effet, la somme \u00e0 rendre est de 48 euros soit 20 + 20 + 5 + 2 + 1 . Le code de la fonction rendu_monnaie est donn\u00e9 ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def rendu_monnaie ( somme_due , somme_versee ): '''Renvoie la liste des pi\u00e8ces \u00e0 rendre pour rendre la monnaie lorsqu'on doit rendre somme_versee - somme_due''' rendu = ... a_rendre = ... i = len ( pieces ) - 1 while a_rendre > ... : while pieces [ i ] > a_rendre : i = i - 1 rendu . append ( ... ) a_rendre = ... return rendu Compl\u00e9ter ce code et le tester : \ud83d\udc0d Script Python >>> rendu_monnaie ( 700 , 700 ) [] >>> rendu_monnaie ( 102 , 500 ) [ 200 , 100 , 50 , 20 , 20 , 5 , 2 , 1 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 pieces = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] def rendu_monnaie ( somme_due , somme_versee ): '''Renvoie la liste des pi\u00e8ces \u00e0 rendre pour rendre la monnaie lorsqu'on doit rendre somme_versee - somme_due''' rendu = [] a_rendre = somme_versee - somme_due i = len ( pieces ) - 1 while a_rendre > 0 : while pieces [ i ] > a_rendre : i = i - 1 rendu . append ( pieces [ i ]) a_rendre = a_rendre - pieces [ i ] return rendu Markdown On consid\u00e8re dans cet exercice un algorithme glouton pour le rendu de monnaie. Pour rendre une somme en monnaie, on utilise \u00e0 chaque fois la plus grosse pi\u00e8ce possible et ainsi de suite jusqu\u2019\u00e0 ce que la somme restante \u00e0 rendre soit nulle. Les pi\u00e8ces de monnaie utilis\u00e9es sont : `pieces = [1, 2, 5, 10, 20, 50, 100, 200]` On souhaite \u00e9crire une fonction `rendu_monnaie` qui prend en param\u00e8tres - un entier `somme_due` repr\u00e9sentant la somme \u00e0 payer ; - un entier `somme_versee` repr\u00e9sentant la somme vers\u00e9e qui est sup\u00e9rieure ou \u00e9gale \u00e0 `somme_due` ; et qui renvoie un tableau de type `list` contenant les pi\u00e8ces qui composent le rendu de la monnaie restante, c\u2019est-\u00e0-dire de `somme_versee - somme_due` . Ainsi, l\u2019instruction `rendu_monnaie(452, 500)` renvoie le tableau `[20, 20, 5, 2, 1]` . En effet, la somme \u00e0 rendre est de `48` euros soit `20 + 20 + 5 + 2 + 1` . Le code de la fonction `rendu_monnaie` est donn\u00e9 ci-dessous : ```python linenums='1' def rendu_monnaie(somme_due, somme_versee): '''Renvoie la liste des pi\u00e8ces \u00e0 rendre pour rendre la monnaie lorsqu'on doit rendre somme_versee - somme_due''' rendu = ... a_rendre = ... i = len(pieces) - 1 while a_rendre > ...: while pieces[i] > a_rendre: i = i - 1 rendu.append(...) a_rendre = ... return rendu Compl\u00e9ter ce code et le tester : \ud83d\udc0d Script Python >>> rendu_monnaie ( 700 , 700 ) [] >>> rendu_monnaie ( 102 , 500 ) [ 200 , 100 , 50 , 20 , 20 , 5 , 2 , 1 ] ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 45.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-46", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 46"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-461", "text": "Exercice 46.1 \u00c9nonc\u00e9 Correction Source Markdown \u00c9crire une fonction recherche qui prend en param\u00e8tres un tableau tab de nombres entiers tri\u00e9s par ordre croissant et un nombre entier n , et qui effectue une recherche dichotomique du nombre entier n dans le tableau non vide tab . Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, None sinon. Exemples : \ud83d\udc0d Script Python >>> recherche ([ 2 , 3 , 4 , 5 , 6 ], 5 ) 3 >>> recherche ([ 2 , 3 , 4 , 6 , 7 ], 5 ) # renvoie None \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 def recherche ( tab , n ): ind_debut = 0 ind_fin = len ( tab ) - 1 while ind_debut <= ind_fin : ind_milieu = ( ind_debut + ind_fin ) // 2 if tab [ ind_milieu ] == n : return ind_milieu elif tab [ ind_milieu ] < n : ind_debut = ind_milieu + 1 else : ind_fin = ind_milieu - 1 return None \ud83d\udccb Texte \u00c9crire une fonction `recherche` qui prend en param\u00e8tres un tableau `tab` de nombres entiers tri\u00e9s par ordre croissant et un nombre entier `n`, et qui effectue une recherche dichotomique du nombre entier `n` dans le tableau non vide `tab`. Cette fonction doit renvoyer un indice correspondant au nombre cherch\u00e9 s\u2019il est dans le tableau, `None` sinon. Exemples : ```python >>> recherche([2, 3, 4, 5, 6], 5) 3 >>> recherche([2, 3, 4, 6, 7], 5) # renvoie None ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 46.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-462", "text": "Exercice 46.2 \u00c9nonc\u00e9 Correction Sources Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019 ...) ne sont pas cod\u00e9s. La fonction position_alphabet ci-dessous prend en param\u00e8tre un caract\u00e8re lettre et renvoie la position de lettre dans la cha\u00eene de caract\u00e8res alphabet s\u2019il s\u2019y trouve. La fonction cesar prend en param\u00e8tres une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage decalage . \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): '''Renvoie la position de la lettre dans l'alphabet''' return ord ( lettre ) - ord ( 'A' ) def cesar ( message , decalage ): '''Renvoie le message cod\u00e9 par la m\u00e9thode de C\u00e9sar pour le decalage donn\u00e9''' resultat = '' for ... in message : if 'A' <= c and c <= 'Z' : indice = ( ... ) % 26 resultat = resultat + alphabet [ indice ] else : resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet ( lettre ): '''Renvoie la position de la lettre dans l'alphabet''' return ord ( lettre ) - ord ( 'A' ) def cesar ( message , decalage ): '''Renvoie le message cod\u00e9 par la m\u00e9thode de C\u00e9sar pour le decalage donn\u00e9''' resultat = '' for c in message : if 'A' <= c and c <= 'Z' : indice = ( position_alphabet ( c ) + decalage ) % 26 resultat = resultat + alphabet [ indice ] else : resultat = resultat + c return resultat Markdown Le codage de C\u00e9sar transforme un message en changeant chaque lettre en la d\u00e9calant dans l\u2019alphabet. Par exemple, avec un d\u00e9calage de 3, le A se transforme en D, le B en E, ..., le X en A, le Y en B et le Z en C. Les autres caract\u00e8res (\u2018!\u2019,\u2019 ?\u2019 ...) ne sont pas cod\u00e9s. La fonction `position_alphabet` ci-dessous prend en param\u00e8tre un caract\u00e8re `lettre` et renvoie la position de `lettre` dans la cha\u00eene de caract\u00e8res `alphabet` s\u2019il s\u2019y trouve. La fonction `cesar` prend en param\u00e8tres une cha\u00eene de caract\u00e8res `message` et un nombre entier `decalage` et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant le d\u00e9calage `decalage` . ```python linenums='1' alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def position_alphabet(lettre): '''Renvoie la position de la lettre dans l'alphabet''' return ord(lettre) - ord('A') def cesar(message, decalage): '''Renvoie le message cod\u00e9 par la m\u00e9thode de C\u00e9sar pour le decalage donn\u00e9''' resultat = '' for ... in message: if 'A' <= c and c <= 'Z': indice = (...) % 26 resultat = resultat + alphabet[indice] else: resultat = ... return resultat Compl\u00e9ter la fonction cesar . Exemples : \ud83d\udc0d Script Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 46.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-47", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 47"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-471", "text": "Exercice 47.1 \u00c9nonc\u00e9 Correction Source Markdown Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : {'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50} \u00c9crire une fonction max_dico qui : Prend en param\u00e8tre un dictionnaire dico non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; Renvoie un tuple dont : La premi\u00e8re valeur est une cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; la seconde valeur est cette valeur maximale. Exemples : \ud83d\udc0d Script Python >>> max_dico ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ( 'Ada' , 201 ) >>> max_dico ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 220 , 'Tim' : 50 }) ( 'Alan' , 222 ) \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 def max_dico ( dico ): cle_max = '' val_max = 0 for cle in dico : if dico [ cle ] > val_max : val_max = dico [ cle ] cle_max = cle return ( cle_max , val_max ) \ud83d\udccb Texte Sur le r\u00e9seau social TipTop, on s\u2019int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans des dictionnaires o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : `{'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}` \u00c9crire une fonction `max_dico` qui : - Prend en param\u00e8tre un dictionnaire `dico` non vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es sont des entiers ; - Renvoie un tuple dont : - La premi\u00e8re valeur est une cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; - la seconde valeur est cette valeur maximale. Exemples : ```python >>> max_dico({'Bob': 102, 'Ada': 201, 'Alice': 103, 'Tim': 50}) ('Ada', 201) >>> max_dico({'Alan': 222, 'Ada': 201, 'Eve': 220, 'Tim': 50}) ('Alan', 222) ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 47.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-472", "text": "Exercice 47.2 \u00c9nonc\u00e9 Correction Sources Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau [2, 3, '+', 5, '*'] . Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : [3, 2, '*', 5, '+'] . D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe Pile qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction eval_expression qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self . est_vide () return self . contenu . pop () def eval_expression ( tab ): p = Pile () for ... in tab : if element != '+' ... element != '*' : p . empiler ( ... ) else : if element == ... : resultat = ... + ... else : resultat = ... p . empiler ( ... ) return ... Exemples : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 >>> eval_expression ([ 1 , 2 , '+' , 3 , '*' ]) 9 >>> eval_expression ([ 1 , 2 , 3 , '+' , '*' ]) 5 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Pile : \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ ( self ): self . contenu = [] def est_vide ( self ): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self . contenu == [] def empiler ( self , v ): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self . contenu . append ( v ) def depiler ( self ): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. \"\"\" if not self . est_vide (): return self . contenu . pop () def eval_expression ( tab ): p = Pile () for element in tab : if element != '+' and element != '*' : p . empiler ( element ) else : if element == '+' : resultat = p . depiler () + p . depiler () else : resultat = p . depiler () * p . depiler () p . empiler ( resultat ) return p . depiler () Markdown Nous avons l\u2019habitude de noter les expressions arithm\u00e9tiques avec des parenth\u00e8ses comme par exemple : (2 + 3) \u00d7 5. Il existe une autre notation utilis\u00e9e par certaines calculatrices, appel\u00e9e notation postfixe, qui n\u2019utilise pas de parenth\u00e8ses. L\u2019expression arithm\u00e9tique pr\u00e9c\u00e9dente est alors obtenue en saisissant successivement 2, puis 3, puis l\u2019op\u00e9rateur +, puis 5, et enfin l\u2019op\u00e9rateur \u00d7. On mod\u00e9lise cette saisie par le tableau `[2, 3, '+', 5, '*']` . Autre exemple, la notation postfixe de 3 \u00d7 2 + 5 est mod\u00e9lis\u00e9e par le tableau : `[3, 2, '*', 5, '+']` . D\u2019une mani\u00e8re plus g\u00e9n\u00e9rale, la valeur associ\u00e9e \u00e0 une expression arithm\u00e9tique en notation postfixe est d\u00e9termin\u00e9e \u00e0 l\u2019aide d\u2019une pile en parcourant l\u2019expression arithm\u00e9tique de gauche \u00e0 droite de la fa\u00e7on suivante : - Si l\u2019\u00e9l\u00e9ment parcouru est un nombre, on le place au sommet de la pile ; - Si l\u2019\u00e9l\u00e9ment parcouru est un op\u00e9rateur, on r\u00e9cup\u00e8re les deux \u00e9l\u00e9ments situ\u00e9s au sommet de la pile et on leur applique l\u2019op\u00e9rateur. On place alors le r\u00e9sultat au sommet de la pile. - \u00c0 la fin du parcours, il reste alors un seul \u00e9l\u00e9ment dans la pile qui est le r\u00e9sultat de l\u2019expression arithm\u00e9tique. Dans le cadre de cet exercice, on se limitera aux op\u00e9rations \u00d7 et +. Pour cet exercice, on dispose d\u2019une classe `Pile` qui impl\u00e9mente les m\u00e9thodes de base sur la structure de pile. Compl\u00e9ter le script de la fonction `eval_expression` qui re\u00e7oit en param\u00e8tre une liste python repr\u00e9sentant la notation postfixe d\u2019une expression arithm\u00e9tique et qui renvoie sa valeur associ\u00e9e. ```python linenums='1' class Pile: \"\"\"Classe d\u00e9finissant une structure de pile.\"\"\" def __init__ (self): self.contenu = [] def est_vide(self): \"\"\"Renvoie le bool\u00e9en True si la pile est vide, False sinon.\"\"\" return self.contenu == [] def empiler(self, v): \"\"\"Place l'\u00e9l\u00e9ment v au sommet de la pile\"\"\" self.contenu.append(v) def depiler(self): \"\"\" Retire et renvoie l\u2019\u00e9l\u00e9ment plac\u00e9 au sommet de la pile, si la pile n\u2019est pas vide. Produit une erreur sinon. \"\"\" assert not self.est_vide() return self.contenu.pop() def eval_expression(tab): p = Pile() for ... in tab: if element != '+' ... element != '*': p.empiler(...) else: if element == ...: resultat = ... + ... else: resultat = ... p.empiler(...) return ... Exemples : \ud83d\udc0d Script Python >>> eval_expression ([ 2 , 3 , '+' , 5 , '*' ]) 25 >>> eval_expression ([ 1 , 2 , '+' , 3 , '*' ]) 9 >>> eval_expression ([ 1 , 2 , 3 , '+' , '*' ]) 5 ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 47.2"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#sujet-48", "text": "Version originale du sujet en pdf.", "title": "\u25b6 Sujet 48"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-481", "text": "Exercice 48.1 \u00c9nonc\u00e9 Correction Source Markdown On consid\u00e8re dans cet exercice un graphe orient\u00e9 repr\u00e9sent\u00e9 sous forme de listes d\u2019adjacence. On suppose que les sommets sont num\u00e9rot\u00e9s de 0 \u00e0 n-1 . Par exemple, le graphe suivant : est repr\u00e9sent\u00e9 par la liste d\u2019adjacence suivante : \ud83d\udc0d Script Python adj = [[ 1 , 2 ], [ 2 ], [ 0 ], [ 0 ]] \u00c9crire une fonction voisins_entrants(adj, x) qui prend en param\u00e8tre le graphe donn\u00e9 sous forme de liste d\u2019adjacence et qui renvoie une liste contenant les voisins entrants du sommet x , c\u2019est-\u00e0-dire les sommets y tels qu\u2019il existe une ar\u00eate de y vers x . Exemples : \ud83d\udc0d Script Python >>> voisins_entrants ([[ 1 , 2 ], [ 2 ], [ 0 ], [ 0 ]], 0 ) [ 2 , 3 ] >>> voisins_entrants ([[ 1 , 2 ], [ 2 ], [ 0 ], [ 0 ]], 1 ) [ 0 ] \ud83d\udc0d Script Python 1 2 3 4 5 6 def voisins_entrants ( adj , x ): vois = [] for i in range ( len ( adj )): if x in adj [ i ]: vois . append ( i ) return vois \ud83d\udccb Texte On consid\u00e8re dans cet exercice un graphe orient\u00e9 repr\u00e9sent\u00e9 sous forme de listes d\u2019adjacence. On suppose que les sommets sont num\u00e9rot\u00e9s de `0` \u00e0 `n-1`. Par exemple, le graphe suivant : ![image](data2024/graph2.png){: .center} est repr\u00e9sent\u00e9 par la liste d\u2019adjacence suivante : ```python adj = [[1, 2], [2], [0], [0]] ``` \u00c9crire une fonction `voisins_entrants(adj, x)` qui prend en param\u00e8tre le graphe donn\u00e9 sous forme de liste d\u2019adjacence et qui renvoie une liste contenant les voisins entrants du sommet `x`, c\u2019est-\u00e0-dire les sommets `y` tels qu\u2019il existe une ar\u00eate de `y` vers `x`. Exemples : ```python >>> voisins_entrants([[1, 2], [2], [0], [0]], 0) [2, 3] >>> voisins_entrants([[1, 2], [2], [0], [0]], 1) [0] ``` R\u00e9digez votre code sur Basthon", "title": "Exercice 48.1"}, {"location": "T6_6_Epreuve_pratique/BNS_2024/#exercice-482", "text": "Exercice 48.2 \u00c9nonc\u00e9 Correction Sources Markdown On consid\u00e8re dans cet exercice la suite de nombre suivante : 1, 11, 21, 1211, 111221, ... Cette suite est construite ainsi : pour passer d\u2019une valeur \u00e0 la suivante, on la lit et on l\u2019\u00e9crit sous la forme d\u2019un nombre. Ainsi, pour 1211 : on lit un 1, un 2, deux 1 ; on \u00e9crit donc en nombre 1 1, 1 2, 2 1 ; puis on concat\u00e8ne 111221 . Compl\u00e9ter la fonction nombre_suivant qui prend en entr\u00e9e un nombre sous forme de chaine de caract\u00e8res et qui renvoie le nombre suivant par ce proc\u00e9d\u00e9, encore sous forme de cha\u00eene de caract\u00e8res. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def nombre_suivant ( s ): '''Renvoie le nombre suivant de celui represent\u00e9 par s en appliquant le proc\u00e9d\u00e9 de lecture.''' resultat = '' chiffre = s [ 0 ] compte = 1 for i in range ( ... ): if s [ i ] == chiffre : compte = ... else : resultat += ... + ... chiffre = ... ... lecture_ ... = ... + ... resultat += lecture_chiffre return resultat Exemples : \ud83d\udc0d Script Python >>> nombre_suivant ( '1211' ) '111221' >>> nombre_suivant ( '311' ) '1321' \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def nombre_suivant ( s ): '''Renvoie le nombre suivant de celui represent\u00e9 par s en appliquant le proc\u00e9d\u00e9 de lecture.''' resultat = '' chiffre = s [ 0 ] compte = 1 for i in range ( 1 , len ( s )): if s [ i ] == chiffre : compte = compte + 1 else : resultat += str ( compte ) + chiffre chiffre = s [ i ] compte = 1 lecture_chiffre = str ( compte ) + chiffre resultat += lecture_chiffre return resultat Markdown On consid\u00e8re dans cet exercice la suite de nombre suivante : 1, 11, 21, 1211, 111221, ... Cette suite est construite ainsi : pour passer d\u2019une valeur \u00e0 la suivante, on la lit et on l\u2019\u00e9crit sous la forme d\u2019un nombre. Ainsi, pour 1211 : - on lit *un 1, un 2, deux 1* ; - on \u00e9crit donc en nombre *1 1, 1 2, 2 1* ; - puis on concat\u00e8ne *111221* . Compl\u00e9ter la fonction `nombre_suivant` qui prend en entr\u00e9e un nombre sous forme de chaine de caract\u00e8res et qui renvoie le nombre suivant par ce proc\u00e9d\u00e9, encore sous forme de cha\u00eene de caract\u00e8res. ```python linenums='1' def nombre_suivant(s): '''Renvoie le nombre suivant de celui represent\u00e9 par s en appliquant le proc\u00e9d\u00e9 de lecture.''' resultat = '' chiffre = s[0] compte = 1 for i in range(...): if s[i] == chiffre: compte = ... else: resultat += ... + ... chiffre = ... ... lecture_... = ... + ... resultat += lecture_chiffre return resultat Exemples : \ud83d\udc0d Script Python >>> nombre_suivant ( '1211' ) '111221' >>> nombre_suivant ( '311' ) '1321' ``` Compl\u00e9tez le code sur Basthon", "title": "Exercice 48.2"}, {"location": "T6_Annales/epreuve_bac/", "text": "\u00c9preuves du baccalaur\u00e9at \u2693\ufe0e Modalit\u00e9s \u2693\ufe0e L'\u00e9preuve se partage en : une \u00c9preuve Pratique (sur 20 points, \u00e0 l'\u00e9crit, dur\u00e9e 3h30, coefficient 0.75) une \u00c9preuve \u00c9crite (sur 20 points, sur machine, dur\u00e9e 1h, coefficient 0.25) On peut consid\u00e9rer que la note sur 20 au bacaccalaur\u00e9at en NSI est constitu\u00e9e de 15 points d'\u00e9preuve \u00e9crite et de 5 points d'\u00e9preuve pratique. \u00c9preuve Pratique \u2693\ufe0e Textes r\u00e8glementaires https://www.education.gouv.fr/bo/20/Special2/MENE2001797N.htm?cid_bo=149244 Dur\u00e9e : 1 heure L'\u00e9preuve pratique donne lieu \u00e0 une note sur 20 points, coefficient 0.25. La partie pratique consiste en la r\u00e9solution de deux exercices sur ordinateur , chacun \u00e9tant not\u00e9 sur 10 points . Le candidat est \u00e9valu\u00e9 sur la base d\u2019un dialogue avec un professeur-examinateur. Un examinateur \u00e9value au maximum quatre \u00e9l\u00e8ves. L\u2019examinateur ne peut pas \u00e9valuer un \u00e9l\u00e8ve qu\u2019il a eu en classe durant l\u2019ann\u00e9e en cours. L\u2019\u00e9valuation de cette partie se d\u00e9roule au cours du deuxi\u00e8me trimestre pendant la p\u00e9riode de l\u2019\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9. Premier exercice Le premier exercice consiste \u00e0 programmer un algorithme figurant explicitement au programme, ne pr\u00e9sentant pas de difficult\u00e9 particuli\u00e8re, dont on fournit une sp\u00e9cification. Il s\u2019agit donc de restituer un algorithme rencontr\u00e9 et travaill\u00e9 \u00e0 plusieurs reprises en cours de formation. Le sujet peut proposer un jeu de test avec les r\u00e9ponses attendues pour permettre au candidat de v\u00e9rifier son travail. Deuxi\u00e8me exercice Pour le second exercice, un programme est fourni au candidat. Cet exercice ne demande pas l\u2019\u00e9criture compl\u00e8te d\u2019un programme, mais permet de valider des comp\u00e9tences de programmation suivant des modalit\u00e9s vari\u00e9es : le candidat doit, par exemple, compl\u00e9ter un programme \u00ab \u00e0 trous \u00bb afin de r\u00e9pondre \u00e0 une sp\u00e9cification donn\u00e9e, ou encore compl\u00e9ter un programme pour le documenter, ou encore compl\u00e9ter un programme en ajoutant des assertions, etc. Banque d'exercices \u2693\ufe0e Textes r\u00e8glementaires https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi Une page sp\u00e9cifique consacr\u00e9e aux exercices de la BNS est disponible ici . \u00c9preuve \u00c9crite \u2693\ufe0e \u00c0 compter de la session 2023, l'\u00e9preuve consiste en trois exercices qui doivent tous \u00eatre trait\u00e9s. Textes r\u00e8glementaires Programme d'examen des \u00e9preuves terminales des enseignements de sp\u00e9cialit\u00e9 de la voie g\u00e9n\u00e9rale - \u00e0 compter de la session 2023 Les annales des sujets pass\u00e9s (2020, 2021, 2022) comportent tous 5 exercices dont seulement 3 devaient \u00eatre trait\u00e9s. Ce n'est plus le cas depuis la session 2023 o\u00f9 la totalit\u00e9 du sujet doit \u00eatre trait\u00e9.", "title": "\u00c9preuves du baccalaur\u00e9at"}, {"location": "T6_Annales/epreuve_bac/#epreuves-du-baccalaureat", "text": "", "title": "\u00c9preuves du baccalaur\u00e9at"}, {"location": "T6_Annales/epreuve_bac/#modalites", "text": "L'\u00e9preuve se partage en : une \u00c9preuve Pratique (sur 20 points, \u00e0 l'\u00e9crit, dur\u00e9e 3h30, coefficient 0.75) une \u00c9preuve \u00c9crite (sur 20 points, sur machine, dur\u00e9e 1h, coefficient 0.25) On peut consid\u00e9rer que la note sur 20 au bacaccalaur\u00e9at en NSI est constitu\u00e9e de 15 points d'\u00e9preuve \u00e9crite et de 5 points d'\u00e9preuve pratique.", "title": "Modalit\u00e9s"}, {"location": "T6_Annales/epreuve_bac/#epreuve-pratique", "text": "Textes r\u00e8glementaires https://www.education.gouv.fr/bo/20/Special2/MENE2001797N.htm?cid_bo=149244 Dur\u00e9e : 1 heure L'\u00e9preuve pratique donne lieu \u00e0 une note sur 20 points, coefficient 0.25. La partie pratique consiste en la r\u00e9solution de deux exercices sur ordinateur , chacun \u00e9tant not\u00e9 sur 10 points . Le candidat est \u00e9valu\u00e9 sur la base d\u2019un dialogue avec un professeur-examinateur. Un examinateur \u00e9value au maximum quatre \u00e9l\u00e8ves. L\u2019examinateur ne peut pas \u00e9valuer un \u00e9l\u00e8ve qu\u2019il a eu en classe durant l\u2019ann\u00e9e en cours. L\u2019\u00e9valuation de cette partie se d\u00e9roule au cours du deuxi\u00e8me trimestre pendant la p\u00e9riode de l\u2019\u00e9preuve \u00e9crite de sp\u00e9cialit\u00e9. Premier exercice Le premier exercice consiste \u00e0 programmer un algorithme figurant explicitement au programme, ne pr\u00e9sentant pas de difficult\u00e9 particuli\u00e8re, dont on fournit une sp\u00e9cification. Il s\u2019agit donc de restituer un algorithme rencontr\u00e9 et travaill\u00e9 \u00e0 plusieurs reprises en cours de formation. Le sujet peut proposer un jeu de test avec les r\u00e9ponses attendues pour permettre au candidat de v\u00e9rifier son travail. Deuxi\u00e8me exercice Pour le second exercice, un programme est fourni au candidat. Cet exercice ne demande pas l\u2019\u00e9criture compl\u00e8te d\u2019un programme, mais permet de valider des comp\u00e9tences de programmation suivant des modalit\u00e9s vari\u00e9es : le candidat doit, par exemple, compl\u00e9ter un programme \u00ab \u00e0 trous \u00bb afin de r\u00e9pondre \u00e0 une sp\u00e9cification donn\u00e9e, ou encore compl\u00e9ter un programme pour le documenter, ou encore compl\u00e9ter un programme en ajoutant des assertions, etc.", "title": "\u00c9preuve Pratique"}, {"location": "T6_Annales/epreuve_bac/#banque-dexercices", "text": "Textes r\u00e8glementaires https://eduscol.education.fr/2661/banque-des-epreuves-pratiques-de-specialite-nsi Une page sp\u00e9cifique consacr\u00e9e aux exercices de la BNS est disponible ici .", "title": "Banque d'exercices"}, {"location": "T6_Annales/epreuve_bac/#epreuve-ecrite", "text": "\u00c0 compter de la session 2023, l'\u00e9preuve consiste en trois exercices qui doivent tous \u00eatre trait\u00e9s. Textes r\u00e8glementaires Programme d'examen des \u00e9preuves terminales des enseignements de sp\u00e9cialit\u00e9 de la voie g\u00e9n\u00e9rale - \u00e0 compter de la session 2023 Les annales des sujets pass\u00e9s (2020, 2021, 2022) comportent tous 5 exercices dont seulement 3 devaient \u00eatre trait\u00e9s. Ce n'est plus le cas depuis la session 2023 o\u00f9 la totalit\u00e9 du sujet doit \u00eatre trait\u00e9.", "title": "\u00c9preuve \u00c9crite"}, {"location": "T6_Annales/liste_sujets/", "text": "Annales des \u00c9preuves \u00c9crites \u2693\ufe0e 2023 \u2693\ufe0e Centres \u00c9trangers J2 Centres \u00c9trangers J1 Polyn\u00e9sie J2 Polyn\u00e9sie J1 Sujet 0 - version A Sujet 0 - version B correction 2022 \u2693\ufe0e Nouvelle-Cal\u00e9donie J1 Nouvelle-Cal\u00e9donie J2 Am\u00e9rique du Nord J1 Am\u00e9rique du Nord J2 Am\u00e9rique du Sud J1 Am\u00e9rique du Sud J2 correction Asie J1 Asie J2 Centres \u00c9trangers J2 Centres \u00c9trangers J1 La R\u00e9union J2 La R\u00e9union J1 M\u00e9tropole J2 M\u00e9tropole J1 M\u00e9tropole Septembre Polyn\u00e9sie 2021 \u2693\ufe0e Am\u00e9rique du Nord Centres \u00c9trangers 1 Centres \u00c9trangers 2 M\u00e9tropole 1 M\u00e9tropole 2 M\u00e9tropole Candidats Libres 1 M\u00e9tropole Candidats Libres 2 Polyn\u00e9sie Septembre 2020 \u2693\ufe0e sujet 0", "title": "Annales des \u00c9preuves \u00c9crites"}, {"location": "T6_Annales/liste_sujets/#annales-des-epreuves-ecrites", "text": "", "title": "Annales des \u00c9preuves \u00c9crites"}, {"location": "T6_Annales/liste_sujets/#2023", "text": "Centres \u00c9trangers J2 Centres \u00c9trangers J1 Polyn\u00e9sie J2 Polyn\u00e9sie J1 Sujet 0 - version A Sujet 0 - version B correction", "title": "2023"}, {"location": "T6_Annales/liste_sujets/#2022", "text": "Nouvelle-Cal\u00e9donie J1 Nouvelle-Cal\u00e9donie J2 Am\u00e9rique du Nord J1 Am\u00e9rique du Nord J2 Am\u00e9rique du Sud J1 Am\u00e9rique du Sud J2 correction Asie J1 Asie J2 Centres \u00c9trangers J2 Centres \u00c9trangers J1 La R\u00e9union J2 La R\u00e9union J1 M\u00e9tropole J2 M\u00e9tropole J1 M\u00e9tropole Septembre Polyn\u00e9sie", "title": "2022"}, {"location": "T6_Annales/liste_sujets/#2021", "text": "Am\u00e9rique du Nord Centres \u00c9trangers 1 Centres \u00c9trangers 2 M\u00e9tropole 1 M\u00e9tropole 2 M\u00e9tropole Candidats Libres 1 M\u00e9tropole Candidats Libres 2 Polyn\u00e9sie Septembre", "title": "2021"}, {"location": "T6_Annales/liste_sujets/#2020", "text": "sujet 0", "title": "2020"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/", "text": "Correction du sujet 22-NSIJ2AS1 / Am\u00e9rique du Sud J2 2022 \u2693\ufe0e Sujet Exercice 1 \u2693\ufe0e Correction Q1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def plus_proche_voisin ( t , cible ) : dmin = distance ( t [ 0 ], cible ) idx_ppv = 0 n = len ( t ) for idx in range ( 1 , n ) : if distance ( t [ idx ], cible ) < dmin : dmin = distance ( t [ idx ], cible ) idx_ppv = idx return idx_ppv Correction Q2 La complexit\u00e9 est lin\u00e9aire, car le nombre d'op\u00e9rations est proportionnel \u00e0 la taille du tableau t . Correction Q3.a Il suffit d'ins\u00e9rer la ligne dist = distance(obj, cible) en dessous de la boucle for et d'utiliser cette variable dist partout \u00e0 la place de distance(obj, cible) . Correction Q3.b La complexit\u00e9 (m\u00eame r\u00e9p\u00e9t\u00e9e) d'une op\u00e9ration d'insertion d'un seul \u00e9l\u00e9ment \u00e0 sa bonne place dans une liste est moindre que celle d'un tri global. (NDLR : pas s\u00fbr) Correction Q3.c \ud83d\udc0d Script Python 1 2 3 4 5 def insertion ( kppv , idx , d ): i = 0 while d < kppv [ i ][ 1 ] and i < len ( kppv ): i += 1 kppv . insert ( i , ( idx , d )) Exercice 2 \u2693\ufe0e Partie A \u2693\ufe0e Correction Q1 ifconfig Correction Q2 DHCP (NDLR : question hors-programme) Correction Q3 192.168.1.1 Correction Q4 C\u2019est possible et cette adresse serait celle de la box vers Internet. Correction Q5 Oui, car les adresses 192.168.x.x ne sont pas rout\u00e9es sur Internet. Partie B \u2693\ufe0e Correction Q1 \\(C = \\dfrac{10^9}{50 \\times 10^6}=\\dfrac{1000}{50}=20\\) Correction Q2.a. Correction Q2.b. Suivant le protocole OSPF, il faut minimiser le co\u00fbt total. Il faut pour cela suivre le chemin R1-R3-R6-R7-R4-R5-R8, pour un co\u00fbt total de 80. Correction Q3.c. Pour que le protocole OSPF fasse passer par la liaison R1-R4, il faut que celle-ci ait un co\u00fbt inf\u00e9rieur \u00e0 la liaison actuelle R1-R3-R6-R7-R4, qui a un co\u00fbt de 40. Il faut donc que le co\u00fbt R1-R4 soit inf\u00e9rieur \u00e0 40, ce qui sera le cas pour une bande passante sup\u00e9rieure \u00e0 25 Mb/s (car \\(\\dfrac{10^9}{25 \\times 10^6}=40\\) ) Exercice 3 \u2693\ufe0e Correction Q1 SQL UPDATE ModeleVelo SET Stock = 0 WHERE nomModele = \"Bovelo\" ; Correction Q2 Il faut effectuer d'abord la requ\u00eate 4 (qui d\u00e9clare le nouveau fabricant, qui aura pour idFabricant 3127), puis la requ\u00eate 2 (o\u00f9 on peut retrouver l'id 3127). Correction Q3.a. SQL SELECT nomModele , idFabricant FROM ModeleVelo WHERE Stock = 0 ; Correction Q3.b. SQL SELECT COUNT ( numeroCommande ) FROM Commande WHERE date >= '2022-01-01' ; Correction Q3.c. SQL SELECT Fabricant . nom FROM Fabricant JOIN ModeleVelo ON Fabricant . idFabricant = ModeleVelo . idFabricant WHERE ModeleVelo . Stock > 0 Correction Q4. Cette requ\u00eate permet d'obtenir le nom de tous les clients ayant achet\u00e9 le mod\u00e8le de v\u00e9lo \"Bovelo\". Si certains l'ont achet\u00e9 en plusieurs exemplaires, leur nom n'apparaitra qu'une seule fois. Exercice 4 \u2693\ufe0e Correction Q1.a. \ud83d\udc0d Script Python from math import sqrt Correction Q1.b. \ud83d\udc0d Script Python 1 2 def distance_points ( a , b ): return sqrt (( b [ 0 ] - a [ 0 ]) ** 2 + ( b [ 1 ] - a [ 1 ]) ** 2 ) Correction Q2. \ud83d\udc0d Script Python 1 2 3 4 5 def distance ( p , a , b ): if a == b : return distance_points ( p , a ) else : return distance_point_droite ( p , a , b ) Correction Q3. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def le_plus_loin ( ligne ): n = len ( ligne ) deb = ligne [ 0 ] fin = ligne [ n - 1 ] dmax = 0 indice_max = 0 for idx in range ( 1 , n - 1 ): p = ligne [ idx ] d = distance ( p , deb , fin ) if d > dmax : dmax = d indice_max = idx return ( indice_max , dmax ) Correction Q4. \ud83d\udc0d Script Python 1 2 3 4 5 def extrait ( tab , i , j ): ext = [] for k in range ( i , j + 1 ): ext . append ( tab [ k ]) return ext Correction Q5. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def simplifie ( ligne , seuil ): n = len ( ligne ) if n <= 2 : return ligne else : indice_max , dmax = le_plus_loin ( ligne ) if dmax <= seuil : return [ ligne [ 0 ], ligne [ n - 1 ]] else : return simplifie ( extrait ( ligne , 0 , indice_max ), seuil ) + \\ simplifie ( extrait ( ligne , indice_max + 1 , n - 1 ), seuil ) Mise en pratique de l'algorithme de Douglas-Peucker (exercice 4) \u2693\ufe0e T\u00e9l\u00e9chargez d'abord le fichier coord_france.txt puis placez-le dans le m\u00eame dossier que le code Python ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 from math import sqrt import matplotlib.pyplot as plt data = open ( 'coord_france.txt' ) . read () . splitlines () france = [] for couple in data : cpl = couple . split ( ',' ) france . append (( int ( cpl [ 0 ]), int ( cpl [ 1 ]))) def distance_points ( a , b ): return sqrt (( b [ 0 ] - a [ 0 ]) ** 2 + ( b [ 1 ] - a [ 1 ]) ** 2 ) def distance_point_droite ( p , a , b ): if b [ 0 ] == a [ 0 ]: return abs ( p [ 0 ] - a [ 0 ]) m = ( b [ 1 ] - a [ 1 ]) / ( b [ 0 ] - a [ 0 ]) od = a [ 1 ] - m * a [ 0 ] xm = ( p [ 0 ] * ( b [ 0 ] - a [ 0 ]) + ( p [ 1 ] - od ) * ( b [ 1 ] - a [ 1 ])) / ( b [ 0 ] - a [ 0 ] + m * ( b [ 1 ] - a [ 1 ])) ym = m * xm + od return distance_points ( p , ( xm , ym )) def distance ( p , a , b ): if a == b : return distance_points ( p , a ) else : return distance_point_droite ( p , a , b ) def le_plus_loin ( ligne ): n = len ( ligne ) deb = ligne [ 0 ] fin = ligne [ n - 1 ] dmax = 0 indice_max = 0 for idx in range ( 1 , n - 1 ): p = ligne [ idx ] d = distance ( p , deb , fin ) if d > dmax : dmax = d indice_max = idx return ( indice_max , dmax ) def extrait ( tab , i , j ): ext = [] for k in range ( i , j + 1 ): ext . append ( tab [ k ]) return ext def simplifie ( ligne , seuil ): n = len ( ligne ) if n <= 2 : return ligne else : indice_max , dmax = le_plus_loin ( ligne ) if dmax <= seuil : return [ ligne [ 0 ], ligne [ n - 1 ]] else : return simplifie ( extrait ( ligne , 0 , indice_max ), seuil ) + \\ simplifie ( extrait ( ligne , indice_max + 1 , n - 1 ), seuil ) def trace ( ligne , seuil ): new_ligne = simplifie ( ligne , seuil ) x = [ p [ 0 ] for p in new_ligne ] y = [ p [ 1 ] for p in new_ligne ] plt . plot ( x , y , 'b-' , linewidth = 0.5 ) plt . text ( 195014 , 2865745 , 'seuil : ' + str ( seuil )) plt . axis ( 'equal' ) plt . axis ( 'off' ) plt . show () trace ( france , 0 ) Le rendu avec un seuil \u00e9gal \u00e0 0 est celui-ci : Vous pouvez faire varier le seuil entre 0 et 5000 et observer les modifications. Exercice 5 \u2693\ufe0e Correction Q1 La plus grande somme est 16, via la branche 2-7-4-3. Correction Q2.a. \ud83d\udc0d Script Python a = Noeud ( 2 ) a . modifier_sag ( Noeud ( 7 )) a . modifier_sad ( Noeud ( 5 )) a . sag . modifier_sag ( Noeud ( 4 )) a . sag . modifier_sad ( Noeud ( 1 )) a . sad . modifier_sad ( Noeud ( 8 )) Correction Q2.b. La m\u00e9thode niveau renvoie 2 (qui est la hauteur de cet arbre, en prenant la convention que l'arbre r\u00e9duit \u00e0 son n\u0153ud-racine a une hauteur de 0). Correction Q3. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def pgde_somme ( self ): if self . sag != None and self . sad != None : pgde_g = self . sag . pgde_somme () pgde_d = self . sad . pgde_somme () return self . etiquette + max ( pgde_g , pgde_d ) if self . sag != None : return self . sag . pgde_somme () + self . etiquette if self . sad != None : return self . sad . pgde_somme () + self . etiquette return self . etiquette Correction Q4.a. Correction Q4.b. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def est_magique ( self ): if self . sag != None and self . sad != None : return self . sag . est_magique () and self . sad . est_magique () \\ and self . sag . pgde_somme () == self . sad . pgde_somme () if self . sag != None : return self . sag . est_magique () if self . sad != None : return self . sad . est_magique () return True", "title": "Correction du sujet 22-NSIJ2AS1 / Am\u00e9rique du Sud J2 2022"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#correction-du-sujet-22-nsij2as1-amerique-du-sud-j2-2022", "text": "Sujet", "title": "Correction du sujet 22-NSIJ2AS1 / Am\u00e9rique du Sud J2 2022"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#exercice-1", "text": "Correction Q1 \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def plus_proche_voisin ( t , cible ) : dmin = distance ( t [ 0 ], cible ) idx_ppv = 0 n = len ( t ) for idx in range ( 1 , n ) : if distance ( t [ idx ], cible ) < dmin : dmin = distance ( t [ idx ], cible ) idx_ppv = idx return idx_ppv Correction Q2 La complexit\u00e9 est lin\u00e9aire, car le nombre d'op\u00e9rations est proportionnel \u00e0 la taille du tableau t . Correction Q3.a Il suffit d'ins\u00e9rer la ligne dist = distance(obj, cible) en dessous de la boucle for et d'utiliser cette variable dist partout \u00e0 la place de distance(obj, cible) . Correction Q3.b La complexit\u00e9 (m\u00eame r\u00e9p\u00e9t\u00e9e) d'une op\u00e9ration d'insertion d'un seul \u00e9l\u00e9ment \u00e0 sa bonne place dans une liste est moindre que celle d'un tri global. (NDLR : pas s\u00fbr) Correction Q3.c \ud83d\udc0d Script Python 1 2 3 4 5 def insertion ( kppv , idx , d ): i = 0 while d < kppv [ i ][ 1 ] and i < len ( kppv ): i += 1 kppv . insert ( i , ( idx , d ))", "title": "Exercice 1"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#exercice-2", "text": "", "title": "Exercice 2"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#partie-a", "text": "Correction Q1 ifconfig Correction Q2 DHCP (NDLR : question hors-programme) Correction Q3 192.168.1.1 Correction Q4 C\u2019est possible et cette adresse serait celle de la box vers Internet. Correction Q5 Oui, car les adresses 192.168.x.x ne sont pas rout\u00e9es sur Internet.", "title": "Partie A"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#partie-b", "text": "Correction Q1 \\(C = \\dfrac{10^9}{50 \\times 10^6}=\\dfrac{1000}{50}=20\\) Correction Q2.a. Correction Q2.b. Suivant le protocole OSPF, il faut minimiser le co\u00fbt total. Il faut pour cela suivre le chemin R1-R3-R6-R7-R4-R5-R8, pour un co\u00fbt total de 80. Correction Q3.c. Pour que le protocole OSPF fasse passer par la liaison R1-R4, il faut que celle-ci ait un co\u00fbt inf\u00e9rieur \u00e0 la liaison actuelle R1-R3-R6-R7-R4, qui a un co\u00fbt de 40. Il faut donc que le co\u00fbt R1-R4 soit inf\u00e9rieur \u00e0 40, ce qui sera le cas pour une bande passante sup\u00e9rieure \u00e0 25 Mb/s (car \\(\\dfrac{10^9}{25 \\times 10^6}=40\\) )", "title": "Partie B"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#exercice-3", "text": "Correction Q1 SQL UPDATE ModeleVelo SET Stock = 0 WHERE nomModele = \"Bovelo\" ; Correction Q2 Il faut effectuer d'abord la requ\u00eate 4 (qui d\u00e9clare le nouveau fabricant, qui aura pour idFabricant 3127), puis la requ\u00eate 2 (o\u00f9 on peut retrouver l'id 3127). Correction Q3.a. SQL SELECT nomModele , idFabricant FROM ModeleVelo WHERE Stock = 0 ; Correction Q3.b. SQL SELECT COUNT ( numeroCommande ) FROM Commande WHERE date >= '2022-01-01' ; Correction Q3.c. SQL SELECT Fabricant . nom FROM Fabricant JOIN ModeleVelo ON Fabricant . idFabricant = ModeleVelo . idFabricant WHERE ModeleVelo . Stock > 0 Correction Q4. Cette requ\u00eate permet d'obtenir le nom de tous les clients ayant achet\u00e9 le mod\u00e8le de v\u00e9lo \"Bovelo\". Si certains l'ont achet\u00e9 en plusieurs exemplaires, leur nom n'apparaitra qu'une seule fois.", "title": "Exercice 3"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#exercice-4", "text": "Correction Q1.a. \ud83d\udc0d Script Python from math import sqrt Correction Q1.b. \ud83d\udc0d Script Python 1 2 def distance_points ( a , b ): return sqrt (( b [ 0 ] - a [ 0 ]) ** 2 + ( b [ 1 ] - a [ 1 ]) ** 2 ) Correction Q2. \ud83d\udc0d Script Python 1 2 3 4 5 def distance ( p , a , b ): if a == b : return distance_points ( p , a ) else : return distance_point_droite ( p , a , b ) Correction Q3. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def le_plus_loin ( ligne ): n = len ( ligne ) deb = ligne [ 0 ] fin = ligne [ n - 1 ] dmax = 0 indice_max = 0 for idx in range ( 1 , n - 1 ): p = ligne [ idx ] d = distance ( p , deb , fin ) if d > dmax : dmax = d indice_max = idx return ( indice_max , dmax ) Correction Q4. \ud83d\udc0d Script Python 1 2 3 4 5 def extrait ( tab , i , j ): ext = [] for k in range ( i , j + 1 ): ext . append ( tab [ k ]) return ext Correction Q5. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def simplifie ( ligne , seuil ): n = len ( ligne ) if n <= 2 : return ligne else : indice_max , dmax = le_plus_loin ( ligne ) if dmax <= seuil : return [ ligne [ 0 ], ligne [ n - 1 ]] else : return simplifie ( extrait ( ligne , 0 , indice_max ), seuil ) + \\ simplifie ( extrait ( ligne , indice_max + 1 , n - 1 ), seuil )", "title": "Exercice 4"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#mise-en-pratique-de-lalgorithme-de-douglas-peucker-exercice-4", "text": "T\u00e9l\u00e9chargez d'abord le fichier coord_france.txt puis placez-le dans le m\u00eame dossier que le code Python ci-dessous : \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 from math import sqrt import matplotlib.pyplot as plt data = open ( 'coord_france.txt' ) . read () . splitlines () france = [] for couple in data : cpl = couple . split ( ',' ) france . append (( int ( cpl [ 0 ]), int ( cpl [ 1 ]))) def distance_points ( a , b ): return sqrt (( b [ 0 ] - a [ 0 ]) ** 2 + ( b [ 1 ] - a [ 1 ]) ** 2 ) def distance_point_droite ( p , a , b ): if b [ 0 ] == a [ 0 ]: return abs ( p [ 0 ] - a [ 0 ]) m = ( b [ 1 ] - a [ 1 ]) / ( b [ 0 ] - a [ 0 ]) od = a [ 1 ] - m * a [ 0 ] xm = ( p [ 0 ] * ( b [ 0 ] - a [ 0 ]) + ( p [ 1 ] - od ) * ( b [ 1 ] - a [ 1 ])) / ( b [ 0 ] - a [ 0 ] + m * ( b [ 1 ] - a [ 1 ])) ym = m * xm + od return distance_points ( p , ( xm , ym )) def distance ( p , a , b ): if a == b : return distance_points ( p , a ) else : return distance_point_droite ( p , a , b ) def le_plus_loin ( ligne ): n = len ( ligne ) deb = ligne [ 0 ] fin = ligne [ n - 1 ] dmax = 0 indice_max = 0 for idx in range ( 1 , n - 1 ): p = ligne [ idx ] d = distance ( p , deb , fin ) if d > dmax : dmax = d indice_max = idx return ( indice_max , dmax ) def extrait ( tab , i , j ): ext = [] for k in range ( i , j + 1 ): ext . append ( tab [ k ]) return ext def simplifie ( ligne , seuil ): n = len ( ligne ) if n <= 2 : return ligne else : indice_max , dmax = le_plus_loin ( ligne ) if dmax <= seuil : return [ ligne [ 0 ], ligne [ n - 1 ]] else : return simplifie ( extrait ( ligne , 0 , indice_max ), seuil ) + \\ simplifie ( extrait ( ligne , indice_max + 1 , n - 1 ), seuil ) def trace ( ligne , seuil ): new_ligne = simplifie ( ligne , seuil ) x = [ p [ 0 ] for p in new_ligne ] y = [ p [ 1 ] for p in new_ligne ] plt . plot ( x , y , 'b-' , linewidth = 0.5 ) plt . text ( 195014 , 2865745 , 'seuil : ' + str ( seuil )) plt . axis ( 'equal' ) plt . axis ( 'off' ) plt . show () trace ( france , 0 ) Le rendu avec un seuil \u00e9gal \u00e0 0 est celui-ci : Vous pouvez faire varier le seuil entre 0 et 5000 et observer les modifications.", "title": "Mise en pratique de l'algorithme de Douglas-Peucker (exercice 4)"}, {"location": "T6_Annales/corrections/2022/corr_AmSudJ2_2022/#exercice-5", "text": "Correction Q1 La plus grande somme est 16, via la branche 2-7-4-3. Correction Q2.a. \ud83d\udc0d Script Python a = Noeud ( 2 ) a . modifier_sag ( Noeud ( 7 )) a . modifier_sad ( Noeud ( 5 )) a . sag . modifier_sag ( Noeud ( 4 )) a . sag . modifier_sad ( Noeud ( 1 )) a . sad . modifier_sad ( Noeud ( 8 )) Correction Q2.b. La m\u00e9thode niveau renvoie 2 (qui est la hauteur de cet arbre, en prenant la convention que l'arbre r\u00e9duit \u00e0 son n\u0153ud-racine a une hauteur de 0). Correction Q3. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 10 11 def pgde_somme ( self ): if self . sag != None and self . sad != None : pgde_g = self . sag . pgde_somme () pgde_d = self . sad . pgde_somme () return self . etiquette + max ( pgde_g , pgde_d ) if self . sag != None : return self . sag . pgde_somme () + self . etiquette if self . sad != None : return self . sad . pgde_somme () + self . etiquette return self . etiquette Correction Q4.a. Correction Q4.b. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 8 9 def est_magique ( self ): if self . sag != None and self . sad != None : return self . sag . est_magique () and self . sad . est_magique () \\ and self . sag . pgde_somme () == self . sad . pgde_somme () if self . sag != None : return self . sag . est_magique () if self . sad != None : return self . sad . est_magique () return True", "title": "Exercice 5"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_A/", "text": "Correction du sujet 0 version A / 2023 \u2693\ufe0e Sujet Exercice 1 \u2693\ufe0e correction Q1. Les attributs de la table groupes sont idgrp , nom , style et nb_pers . Correction Q2. Le musicien Charlie Parker est pr\u00e9sent 2 fois dans cette table (avec deux instruments diff\u00e9rents). L'attribut nom ne peut donc pas \u00eatre une cl\u00e9 primaire, qui doit \u00eatre unique. Correction Q3. Cette requ\u00eate renvoie 'Weather Report' et 'Return to Forever' . Correction Q4. SQL UPDATE concerts SET heure_fin = '22h30' WHERE idconc = 36 ; Correction Q5. SQL SELECT groupes . nom FROM groupes JOIN concerts ON concerts . idgrp = groupes . idgrp WHERE concerts . scene = 1 ; Correction Q6. SQL INSERT INTO groupes VALUES ( 15 , 'Smooth Jazz Fourplay' , 'Free Jazz' , 4 ); Correction Q7. \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche_nom ( tab_mus ): lst = [] for mus in tab_mus : if mus [ 'nb_concerts' ] >= 4 : lst . append ( mus [ 'nom' ]) return lst Exercice 2 \u2693\ufe0e correction Q1. Cet ordinateur appartient \u00e0 Alice car il fait partie du r\u00e9seau 172.16.2.0/24 . Le masque en /24 nous indique que ce r\u00e9seau contiendra des adresses de type 172.16.2.X , ce qui est bien le cas de l'adresse 172.16.2.3 . Correction Q2. \\(C=\\dfrac{10000}{1000}=10\\) . Correction Q3. Table de routage du routeur R6 Destination Pass Co\u00fbt LAN1 R5 21 LAN2 - - WAN1 R5 11 WAN2 R5 20 WAN3 R5 11 WAN4 R5 12 WAN5 R5 10 WAN6 - - WAN7 - - WAN8 R5 10 Correction Q4. R1-R2-R5-R6 Correction Q5. Le nouveau co\u00fbt de 111 correspond \u00e0 la route R1-R2-R4-R6 . Ce sera la nouvelle route la plus courte si le routeur R5 tombe en panne.", "title": "Correction du sujet 0 version A / 2023"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_A/#correction-du-sujet-0-version-a-2023", "text": "Sujet", "title": "Correction du sujet 0 version A / 2023"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_A/#exercice-1", "text": "correction Q1. Les attributs de la table groupes sont idgrp , nom , style et nb_pers . Correction Q2. Le musicien Charlie Parker est pr\u00e9sent 2 fois dans cette table (avec deux instruments diff\u00e9rents). L'attribut nom ne peut donc pas \u00eatre une cl\u00e9 primaire, qui doit \u00eatre unique. Correction Q3. Cette requ\u00eate renvoie 'Weather Report' et 'Return to Forever' . Correction Q4. SQL UPDATE concerts SET heure_fin = '22h30' WHERE idconc = 36 ; Correction Q5. SQL SELECT groupes . nom FROM groupes JOIN concerts ON concerts . idgrp = groupes . idgrp WHERE concerts . scene = 1 ; Correction Q6. SQL INSERT INTO groupes VALUES ( 15 , 'Smooth Jazz Fourplay' , 'Free Jazz' , 4 ); Correction Q7. \ud83d\udc0d Script Python 1 2 3 4 5 6 def recherche_nom ( tab_mus ): lst = [] for mus in tab_mus : if mus [ 'nb_concerts' ] >= 4 : lst . append ( mus [ 'nom' ]) return lst", "title": "Exercice 1"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_A/#exercice-2", "text": "correction Q1. Cet ordinateur appartient \u00e0 Alice car il fait partie du r\u00e9seau 172.16.2.0/24 . Le masque en /24 nous indique que ce r\u00e9seau contiendra des adresses de type 172.16.2.X , ce qui est bien le cas de l'adresse 172.16.2.3 . Correction Q2. \\(C=\\dfrac{10000}{1000}=10\\) . Correction Q3. Table de routage du routeur R6 Destination Pass Co\u00fbt LAN1 R5 21 LAN2 - - WAN1 R5 11 WAN2 R5 20 WAN3 R5 11 WAN4 R5 12 WAN5 R5 10 WAN6 - - WAN7 - - WAN8 R5 10 Correction Q4. R1-R2-R5-R6 Correction Q5. Le nouveau co\u00fbt de 111 correspond \u00e0 la route R1-R2-R4-R6 . Ce sera la nouvelle route la plus courte si le routeur R5 tombe en panne.", "title": "Exercice 2"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_B/", "text": "Correction du sujet 0 version B / 2023 \u2693\ufe0e Sujet Exercice 1 \u2693\ufe0e correction Q1.a. Commande 1 : cd /home/documents/collections/timbres (chemin absolu) Commande 2 : cd ../collections/timbres (chemin relatif) correction Q1.b. cd /home/documents/collections/timbres correction Q2.a. \\(C = \\dfrac{10^8}{100 \\times 10^6} = 1\\) Correction Q2.b. La route minimale est donc A-B-C-E-F-G (co\u00fbt total de 1,04) Correction Q3. Les descripteurs de ce fichier sont : nom_timbre (valeurs associ\u00e9es : Gustave Eiffel , Marianne , Alan Turing ) annee_fabrication (valeurs associ\u00e9es : 1950 , 1989 , 2012 ) nom_collectionneur (valeurs associ\u00e9es : Dupont , Durand ) Correction Q4.a. Une cl\u00e9 primaire est attribut qui d\u00e9signe de mani\u00e8re unique un enregistrement. Correction Q4.b. Non, car deux enregistrements poss\u00e8dent le nom \u00abGustave Eiffel\u00bb. Correction Q4.c. Non, car deux enregistrements ont pour ann\u00e9e de fabrication 1989. (merci Vincent) Correction Q4.d. On peut cr\u00e9er une cl\u00e9 primaire artificielle (un nombre entier), ou bien consid\u00e9rer le couple ( nom , annee_fabrication ) comme cl\u00e9 primaire. Correction Q5.a. Cette requ\u00eate va modifier l'attribut ref_licence de Jean-Pierre Dupond ET de Alexandra, qui auront donc la m\u00eame r\u00e9f\u00e9rence de licence 'Ythpswz' . Correction Q5.b. L'attribut ref_licence ne peut plus \u00eatre une cl\u00e9 primaire car deux enregistrements diff\u00e9rents auront la m\u00eame valeur pour cet attribut. Correction Q6. SQL SELECT nom , prenom , nbre_timbres FROM collectionneurs WHERE annee_naissance >= 1963 ; Exercice 2 \u2693\ufe0e Correction Q1.a. Une fonction r\u00e9cursive est une fonction qui fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition. Correction Q1.b. Lors du premier appel de la fonction, le param\u00e8tre n vaut 3. Lors des appels r\u00e9cursifs, ce param\u00e8tre va d\u00e9cro\u00eetre \u00e0 2, 1 puis 0 puisque l'appel se fait sous condition que n >= 0 . Le dernier appel se fait avec la valeur n = -1 . Lors de l'ex\u00e9cution de compte_rebours(n-1) , rien ne se passe. La derni\u00e8re valeur affich\u00e9e est donc 0. Correction Q2. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fact ( n ): \"\"\" renvoie le produit des nombres entiers strictement positifs inf\u00e9rieurs \u00e0 n \"\"\" if n == 0 : return 1 else : return n * fact ( n - 1 ) Correction Q3.a. L'affichage en console sera : \ud83d\udc0d Script Python 3 2 1 Correction Q3.b. La variable res contiendra la valeur 6. Correction Q4. \ud83d\udc0d Script Python 1 2 3 4 5 def somme_entiers ( n ): somme = 0 for nb in range ( n + 1 ): somme += nb return somme Exercice 3 \u2693\ufe0e Correction Q1.a. Exemple d'attribut : valeur Exemple de m\u00e9thode : get_valeur Correction Q1.b Apr\u00e8s ex\u00e9cution, a vaut 15 et b vaut 6. Correction Q2. Correction Q3. Ce n'est pas un ABR car la valeur 13 est cens\u00e9e \u00eatre plus petite que la valeur 12. Correction Q4. La liste renvoy\u00e9e est [1, 6, 10, 15, 16, 18, 16, 25] .", "title": "Correction du sujet 0 version B / 2023"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_B/#correction-du-sujet-0-version-b-2023", "text": "Sujet", "title": "Correction du sujet 0 version B / 2023"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_B/#exercice-1", "text": "correction Q1.a. Commande 1 : cd /home/documents/collections/timbres (chemin absolu) Commande 2 : cd ../collections/timbres (chemin relatif) correction Q1.b. cd /home/documents/collections/timbres correction Q2.a. \\(C = \\dfrac{10^8}{100 \\times 10^6} = 1\\) Correction Q2.b. La route minimale est donc A-B-C-E-F-G (co\u00fbt total de 1,04) Correction Q3. Les descripteurs de ce fichier sont : nom_timbre (valeurs associ\u00e9es : Gustave Eiffel , Marianne , Alan Turing ) annee_fabrication (valeurs associ\u00e9es : 1950 , 1989 , 2012 ) nom_collectionneur (valeurs associ\u00e9es : Dupont , Durand ) Correction Q4.a. Une cl\u00e9 primaire est attribut qui d\u00e9signe de mani\u00e8re unique un enregistrement. Correction Q4.b. Non, car deux enregistrements poss\u00e8dent le nom \u00abGustave Eiffel\u00bb. Correction Q4.c. Non, car deux enregistrements ont pour ann\u00e9e de fabrication 1989. (merci Vincent) Correction Q4.d. On peut cr\u00e9er une cl\u00e9 primaire artificielle (un nombre entier), ou bien consid\u00e9rer le couple ( nom , annee_fabrication ) comme cl\u00e9 primaire. Correction Q5.a. Cette requ\u00eate va modifier l'attribut ref_licence de Jean-Pierre Dupond ET de Alexandra, qui auront donc la m\u00eame r\u00e9f\u00e9rence de licence 'Ythpswz' . Correction Q5.b. L'attribut ref_licence ne peut plus \u00eatre une cl\u00e9 primaire car deux enregistrements diff\u00e9rents auront la m\u00eame valeur pour cet attribut. Correction Q6. SQL SELECT nom , prenom , nbre_timbres FROM collectionneurs WHERE annee_naissance >= 1963 ;", "title": "Exercice 1"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_B/#exercice-2", "text": "Correction Q1.a. Une fonction r\u00e9cursive est une fonction qui fait appel \u00e0 elle-m\u00eame dans sa propre d\u00e9finition. Correction Q1.b. Lors du premier appel de la fonction, le param\u00e8tre n vaut 3. Lors des appels r\u00e9cursifs, ce param\u00e8tre va d\u00e9cro\u00eetre \u00e0 2, 1 puis 0 puisque l'appel se fait sous condition que n >= 0 . Le dernier appel se fait avec la valeur n = -1 . Lors de l'ex\u00e9cution de compte_rebours(n-1) , rien ne se passe. La derni\u00e8re valeur affich\u00e9e est donc 0. Correction Q2. \ud83d\udc0d Script Python 1 2 3 4 5 6 7 def fact ( n ): \"\"\" renvoie le produit des nombres entiers strictement positifs inf\u00e9rieurs \u00e0 n \"\"\" if n == 0 : return 1 else : return n * fact ( n - 1 ) Correction Q3.a. L'affichage en console sera : \ud83d\udc0d Script Python 3 2 1 Correction Q3.b. La variable res contiendra la valeur 6. Correction Q4. \ud83d\udc0d Script Python 1 2 3 4 5 def somme_entiers ( n ): somme = 0 for nb in range ( n + 1 ): somme += nb return somme", "title": "Exercice 2"}, {"location": "T6_Annales/corrections/2023/corr_sujet0_B/#exercice-3", "text": "Correction Q1.a. Exemple d'attribut : valeur Exemple de m\u00e9thode : get_valeur Correction Q1.b Apr\u00e8s ex\u00e9cution, a vaut 15 et b vaut 6. Correction Q2. Correction Q3. Ce n'est pas un ABR car la valeur 13 est cens\u00e9e \u00eatre plus petite que la valeur 12. Correction Q4. La liste renvoy\u00e9e est [1, 6, 10, 15, 16, 18, 16, 25] .", "title": "Exercice 3"}, {"location": "T7_Divers/10_orientation/cours/", "text": "Orientation Post-Bac \u2693\ufe0e Quelles \u00e9tudes pour poursuivre dans l'informatique ? 1. Les cursus ing\u00e9nieurs publics post-bac \u2693\ufe0e 1.1 \u00c9coles du r\u00e9seau Geipi-Polytech \u2693\ufe0e https://www.geipi-polytech.org/les-ecoles-du-concours-geipi-polytech#Informatique sur dossier ou concours (inscription via Parcoursup) \u00e0 la fin de l'ann\u00e9e de Terminale 1.2 \u00c9coles du r\u00e9seau INSA \u2693\ufe0e https://www.groupe-insa.fr/decouvrir/nos-ecoles sur dossier (inscription via Parcoursup) 1.3 La pr\u00e9pa des INP Bordeaux \u2693\ufe0e https://www.bordeaux-inp.fr/fr/la-prepa-des-inp-0 sur dossier (inscription via Parcoursup) 1.4 Le cursus CMI de l'Universit\u00e9 de Bordeaux \u2693\ufe0e https://jechoisis.u-bordeaux.fr/choisir/sciences-et-technologies/cmi via Parcoursup 2. La classe pr\u00e9paratoire MP2I au lyc\u00e9e Montaigne \u2693\ufe0e https://montaigne-bordeaux.fr/classe-mp2i/ https://prepas-mp2i.fr/mp2i/ via Parcoursup 3. La licence Informatique du l'Universit\u00e9 de Bordeaux \u2693\ufe0e https://jechoisis.u-bordeaux.fr/choisir/sciences-et-technologies/licences/licence-informatique via Parcoursup 5. Le BUT informatique de l'Universit\u00e9 de Bordeaux \u2693\ufe0e https://jechoisis.u-bordeaux.fr/choisir/sciences-et-technologies/1096/informatique via Parcoursup 6. Les BTS \u2693\ufe0e 6.1 Le BTS SN-IR au lyc\u00e9e Kastler (Talence) \u2693\ufe0e BTS Syst\u00e8mes num\u00e9riques option A informatique et r\u00e9seaux http://www.lyceekastler.fr/formations/superieur/bts/sn-ir/ via Parcoursup 6.2 Le BTS SIO au lyc\u00e9e Gustave Eiffel (Bordeaux) \u2693\ufe0e BTS Services informatiques aux organisations (SIO) https://www.eiffel-bordeaux.org/bts-services-informatiques-aux-organisations-sio.html via Parcoursup 7. Les \u00e9coles d'ing\u00e9nieurs priv\u00e9es post-bac \u00e0 Bordeaux \u2693\ufe0e 7.1 Ynov \u2693\ufe0e https://www.ynov.com/ 7.2 Epitech \u2693\ufe0e https://www.epitech.eu/ 7.3 Epsi \u2693\ufe0e https://www.epsi.fr/", "title": "Orientation Post-Bac"}, {"location": "T7_Divers/10_orientation/cours/#orientation-post-bac", "text": "Quelles \u00e9tudes pour poursuivre dans l'informatique ?", "title": "Orientation Post-Bac"}, {"location": "T7_Divers/10_orientation/cours/#1-les-cursus-ingenieurs-publics-post-bac", "text": "", "title": "1. Les cursus ing\u00e9nieurs publics post-bac"}, {"location": "T7_Divers/10_orientation/cours/#11-ecoles-du-reseau-geipi-polytech", "text": "https://www.geipi-polytech.org/les-ecoles-du-concours-geipi-polytech#Informatique sur dossier ou concours (inscription via Parcoursup) \u00e0 la fin de l'ann\u00e9e de Terminale", "title": "1.1 \u00c9coles du r\u00e9seau Geipi-Polytech"}, {"location": "T7_Divers/10_orientation/cours/#12-ecoles-du-reseau-insa", "text": "https://www.groupe-insa.fr/decouvrir/nos-ecoles sur dossier (inscription via Parcoursup)", "title": "1.2 \u00c9coles du r\u00e9seau INSA"}, {"location": "T7_Divers/10_orientation/cours/#13-la-prepa-des-inp-bordeaux", "text": "https://www.bordeaux-inp.fr/fr/la-prepa-des-inp-0 sur dossier (inscription via Parcoursup)", "title": "1.3 La pr\u00e9pa des INP Bordeaux"}, {"location": "T7_Divers/10_orientation/cours/#14-le-cursus-cmi-de-luniversite-de-bordeaux", "text": "https://jechoisis.u-bordeaux.fr/choisir/sciences-et-technologies/cmi via Parcoursup", "title": "1.4 Le cursus CMI de l'Universit\u00e9 de Bordeaux"}, {"location": "T7_Divers/10_orientation/cours/#2-la-classe-preparatoire-mp2i-au-lycee-montaigne", "text": "https://montaigne-bordeaux.fr/classe-mp2i/ https://prepas-mp2i.fr/mp2i/ via Parcoursup", "title": "2. La classe pr\u00e9paratoire MP2I au lyc\u00e9e Montaigne"}, {"location": "T7_Divers/10_orientation/cours/#3-la-licence-informatique-du-luniversite-de-bordeaux", "text": "https://jechoisis.u-bordeaux.fr/choisir/sciences-et-technologies/licences/licence-informatique via Parcoursup", "title": "3. La licence Informatique du l'Universit\u00e9 de Bordeaux"}, {"location": "T7_Divers/10_orientation/cours/#5-le-but-informatique-de-luniversite-de-bordeaux", "text": "https://jechoisis.u-bordeaux.fr/choisir/sciences-et-technologies/1096/informatique via Parcoursup", "title": "5. Le BUT informatique de l'Universit\u00e9 de Bordeaux"}, {"location": "T7_Divers/10_orientation/cours/#6-les-bts", "text": "", "title": "6. Les BTS"}, {"location": "T7_Divers/10_orientation/cours/#61-le-bts-sn-ir-au-lycee-kastler-talence", "text": "BTS Syst\u00e8mes num\u00e9riques option A informatique et r\u00e9seaux http://www.lyceekastler.fr/formations/superieur/bts/sn-ir/ via Parcoursup", "title": "6.1 Le BTS SN-IR au lyc\u00e9e Kastler (Talence)"}, {"location": "T7_Divers/10_orientation/cours/#62-le-bts-sio-au-lycee-gustave-eiffel-bordeaux", "text": "BTS Services informatiques aux organisations (SIO) https://www.eiffel-bordeaux.org/bts-services-informatiques-aux-organisations-sio.html via Parcoursup", "title": "6.2 Le BTS SIO au lyc\u00e9e Gustave Eiffel (Bordeaux)"}, {"location": "T7_Divers/10_orientation/cours/#7-les-ecoles-dingenieurs-privees-post-bac-a-bordeaux", "text": "", "title": "7. Les \u00e9coles d'ing\u00e9nieurs priv\u00e9es post-bac \u00e0 Bordeaux"}, {"location": "T7_Divers/10_orientation/cours/#71-ynov", "text": "https://www.ynov.com/", "title": "7.1 Ynov"}, {"location": "T7_Divers/10_orientation/cours/#72-epitech", "text": "https://www.epitech.eu/", "title": "7.2 Epitech"}, {"location": "T7_Divers/10_orientation/cours/#73-epsi", "text": "https://www.epsi.fr/", "title": "7.3 Epsi"}, {"location": "T7_Divers/1_Conseils_generaux/cours/", "text": "Conseils de travail \u2693\ufe0e Conditions mat\u00e9rielles \u2693\ufe0e Il est conseill\u00e9 de travailler avec 3 espaces: l'\u00e9cran de l'ordinateur partitionn\u00e9 avec les 2 premiers espaces: ce site et un IDE (Thonny par exemple); C'est en codant qu'on apprend \u00e0 coder Tous les exemples de code dans le cours doivent \u00eatre retap\u00e9s (r\u00e9sistez \u00e0 l'envie du copier-coller) dans Thonny, soit en fen\u00eatre de script, soit en console. Cela permet de : m\u00e9moriser la syntaxe ; v\u00e9rifier si le code propos\u00e9 ne contient pas d'erreur ; et le plus important : faire ses propres tests et modifications pour v\u00e9rifier sa bonne compr\u00e9hension. et un troisi\u00e8me espace essentiel : un petit cahier \u00e0 spirale et un stylo ! Script ou console ??? \u2693\ufe0e Thonny, comme la grande majorit\u00e9 des IDE Python, est compos\u00e9 de deux zones distinctes : la zone de script la console La zone de script est asynchrone . Il ne se passera rien tant que vous n'aurez pas ex\u00e9cut\u00e9 le script (par F5 par exemple). C'est donc l'endroit o\u00f9 on va r\u00e9diger son programme. La console est synchrone : elle r\u00e9pond d\u00e8s que vous appuyez sur la touche Entr\u00e9e. Elle sert donc aux petits tests rapides, ou bien tests post-ex\u00e9cution d'un code. Utilisation classique du couple script / console On \u00e9crit son code dans la zone de script On l'ex\u00e9cute. On interroge la console pour conna\u00eetre l'\u00e9tat des variables, pour utiliser les fonctions construites dans le script. Pour les extraits de code pr\u00e9sents sur ce site : tout le code qui est pr\u00e9c\u00e9d\u00e9 d'une num\u00e9rotation de ligne est \u00e0 \u00e9crire en zone de script. Exemple : \ud83d\udc0d Script Python 1 2 3 def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) tout le code qui est pr\u00e9c\u00e9d\u00e9 >>> est \u00e0 taper en console. Exemple : \ud83d\udc0d Script Python >>> accueil ( 5 ) Dossiers, fichiers et versionning \u2693\ufe0e Cette ann\u00e9e en NSI nous allons manipuler un certain nombre de fichiers. Il est important de les nommer et les classer de fa\u00e7on rigoureuse pour les retrouver rapidement et les partager. Conseils Utilisez des dossiers pour classer vos fichiers. Il n'y en a jamais assez. Prenez l'habitude de faire plusieurs sauvegardes de vos documents (sur le r\u00e9seau du lyc\u00e9e, sur l'ENT, sur cl\u00e9 USB). \u00c9vitez dans les noms de fichiers et de dossiers les espaces (utilisez plut\u00f4t _ ) ainsi que les caract\u00e8res accentu\u00e9s et les caract\u00e8res sp\u00e9ciaux. Un nom de fichier doit \u00eatre parlant (un peu comme une variable en fait). On \u00e9vitera de nommer ses codes Python python1.py , python2.py , python3.py , etc. Mais plut\u00f4t 1NSI_T4_tri_selection.py par exemple pour un exercice de programmation sur le tri par selection au th\u00e8me 4. Lorsqu'on travaille sur un projet ou un programme cons\u00e9quent, il peut \u00eatre utile de conserver des archives du travail \u00e0 plusieurs \u00e9tapes de l'\u00e9laboration, plut\u00f4t que de ne conserver que la derni\u00e8re version. \u00c0 cet effet on pourra num\u00e9roter : 1NSI_projet_morpion_v1.py , puis 1NSI_projet_morpion_v2.py , 1NSI_projet_morpion_v3.py , etc. Usage du clavier \u2693\ufe0e Utiliser le clavier est souvent bien plus pratique et surtout plus rapide qu'utiliser la souris. Encore faut-il apprendre \u00e0 l'apprivoiser... La s\u00e9lection au clavier Outre les touches DEBUT et FIN qui permettent d'atteindre rapidement le d\u00e9but ou la fin d'une ligne, les fl\u00e8ches directionelles servent \u00e9videmment \u00e0 se d\u00e9placer dans du texte. Mais combin\u00e9es: \u00e0 la touche CTRL : elles permettent de se d\u00e9placer de mot en mot; \u00e0 la touche MAJ : elles permettent de s\u00e9lectionner un caract\u00e8re; aux touches MAJ et CTRL : elles permettent de s\u00e9lectionner une mot. De m\u00eame, en se pla\u00e7ant en d\u00e9but d'une ligne et en combinant la touche MAJ et FIN , on s\u00e9lectionne la ligne enti\u00e8re. Les raccourcis clavier Il existe de tr\u00e8s nombreux raccourcis clavier qui permettent d'ex\u00e9cuter des t\u00e2ches courantes sans passer par les menus du logiciel. Certains sont (quasi-)universels, c'est-\u00e0-dire que ce sont les m\u00eames sur tous les logiciels, d'autres sont sp\u00e9cifiques \u00e0 chaque logiciel. Il est important d'en conna\u00eetre quelques-uns pour \u00eatre plus efficace. Les universels IDE Navigateur Web La triplette magique CTRL+X , CTRL+C , CTRL+V pour couper, copier, coller; CTRL+O pour ouvrir un fichier CTRL+N pour cr\u00e9er un nouveau document; CTRL+S pour sauvegarder le document en cours; CTRL+MAJ+S pour sauvegarder en pr\u00e9cisant le nom du fichier; CTRL+Z pour annuler la derni\u00e8re action, CTRL+Y ou CTRL+MAJ+Z pour la r\u00e9tablir; CTRL+W pour fermer un onglet; CTRL+Q ou ALT+F4 pour fermer le logiciel; CTRL+A pour s\u00e9lectionner tout (All). \u00c0 chercher de suite lorsqu'on utilise un nouvel IDE, les raccourcis pour les actions suivantes (entre parenth\u00e8ses ceux de Thonny): ex\u00e9cuter le code ( F5 ) commenter/d\u00e9commenter une ligne ( CTRL+M ) CTRL+T pour ouvrir un nouvel onglet; CTRL+H pour ouvrir l'historique; combiner CTRL + clic pour forcer l'ouverture d'un lien dans un nouvel onglet; combiner MAJ + clic pour forcer l'ouverture d'un lien dans une nouvelle fen\u00eatre; sources site de C\u00e9dric Gouygou", "title": "Conseils de travail"}, {"location": "T7_Divers/1_Conseils_generaux/cours/#conseils-de-travail", "text": "", "title": "Conseils de travail"}, {"location": "T7_Divers/1_Conseils_generaux/cours/#conditions-materielles", "text": "Il est conseill\u00e9 de travailler avec 3 espaces: l'\u00e9cran de l'ordinateur partitionn\u00e9 avec les 2 premiers espaces: ce site et un IDE (Thonny par exemple); C'est en codant qu'on apprend \u00e0 coder Tous les exemples de code dans le cours doivent \u00eatre retap\u00e9s (r\u00e9sistez \u00e0 l'envie du copier-coller) dans Thonny, soit en fen\u00eatre de script, soit en console. Cela permet de : m\u00e9moriser la syntaxe ; v\u00e9rifier si le code propos\u00e9 ne contient pas d'erreur ; et le plus important : faire ses propres tests et modifications pour v\u00e9rifier sa bonne compr\u00e9hension. et un troisi\u00e8me espace essentiel : un petit cahier \u00e0 spirale et un stylo !", "title": "Conditions mat\u00e9rielles"}, {"location": "T7_Divers/1_Conseils_generaux/cours/#script-ou-console", "text": "Thonny, comme la grande majorit\u00e9 des IDE Python, est compos\u00e9 de deux zones distinctes : la zone de script la console La zone de script est asynchrone . Il ne se passera rien tant que vous n'aurez pas ex\u00e9cut\u00e9 le script (par F5 par exemple). C'est donc l'endroit o\u00f9 on va r\u00e9diger son programme. La console est synchrone : elle r\u00e9pond d\u00e8s que vous appuyez sur la touche Entr\u00e9e. Elle sert donc aux petits tests rapides, ou bien tests post-ex\u00e9cution d'un code. Utilisation classique du couple script / console On \u00e9crit son code dans la zone de script On l'ex\u00e9cute. On interroge la console pour conna\u00eetre l'\u00e9tat des variables, pour utiliser les fonctions construites dans le script. Pour les extraits de code pr\u00e9sents sur ce site : tout le code qui est pr\u00e9c\u00e9d\u00e9 d'une num\u00e9rotation de ligne est \u00e0 \u00e9crire en zone de script. Exemple : \ud83d\udc0d Script Python 1 2 3 def accueil ( n ): for k in range ( n ): print ( \"bonjour\" ) tout le code qui est pr\u00e9c\u00e9d\u00e9 >>> est \u00e0 taper en console. Exemple : \ud83d\udc0d Script Python >>> accueil ( 5 )", "title": "Script ou console ???"}, {"location": "T7_Divers/1_Conseils_generaux/cours/#dossiers-fichiers-et-versionning", "text": "Cette ann\u00e9e en NSI nous allons manipuler un certain nombre de fichiers. Il est important de les nommer et les classer de fa\u00e7on rigoureuse pour les retrouver rapidement et les partager. Conseils Utilisez des dossiers pour classer vos fichiers. Il n'y en a jamais assez. Prenez l'habitude de faire plusieurs sauvegardes de vos documents (sur le r\u00e9seau du lyc\u00e9e, sur l'ENT, sur cl\u00e9 USB). \u00c9vitez dans les noms de fichiers et de dossiers les espaces (utilisez plut\u00f4t _ ) ainsi que les caract\u00e8res accentu\u00e9s et les caract\u00e8res sp\u00e9ciaux. Un nom de fichier doit \u00eatre parlant (un peu comme une variable en fait). On \u00e9vitera de nommer ses codes Python python1.py , python2.py , python3.py , etc. Mais plut\u00f4t 1NSI_T4_tri_selection.py par exemple pour un exercice de programmation sur le tri par selection au th\u00e8me 4. Lorsqu'on travaille sur un projet ou un programme cons\u00e9quent, il peut \u00eatre utile de conserver des archives du travail \u00e0 plusieurs \u00e9tapes de l'\u00e9laboration, plut\u00f4t que de ne conserver que la derni\u00e8re version. \u00c0 cet effet on pourra num\u00e9roter : 1NSI_projet_morpion_v1.py , puis 1NSI_projet_morpion_v2.py , 1NSI_projet_morpion_v3.py , etc.", "title": "Dossiers, fichiers et versionning"}, {"location": "T7_Divers/1_Conseils_generaux/cours/#usage-du-clavier", "text": "Utiliser le clavier est souvent bien plus pratique et surtout plus rapide qu'utiliser la souris. Encore faut-il apprendre \u00e0 l'apprivoiser... La s\u00e9lection au clavier Outre les touches DEBUT et FIN qui permettent d'atteindre rapidement le d\u00e9but ou la fin d'une ligne, les fl\u00e8ches directionelles servent \u00e9videmment \u00e0 se d\u00e9placer dans du texte. Mais combin\u00e9es: \u00e0 la touche CTRL : elles permettent de se d\u00e9placer de mot en mot; \u00e0 la touche MAJ : elles permettent de s\u00e9lectionner un caract\u00e8re; aux touches MAJ et CTRL : elles permettent de s\u00e9lectionner une mot. De m\u00eame, en se pla\u00e7ant en d\u00e9but d'une ligne et en combinant la touche MAJ et FIN , on s\u00e9lectionne la ligne enti\u00e8re. Les raccourcis clavier Il existe de tr\u00e8s nombreux raccourcis clavier qui permettent d'ex\u00e9cuter des t\u00e2ches courantes sans passer par les menus du logiciel. Certains sont (quasi-)universels, c'est-\u00e0-dire que ce sont les m\u00eames sur tous les logiciels, d'autres sont sp\u00e9cifiques \u00e0 chaque logiciel. Il est important d'en conna\u00eetre quelques-uns pour \u00eatre plus efficace. Les universels IDE Navigateur Web La triplette magique CTRL+X , CTRL+C , CTRL+V pour couper, copier, coller; CTRL+O pour ouvrir un fichier CTRL+N pour cr\u00e9er un nouveau document; CTRL+S pour sauvegarder le document en cours; CTRL+MAJ+S pour sauvegarder en pr\u00e9cisant le nom du fichier; CTRL+Z pour annuler la derni\u00e8re action, CTRL+Y ou CTRL+MAJ+Z pour la r\u00e9tablir; CTRL+W pour fermer un onglet; CTRL+Q ou ALT+F4 pour fermer le logiciel; CTRL+A pour s\u00e9lectionner tout (All). \u00c0 chercher de suite lorsqu'on utilise un nouvel IDE, les raccourcis pour les actions suivantes (entre parenth\u00e8ses ceux de Thonny): ex\u00e9cuter le code ( F5 ) commenter/d\u00e9commenter une ligne ( CTRL+M ) CTRL+T pour ouvrir un nouvel onglet; CTRL+H pour ouvrir l'historique; combiner CTRL + clic pour forcer l'ouverture d'un lien dans un nouvel onglet; combiner MAJ + clic pour forcer l'ouverture d'un lien dans une nouvelle fen\u00eatre; sources site de C\u00e9dric Gouygou", "title": "Usage du clavier"}, {"location": "T7_Divers/3_IDE/cours/", "text": "IDE \u2693\ufe0e Comme pour tous les langages de programmation, il n'existe pas un logiciel permettant de coder en Python, mais un tr\u00e8s (tr\u00e8s) grand nombre de logiciels diff\u00e9rents, qu'on regroupe sous le nom d'IDE (interfaces de d\u00e9veloppement): Thonny, Pyzo, PyCharm, Spyder, VisualStudioCode... impossible de toutes les citer ! Par exemple pour installer Thonny \u2693\ufe0e Rendez vous sur la page https://thonny.org/ T\u00e9l\u00e9chargez et installez la version qui correspond \u00e0 votre syst\u00e8me d'exploitation (Windows, Mac, Linux). Solutions en ligne \u2693\ufe0e En ligne, sans aucune installation, vous pouvez utiliser https://console.basthon.fr/ ou bien m\u00eame la console ci-dessous ! >>> ou l'IDE qui suit : Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder", "title": "IDE"}, {"location": "T7_Divers/3_IDE/cours/#ide", "text": "Comme pour tous les langages de programmation, il n'existe pas un logiciel permettant de coder en Python, mais un tr\u00e8s (tr\u00e8s) grand nombre de logiciels diff\u00e9rents, qu'on regroupe sous le nom d'IDE (interfaces de d\u00e9veloppement): Thonny, Pyzo, PyCharm, Spyder, VisualStudioCode... impossible de toutes les citer !", "title": "IDE"}, {"location": "T7_Divers/3_IDE/cours/#par-exemple-pour-installer-thonny", "text": "Rendez vous sur la page https://thonny.org/ T\u00e9l\u00e9chargez et installez la version qui correspond \u00e0 votre syst\u00e8me d'exploitation (Windows, Mac, Linux).", "title": "Par exemple pour installer Thonny"}, {"location": "T7_Divers/3_IDE/cours/#solutions-en-ligne", "text": "En ligne, sans aucune installation, vous pouvez utiliser https://console.basthon.fr/ ou bien m\u00eame la console ci-dessous ! >>> ou l'IDE qui suit : Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder", "title": "Solutions en ligne"}, {"location": "T7_Divers/4_Processing/cours/", "text": "Processing \u2693\ufe0e Processing est un outil de cr\u00e9ation multim\u00e9dia utilisant le code informatique. Simple de prise en main, il a \u00e9t\u00e9 cr\u00e9\u00e9 par des artistes pour des artistes. On peut utiliser le langage Python pour entrer les instructions. Nous l'utiliserons pour ajouter du graphisme \u00e0 nos cr\u00e9ations... Documentation Le site officiel (anglais) Un manuel d'utilisation (fran\u00e7ais) Les bases de Processing \u2693\ufe0e Rep\u00e8re \u2693\ufe0e \u00c0 l'ex\u00e9cution de tout script Processing, une fen\u00eatre s'affiche avec une zone de dessin. Sa taille se d\u00e9finit \u00e0 l'aide de la fonction size . Par exemple, pour cr\u00e9er une zone de dessin de 300 pixels sur 200 pixels, on utilisera: \ud83d\udc0d Script Python size ( 300 , 200 ) Chaque pixel de cette zone est rep\u00e9r\u00e9e par des coordonn\u00e9es dans le rep\u00e8re suivant, dont l'origine se situe en haut \u00e0 gauche et l'axe des ordonn\u00e9es est orient\u00e9 vers le bas . Trac\u00e9s \u2693\ufe0e Trac\u00e9s de base point : permet de dessiner un point (pixel). En param\u00e8tre, les coordonn\u00e9es du point. line : permet de tracer une ligne entre deux points. En param\u00e8tres, les coordonn\u00e9es des deux points. rect : permet de tracer un rectangle. En param\u00e8tres, les coordonn\u00e9es du sommet haut-gauche, puis la largeur et la hauteur du rectangle. ellipse : permet de tracer une ellipse. En param\u00e8tres, les coordonn\u00e9es du centre, puis la largeur et la hauteur (mettre la m\u00eame valeur pour un cercle). Exemples Copier-coller le code suivant et faire varier les param\u00e8tres pour bien les comprendre. \ud83d\udc0d Script Python size ( 200 , 200 ) point ( 10 , 60 ) line ( 10 , 10 , 100 , 150 ) rect ( 80 , 10 , 20 , 50 ) ellipse ( 150 , 100 , 80 , 40 ) Couleurs \u2693\ufe0e Pinceau background : permet de d\u00e9finir la couleur du fond de la zone de dessin. En param\u00e8tres, les trois composantes RGB de la couleur. stroke : permet de d\u00e9finir la couleur du pinceau (noir par d\u00e9faut) pour le contour de la forme. En param\u00e8tres, les trois composantes RGB de la couleur. noStroke : permet de dessiner une forme sans coutour (pas de param\u00e8tre). strokeWeight : permet de d\u00e9finir la largeur du pinceau. En param\u00e8tre, le nombre de pixel. fill : permet de d\u00e9finir la couleur de remplissage de la forme. En param\u00e8tres, les trois composantes RGB de la couleur. Exemples Copier-coller le code suivant et faire varier les param\u00e8tres pour bien les comprendre. \ud83d\udc0d Script Python size ( 200 , 200 ) background ( 255 , 255 , 255 ) stroke ( 255 , 0 , 0 ) point ( 10 , 60 ) line ( 10 , 10 , 100 , 150 ) stroke ( 0 , 127 , 255 ) strokeWeight ( 5 ) rect ( 80 , 10 , 20 , 50 ) noStroke () fill ( 204 , 153 , 204 ) ellipse ( 150 , 100 , 80 , 40 ) Exercices \u2693\ufe0e Exercice 6 \u00c9crire un programme qui affiche le drapeau fran\u00e7ais, comme ci-contre, dans une zone de 300 x 200 pixels. Exercice 7 \u00c9crire un programme qui trace un quadrillage (espacement de 20 pixels). Contrainte: en seulement 3 lignes (sans compter \u00e9ventuellement size . Exercice 8 Afficher une croix verte de longueur 50 centr\u00e9e au point (60 ; 40), et un cercle rouge de diam\u00e8tre 30 centr\u00e9 en (150 ; 100). On prendra 10 pixels comme \u00e9paisseur. Exercice 9 Cr\u00e9ez un programme permettant d\u2019afficher 100 disques \u00e0 l\u2019\u00e9cran. La taille de chaque disque devra \u00eatre al\u00e9atoire (mais comprise entre 20 et 50). La couleur de chaque disque devra aussi \u00eatre al\u00e9atoire. Avec Processing, il est tr\u00e8s simple d\u2019avoir un nombre al\u00e9atoire : random(a,b) permet d\u2019obtenir un nombre al\u00e9atoire entre a et b . source site de C\u00e9dric Gouygou", "title": "Processing"}, {"location": "T7_Divers/4_Processing/cours/#processing", "text": "Processing est un outil de cr\u00e9ation multim\u00e9dia utilisant le code informatique. Simple de prise en main, il a \u00e9t\u00e9 cr\u00e9\u00e9 par des artistes pour des artistes. On peut utiliser le langage Python pour entrer les instructions. Nous l'utiliserons pour ajouter du graphisme \u00e0 nos cr\u00e9ations... Documentation Le site officiel (anglais) Un manuel d'utilisation (fran\u00e7ais)", "title": "Processing"}, {"location": "T7_Divers/4_Processing/cours/#les-bases-de-processing", "text": "", "title": "Les bases de Processing"}, {"location": "T7_Divers/4_Processing/cours/#repere", "text": "\u00c0 l'ex\u00e9cution de tout script Processing, une fen\u00eatre s'affiche avec une zone de dessin. Sa taille se d\u00e9finit \u00e0 l'aide de la fonction size . Par exemple, pour cr\u00e9er une zone de dessin de 300 pixels sur 200 pixels, on utilisera: \ud83d\udc0d Script Python size ( 300 , 200 ) Chaque pixel de cette zone est rep\u00e9r\u00e9e par des coordonn\u00e9es dans le rep\u00e8re suivant, dont l'origine se situe en haut \u00e0 gauche et l'axe des ordonn\u00e9es est orient\u00e9 vers le bas .", "title": "Rep\u00e8re"}, {"location": "T7_Divers/4_Processing/cours/#traces", "text": "Trac\u00e9s de base point : permet de dessiner un point (pixel). En param\u00e8tre, les coordonn\u00e9es du point. line : permet de tracer une ligne entre deux points. En param\u00e8tres, les coordonn\u00e9es des deux points. rect : permet de tracer un rectangle. En param\u00e8tres, les coordonn\u00e9es du sommet haut-gauche, puis la largeur et la hauteur du rectangle. ellipse : permet de tracer une ellipse. En param\u00e8tres, les coordonn\u00e9es du centre, puis la largeur et la hauteur (mettre la m\u00eame valeur pour un cercle). Exemples Copier-coller le code suivant et faire varier les param\u00e8tres pour bien les comprendre. \ud83d\udc0d Script Python size ( 200 , 200 ) point ( 10 , 60 ) line ( 10 , 10 , 100 , 150 ) rect ( 80 , 10 , 20 , 50 ) ellipse ( 150 , 100 , 80 , 40 )", "title": "Trac\u00e9s"}, {"location": "T7_Divers/4_Processing/cours/#couleurs", "text": "Pinceau background : permet de d\u00e9finir la couleur du fond de la zone de dessin. En param\u00e8tres, les trois composantes RGB de la couleur. stroke : permet de d\u00e9finir la couleur du pinceau (noir par d\u00e9faut) pour le contour de la forme. En param\u00e8tres, les trois composantes RGB de la couleur. noStroke : permet de dessiner une forme sans coutour (pas de param\u00e8tre). strokeWeight : permet de d\u00e9finir la largeur du pinceau. En param\u00e8tre, le nombre de pixel. fill : permet de d\u00e9finir la couleur de remplissage de la forme. En param\u00e8tres, les trois composantes RGB de la couleur. Exemples Copier-coller le code suivant et faire varier les param\u00e8tres pour bien les comprendre. \ud83d\udc0d Script Python size ( 200 , 200 ) background ( 255 , 255 , 255 ) stroke ( 255 , 0 , 0 ) point ( 10 , 60 ) line ( 10 , 10 , 100 , 150 ) stroke ( 0 , 127 , 255 ) strokeWeight ( 5 ) rect ( 80 , 10 , 20 , 50 ) noStroke () fill ( 204 , 153 , 204 ) ellipse ( 150 , 100 , 80 , 40 )", "title": "Couleurs"}, {"location": "T7_Divers/4_Processing/cours/#exercices", "text": "Exercice 6 \u00c9crire un programme qui affiche le drapeau fran\u00e7ais, comme ci-contre, dans une zone de 300 x 200 pixels. Exercice 7 \u00c9crire un programme qui trace un quadrillage (espacement de 20 pixels). Contrainte: en seulement 3 lignes (sans compter \u00e9ventuellement size . Exercice 8 Afficher une croix verte de longueur 50 centr\u00e9e au point (60 ; 40), et un cercle rouge de diam\u00e8tre 30 centr\u00e9 en (150 ; 100). On prendra 10 pixels comme \u00e9paisseur. Exercice 9 Cr\u00e9ez un programme permettant d\u2019afficher 100 disques \u00e0 l\u2019\u00e9cran. La taille de chaque disque devra \u00eatre al\u00e9atoire (mais comprise entre 20 et 50). La couleur de chaque disque devra aussi \u00eatre al\u00e9atoire. Avec Processing, il est tr\u00e8s simple d\u2019avoir un nombre al\u00e9atoire : random(a,b) permet d\u2019obtenir un nombre al\u00e9atoire entre a et b . source site de C\u00e9dric Gouygou", "title": "Exercices"}, {"location": "T7_Divers/5_Capytale/cours/", "text": "Utilisation du service Capytale \u2693\ufe0e Capytale est accessible via lyc\u00e9econnect\u00e9, il faut donc avoir ses identifiants Educonnect. Activit\u00e9-test : \u2693\ufe0e Suivez ce lien Cliquez sur Atrium Identifiez vous gr\u00e2ce \u00e0 vos identifiants Educonnect C'est parti !", "title": "Utilisation du service Capytale"}, {"location": "T7_Divers/5_Capytale/cours/#utilisation-du-service-capytale", "text": "Capytale est accessible via lyc\u00e9econnect\u00e9, il faut donc avoir ses identifiants Educonnect.", "title": "Utilisation du service Capytale"}, {"location": "T7_Divers/5_Capytale/cours/#activite-test", "text": "Suivez ce lien Cliquez sur Atrium Identifiez vous gr\u00e2ce \u00e0 vos identifiants Educonnect C'est parti !", "title": "Activit\u00e9-test :"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/", "text": "Initiation \u00e0 Pygame \u2693\ufe0e 0. Preambule \u2693\ufe0e Pygame est un package de Python facilitant la cr\u00e9ation de jeux bas\u00e9s une interface graphique. Vous pouvez : l'installer sur votre distribution Python, par pip3 install pygame . le tester directement via https://repl.it/, en choisissant pygame dans la liste des langages propos\u00e9s. 1. Pr\u00e9paration de la sc\u00e8ne du jeu \u2693\ufe0e \ud83d\udc0d Script Python import pygame , sys from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 10 , 186 , 181 ]) pygame . display . flip () while True : pass Ce code devrait vous donner ceci : Commentaires Le package sys permettra de fermer le programme au niveau de l'OS par la commande sys.exit() La ligne from pygame.locals import * permettra d'utiliser des variables locales d\u00e9j\u00e0 d\u00e9finies par pygame , comme MOUSEBUTTONDOWN , par exemple. Durant tout le code, notre sc\u00e8ne de travail sera l'objet fenetre , dans lequel nous viendrons coller de nouveaux \u00e9l\u00e9ments. \u00c9l\u00e9ments structurants d'un code pygame : pygame.init() effectue une initialisation globale de tous les modules pygame import\u00e9s. \u00c0 mettre au d\u00e9but du code. pygame.display.flip() effectue un rafra\u00eechissement total de tous les \u00e9l\u00e9ments graphiques de la fen\u00eatre. \u00c0 mettre donc plut\u00f4t vers la fin du code. while True : comme tr\u00e8s souvent dans les jeux, la structure essentielle est une boucle infinie dont on ne sortira que par une interruption syst\u00e8me ( sys.exit() ) o\u00f9 lors de la bascule d'un bool\u00e9en. Pour l'instant, cette boucle est vide ( pass ). 2. Apparition d'un personnage \u2693\ufe0e 2.1. T\u00e9l\u00e9chargement de l'image \u2693\ufe0e Nous allons travailler avec le sprite ci-dessous, nomm\u00e9 perso.png . Il est issu de https://openclassrooms.com/fr/courses/1399541-interface-graphique-pygame-pour-python/1399813-premieres-fenetres T\u00e9l\u00e9chargez-le pour le mettre dans le m\u00eame dossier que votre code pygame . Vous pouvez trouver sur internet un grand nombre de sprites libres de droits, au format png (donc g\u00e9rant la transparence), dans de multiples positions (ce qui permet de simuler des mouvements fluides). Ici nous travaillerons avec un sprite unique. 2.2. Importation de l'image dans la fen\u00eatre \u2693\ufe0e \ud83d\udc0d Script Python perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () La fonction convert_alpha() est appel\u00e9e pour que soit correctement trait\u00e9 le canal de transparence (canal alpha ) de notre image. 2.3. Affichage de l'image \u2693\ufe0e \u00c0 ce stade, perso est un objet pygame de type Surface . Afin de facilement pouvoir le d\u00e9placer, nous allons stocker la position de cet objet dans une variable position_perso , qui sera de type rect . \ud83d\udc0d Script Python position_perso = perso . get_rect () Pour afficher cette image, nous allons venir le superposer aux \u00e9l\u00e9ments graphiques d\u00e9j\u00e0 dessin\u00e9s (en l'occurence : rien) avec l'instruction blit() : \ud83d\udc0d Script Python fenetre . blit ( perso , position_perso ) \u25b8 r\u00e9capitulatif du code \ud83d\udc0d Script Python import pygame , sys from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 10 , 186 , 181 ]) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () fenetre . blit ( perso , position_perso ) pygame . display . flip () while True : pass Aper\u00e7u 3. Gestion des \u00e9v\u00e8nements \u2693\ufe0e Lorsqu'un programme pygame est lanc\u00e9, la variable interne pygame.event.get() re\u00e7oit en continu les \u00e9v\u00e8nements des p\u00e9riph\u00e9riques g\u00e9r\u00e9s par le syst\u00e8me d'exploitation. Nous allons nous int\u00e9resser aux \u00e9v\u00e8nements de type KEYDOWN (touche de clavier appuy\u00e9e) ou de type MOUSEBUTTONDOWN (boutons de souris appuy\u00e9). 3.1. \u00c9v\u00e8nements clavier \u2693\ufe0e 3.1.1. Exemple de code \u2693\ufe0e La structure de code pour d\u00e9tecter l'appui sur une touche de clavier est, dans le cas de la d\u00e9tection de la touche \u00abFl\u00e8che droite\u00bb : \ud83d\udc0d Script Python for event in pygame . event . get (): if event . type == KEYDOWN : if event . key == K_RIGHT : print ( \"fl\u00e8che droite appuy\u00e9e\" ) La touche (en anglais key ) \u00abFl\u00e8che Droite\u00bb est appel\u00e9e K_RIGHT par pygame . Le nom de toutes les touches peut \u00eatre retrouv\u00e9 \u00e0 l'adresse https://www.pygame.org/docs/ref/key.html. Remarque : c'est gr\u00e2ce \u00e0 la ligne initiale \ud83d\udc0d Script Python from pygame.locals import * que la variable K_RIGHT (et toutes les autres) est reconnue. 3.1.2. Probl\u00e8me de la r\u00e9manence \u2693\ufe0e Quand une touche de clavier est appuy\u00e9e, elle le reste un certain temps. Parfois volontairement (sur un intervalle long) quand l'utilisateur d\u00e9cide de la laisser appuy\u00e9e, mais aussi involontairement (sur un intervalle tr\u00e8s court), lors d'un appui \u00abclassique\u00bb. Il existe donc toujours un intervalle de temps pendant lequel la touche reste appuy\u00e9e. Que doit faire notre programme pendant ce temps ? Deux options sont possibles : option 1 : consid\u00e9rer que la touche appuy\u00e9e correspond \u00e0 un seul et unique \u00e9v\u00e8nement, quelle que soit la dur\u00e9e de l'appui sur la touche. option 2 : consid\u00e9rer qu'au bout d'un certain d\u00e9lai, la touche encore appuy\u00e9e doit d\u00e9clencher un nouvel \u00e9v\u00e8nement. Par d\u00e9faut, pygame est r\u00e9gl\u00e9 sur l'option 1. N\u00e9anmoins, il est classique pour les jeux vid\u00e9os de vouloir que \u00ablaisser la touche appuy\u00e9e\u00bb continue \u00e0 faire avancer le personnage. Nous allons donc faire en sorte que toutes les 50 millisecondes, un nouvel appui soit d\u00e9tect\u00e9 si la touche est rest\u00e9e enfonc\u00e9e. Cela se fera par l'expression : \ud83d\udc0d Script Python pygame . key . set_repeat ( 50 ) 3.2 \u00c9v\u00e8nements souris \u2693\ufe0e 3.2.1. Exemple de code \u2693\ufe0e La structure de code pour d\u00e9tecter l'appui sur un bouton de la souris est, dans le cas de la d\u00e9tection du bouton de gauche (le bouton 1) : \ud83d\udc0d Script Python for event in pygame . event . get (): if event . type == MOUSEBUTTONDOWN and event . button == 1 : print ( \"clic gauche d\u00e9tect\u00e9\" ) 3.2.2. R\u00e9cup\u00e9ration des coordonn\u00e9es de la souris \u2693\ufe0e Le tuple (abscisse, ordonn\u00e9e) des coordonn\u00e9es de la souris sera r\u00e9cup\u00e9r\u00e9 avec l'instruction pygame.mouse.get_pos() . 4. D\u00e9placement du personnage \u2693\ufe0e Le d\u00e9placement d'un personnage se fera toujours par modification de ses coordonn\u00e9es (et visuellement, par effacement de la derni\u00e8re position). Ce d\u00e9placement pourra \u00eatre : - absolu : on donne de nouvelles coordonn\u00e9es au personnage. - relatif : on indique de combien le personnage doit se d\u00e9caler par rapport \u00e0 sa position initiale. 4.1. D\u00e9placement absolu \u2693\ufe0e Pour afficher le personnage \u00e0 la position (100,200) , on \u00e9crira : \ud83d\udc0d Script Python position_perso . topleft = ( 100 , 200 ) o\u00f9 position_perso est l'objet de type rect contenant les coordonn\u00e9es. Exercice 1 : R\u00e9aliser un d\u00e9placement al\u00e9atoire, comme l'animation ci-dessous. Vous pourrez utiliser les instructions : - pygame.time.delay(1000) afin de ne bouger le personnage que toutes les 1000 millisecondes. - randint(a,b) du package random , qui renvoie un entier pseudo-al\u00e9atoire entre a et b . Proposition de correction \ud83d\udc0d Script Python import pygame , sys from pygame.locals import * from random import randint pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () while True : fenetre . fill ([ 10 , 186 , 181 ]) position_perso . topleft = ( randint ( 0 , 540 ), randint ( 0 , 380 )) fenetre . blit ( perso , position_perso ) pygame . display . flip () pygame . time . delay ( 1000 ) 4.2. D\u00e9placement relatif \u2693\ufe0e Pour d\u00e9placer le personnage de 15 pixels vers la droite et de 10 pixels vers le haut par rapport \u00e0 sa position pr\u00e9c\u00e9dente, on \u00e9crira : \ud83d\udc0d Script Python position_perso . move ( 15 , - 10 ) o\u00f9 position_perso est l'objet de type rect contenant les coordonn\u00e9es. Exercice 2 : R\u00e9aliser un contr\u00f4le au clavier du personnage, comme dans l'animation ci-dessous. Proposition de correction \ud83d\udc0d Script Python import pygame , sys from pygame.locals import * pygame . init () pygame . key . set_repeat ( 50 ) fenetre = pygame . display . set_mode (( 640 , 480 )) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () pas_deplacement = 15 while True : for event in pygame . event . get () : if event . type == KEYDOWN : if event . key == K_DOWN : position_perso = position_perso . move ( 0 , pas_deplacement ) if event . key == K_UP : position_perso = position_perso . move ( 0 , - pas_deplacement ) if event . key == K_RIGHT : position_perso = position_perso . move ( pas_deplacement , 0 ) if event . key == K_LEFT : position_perso = position_perso . move ( - pas_deplacement , 0 ) fenetre . fill ([ 10 , 186 , 181 ]) fenetre . blit ( perso , position_perso ) pygame . display . flip () 5. \u00c0 vous ! \u2693\ufe0e Fabriquez le jeu que vous souhaitez \u00e0 partir des informations ci-dessus. Bien d'autres aides peuvent \u00eatre trouv\u00e9es dans les liens cit\u00e9es dans la partie Bibliographie. Exemple de r\u00e9alisation possible : un clicker avec un temps qui diminue \u00e0 progressivement, et comptage des points. Quelques aides : \u00e9crire du texte : \ud83d\udc0d Script Python font = pygame . font . Font ( pygame . font . get_default_font (), 36 ) text = font . render ( \"Game Over\" , True , ( 255 , 0 , 0 )) fenetre . blit ( text , dest = ( 550 , 40 )) dessiner un rectangle : \ud83d\udc0d Script Python pygame . draw . rect ( fenetre ,( 0 , 255 , 0 ),( 500 , 20 , 100 , 10 )) dessine un rectangle vert de 100 pixels sur 10 pixels, dont le coin en haut \u00e0 gauche est \u00e0 la position (500,20). g\u00e9rer le temps: \ud83d\udc0d Script Python import time topchrono = time . time () delai = 5 sortir = False while sortir == False : if time . time () - topchrono > delai : print ( \"5 secondes se sont \u00e9coul\u00e9es\" ) sortir = True Bibliographie Documentation officielle de Pygame, https://www.pygame.org/docs/ Cours d'OpenClassrooms, https://openclassrooms.com/fr/courses/1399541-interface-graphique-pygame-pour-python/1399813-premieres-fenetres.", "title": "Initiation \u00e0 Pygame"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#initiation-a-pygame", "text": "", "title": "Initiation \u00e0 Pygame"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#0-preambule", "text": "Pygame est un package de Python facilitant la cr\u00e9ation de jeux bas\u00e9s une interface graphique. Vous pouvez : l'installer sur votre distribution Python, par pip3 install pygame . le tester directement via https://repl.it/, en choisissant pygame dans la liste des langages propos\u00e9s.", "title": "0. Preambule"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#1-preparation-de-la-scene-du-jeu", "text": "\ud83d\udc0d Script Python import pygame , sys from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 10 , 186 , 181 ]) pygame . display . flip () while True : pass Ce code devrait vous donner ceci : Commentaires Le package sys permettra de fermer le programme au niveau de l'OS par la commande sys.exit() La ligne from pygame.locals import * permettra d'utiliser des variables locales d\u00e9j\u00e0 d\u00e9finies par pygame , comme MOUSEBUTTONDOWN , par exemple. Durant tout le code, notre sc\u00e8ne de travail sera l'objet fenetre , dans lequel nous viendrons coller de nouveaux \u00e9l\u00e9ments. \u00c9l\u00e9ments structurants d'un code pygame : pygame.init() effectue une initialisation globale de tous les modules pygame import\u00e9s. \u00c0 mettre au d\u00e9but du code. pygame.display.flip() effectue un rafra\u00eechissement total de tous les \u00e9l\u00e9ments graphiques de la fen\u00eatre. \u00c0 mettre donc plut\u00f4t vers la fin du code. while True : comme tr\u00e8s souvent dans les jeux, la structure essentielle est une boucle infinie dont on ne sortira que par une interruption syst\u00e8me ( sys.exit() ) o\u00f9 lors de la bascule d'un bool\u00e9en. Pour l'instant, cette boucle est vide ( pass ).", "title": "1. Pr\u00e9paration de la sc\u00e8ne du jeu"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#2-apparition-dun-personnage", "text": "", "title": "2. Apparition d'un personnage"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#21-telechargement-de-limage", "text": "Nous allons travailler avec le sprite ci-dessous, nomm\u00e9 perso.png . Il est issu de https://openclassrooms.com/fr/courses/1399541-interface-graphique-pygame-pour-python/1399813-premieres-fenetres T\u00e9l\u00e9chargez-le pour le mettre dans le m\u00eame dossier que votre code pygame . Vous pouvez trouver sur internet un grand nombre de sprites libres de droits, au format png (donc g\u00e9rant la transparence), dans de multiples positions (ce qui permet de simuler des mouvements fluides). Ici nous travaillerons avec un sprite unique.", "title": "2.1. T\u00e9l\u00e9chargement de l'image"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#22-importation-de-limage-dans-la-fenetre", "text": "\ud83d\udc0d Script Python perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () La fonction convert_alpha() est appel\u00e9e pour que soit correctement trait\u00e9 le canal de transparence (canal alpha ) de notre image.", "title": "2.2. Importation de l'image dans la fen\u00eatre"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#23-affichage-de-limage", "text": "\u00c0 ce stade, perso est un objet pygame de type Surface . Afin de facilement pouvoir le d\u00e9placer, nous allons stocker la position de cet objet dans une variable position_perso , qui sera de type rect . \ud83d\udc0d Script Python position_perso = perso . get_rect () Pour afficher cette image, nous allons venir le superposer aux \u00e9l\u00e9ments graphiques d\u00e9j\u00e0 dessin\u00e9s (en l'occurence : rien) avec l'instruction blit() : \ud83d\udc0d Script Python fenetre . blit ( perso , position_perso ) \u25b8 r\u00e9capitulatif du code \ud83d\udc0d Script Python import pygame , sys from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fenetre . fill ([ 10 , 186 , 181 ]) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () fenetre . blit ( perso , position_perso ) pygame . display . flip () while True : pass Aper\u00e7u", "title": "2.3. Affichage de l'image"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#3-gestion-des-evenements", "text": "Lorsqu'un programme pygame est lanc\u00e9, la variable interne pygame.event.get() re\u00e7oit en continu les \u00e9v\u00e8nements des p\u00e9riph\u00e9riques g\u00e9r\u00e9s par le syst\u00e8me d'exploitation. Nous allons nous int\u00e9resser aux \u00e9v\u00e8nements de type KEYDOWN (touche de clavier appuy\u00e9e) ou de type MOUSEBUTTONDOWN (boutons de souris appuy\u00e9).", "title": "3. Gestion des \u00e9v\u00e8nements"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#31-evenements-clavier", "text": "", "title": "3.1. \u00c9v\u00e8nements clavier"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#32-evenements-souris", "text": "", "title": "3.2 \u00c9v\u00e8nements souris"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#4-deplacement-du-personnage", "text": "Le d\u00e9placement d'un personnage se fera toujours par modification de ses coordonn\u00e9es (et visuellement, par effacement de la derni\u00e8re position). Ce d\u00e9placement pourra \u00eatre : - absolu : on donne de nouvelles coordonn\u00e9es au personnage. - relatif : on indique de combien le personnage doit se d\u00e9caler par rapport \u00e0 sa position initiale.", "title": "4. D\u00e9placement du personnage"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#41-deplacement-absolu", "text": "Pour afficher le personnage \u00e0 la position (100,200) , on \u00e9crira : \ud83d\udc0d Script Python position_perso . topleft = ( 100 , 200 ) o\u00f9 position_perso est l'objet de type rect contenant les coordonn\u00e9es. Exercice 1 : R\u00e9aliser un d\u00e9placement al\u00e9atoire, comme l'animation ci-dessous. Vous pourrez utiliser les instructions : - pygame.time.delay(1000) afin de ne bouger le personnage que toutes les 1000 millisecondes. - randint(a,b) du package random , qui renvoie un entier pseudo-al\u00e9atoire entre a et b . Proposition de correction \ud83d\udc0d Script Python import pygame , sys from pygame.locals import * from random import randint pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () while True : fenetre . fill ([ 10 , 186 , 181 ]) position_perso . topleft = ( randint ( 0 , 540 ), randint ( 0 , 380 )) fenetre . blit ( perso , position_perso ) pygame . display . flip () pygame . time . delay ( 1000 )", "title": "4.1. D\u00e9placement absolu"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#42-deplacement-relatif", "text": "Pour d\u00e9placer le personnage de 15 pixels vers la droite et de 10 pixels vers le haut par rapport \u00e0 sa position pr\u00e9c\u00e9dente, on \u00e9crira : \ud83d\udc0d Script Python position_perso . move ( 15 , - 10 ) o\u00f9 position_perso est l'objet de type rect contenant les coordonn\u00e9es. Exercice 2 : R\u00e9aliser un contr\u00f4le au clavier du personnage, comme dans l'animation ci-dessous. Proposition de correction \ud83d\udc0d Script Python import pygame , sys from pygame.locals import * pygame . init () pygame . key . set_repeat ( 50 ) fenetre = pygame . display . set_mode (( 640 , 480 )) perso = pygame . image . load ( \"perso.png\" ) . convert_alpha () position_perso = perso . get_rect () pas_deplacement = 15 while True : for event in pygame . event . get () : if event . type == KEYDOWN : if event . key == K_DOWN : position_perso = position_perso . move ( 0 , pas_deplacement ) if event . key == K_UP : position_perso = position_perso . move ( 0 , - pas_deplacement ) if event . key == K_RIGHT : position_perso = position_perso . move ( pas_deplacement , 0 ) if event . key == K_LEFT : position_perso = position_perso . move ( - pas_deplacement , 0 ) fenetre . fill ([ 10 , 186 , 181 ]) fenetre . blit ( perso , position_perso ) pygame . display . flip ()", "title": "4.2. D\u00e9placement relatif"}, {"location": "T7_Divers/6_Pygame/05_Initiation_Pygame/#5-a-vous", "text": "Fabriquez le jeu que vous souhaitez \u00e0 partir des informations ci-dessus. Bien d'autres aides peuvent \u00eatre trouv\u00e9es dans les liens cit\u00e9es dans la partie Bibliographie. Exemple de r\u00e9alisation possible : un clicker avec un temps qui diminue \u00e0 progressivement, et comptage des points. Quelques aides : \u00e9crire du texte : \ud83d\udc0d Script Python font = pygame . font . Font ( pygame . font . get_default_font (), 36 ) text = font . render ( \"Game Over\" , True , ( 255 , 0 , 0 )) fenetre . blit ( text , dest = ( 550 , 40 )) dessiner un rectangle : \ud83d\udc0d Script Python pygame . draw . rect ( fenetre ,( 0 , 255 , 0 ),( 500 , 20 , 100 , 10 )) dessine un rectangle vert de 100 pixels sur 10 pixels, dont le coin en haut \u00e0 gauche est \u00e0 la position (500,20). g\u00e9rer le temps: \ud83d\udc0d Script Python import time topchrono = time . time () delai = 5 sortir = False while sortir == False : if time . time () - topchrono > delai : print ( \"5 secondes se sont \u00e9coul\u00e9es\" ) sortir = True Bibliographie Documentation officielle de Pygame, https://www.pygame.org/docs/ Cours d'OpenClassrooms, https://openclassrooms.com/fr/courses/1399541-interface-graphique-pygame-pour-python/1399813-premieres-fenetres.", "title": "5. \u00c0 vous !"}, {"location": "T7_Divers/7_Liens/liens/", "text": "Liens utiles \u2693\ufe0e Cours de Premi\u00e8re \u2693\ufe0e \u00c0 retrouver ici \u00c0 propos de la sp\u00e9cialit\u00e9 NSI \u2693\ufe0e Le site Eduscol Pour r\u00e9soudre des \u00e9nigmes \u2693\ufe0e Quelques sites de challenges/\u00e9nigmes/d\u00e9fis de programmation: PyD\u00e9fis Hackinscience Advent of Code MicroContest \u00c0 propos de la culture des sciences de l'informatique \u2693\ufe0e Interstices Inria Pour se former en autonomie \u2693\ufe0e Au cas o\u00f9 vous vous ennuieriez... France-IOI CheckIO CodinGame", "title": "Liens utiles"}, {"location": "T7_Divers/7_Liens/liens/#liens-utiles", "text": "", "title": "Liens utiles"}, {"location": "T7_Divers/7_Liens/liens/#cours-de-premiere", "text": "\u00c0 retrouver ici", "title": "Cours de Premi\u00e8re"}, {"location": "T7_Divers/7_Liens/liens/#a-propos-de-la-specialite-nsi", "text": "Le site Eduscol", "title": "\u00c0 propos de la sp\u00e9cialit\u00e9 NSI"}, {"location": "T7_Divers/7_Liens/liens/#pour-resoudre-des-enigmes", "text": "Quelques sites de challenges/\u00e9nigmes/d\u00e9fis de programmation: PyD\u00e9fis Hackinscience Advent of Code MicroContest", "title": "Pour r\u00e9soudre des \u00e9nigmes"}, {"location": "T7_Divers/7_Liens/liens/#a-propos-de-la-culture-des-sciences-de-linformatique", "text": "Interstices Inria", "title": "\u00c0 propos de la culture des sciences de l'informatique"}, {"location": "T7_Divers/7_Liens/liens/#pour-se-former-en-autonomie", "text": "Au cas o\u00f9 vous vous ennuieriez... France-IOI CheckIO CodinGame", "title": "Pour se former en autonomie"}, {"location": "T7_Divers/8_Mkdocs/mkdocs/", "text": "MkDocs \u2693\ufe0e Ce site \u00e0 \u00e9t\u00e9 r\u00e9alis\u00e9 avec MkDocs . Le principe est d'\u00e9crire des fichiers markdowns qui sont ensuite convertis en fichiers html. Pour mettre en forme les pages consulter la r\u00e9f\u00e9rence vers Material for MkDocs (si la page n'est pas assez large, cliquer en haut \u00e0 gauche de la page sur \u2261 pour acc\u00e9der au menu donnant acc\u00e8s aux informations sur Admonittions, Annotations, Buttons, Code blocks... ).", "title": "MkDocs"}, {"location": "T7_Divers/8_Mkdocs/mkdocs/#mkdocs", "text": "Ce site \u00e0 \u00e9t\u00e9 r\u00e9alis\u00e9 avec MkDocs . Le principe est d'\u00e9crire des fichiers markdowns qui sont ensuite convertis en fichiers html. Pour mettre en forme les pages consulter la r\u00e9f\u00e9rence vers Material for MkDocs (si la page n'est pas assez large, cliquer en haut \u00e0 gauche de la page sur \u2261 pour acc\u00e9der au menu donnant acc\u00e8s aux informations sur Admonittions, Annotations, Buttons, Code blocks... ).", "title": "MkDocs"}]}